Smalltalk globals at: #oldUndec put: Undeclared copy.Smalltalk globals at: #oldUnimp put:  SystemNavigation default allUnimplementedCalls copy.Object subclass: #Morph  instanceVariableNames: 'bounds owner submorphs fullBounds color extension'  classVariableNames: 'CmdGesturesEnabled DefaultYellowButtonMenuEnabled EmptyArray'  poolDictionaries: ''  category: 'Morphic-Kernel'!Object subclass: #WorldState  instanceVariableNames: 'hands viewBox canvas damageRecorder stepList lastStepTime lastStepMessage lastCycleTime alarms lastAlarmTime menuBuilder'  classVariableNames: 'CanSurrenderToOS DebugShowDamage DeferredUIMessages DesktopMenuPragmaKeyword DesktopMenuTitle EasySelectingWorld LastCycleTime MinCycleLapse ServerMode ShowUpdateOptionInWorldMenu'  poolDictionaries: ''  category: 'Morphic-Worlds'!BitBlt subclass: #GrafPort  instanceVariableNames: 'alpha fillPattern lastFont lastFontForegroundColor lastFontBackgroundColor'  classVariableNames: ''  poolDictionaries: ''  category: 'Morphic-Support'!Object subclass: #MorphicEvent  instanceVariableNames: 'timeStamp source windowIndex'  classVariableNames: ''  poolDictionaries: ''  category: 'Morphic-Events'!MorphicEvent subclass: #UserInputEvent  instanceVariableNames: 'type buttons position handler wasHandled'  classVariableNames: ''  poolDictionaries: 'EventSensorConstants'  category: 'Morphic-Events'!ArrayedCollection variableWordSubclass: #ShortIntegerArray  instanceVariableNames: ''  classVariableNames: 'LastSaveOrder'  poolDictionaries: ''  category: 'Balloon-Collections'!Object subclass: #MorphicEventDispatcher  instanceVariableNames: 'lastType lastDispatch'  classVariableNames: ''  poolDictionaries: ''  category: 'Morphic-Events'!UserInputEvent subclass: #MouseEvent  instanceVariableNames: ''  classVariableNames: ''  poolDictionaries: ''  category: 'Morphic-Events'!UserInputEvent subclass: #KeyboardEvent  instanceVariableNames: 'keyValue charCode scanCode'  classVariableNames: ''  poolDictionaries: ''  category: 'Morphic-Events'!MouseEvent subclass: #MouseMoveEvent  instanceVariableNames: 'startPoint trail'  classVariableNames: ''  poolDictionaries: ''  category: 'Morphic-Events'!Object subclass: #Color  instanceVariableNames: 'rgb cachedDepth cachedBitPattern'  classVariableNames: 'Black Blue BlueShift Brown CachedColormaps ColorChart ColorNames ComponentMask ComponentMax Cyan DarkGray Gray GrayToIndexMap Green GreenShift HalfComponentMask HighLightBitmaps IndexedColors LightBlue LightBrown LightCyan LightGray LightGreen LightMagenta LightOrange LightRed LightYellow Magenta MaskingMap Orange PureBlue PureCyan PureGreen PureMagenta PureRed PureYellow RandomStream Red RedShift TranslucentPatterns Transparent VeryDarkGray VeryLightGray VeryVeryDarkGray VeryVeryLightGray White Yellow'  poolDictionaries: ''  category: 'Graphics-Primitives'!Object subclass: #BorderStyle  instanceVariableNames: ''  classVariableNames: 'Default'  poolDictionaries: ''  category: 'Morphic-Borders'!DisplayMedium subclass: #Form  instanceVariableNames: 'bits width height depth offset'  classVariableNames: 'FloodFillTolerance'  poolDictionaries: ''  category: 'Graphics-Display Objects'!Trait named: #TEasilyThemed  uses: {}  category: 'Polymorph-Widgets'!UIManager subclass: #MorphicUIManager  uses: TEasilyThemed  instanceVariableNames: 'interactiveParser'  classVariableNames: 'UIProcess'  poolDictionaries: ''  category: 'Polymorph-Widgets-Themes'!MorphicUIManager class  uses: TEasilyThemed classTrait  instanceVariableNames: ''!Object subclass: #Canvas  instanceVariableNames: ''  classVariableNames: ''  poolDictionaries: ''  category: 'Morphic-Support'!Canvas subclass: #ColorMappingCanvas  instanceVariableNames: 'myCanvas'  classVariableNames: ''  poolDictionaries: ''  category: 'Morphic-Support'!ColorMappingCanvas subclass: #ShadowDrawingCanvas  instanceVariableNames: 'shadowColor'  classVariableNames: ''  poolDictionaries: ''  category: 'Morphic-Support'!Object subclass: #MouseOverHandler  instanceVariableNames: 'mouseOverMorphs enteredMorphs overMorphs leftMorphs'  classVariableNames: ''  poolDictionaries: ''  category: 'Morphic-Events'!MorphicEvent subclass: #DropEvent  instanceVariableNames: 'position contents wasHandled'  classVariableNames: ''  poolDictionaries: ''  category: 'Morphic-Events'!MouseEvent subclass: #MouseButtonEvent  instanceVariableNames: 'whichButton'  classVariableNames: ''  poolDictionaries: ''  category: 'Morphic-Events'!Object subclass: #DamageRecorder  instanceVariableNames: 'invalidRects totalRepaint'  classVariableNames: ''  poolDictionaries: ''  category: 'Morphic-Support'!Object subclass: #TextStopConditions  instanceVariableNames: 'stops crossedX endOfRun'  classVariableNames: ''  poolDictionaries: ''  category: 'Graphics-Text'!ArrayedCollection variableWordSubclass: #ShortRunArray  instanceVariableNames: ''  classVariableNames: 'LastSaveOrder'  poolDictionaries: ''  category: 'Balloon-Collections'!Object subclass: #MorphExtension  instanceVariableNames: 'locked visible sticky balloonText externalName eventHandler otherProperties fillStyle layoutPolicy layoutFrame layoutProperties borderStyle cornerStyle actionMap clipSubmorphs'  classVariableNames: ''  poolDictionaries: ''  category: 'Morphic-Kernel'!Morph subclass: #HandMorph  instanceVariableNames: 'mouseFocus keyboardFocus eventListeners mouseListeners keyboardListeners mouseClickState mouseOverHandler lastMouseEvent targetOffset damageRecorder cacheCanvas cachedCanvasHasHoles temporaryCursor temporaryCursorOffset hardwareCursor hasChanged savedPatch lastEventBuffer lastKeyScanCode combinedChar'  classVariableNames: 'CompositionWindowManager DoubleClickTime EventStats NormalCursor PasteBuffer ShowEvents'  poolDictionaries: 'EventSensorConstants'  category: 'Morphic-Kernel'!Morph subclass: #BorderedMorph  instanceVariableNames: 'borderWidth borderColor'  classVariableNames: ''  poolDictionaries: ''  category: 'Morphic-Kernel'!BorderedMorph subclass: #PasteUpMorph  instanceVariableNames: 'backgroundMorph worldState griddingOn'  classVariableNames: 'DisableDeferredUpdates WindowEventHandler WorldAnnouncer'  poolDictionaries: ''  category: 'Morphic-Worlds'!Canvas subclass: #FormCanvas  instanceVariableNames: 'origin clipRect form port'  classVariableNames: ''  poolDictionaries: ''  category: 'Morphic-Support'!!Object methodsFor: '*Morphic' stamp: 'JuanVuletich 11/1/2010 15:18'!currentWorld  "Answer a morphic world that is the current UI focus."  ^UIManager default currentWorld! !!WorldState methodsFor: 'alarms' stamp: 'ar 9/11/2000 17:11'!adjustAlarmTimes: nowTime  "Adjust the alarm times after some clock weirdness (such as roll-over, image-startup etc)"  | deltaTime |  deltaTime := nowTime - lastAlarmTime.  self alarms do:[:alarm| alarm scheduledTime: alarm scheduledTime + deltaTime].! !!WorldState methodsFor: 'alarms' stamp: 'nice 4/16/2009 19:03'!alarmSortBlock  ^[ :alarm1 :alarm2 |     alarm1 scheduledTime < alarm2 scheduledTime.  ]! !!WorldState methodsFor: 'alarms' stamp: 'RAA 1/5/2001 10:46'!alarms  ^alarms ifNil: [alarms := Heap sortBlock: self alarmSortBlock]! !!WorldState methodsFor: 'alarms' stamp: 'dgd 2/22/2003 13:31'!removeAlarm: aSelector for: aTarget   "Remove the alarm with the given selector"  | alarm |  alarm := self alarms         detect: [:any | any receiver == aTarget and: [any selector == aSelector]]        ifNone: [nil].  alarm isNil ifFalse: [self alarms remove: alarm]! !!WorldState methodsFor: 'alarms' stamp: 'ar 10/22/2000 16:55'!triggerAlarmsBefore: nowTime  "Trigger all pending alarms that are to be executed before nowTime."  | pending |  lastAlarmTime ifNil:[lastAlarmTime := nowTime].  (nowTime < lastAlarmTime or:[nowTime - lastAlarmTime > 10000])    ifTrue:[self adjustAlarmTimes: nowTime].  pending := self alarms.  [pending isEmpty not and:[pending first scheduledTime < nowTime]]    whileTrue:[pending removeFirst value: nowTime].  lastAlarmTime := nowTime.! !!WorldState methodsFor: 'canvas' stamp: 'dgd 2/22/2003 13:29'!canvas: x   canvas := x.  damageRecorder isNil     ifTrue: [damageRecorder := DamageRecorder new]    ifFalse: [damageRecorder doFullRepaint]! !!WorldState methodsFor: 'canvas' stamp: 'RAA 5/25/2000 15:12'!doFullRepaint  damageRecorder doFullRepaint! !!WorldState methodsFor: 'canvas' stamp: 'ar 1/30/2001 23:25'!recordDamagedRect: damageRect  damageRecorder ifNotNil: [damageRecorder recordInvalidRect: damageRect truncated]! !!WorldState methodsFor: 'canvas' stamp: 'di 6/7/1999 17:44'!viewBox  ^ viewBox! !!WorldState methodsFor: 'canvas' stamp: 'di 6/7/1999 17:58'!viewBox: x  viewBox := x! !!WorldState methodsFor: 'hands' stamp: 'ar 1/22/2001 14:26'!activeHand  ^ ActiveHand! !!WorldState methodsFor: 'hands' stamp: 'ar 10/26/2000 14:51'!addHand: aHandMorph  "Add the given hand to the list of hands for this world."  hands := (hands copyWithout: aHandMorph) copyWith: aHandMorph.! !!WorldState methodsFor: 'hands' stamp: 'di 6/7/1999 17:40'!hands  ^ hands! !!WorldState methodsFor: 'hands' stamp: 'RAA 5/24/2000 10:13'!handsDo: aBlock  ^ hands do: aBlock! !!WorldState methodsFor: 'hands' stamp: 'RAA 5/24/2000 12:09'!handsReverseDo: aBlock  ^ hands reverseDo: aBlock! !!WorldState methodsFor: 'hands' stamp: 'nice 1/5/2010 15:59'!selectHandsToDrawForDamage: damageList  "Select the set of hands that must be redrawn because either (a) the hand itself has changed or (b) the hand intersects some damage rectangle."  | result |  result := OrderedCollection new.  hands do: [:h | | hBnds |    h needsToBeDrawn ifTrue: [      h hasChanged        ifTrue: [result add: h]        ifFalse: [          hBnds := h fullBounds.          (damageList detect: [:r | r intersects: hBnds] ifNone: [nil])            ifNotNil: [result add: h]]]].  ^ result! !!WorldState methodsFor: 'initialization' stamp: 'alain.plantec 5/28/2009 11:16'!initialize  super initialize.  hands := Array new.  damageRecorder:= DamageRecorder new.  stepList := Heap sortBlock: self stepListSortBlock.  lastStepTime := 0.  lastAlarmTime := 0.! !!WorldState methodsFor: 'initialization' stamp: 'sw 9/5/2000 06:39'!stepListSize  ^ stepList size! !!WorldState methodsFor: 'settings' stamp: 'AlainPlantec 12/14/2009 14:01'!serverMode  ^ self class serverMode! !!WorldState methodsFor: 'stepping' stamp: 'AlainPlantec 10/17/2009 19:02'!cleanseStepListForWorld: aWorld  "Remove morphs from the step list that are not in this World"  | deletions morphToStep |  deletions := nil.  stepList do: [:entry |    morphToStep := entry receiver.    morphToStep world == aWorld ifFalse:[      deletions ifNil: [deletions := OrderedCollection new].      deletions addLast: entry]].  deletions ifNotNil:[    deletions do: [:entry|      self stopStepping: entry receiver]].  self alarms copy do:[:entry|    morphToStep := entry receiver.    (morphToStep isMorph and:[morphToStep world == aWorld])       ifFalse:[self removeAlarm: entry selector for: entry receiver]].! !!WorldState methodsFor: 'stepping' stamp: 'ar 10/22/2000 16:05'!listOfSteppingMorphs  ^stepList collect:[:entry| entry receiver].! !!WorldState methodsFor: 'stepping' stamp: 'dgd 2/22/2003 13:31'!runLocalStepMethodsIn: aWorld   "Run morph 'step' methods (LOCAL TO THIS WORLD) whose time has come. Purge any morphs that are no longer in this world.  ar 3/13/1999: Remove buggy morphs from the step list so that they don't raise repeated errors."  | now morphToStep stepTime priorWorld |  now := Time millisecondClockValue.  priorWorld := ActiveWorld.  ActiveWorld := aWorld.  self triggerAlarmsBefore: now.  stepList isEmpty     ifTrue:       [ActiveWorld := priorWorld.      ^self].  (now < lastStepTime or: [now - lastStepTime > 5000])     ifTrue: [self adjustWakeupTimes: now].  "clock slipped"  [stepList isEmpty not and: [stepList first scheduledTime < now]]     whileTrue:       [lastStepMessage := stepList removeFirst.      morphToStep := lastStepMessage receiver.      (morphToStep shouldGetStepsFrom: aWorld)         ifTrue:           [lastStepMessage value: now.          lastStepMessage ifNotNil:               [stepTime := lastStepMessage stepTime ifNil: [morphToStep stepTime].              lastStepMessage scheduledTime: now + (stepTime max: 1).              stepList add: lastStepMessage]].      lastStepMessage := nil].  lastStepTime := now.  ActiveWorld := priorWorld! !!WorldState methodsFor: 'stepping' stamp: 'StephaneDucasse 1/31/2011 16:51'!runStepMethodsIn: aWorld  "Perform periodic activity inbetween event cycles"    | queue nextInQueue|  "If available dispatch some deferred UI Message"  queue := self class deferredUIMessages.  [(nextInQueue := queue nextOrNil) isNil]    whileFalse: [ nextInQueue value].  self runLocalStepMethodsIn: aWorld.! !!WorldState methodsFor: 'stepping' stamp: 'nice 4/16/2009 19:03'!stepListSortBlock  ^[ :stepMsg1 :stepMsg2 |     stepMsg1 scheduledTime <= stepMsg2 scheduledTime  ]! !!WorldState methodsFor: 'update cycle' stamp: 'RAA 5/24/2000 13:13'!checkIfUpdateNeeded  damageRecorder updateIsNeeded ifTrue: [^true].  hands do: [:h | (h hasChanged and: [h needsToBeDrawn]) ifTrue: [^true]].  ^false  "display is already up-to-date"! !!WorldState methodsFor: 'update cycle' stamp: 'nice 1/5/2010 15:59'!displayWorld: aWorld submorphs: submorphs  "Update this world's display."  | deferredUpdateMode handsToDraw allDamage |  submorphs do: [:m | m fullBounds].  "force re-layout if needed"  self checkIfUpdateNeeded ifFalse: [^ self].  "display is already up-to-date"  deferredUpdateMode := self doDeferredUpdatingFor: aWorld.  deferredUpdateMode ifFalse: [self assuredCanvas].  canvas roundCornersOf: aWorld during:[ | worldDamageRects handDamageRects |    worldDamageRects := self drawWorld: aWorld submorphs: submorphs invalidAreasOn: canvas.  "repair world's damage on canvas"    "self handsDo:[:h| h noticeDamageRects: worldDamageRects]."    handsToDraw := self selectHandsToDrawForDamage: worldDamageRects.    handDamageRects := handsToDraw collect: [:h | h savePatchFrom: canvas].    allDamage := worldDamageRects, handDamageRects.    handsToDraw reverseDo: [:h | canvas fullDrawMorph: h].  "draw hands onto world canvas"  ].  "*make this true to flash damaged areas for testing*"  self class debugShowDamage ifTrue: [aWorld flashRects: allDamage color: Color black].  canvas finish.  "quickly copy altered rects of canvas to Display:"  deferredUpdateMode    ifTrue: [self forceDamageToScreen: allDamage]    ifFalse: [canvas showAt: aWorld viewBox origin invalidRects: allDamage].  handsToDraw do: [:h | h restoreSavedPatchOn: canvas].  "restore world canvas under hands"  Display deferUpdates: false; forceDisplayUpdate.! !!WorldState methodsFor: 'update cycle' stamp: 'ar 6/28/2003 01:07'!displayWorldSafely: aWorld  "Update this world's display and keep track of errors during draw methods."  [aWorld displayWorld] ifError: [:err :rcvr |    "Handle a drawing error"    | errCtx errMorph |    errCtx := thisContext.    [      errCtx := errCtx sender.      "Search the sender chain to find the morph causing the problem"      [errCtx notNil and:[(errCtx receiver isMorph) not]]         whileTrue:[errCtx := errCtx sender].      "If we're at the root of the context chain then we have a fatal drawing problem"      errCtx ifNil:[^self handleFatalDrawingError: err].      errMorph := errCtx receiver.      "If the morph causing the problem has already the #drawError flag set,      then search for the next morph above in the caller chain."      errMorph hasProperty: #errorOnDraw    ] whileTrue.    errMorph setProperty: #errorOnDraw toValue: true.    "Install the old error handler, so we can re-raise the error"    rcvr error: err.  ].! !!WorldState methodsFor: 'update cycle' stamp: 'stephane.ducasse 10/18/2008 21:51'!doDeferredUpdatingFor: aWorld        "If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, do nothing and answer false. One can set the class variable DisableDeferredUpdates to true to completely disable the deferred updating feature."  | properDisplay |  PasteUpMorph disableDeferredUpdates ifTrue: [^ false].  (Display deferUpdates: true) ifNil: [^ false].  "deferred updates not supported"  properDisplay := canvas notNil and: [canvas form == Display].  aWorld == World ifTrue: [  "this world fills the entire Display"    properDisplay ifFalse: [      aWorld viewBox: Display boundingBox.    "do first since it may clear canvas"      self canvas: (Display getCanvas copyClipRect: Display boundingBox).    ]  ] ifFalse: [  "this world is inside an MVC window"    (properDisplay and: [canvas clipRect = aWorld viewBox]) ifFalse: [      self canvas:        (Display getCanvas copyOffset: 0@0 clipRect: aWorld viewBox)    ]  ].  ^ true! !!WorldState methodsFor: 'update cycle' stamp: 'adrian_lienhard 7/18/2009 15:30'!doOneCycleFor: aWorld  "Do one cycle of the interaction loop. This method is called repeatedly when the world is running. This is a moderately private method; a better alternative is usually either to wait for events or to check the state of things from #step methods."  self interCyclePause: MinCycleLapse.  self doOneCycleNowFor: aWorld.! !!WorldState methodsFor: 'update cycle' stamp: 'md 4/30/2008 16:33'!doOneCycleNowFor: aWorld  "Immediately do one cycle of the interaction loop.  This should not be called directly, but only via doOneCycleFor:"  DisplayScreen checkForNewScreenSize.  "process user input events"  LastCycleTime := Time millisecondClockValue.  self handsDo: [:h |    ActiveHand := h.    h processEvents.    ActiveHand := nil  ].  "the default is the primary hand"  ActiveHand := self hands first.  aWorld runStepMethods.    "there are currently some variations here"  self displayWorldSafely: aWorld.! !!WorldState methodsFor: 'update cycle' stamp: 'nice 1/5/2010 15:59'!drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas   "Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas thatwere redrawn."  | rectList n morphs rects validList |  rectList := damageRecorder invalidRectsFullBounds: aWorld viewBox.  "sort by areas to draw largest portions first"  rectList := rectList asArray sort: [:r1 :r2 | r1 area > r2 area].  damageRecorder reset.  n := submorphs size.  morphs := OrderedCollection new: n * 2.  rects := OrderedCollection new: n * 2.  validList := OrderedCollection new: n * 2.  rectList do:       [:dirtyRect |       dirtyRect allAreasOutsideList: validList        do:           [:r | | mm rect i c remnantIntersects remnants rectToFill |           "Experimental top-down drawing --      Traverses top to bottom, stopping if the entire area is filled.      If only a single rectangle remains, then continue with the reduced rectangle."          rectToFill := r.          remnants := OrderedCollection with: r.          i := 1.          [remnants isEmpty or: [i > n]] whileFalse:               [mm := submorphs at: i.              ((remnantIntersects := remnants select: [:each | (mm fullBounds intersects: each)]) notEmpty and: [mm visible])                 ifTrue:                   [morphs addLast: mm.                                    rects addLast: (Rectangle merging: (remnantIntersects collect: [:each | mm fullBounds intersect: each])).                  remnants removeAll: remnantIntersects.                  remnantIntersects do: [:eachIntersect | remnants addAll: (mm areasRemainingToFill: eachIntersect)].                  remnants size = 1 ifTrue: [rectToFill := remnants first].                  remnants isEmpty ifTrue: [rectToFill := nil]].              i := i + 1].          "Now paint from bottom to top, but using the reduced rectangles."          rectToFill             ifNotNil: [aWorld drawOn: (c := aCanvas copyClipRect: rectToFill)].          [morphs isEmpty] whileFalse:               [(rect := rects removeLast) == rectToFill                 ifFalse: [c := aCanvas copyClipRect: (rectToFill := rect)].              c fullDrawMorph: morphs removeLast].          morphs reset.          rects reset.          validList add: r]].  ^validList! !!WorldState methodsFor: 'update cycle' stamp: 'stephane.ducasse 9/25/2008 18:11'!forceDamageToScreen: allDamage  Display forceDamageToScreen: allDamage.  ! !!WorldState methodsFor: 'update cycle' stamp: 'AlainPlantec 1/7/2010 22:54'!interCyclePause: milliSecs  "delay enough that the previous cycle plus the amount of delay will equal milliSecs.  If the cycle is already expensive, then no delay occurs.  However, if the system is idly waiting for interaction from the user, the method will delay for a proportionally long time and cause the overall CPU usage of Squeak to be low.  If self serverMode returns true then, always do a complete delay of 50ms, independant of my argument. This prevents the freezing problem described in Mantis #6581"  | currentTime wait |  self serverMode    ifFalse: [      (lastCycleTime notNil and: [CanSurrenderToOS ~~ false]) ifTrue: [         currentTime := Time millisecondClockValue.        wait := lastCycleTime + milliSecs - currentTime.        (wait > 0 and: [ wait <= milliSecs ] ) ifTrue: [          (Delay forMilliseconds: wait) wait ] ] ]    ifTrue: [ (Delay forMilliseconds: 50) wait ].  lastCycleTime := Time millisecondClockValue.  CanSurrenderToOS := true.! !!GrafPort methodsFor: 'accessing' stamp: 'ar 2/17/2000 01:09'!fillPattern: anObject  fillPattern := anObject.  self fillColor: anObject.! !!GrafPort methodsFor: 'copying' stamp: 'GuillermoPolito 9/1/2010 18:39'!copyBits  "Override copybits to do translucency if desired"  (combinationRule >= 30 and: [combinationRule <= 31])     ifTrue: [self copyBitsTranslucent: (alpha ifNil:[255])]    ifFalse: [super copyBits]! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 5/17/2000 21:20'!fillRect: rect offset: aPoint  "The offset is really just for stupid InfiniteForms."  | fc |  fillPattern class == InfiniteForm ifTrue:[    fc := halftoneForm.    self fillColor: nil.    fillPattern displayOnPort: ((self clippedBy: rect) colorMap: nil) at: aPoint.    halftoneForm := fc.    ^self].  destX := rect left.  destY := rect top.  sourceX := 0.  sourceY := 0.  width := rect width.  height := rect height.  self copyBits.! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/17/2000 01:08'!image: aForm at: aPoint sourceRect: sourceRect rule: rule  "Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."  sourceForm := aForm.  combinationRule := rule.  self sourceRect: sourceRect.  self destOrigin: aPoint.  self copyBits! !!MorphicEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 16:48'!hand  "Return the source that generated the event"  ^source! !!MorphicEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 19:17'!isDropEvent  ^false! !!MorphicEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 19:19'!isKeyboard  ^false! !!MorphicEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 19:19'!isMouse  ^false! !!MorphicEvent methodsFor: 'testing' stamp: 'ar 9/14/2000 18:21'!isMouseOver  ^self type == #mouseOver! !!MorphicEvent methodsFor: 'testing' stamp: 'JMM 10/6/2004 21:23'!isMove  ^false! !!MorphicEvent methodsFor: 'testing' stamp: 'JMM 10/6/2004 21:35'!isWindowEvent  ^false! !!UserInputEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 15:54'!handler  ^handler! !!UserInputEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 15:54'!handler: anObject  handler := anObject! !!UserInputEvent methodsFor: 'accessing' stamp: 'ar 9/15/2000 22:45'!position  ^position! !!UserInputEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 15:45'!type  "Return a symbol indicating the type this event."  ^ type! !!UserInputEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 15:54'!wasHandled  ^wasHandled! !!UserInputEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 15:54'!wasHandled: aBool  wasHandled := aBool.! !!UserInputEvent methodsFor: 'modifier state' stamp: 'ar 9/13/2000 15:44'!controlKeyPressed  "Answer true if the control key on the keyboard was being held down when this event occurred."  ^ buttons anyMask: 16! !!UserInputEvent methodsFor: 'transforming' stamp: 'ar 10/9/2000 00:38'!transformBy: aMorphicTransform  "Transform the receiver into a local coordinate system."  position :=  aMorphicTransform globalPointToLocal: position.! !!UserInputEvent methodsFor: 'transforming' stamp: 'ar 10/9/2000 00:38'!transformedBy: aMorphicTransform  "Return the receiver transformed by the given transform into a local coordinate system."  ^self shallowCopy transformBy: aMorphicTransform! !!ShortIntegerArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:41'!at: index  "Return the 16-bit integer value at the given index of the receiver."  <primitive: 143>  index isInteger ifTrue: [self errorSubscriptBounds: index].  index isNumber ifTrue: [^ self at: index truncated].  self errorNonIntegerIndex.! !!ShortIntegerArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:41'!at: index put: value  "Store the given 16-bit integer at the given index in the receiver."  <primitive: 144>  index isInteger    ifTrue: [      (index >= 1 and: [index <= self size])        ifTrue: [self errorImproperStore]        ifFalse: [self errorSubscriptBounds: index]].  index isNumber ifTrue: [^ self at: index truncated put: value].  self errorNonIntegerIndex.! !!ShortIntegerArray methodsFor: 'accessing' stamp: 'ar 11/3/1998 15:41'!size  ^super size * 2! !!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'ar 10/10/2000 01:20'!dispatchDefault: anEvent with: aMorph  "Dispatch the given event. The event will be passed to the front-most visible submorph that contains the position wrt. to the event."  | localEvt index child morphs inside |  "See if we're fully outside aMorphs bounds"  (aMorph fullBounds containsPoint: anEvent position) ifFalse:[^#rejected]. "outside"  "Traverse children"  index := 1.  morphs := aMorph submorphs.  inside := false.  [index <= morphs size] whileTrue:[    child := morphs at: index.    localEvt := anEvent transformedBy: (child transformedFrom: aMorph).    (child processEvent: localEvt using: self) == #rejected ifFalse:[      "Not rejected. The event was in some submorph of the receiver"      inside := true.      localEvt wasHandled ifTrue:[anEvent copyHandlerState: localEvt].      index := morphs size. "break"    ].    index := index + 1.  ].  "Check for being inside the receiver"  inside ifFalse:[inside := aMorph containsPoint: anEvent position event: anEvent].  inside ifTrue:[^aMorph handleEvent: anEvent].  ^#rejected! !!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'ar 10/10/2000 21:13'!dispatchDropEvent: anEvent with: aMorph  "Find the appropriate receiver for the event and let it handle it. The dispatch is similar to the default dispatch with one difference: Morphs are given the chance to reject an entire drop operation. If the operation is rejected, no drop will be executed."  | inside index morphs child localEvt |  "Try to get out quickly"  (aMorph fullBounds containsPoint: anEvent cursorPoint)    ifFalse:[^#rejected].  "Give aMorph a chance to repel the dropping morph"  aMorph rejectDropEvent: anEvent.  anEvent wasHandled ifTrue:[^self].  "Go looking if any of our submorphs wants it"  index := 1.  inside := false.  morphs := aMorph submorphs.  [index <= morphs size] whileTrue:[    child := morphs at: index.    localEvt := anEvent transformedBy: (child transformedFrom: aMorph).    (child processEvent: localEvt using: self) == #rejected ifFalse:[      localEvt wasHandled ifTrue:[^anEvent wasHandled: true]. "done"      inside := true.      index := morphs size]. "break"    index := index + 1.  ].  inside ifFalse:[inside := aMorph containsPoint: anEvent cursorPoint event: anEvent].  inside ifTrue:[^aMorph handleEvent: anEvent].  ^#rejected! !!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'tbn 3/12/2010 01:53'!dispatchEvent: anEvent with: aMorph  "Dispatch the given event for a morph that has chosen the receiver to dispatch its events. The method implements a shortcut for repeated dispatches of events using the same dispatcher."  anEvent type == lastType ifTrue:[^self perform: lastDispatch with: anEvent with: aMorph].  "Otherwise classify"  lastType := anEvent type.  anEvent isMouse ifTrue:[    anEvent isMouseDown ifTrue:[      lastDispatch := #dispatchMouseDown:with:.      ^self dispatchMouseDown: anEvent with: aMorph]].  anEvent type == #dropEvent ifTrue:[    lastDispatch := #dispatchDropEvent:with:.    ^self dispatchDropEvent: anEvent with: aMorph].  lastDispatch := #dispatchDefault:with:.  ^self dispatchDefault: anEvent with: aMorph! !!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'ar 10/10/2000 21:14'!dispatchMouseDown: anEvent with: aMorph  "Find the appropriate receiver for the event and let it handle it. Default rules:  * The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.  * When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.  * When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.  * If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event."  | globalPt localEvt index child morphs handler inside lastHandler |  "Try to get out quickly"  globalPt := anEvent cursorPoint.  (aMorph fullBounds containsPoint: globalPt) ifFalse:[^#rejected].  "Install the prospective handler for the receiver"  lastHandler := anEvent handler. "in case the mouse wasn't even in the receiver"  handler := aMorph handlerForMouseDown: anEvent.  handler ifNotNil:[anEvent handler: handler].  "Now give our submorphs a chance to handle the event"  index := 1.  morphs := aMorph submorphs.  [index <= morphs size] whileTrue:[    child := morphs at: index.    localEvt := anEvent transformedBy: (child transformedFrom: aMorph).    (child processEvent: localEvt using: self) == #rejected ifFalse:[      "Some child did contain the point so we're part of the top-most chain."      inside := false.      localEvt wasHandled ifTrue:[anEvent copyHandlerState: localEvt].      index := morphs size].    index := index + 1.  ].  (inside == false or:[aMorph containsPoint: anEvent cursorPoint event: anEvent]) ifTrue:[    "Receiver is in the top-most unlocked, visible chain."    handler ifNotNil:[handler handleEvent: anEvent].    "Note: Re-installing the handler is not really necessary but good style."    anEvent handler: lastHandler.    ^self  ].  "Mouse was not on receiver nor any of its children"  anEvent handler: lastHandler.  ^#rejected! !!MouseEvent methodsFor: '*Polymorph-Widgets' stamp: 'gvc 1/28/2008 13:14'!isMouseWheel  "Answer whether the receiver is a mouse wheel event."    ^false! !!MouseEvent methodsFor: 'accessing' stamp: 'ar 9/15/2000 22:51'!cursorPoint  "Answer the location of the cursor's hotspot when this event occured."  ^ position! !!MouseEvent methodsFor: 'button state' stamp: 'NS 5/19/2003 15:17'!anyButtonPressed  "Answer true if any mouse button is being pressed."  ^ buttons anyMask: self class anyButton! !!MouseEvent methodsFor: 'button state' stamp: 'NS 5/19/2003 15:17'!blueButtonPressed  "Answer true if the blue mouse button is being pressed. This is the third mouse button or cmd+click on the Mac."  ^ buttons anyMask: self class blueButton! !!MouseEvent methodsFor: 'button state' stamp: 'NS 5/19/2003 15:17'!yellowButtonPressed  "Answer true if the yellow mouse button is being pressed. This is the second mouse button or option+click on the Mac."  ^ buttons anyMask: self class yellowButton! !!MouseEvent methodsFor: 'converting' stamp: 'pmm 3/13/2010 11:33'!asMouseEnter  ^self shallowCopy setType: #mouseEnter! !!MouseEvent methodsFor: 'converting' stamp: 'pmm 3/13/2010 11:33'!asMouseLeave  ^self shallowCopy setType: #mouseLeave! !!MouseEvent methodsFor: 'converting' stamp: 'marcus.denker 8/24/2008 21:42'!asMouseOver  "Convert the receiver into a mouse over event"  ^MouseEvent basicNew setType: #mouseOver position: position buttons: buttons hand: source! !!MouseEvent methodsFor: 'dispatching' stamp: 'ar 10/10/2000 21:15'!sentTo: anObject  "Dispatch the receiver into anObject"  type == #mouseOver ifTrue:[^anObject handleMouseOver: self].  type == #mouseEnter ifTrue:[^anObject handleMouseEnter: self].  type == #mouseLeave ifTrue:[^anObject handleMouseLeave: self].  ^super sentTo: anObject.! !!MouseEvent methodsFor: 'testing' stamp: 'ar 10/5/2000 19:43'!isDraggingEvent  source ifNil:[^false].  source hasSubmorphs ifTrue:[^true].  self anyButtonPressed ifTrue:[^true].  ^false! !!MouseEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 15:30'!isMouse  ^true! !!MouseEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 15:32'!isMouseDown  ^self type == #mouseDown! !!MouseEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 15:32'!isMouseUp  ^self type == #mouseUp! !!MouseEvent methodsFor: 'private' stamp: 'ar 10/10/2000 21:15'!setType: aSymbol  "For quick conversion between event types"  type := aSymbol.! !!MouseEvent methodsFor: 'private' stamp: 'ar 9/15/2000 22:53'!setType: evtType position: evtPos buttons: evtButtons hand: evtHand  type := evtType.  position := evtPos.  buttons := evtButtons.  source := evtHand.  wasHandled := false.! !!MouseMoveEvent methodsFor: 'dispatching' stamp: 'ar 10/10/2000 21:15'!sentTo: anObject  "Dispatch the receiver into anObject"  type == #mouseMove ifTrue:[^anObject handleMouseMove: self].  ^super sentTo: anObject.! !!MouseMoveEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 19:29'!isMove  ^true! !!MouseMoveEvent methodsFor: 'transforming' stamp: 'ar 9/15/2000 22:52'!transformBy: aMorphicTransform  "Transform the receiver into a local coordinate system."  position :=  aMorphicTransform globalPointToLocal: position.  startPoint :=  aMorphicTransform globalPointToLocal: startPoint.! !!MouseMoveEvent methodsFor: 'private' stamp: 'ar 10/5/2000 23:55'!setType: evtType startPoint: evtStart endPoint: evtEnd trail: evtTrail buttons: evtButtons hand: evtHand stamp: stamp  type := evtType.  startPoint := evtStart.  position := evtEnd.  trail := evtTrail.  buttons := evtButtons.  source := evtHand.  wasHandled := false.  timeStamp := stamp.! !!Color methodsFor: '*Polymorph-Widgets' stamp: 'gvc 3/21/2008 16:35'!fillRectangle: aRectangle on: aCanvas  "Fill the given rectangle on the given canvas with the receiver."    aCanvas fillRectangle: aRectangle basicFillStyle: self! !!ShortIntegerArray class methodsFor: 'initialization' stamp: 'bf 1/7/2005 16:39'!initialize  "ShortIntegerArray initialize"  Smalltalk addToStartUpList: self after: Delay.  LastSaveOrder := self new: 2.  LastSaveOrder at: 1 put: 42.  LastSaveOrder at: 2 put: 13.! !!ShortIntegerArray class methodsFor: 'instance creation' stamp: 'ar 1/15/1999 17:28'!new: n  ^super new: n + 1 // 2! !!WorldState class methodsFor: 'accessing' stamp: 'AlainPlantec 12/6/2009 21:42'!debugShowDamage  ^ DebugShowDamage ifNil: [DebugShowDamage := false]! !!WorldState class methodsFor: 'initialization' stamp: 'RAA 7/15/2000 12:58'!addDeferredUIMessage: valuableObject  self deferredUIMessages nextPut: valuableObject.! !!WorldState class methodsFor: 'initialization' stamp: 'MarcusDenker 12/8/2009 17:55'!deferredUIMessages  ^DeferredUIMessages ifNil: [DeferredUIMessages := SharedQueue new].! !!WorldState class methodsFor: 'initialization' stamp: 'MarcusDenker 12/8/2009 17:54'!initialize  "WorldState initialize"  MinCycleLapse := 20.    "allows 50 frames per second..."  DeferredUIMessages := SharedQueue new.! !!WorldState class methodsFor: 'settings' stamp: 'AlainPlantec 12/14/2009 14:02'!serverMode  ^ ServerMode ifNil: [ServerMode := false]! !!BorderStyle methodsFor: '*Polymorph-Widgets' stamp: 'gvc 6/25/2008 12:09'!hasFillStyle  "Answer false."  ^false! !!BorderStyle methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:07'!color  ^Color transparent! !!BorderStyle methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:07'!width  ^0! !!BorderStyle methodsFor: 'color tracking' stamp: 'ar 8/25/2001 17:29'!trackColorFrom: aMorph  "If necessary, update our color to reflect a change in aMorphs color"! !!BorderStyle methodsFor: 'drawing' stamp: 'ar 8/25/2001 16:24'!frameRectangle: aRectangle on: aCanvas  "Frame the given rectangle on aCanvas"  aCanvas frameRectangle: aRectangle width: self width color: self color! !!Form methodsFor: '*Morphic' stamp: 'ar 5/28/2000 12:03'!defaultCanvasClass  "Return the default canvas used for drawing onto the receiver"  ^Display defaultCanvasClass! !!Form methodsFor: '*Morphic' stamp: 'ar 5/28/2000 12:03'!getCanvas  "Return a Canvas that can be used to draw onto the receiver"  ^self defaultCanvasClass on: self! !!MorphicUIManager methodsFor: 'bitBlt' stamp: 'Pavel.Krivanek 10/28/2008 11:02'!grafPort      ^ Display defaultBitBltClass asGrafPort! !!MorphicUIManager methodsFor: 'ui requests' stamp: 'pavel.krivanek 2/24/2007 15:15'!checkForNewDisplaySize  "Check whether the screen size has changed and if so take appropriate actions"  Display extent = DisplayScreen actualScreenSize ifTrue: [^ Display].  DisplayScreen startUp.  World restoreMorphicDisplay.! !!MorphicUIManager methodsFor: 'ui requests' stamp: 'JuanVuletich 11/1/2010 15:17'!currentWorld  ActiveWorld ifNotNil: [^ActiveWorld].  ^World! !!MorphicUIManager methodsFor: 'ui requests' stamp: 'pavel.krivanek 2/24/2007 13:14'!newDisplayDepthNoRestore: pixelSize  "Change depths.  Check if there is enough space!!  , di"  | area need |  pixelSize = Display depth ifTrue: [^ Display  "no change"].  pixelSize abs < Display depth ifFalse:    ["Make sure there is enough space"    area := Display boundingBox area. "pixels"    need := (area * (pixelSize abs - Display depth) // 8)  "new bytes needed"        + Smalltalk lowSpaceThreshold.    (Smalltalk garbageCollectMost <= need      and: [Smalltalk garbageCollect <= need])      ifTrue: [self error: 'Insufficient free space']].  Display setExtent: Display extent depth: pixelSize.  DisplayScreen startUp! !!MorphicUIManager methodsFor: 'ui requests' stamp: 'pavel.krivanek 2/24/2007 13:22'!restoreDisplay  World fullRepaintNeeded! !!Canvas methodsFor: 'accessing' stamp: 'ar 2/17/2000 01:46'!shadowColor: aColor  "Set a shadow color. If set this color overrides any client-supplied color."! !!Canvas methodsFor: 'converting' stamp: 'ar 6/24/1999 17:46'!asShadowDrawingCanvas  ^self asShadowDrawingCanvas: (Color black alpha: 0.5).! !!Canvas methodsFor: 'converting' stamp: 'ar 8/8/2001 14:14'!asShadowDrawingCanvas: aColor  ^(ShadowDrawingCanvas on: self) shadowColor: aColor! !!Canvas methodsFor: 'drawing-general' stamp: 'ar 5/29/1999 05:14'!draw: anObject  ^anObject drawOn: self! !!Canvas methodsFor: 'drawing-general' stamp: 'StephaneDucasse 2/8/2011 09:10'!drawMorph: aMorph  "Draw the receiver morph on the receiver"    "Changed to improve performance. Have seen a 30% improvement."    (aMorph fullBounds intersects: self clipRect)    ifFalse: [^self].  self draw: aMorph! !!Canvas methodsFor: 'drawing-general'!fullDraw: anObject  ^anObject fullDrawOn: self! !!Canvas methodsFor: 'drawing-general' stamp: 'StephaneDucasse 2/8/2011 09:30'!fullDrawMorph: aMorph  "Hook method for potential other canvases. In the core, this method looks supefluous but PostscriptCanvases and other canvases can specialized it for Morph rendering. Therefore it should not be merged with fullDraw:."  self fullDraw: aMorph! !!Canvas methodsFor: 'drawing-general' stamp: 'ar 12/30/2001 18:47'!roundCornersOf: aMorph during: aBlock  ^self roundCornersOf: aMorph in: aMorph bounds during: aBlock! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 2/16/2000 23:45'!drawImage: aForm at: aPoint  "Draw the given Form, which is assumed to be a Form or ColorForm"  self drawImage: aForm    at: aPoint    sourceRect: aForm boundingBox! !!Canvas methodsFor: 'drawing-images' stamp: 'IgorStasenko 7/18/2011 18:08'!drawImage: aForm at: aPoint sourceRect: sourceRect  "Draw the given form."  ^self image: aForm    at: aPoint    sourceRect: sourceRect    rule: Form over! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 2/16/2000 23:48'!paintImage: aForm at: aPoint  "Draw the given Form, which is assumed to be a Form or ColorForm following the convention that zero is the transparent pixel value."  self paintImage: aForm    at: aPoint    sourceRect: aForm boundingBox! !!Canvas methodsFor: 'drawing-images' stamp: 'IgorStasenko 7/18/2011 18:08'!paintImage: aForm at: aPoint sourceRect: sourceRect  "Draw the given Form, which is assumed to be a Form or ColorForm following the convention that zero is the transparent pixel value."  ^self image: aForm    at: aPoint    sourceRect: sourceRect    rule: Form paint! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 2/17/2000 14:05'!translucentImage: aForm at: aPoint  "Draw a translucent image using the best available way of representing translucency."  self translucentImage: aForm    at: aPoint    sourceRect: aForm boundingBox! !!Canvas methodsFor: 'drawing-images' stamp: 'IgorStasenko 7/18/2011 18:08'!translucentImage: aForm at: aPoint sourceRect: sourceRect  "Draw a translucent image using the best available way of representing translucency.  Note: This will be fixed in the future."  (self depth < 32 or:[aForm isTranslucent not])     ifTrue:[^self paintImage: aForm at: aPoint sourceRect: sourceRect].  self image: aForm    at: aPoint    sourceRect: sourceRect    rule: Form blend! !!Canvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/18/1999 07:32'!fillRectangle: r color: c  "Fill the rectangle using the given color"  ^self     frameAndFillRectangle: r    fillColor: c    borderWidth: 0    borderColor: Color transparent! !!Canvas methodsFor: 'drawing-rectangles' stamp: 'StephaneDucasse 2/9/2011 14:36'!fillRectangle: aRectangle fillStyle: aFillStyle  "Fill the given rectangle. Double-dispatched via the fill style."    aFillStyle fillRectangle: aRectangle on: self! !!Canvas methodsFor: 'drawing-rectangles' stamp: 'ar 8/25/2001 17:27'!fillRectangle: aRectangle fillStyle: aFillStyle borderStyle: aBorderStyle  "Fill the given rectangle."  self fillRectangle: (aRectangle insetBy: aBorderStyle width) fillStyle: aFillStyle.  aBorderStyle frameRectangle: aRectangle on: self! !!Canvas methodsFor: 'drawing-rectangles' stamp: 'marcus.denker 8/15/2008 17:43'!frameRectangle: r width: w color: c  "Draw a frame around the given rectangle"  ^self frameAndFillRectangle: r      fillColor: Color transparent      borderWidth: w      borderColor: c! !!Canvas methodsFor: 'initialization' stamp: 'ar 2/9/1999 06:29'!flush! !!ColorMappingCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/22/1999 17:59'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor  "Draw the rectangle using the given attributes"  myCanvas    frameAndFillRectangle: r    fillColor: (self mapColor: fillColor)    borderWidth: borderWidth    borderColor: (self mapColor: borderColor)! !!ColorMappingCanvas methodsFor: 'drawing-support' stamp: 'ar 6/22/1999 18:22'!translateBy: delta during: aBlock  "Set a translation only during the execution of aBlock."  | oldCanvas |  oldCanvas := myCanvas.  myCanvas translateBy: delta during:[:newCanvas|    myCanvas := newCanvas.    aBlock value: self].  myCanvas := oldCanvas.! !!ShadowDrawingCanvas methodsFor: 'accessing' stamp: 'ar 8/8/2001 14:14'!shadowColor: aColor  shadowColor := aColor! !!ShadowDrawingCanvas methodsFor: 'initialization' stamp: 'ar 8/8/2001 14:14'!on: aCanvas  myCanvas := aCanvas.  shadowColor := Color black.! !!ShadowDrawingCanvas methodsFor: 'private' stamp: 'ar 8/8/2001 14:14'!mapColor: aColor  aColor isColor ifFalse:[^aColor]. "Should not happen but who knows..."  ^aColor isTransparent    ifTrue:[aColor]    ifFalse:[shadowColor]! !!ColorMappingCanvas class methodsFor: 'instance creation' stamp: 'ar 6/22/1999 18:23'!on: aCanvas  ^self new on: aCanvas! !!MouseOverHandler methodsFor: 'event handling' stamp: 'HernanWilkinson 6/12/2009 13:40'!noticeMouseOver: aMorph event: anEvent  "Remember that the mouse is currently over some morph"  leftMorphs remove: aMorph ifAbsent: [ enteredMorphs nextPut: aMorph ].  overMorphs nextPut: aMorph.! !!MouseOverHandler methodsFor: 'event handling' stamp: 'HernanWilkinson 6/12/2009 13:51'!processMouseOver: anEvent   self initializeProcessMouseOver.  self handleAsMouseOver: anEvent.  self hasLeftMorphsChanged ifTrue: [     self handleAsMouseLeave: anEvent.    self handleAsMouseEnter: anEvent.    self rememberOverList ].    self initializeTrackedMorphs ! !!MouseOverHandler methodsFor: 'event handling - private' stamp: 'HernanWilkinson 6/12/2009 13:33'!handleAsMouseEnter: anEvent   | asMouseEnterEvent |    asMouseEnterEvent := anEvent asMouseEnter.  enteredMorphs := enteredMorphs contents.  enteredMorphs reverseDo: [ :anEnteredMorph |     self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ]! !!MouseOverHandler methodsFor: 'event handling - private' stamp: 'HernanWilkinson 6/12/2009 08:44'!handleAsMouseLeave: anEvent   self keepLeftMorphsOrder.  self informMouseLeaveToLeftMorphsUsing: anEvent! !!MouseOverHandler methodsFor: 'event handling - private' stamp: 'HernanWilkinson 6/12/2009 11:59'!handleAsMouseOver: anEvent   anEvent hand handleEvent: anEvent asMouseOver.! !!MouseOverHandler methodsFor: 'event handling - private' stamp: 'HernanWilkinson 6/12/2009 11:56'!hasLeftMorphsChanged  ^(leftMorphs isEmpty and: [ enteredMorphs position = 0 ]) not! !!MouseOverHandler methodsFor: 'event handling - private' stamp: 'HernanWilkinson 6/12/2009 13:36'!inform: evt to: aLeftMorph originatedFrom: anEvent ifNotFocusedDo: aBlock  ^ (self is: anEvent withFocusOver: aLeftMorph)     ifTrue: [ self transform: evt from: anEvent andSendTo: aLeftMorph ]    ifFalse: aBlock! !!MouseOverHandler methodsFor: 'event handling - private' stamp: 'HernanWilkinson 6/12/2009 11:41'!informMouseLeaveToLeftMorphsUsing: anEvent   | asMouseLeaveEvent |    asMouseLeaveEvent := anEvent asMouseLeave.    leftMorphs do: [ :aLeftMorph |     self inform: asMouseLeaveEvent to: aLeftMorph originatedFrom: anEvent ifNotFocusedDo: [ overMorphs nextPut: aLeftMorph ] ]! !!MouseOverHandler methodsFor: 'event handling - private' stamp: 'HernanWilkinson 6/12/2009 13:29'!initializeProcessMouseOver  leftMorphs := mouseOverMorphs asIdentitySet.  overMorphs := WriteStream on: (Array new: leftMorphs size).  enteredMorphs := WriteStream on: #()! !!MouseOverHandler methodsFor: 'event handling - private' stamp: 'HernanWilkinson 6/12/2009 13:37'!is: anEvent withFocusOver: aMorph   | focusedMorph |    focusedMorph := anEvent hand mouseFocus.  ^ aMorph = focusedMorph or: [ aMorph hasOwner: focusedMorph ]! !!MouseOverHandler methodsFor: 'event handling - private' stamp: 'HernanWilkinson 6/12/2009 13:32'!keepLeftMorphsOrder  leftMorphs size > 1 ifTrue: [ leftMorphs := mouseOverMorphs intersection: leftMorphs ]  ! !!MouseOverHandler methodsFor: 'event handling - private' stamp: 'HernanWilkinson 6/12/2009 11:58'!rememberOverList  mouseOverMorphs := overMorphs contents.! !!MouseOverHandler methodsFor: 'event handling - private' stamp: 'HernanWilkinson 6/12/2009 13:38'!transform: anEvent from: originalEvent andSendTo: aMorph  | transformedEvent |  transformedEvent := anEvent transformedBy: (aMorph transformedFrom: originalEvent hand).  ^ aMorph handleEvent: transformedEvent! !!MouseOverHandler methodsFor: 'initialization' stamp: 'HernanWilkinson 6/4/2009 14:10'!initialize  mouseOverMorphs := #().    self initializeTrackedMorphs  ! !!MouseOverHandler methodsFor: 'initialization' stamp: 'HernanWilkinson 6/12/2009 13:48'!initializeTrackedMorphs  leftMorphs := OrderedCollection new.  overMorphs := WriteStream on: #().  enteredMorphs := WriteStream on: #().  ! !!DropEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 18:33'!contents  ^contents! !!DropEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 19:21'!cursorPoint  "For compatibility with mouse events"  ^position! !!DropEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 18:33'!type  ^#dropEvent! !!DropEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 18:44'!wasHandled  ^wasHandled! !!DropEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 18:44'!wasHandled: aBool  wasHandled := aBool.! !!DropEvent methodsFor: 'dispatching' stamp: 'ar 1/10/2001 21:24'!sentTo: anObject  "Dispatch the receiver into anObject"  self type == #dropEvent ifTrue:[^anObject handleDropMorph: self].! !!DropEvent methodsFor: 'private' stamp: 'ar 9/13/2000 19:23'!setPosition: pos contents: aMorph hand: aHand  position := pos.  contents := aMorph.  source := aHand.  wasHandled := false.! !!MouseButtonEvent methodsFor: 'accessing' stamp: 'ar 9/15/2000 19:58'!blueButtonChanged  "Answer true if the blue mouse button has changed. This is the third mouse button or cmd+click on the Mac."  ^ whichButton anyMask: 1! !!MouseButtonEvent methodsFor: 'dispatching' stamp: 'ar 9/16/2000 13:05'!sentTo: anObject  "Dispatch the receiver into anObject"  type == #mouseDown ifTrue:[^anObject handleMouseDown: self].  type == #mouseUp ifTrue:[^anObject handleMouseUp: self].  ^super sentTo: anObject! !!MouseButtonEvent methodsFor: 'private' stamp: 'ar 10/5/2000 23:55'!setType: evtType position: evtPos which: button buttons: evtButtons hand: evtHand stamp: stamp  type := evtType.  position := evtPos.  buttons := evtButtons.  source := evtHand.  wasHandled := false.  whichButton := button.  timeStamp := stamp.! !!DamageRecorder methodsFor: 'initialization' stamp: 'sma 6/5/2000 11:55'!reset  "Clear the damage list."  invalidRects := OrderedCollection new: 15.  totalRepaint := false! !!DamageRecorder methodsFor: 'recording'!doFullRepaint  "Record that a full redisplay is needed. No further damage rectangles will be recorded until after the next reset."  ^ totalRepaint := true.! !!DamageRecorder methodsFor: 'recording' stamp: 'StephaneDucasse 2/7/2011 22:25'!invalidRectsFullBounds: aRectangle  "Return a collection of damaged rectangles for the given canvas. If a total repaint has been requested, return the given rectangle."  ^ totalRepaint    ifTrue: [ Array with: aRectangle]    ifFalse: [ invalidRects copy].! !!DamageRecorder methodsFor: 'recording' stamp: 'nice 1/5/2010 15:59'!recordInvalidRect: newRect  "Record the given rectangle in my damage list, a list of rectangular areas of the display that should be redraw on the next display cycle."  "Details: Damaged rectangles are often identical or overlap significantly. In these cases, we merge them to reduce the number of damage rectangles that must be processed when the display is updated. Moreover, above a certain threshold, we ignore the individual rectangles completely, and simply do a complete repaint on the next cycle."  | mergeRect |  totalRepaint ifTrue: [^ self].  "planning full repaint; don't bother collecting damage"  invalidRects do:    [:rect | | a |    ((a := (rect intersect: newRect) area) > 40      and: ["Avoid combining a vertical and horizontal rects.          Can make a big diff and we only test when likely."          a > (newRect area // 4) or: [a > (rect area // 4)]])      ifTrue:      ["merge rectangle in place (see note below) if there is significant overlap"      rect setOrigin: (rect origin min: newRect origin) truncated        corner: (rect corner max: newRect corner) truncated.      ^ self]].  invalidRects size >= 50 ifTrue:    ["if there are too many separate areas, merge them all"    mergeRect := Rectangle merging: invalidRects.    self reset.    invalidRects addLast: mergeRect].  "add the given rectangle to the damage list"  "Note: We make a deep copy of all rectangles added to the damage list,    since rectangles in this list may be extended in place."  invalidRects addLast:    (newRect topLeft truncated corner: newRect bottomRight truncated).! !!DamageRecorder methodsFor: 'testing' stamp: 'dgd 2/22/2003 14:43'!updateIsNeeded  "Return true if the display needs to be updated."  ^totalRepaint or: [invalidRects notEmpty]! !!DamageRecorder class methodsFor: 'instance creation'!new  ^ super new reset! !!BorderStyle class methodsFor: 'instance creation' stamp: 'ar 8/25/2001 17:26'!default  ^Default ifNil:[Default := self new]! !!TextStopConditions methodsFor: 'accessing' stamp: 'nice 3/8/2010 14:02'!at: anInteger put: aSymbolOrNil  "Set the special action associated with a character of code anInteger, or nil if none.  The character code should be betxween 1 and 256 (presumably codePoint + 1).  It can eventually be 257 for endOfRun action, or 258 for crossedX action for backward compatibility with historical squeak versions."    anInteger = 257    ifTrue: [      self endOfRun: aSymbolOrNil..      ^aSymbolOrNil].  anInteger = 258    ifTrue: [      self crossedX: aSymbolOrNil..      ^aSymbolOrNil].  ^stops at: anInteger put: aSymbolOrNil! !!TextStopConditions methodsFor: 'accessing' stamp: 'nice 3/8/2010 12:00'!crossedX: aSymbolOrNil  crossedX := aSymbolOrNil.    "Backward compatibility with historical EndOfRun TextConstant handling"  stops size >= 258 ifTrue: [stops at: 258 put: crossedX]! !!TextStopConditions methodsFor: 'accessing' stamp: 'nice 3/8/2010 12:00'!endOfRun: aSymbolOrNil  endOfRun := aSymbolOrNil.    "Backward compatibility with historical EndOfRun TextConstant handling"  stops size >= 257 ifTrue: [stops at: 257 put: endOfRun]! !!TextStopConditions methodsFor: 'copying' stamp: 'nice 4/17/2009 00:52'!postCopy  stops := stops copy! !!TextStopConditions methodsFor: 'initialize-release' stamp: 'nice 3/8/2010 14:31'!initialize  "Initialize the default stop conditions."  stops := Array new: 258.  self endOfRun: #endOfRun.  self crossedX: #crossedX.! !!ShortRunArray methodsFor: 'private' stamp: 'ar 11/3/1998 21:02'!setRunAt: i toLength: runLength value: value  (value < -16r7FFF or:[value > 16r8000]) ifTrue:[^self errorImproperStore].  (runLength < 0 or:[runLength > 16rFFFF]) ifTrue:[^self errorImproperStore].  self basicAt: i put: (runLength bitShift: 16) +     ((value bitAnd: 16r7FFF) - (value bitAnd: -16r8000)).! !!ShortRunArray methodsFor: 'private' stamp: 'ar 11/3/1998 21:00'!setRuns: runArray values: valueArray  | runLength value |  1 to: runArray size do:[:i|    runLength := runArray at: i.    value := valueArray at: i.    self setRunAt: i toLength: runLength value: value.  ].! !!ShortRunArray class methodsFor: 'initialization' stamp: 'bf 1/7/2005 16:40'!initialize  "ShortRunArray initialize"  Smalltalk addToStartUpList: self after: Delay.  LastSaveOrder := #(42 42 42) as: self.! !!ShortRunArray class methodsFor: 'instance creation' stamp: 'PeterHugossonMiller 9/3/2009 11:21'!newFrom: aCollection  "Compress aCollection into a ShortRunArray"  | lastValue lastRun runs values |  aCollection isEmpty ifTrue:[^self runs:#() values: #()].  runs := (WordArray new: 100) writeStream.  values := (ShortIntegerArray new: 100) writeStream.  lastValue := aCollection first.  lastRun := 0.  aCollection do:[:item|    (item = lastValue and:[lastRun < 16r8000]) ifTrue:[      lastRun := lastRun + 1.    ] ifFalse:[      runs nextPut: lastRun.      values nextPut: lastValue.      lastRun := 1.      lastValue := item.    ].  ].  runs nextPut: lastRun.  values nextPut: lastValue.  ^self runs: runs contents values: values contents! !!ShortRunArray class methodsFor: 'instance creation' stamp: 'ar 11/3/1998 17:12'!runs: runCollection values: valueCollection  ^(self basicNew: runCollection size) setRuns: runCollection values: valueCollection! !!MorphExtension methodsFor: 'accessing' stamp: 'gvc 9/11/2009 18:10'!borderStyle  "Answer the value of borderStyle"  ^borderStyle! !!MorphExtension methodsFor: 'accessing' stamp: 'gvc 9/11/2009 18:10'!clipSubmorphs  "Answer the value of clipSubmorphs"  ^clipSubmorphs! !!MorphExtension methodsFor: 'accessing' stamp: 'gvc 9/11/2009 17:58'!clipSubmorphs: anObject  "Set the value of clipSubmorphs"  clipSubmorphs := anObject! !!MorphExtension methodsFor: 'accessing' stamp: 'gvc 9/11/2009 18:10'!cornerStyle  "Answer the value of cornerStyle"  ^cornerStyle! !!MorphExtension methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:51'!eventHandler  "answer the receiver's eventHandler"  ^ eventHandler ! !!MorphExtension methodsFor: 'accessing' stamp: 'gvc 9/11/2009 18:12'!fillStyle  "Answer the value of fillStyle"  ^ fillStyle! !!MorphExtension methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:38'!locked  "answer whether the receiver is Locked"  ^ locked! !!MorphExtension methodsFor: 'accessing' stamp: 'di 8/14/1998 13:07'!sticky  ^ sticky! !!MorphExtension methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:41'!visible  "answer whether the receiver is visible"  ^ visible! !!MorphExtension methodsFor: 'accessing - layout properties' stamp: 'gvc 9/11/2009 18:12'!layoutPolicy  ^layoutPolicy! !!MorphExtension methodsFor: 'accessing - layout properties' stamp: 'gvc 9/11/2009 18:12'!layoutProperties  ^layoutProperties! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'md 2/27/2006 08:41'!assureOtherProperties  "creates an otherProperties for the receiver if needed"  otherProperties ifNil: [self initializeOtherProperties].  ^ otherProperties! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'md 2/27/2006 08:42'!hasProperty: aSymbol   "Answer whether the receiver has the property named aSymbol"  | property |  otherProperties ifNil: [^ false].  property := otherProperties at: aSymbol ifAbsent: [].  property isNil ifTrue: [^ false].  property == false ifTrue: [^ false].  ^ true! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'marcus.denker 9/17/2008 17:39'!initializeOtherProperties  "private - initializes the receiver's otherProperties"  otherProperties :=  SmallIdentityDictionary new! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'md 2/27/2006 08:37'!removeOtherProperties  "Remove the 'other' properties"  otherProperties := nil! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'md 2/27/2006 08:43'!removeProperty: aSymbol   "removes the property named aSymbol if it exists"  otherProperties ifNil: [^ self].  otherProperties removeKey: aSymbol ifAbsent: [].  otherProperties isEmpty ifTrue: [self removeOtherProperties]! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'dgd 2/16/2003 21:49'!setProperty: aSymbol toValue: abObject   "change the receiver's property named aSymbol to anObject"  self assureOtherProperties at: aSymbol put: abObject! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'dgd 2/16/2003 21:00'!valueOfProperty: aSymbol "answer the value of the receiver's property named aSymbol"  ^ self    valueOfProperty: aSymbol    ifAbsent: []! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'md 2/27/2006 08:43'!valueOfProperty: aSymbol ifAbsent: aBlock   "if the receiver possesses a property of the given name, answer    its value. If not then evaluate aBlock and answer the result of    this block evaluation"  otherProperties ifNil: [^ aBlock value].  ^ otherProperties at: aSymbol ifAbsent: [^ aBlock value]! !!MorphExtension methodsFor: 'initialization' stamp: 'StephaneDucasse 7/18/2010 16:28'!initialize    locked := false.  visible := true.  sticky := false.! !!BitBlt class methodsFor: '*Morphic' stamp: 'ar 5/28/2000 12:04'!asGrafPort  "Return the GrafPort associated with the receiver"  ^GrafPort! !!Morph methodsFor: '*Morphic-Worlds' stamp: 'dgd 9/1/2004 16:10'!clearArea  "Answer the clear area of the receiver. It means the area free    of docking bars."  | visTop visBottom visLeft visRight |  visTop := self top.  visBottom := self bottom.  visLeft := self left.  visRight := self right.  ^ Rectangle    left: visLeft    right: visRight    top: visTop    bottom: visBottom! !!Morph methodsFor: '*Polymorph-Widgets' stamp: 'gvc 5/16/2007 11:26'!changed  "Report that the area occupied by this morph should be redrawn.  Fixed to include submorphs outside the outerBounds."    ^fullBounds     ifNil: [self invalidRect: self privateFullBounds]    ifNotNil: [self invalidRect: fullBounds]! !!Morph methodsFor: '*Polymorph-Widgets' stamp: 'gvc 2/23/2009 13:23'!handlesDropShadowInHand  "Answer whether the receiver will handle drop shadow drawing when picked up in the hand."  ^false! !!Morph methodsFor: '*Polymorph-Widgets' stamp: 'di 9/14/1998 07:31'!handlesMouseOver: evt  "Do I want to receive mouseEnter: and mouseLeave: when the button is up and the hand is empty?  The default response is false, except if you have added sensitivity to mouseEnter: or mouseLeave:, using the on:send:to: mechanism."   self eventHandler ifNotNil: [^ self eventHandler handlesMouseOver: evt].  ^ false! !!Morph methodsFor: '*Polymorph-Widgets' stamp: 'gvc 2/2/2009 13:24'!layoutChanged  "Fixed to always flush layout cache - finally tracked down  layout anomalies due to cached extents in layout  policies not being flushed, the previous (incorrect) assumption being  that it did not matter if layout was to be recomputed (fullBounds being nil).  Recomputing of the layout apparently does not flush so must be done here."    | layout |  fullBounds := nil.  layout := self layoutPolicy.  layout ifNotNil:[layout flushLayoutCache].  owner ifNotNil: [owner layoutChanged].  "note: does not send #ownerChanged here - we'll do this when computing the new layout"! !!Morph methodsFor: '*Polymorph-Widgets' stamp: 'gvc 2/24/2009 13:43'!morphicLayerNumberWithin: anOwner  "Helpful for insuring some morphs always appear in front of or behind others.  Smaller numbers are in front.  Fixed here to call #morphicLayerNumber rather than access property directly."  ^self morphicLayerNumber! !!Morph methodsFor: '*Polymorph-Widgets' stamp: 'StephaneDucasse 11/1/2009 19:24'!privateMoveBy: delta   "Private!! Use 'position:' instead."  | fill border|  bounds := bounds translateBy: delta.  fullBounds ifNotNil: [fullBounds := fullBounds translateBy: delta].  fill := self fillStyle.  fill isOrientedFill ifTrue: [fill origin: fill origin + delta].  border := self borderStyle.  (border hasFillStyle and: [border fillStyle isOrientedFill]) ifTrue: [    border fillStyle origin: border fillStyle origin + delta]! !!Morph methodsFor: '*Polymorph-Widgets' stamp: 'gvc 1/28/2008 16:17'!rejectsEvent: anEvent  "Return true to reject the given event.  Rejecting an event means neither the receiver nor any of it's submorphs will be given any chance to handle it.  If the event is a mouse wheel event then only reject if the receiver is not visible."    (anEvent isMouse and: [anEvent isMouseWheel])    ifTrue: [^self visible not].  ^self isLocked or: [self visible not]! !!Morph methodsFor: 'accessing' stamp: 'gvc 9/11/2009 17:09'!borderStyle  extension ifNil: [^BorderStyle default trackColorFrom: self].  ^(extension borderStyle ifNil: [BorderStyle default]) trackColorFrom: self! !!Morph methodsFor: 'accessing' stamp: 'ar 8/25/2001 18:28'!borderWidth  ^self borderStyle width! !!Morph methodsFor: 'accessing' stamp: 'md 2/27/2006 09:53'!eventHandler  "answer the receiver's eventHandler"  ^ extension ifNotNil: [extension eventHandler] ! !!Morph methodsFor: 'accessing' stamp: 'di 1/3/1999 12:25'!hasTranslucentColor  "Answer true if this any of this morph is translucent but not transparent."  ^ color isColor and: [color isTranslucentColor]! !!Morph methodsFor: 'accessing' stamp: 'md 2/27/2006 09:53'!isLocked  "answer whether the receiver is Locked"  extension ifNil: [^ false].  ^ extension locked! !!Morph methodsFor: 'accessing' stamp: 'md 2/27/2006 09:57'!isSticky  "answer whether the receiver is Sticky"  extension ifNil: [^ false].  ^ extension sticky! !!Morph methodsFor: 'accessing' stamp: 'dgd 9/1/2004 16:14'!visibleClearArea  "Answer the receiver visible clear area. The intersection   between the clear area and the viewbox."  ^ self viewBox intersect: self clearArea! !!Morph methodsFor: 'accessing' stamp: 'ar 6/23/2001 16:06'!wantsToBeCachedByHand  "Return true if the receiver wants to be cached by the hand when it is dragged around.  Note: The default implementation queries all submorphs since subclasses may have shapes that do not fill the receiver's bounds completely."  self hasTranslucentColor ifTrue:[^false].  self submorphsDo:[:m|    m wantsToBeCachedByHand ifFalse:[^false].  ].  ^true! !!Morph methodsFor: 'accessing' stamp: 'AlainPlantec 10/17/2009 17:11'!wantsToBeTopmost  "Answer if the receiver want to be one of the topmost objects in its owner"  ^ false! !!Morph methodsFor: 'accessing - extension' stamp: 'md 2/27/2006 08:46'!assureExtension  "creates an extension for the receiver if needed"  extension ifNil: [self initializeExtension].  ^ extension! !!Morph methodsFor: 'accessing - extension' stamp: 'md 2/27/2006 08:35'!initializeExtension  "private - initializes the receiver's extension"  extension := MorphExtension new! !!Morph methodsFor: 'accessing - properties' stamp: 'md 2/27/2006 09:47'!hasProperty: aSymbol   "Answer whether the receiver has the property named aSymbol"  extension ifNil: [^ false].  ^extension hasProperty: aSymbol! !!Morph methodsFor: 'accessing - properties' stamp: 'md 2/27/2006 09:48'!removeProperty: aSymbol   "removes the property named aSymbol if it exists"  extension ifNil:  [^ self].  extension removeProperty: aSymbol! !!Morph methodsFor: 'accessing - properties' stamp: 'md 2/27/2006 09:48'!setProperty: aSymbol toValue: anObject   "change the receiver's property named aSymbol to anObject"  anObject ifNil: [^ self removeProperty: aSymbol].  self assureExtension setProperty: aSymbol toValue: anObject! !!Morph methodsFor: 'accessing - properties' stamp: 'md 2/27/2006 08:53'!valueOfProperty: aSymbol   "answer the value of the receiver's property named aSymbol"  ^ extension ifNotNil: [extension valueOfProperty: aSymbol]! !!Morph methodsFor: 'accessing - properties' stamp: 'md 2/27/2006 08:50'!valueOfProperty: aSymbol ifAbsent: aBlock   "if the receiver possesses a property of the given name, answer    its value. If not then evaluate aBlock and answer the result of    this block evaluation"  ^ extension     ifNotNil: [extension valueOfProperty: aSymbol ifAbsent: aBlock]    ifNil: [aBlock value]! !!Morph methodsFor: 'change reporting' stamp: 'ar 8/12/2003 21:50'!addedMorph: aMorph  "Notify the receiver that the given morph was just added."! !!Morph methodsFor: 'change reporting' stamp: 'ar 11/12/2000 18:50'!invalidRect: damageRect  ^self invalidRect: damageRect from: self! !!Morph methodsFor: 'change reporting' stamp: 'md 4/3/2006 11:52'!invalidRect: aRectangle from: aMorph  | damageRect |  aRectangle hasPositiveExtent ifFalse: [ ^self ].  damageRect := aRectangle.  aMorph == self ifFalse:[    "Clip to receiver's clipping bounds if the damage came from a child"    self clipSubmorphs       ifTrue:[damageRect := aRectangle intersect: self clippingBounds]].  owner ifNotNil: [owner invalidRect: damageRect from: self].! !!Morph methodsFor: 'change reporting' stamp: 'sw 7/8/1998 13:21'!ownerChanged  "The receiver's owner, some kind of a pasteup, has changed its layout."  self snapToEdgeIfAppropriate! !!Morph methodsFor: 'change reporting' stamp: 'ar 8/12/2003 22:26'!privateInvalidateMorph: aMorph  "Private. Invalidate the given morph after adding or removing.  This method is private because a) we're invalidating the morph 'remotely'  and b) it forces a fullBounds computation which should not be necessary  for a general morph c) the morph may or may not actually invalidate  anything (if it's not in the world nothing will happen) and d) the entire  mechanism should be rewritten."  aMorph fullBounds.  aMorph changed! !!Morph methodsFor: 'classification' stamp: 'jm 5/7/1998 13:45'!isRenderer  "A *renderer* morph transforms the appearance of its submorph in some manner. For example, it might supply a drop shadow or scale and rotate the morph it encases. Answer true if this morph acts as a renderer. This default implementation returns false."  "Details: A renderer is assumed to have a single submorph. Renderers may be nested to concatenate their transformations. It is useful to be able to find the outer-most renderer. This can be done by ascending the owner chain from the rendered morph. To find the morph being rendered, one can descend through the (singleton) submorph lists of the renderer chain until a non-renderer is encountered."  ^ false! !!Morph methodsFor: 'classification' stamp: 'ar 12/16/2001 18:28'!isTextMorph  ^false! !!Morph methodsFor: 'classification'!isWorldMorph  ^ false! !!Morph methodsFor: 'drawing' stamp: 'Henrik Sperre Johansen 3/15/2009 00:03'!areasRemainingToFill: aRectangle   "Pushed up from BorderedMorph, all cases tested for there are  supported by basic Morph."  "Morphs which achieve translucency by other means than fillStyle will have  to reimplement this"  "Fixed here to test the fillStyle rather than color for translucency.  Since can have a translucent fillStyle while the (calculated) color is not."  self fillStyle isTranslucent    ifTrue: [^ Array with: aRectangle].  self wantsRoundedCorners    ifTrue: [(self borderWidth > 0          and: [self borderColor isColor              and: [self borderColor isTranslucent]])        ifTrue: [^ aRectangle            areasOutside: (self innerBounds intersect: self boundsWithinCorners)]        ifFalse: [^ aRectangle areasOutside: self boundsWithinCorners]]    ifFalse: [(self borderWidth > 0          and: [self borderColor isColor              and: [self borderColor isTranslucent]])        ifTrue: [^ aRectangle areasOutside: self innerBounds]        ifFalse: [^ aRectangle areasOutside: self bounds]]! !!Morph methodsFor: 'drawing' stamp: 'ar 10/29/2000 19:16'!clippingBounds  "Return the bounds to which any submorphs should be clipped if the property is set"  ^self innerBounds! !!Morph methodsFor: 'drawing' stamp: 'gvc 9/11/2009 17:59'!clipSubmorphs  "Drawing specific. If this property is set, clip the receiver's    submorphs to the receiver's clipping bounds."    extension ifNil: [^false].  ^extension clipSubmorphs ifNil: [false]! !!Morph methodsFor: 'drawing' stamp: 'gvc 9/11/2009 17:59'!clipSubmorphs: aBool  "Drawing specific. If this property is set, clip the receiver's submorphs to the receiver's clipping bounds."  self invalidRect: self fullBounds.    aBool == self clipSubmorphs ifFalse:[    self assureExtension.    extension clipSubmorphs: aBool.    self invalidRect: self fullBounds]! !!Morph methodsFor: 'drawing' stamp: 'panda 4/28/2000 11:59'!drawDropHighlightOn: aCanvas  self highlightedForDrop ifTrue: [    aCanvas frameRectangle: self fullBounds color: self dropHighlightColor].! !!Morph methodsFor: 'drawing' stamp: '   9/3/2000 13:55'!drawMouseDownHighlightOn: aCanvas  self highlightedForMouseDown ifTrue: [    aCanvas frameRectangle: self fullBounds color: self color darker darker].! !!Morph methodsFor: 'drawing' stamp: 'IgorStasenko 7/18/2011 17:48'!drawOn: aCanvas  aCanvas fillRectangle: self bounds fillStyle: self fillStyle borderStyle: self borderStyle! !!Morph methodsFor: 'drawing' stamp: 'AlainPlantec 2/18/2010 02:08'!drawSubmorphsOn: aCanvas   "Display submorphs back to front"  | drawBlock |  submorphs isEmpty ifTrue: [^self].  drawBlock := [:canvas | submorphs reverseDo: [:m | canvas fullDrawMorph: m]].  self clipSubmorphs     ifTrue: [aCanvas clipBy: (aCanvas clipRect intersect: self clippingBounds) during: drawBlock]    ifFalse: [drawBlock value: aCanvas]! !!Morph methodsFor: 'drawing' stamp: 'IgorStasenko 8/8/2011 17:20'!fullDrawOn: aCanvas  "Draw the full Morphic structure on the given Canvas"  self visible ifFalse: [^ self].  (aCanvas isVisible: self fullBounds) ifFalse:[^self].    (self hasProperty: #errorOnDraw) ifTrue:[^self drawErrorOn: aCanvas].    [    "Note: At some point we should generalize this into some sort of     multi-canvas so that we can cross-optimize some drawing operations."    "Pass 1: Draw eventual drop-shadow"    self hasDropShadow ifTrue: [ self drawDropShadowOn: aCanvas ].    (self hasRolloverBorder and: [(aCanvas seesNothingOutside: self bounds) not])      ifTrue: [self drawRolloverBorderOn: aCanvas].    "Pass 2: Draw receiver itself"    (aCanvas isVisible: self bounds) ifTrue:[aCanvas drawMorph: self].    self drawSubmorphsOn: aCanvas.    self drawDropHighlightOn: aCanvas.    self drawMouseDownHighlightOn: aCanvas.      ] on: Error do: [:err |    self setProperty: #errorOnDraw toValue: true.    ^ self drawErrorOn: aCanvas  ]! !!Morph methodsFor: 'drawing' stamp: 'LC 5/18/2000 08:48'!highlightedForMouseDown  ^(self valueOfProperty: #highlightedForMouseDown) == true! !!Morph methodsFor: 'drawing' stamp: 'jm 6/11/97 17:21'!imageForm  ^ self imageFormForRectangle: self fullBounds! !!Morph methodsFor: 'drawing' stamp: 'di 9/9/1998 22:25'!imageFormForRectangle: rect  ^ self imageForm: Display depth forRectangle: rect! !!Morph methodsFor: 'drawing' stamp: 'ar 9/1/2000 14:23'!imageForm: depth forRectangle: rect  | canvas |  canvas := Display defaultCanvasClass extent: rect extent depth: depth.  canvas translateBy: rect topLeft negated    during:[:tempCanvas| tempCanvas fullDrawMorph: self].  ^ canvas form offset: rect topLeft! !!Morph methodsFor: 'drawing' stamp: 'md 2/27/2006 08:49'!visible  "answer whether the receiver is visible"  extension ifNil: [^ true].  ^ extension visible! !!Morph methodsFor: 'drop shadows' stamp: 'dgd 2/16/2003 21:42'!hasDropShadow  "answer whether the receiver has DropShadow"  ^ self    valueOfProperty: #hasDropShadow    ifAbsent: [false]! !!Morph methodsFor: 'drop shadows' stamp: 'dgd 2/16/2003 21:58'!hasRolloverBorder  "answer whether the receiver has RolloverBorder"  ^ self    valueOfProperty: #hasRolloverBorder    ifAbsent: [false]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'AlainPlantec 12/1/2010 09:32'!aboutToBeGrabbedBy: aHand  "The receiver is being grabbed by a hand.  Perform necessary adjustments (if any) and return the actual morph  that should be added to the hand."  | extentToHandToHand |  self formerOwner: owner.  self formerPosition: self position.  (extentToHandToHand := self valueOfProperty: #expandedExtent)    ifNotNil: [self removeProperty: #expandedExtent.      self extent: extentToHandToHand].  ^self "Grab me"! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:41'!enableDragNDrop  self enableDragNDrop: true! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 10/11/2000 18:21'!enableDragNDrop: aBoolean  "Set both properties at once"  self separateDragAndDrop.  self enableDrag: aBoolean.  self enableDrop: aBoolean.! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:50'!enableDrag: aBoolean  self setProperty: #dragEnabled toValue: aBoolean! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:51'!enableDrop: aBoolean  self setProperty: #dropEnabled toValue: aBoolean! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 18:13'!formerOwner  ^self valueOfProperty: #formerOwner! !!Morph methodsFor: 'dropping/grabbing' stamp: 'GuillermoPolito 9/1/2010 18:40'!formerOwner: aMorphOrNil   aMorphOrNil ifNil: [self removeProperty: #formerOwner]    ifNotNil: [self setProperty: #formerOwner toValue: aMorphOrNil]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 18:13'!formerPosition  ^self valueOfProperty: #formerPosition! !!Morph methodsFor: 'dropping/grabbing' stamp: 'GuillermoPolito 9/1/2010 18:41'!formerPosition: formerPosition   formerPosition ifNil: [self removeProperty: #formerPosition]    ifNotNil: [self setProperty: #formerPosition toValue: formerPosition]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 10/6/2000 15:13'!grabTransform  "Return the transform for the receiver which should be applied during grabbing"  ^owner ifNil:[IdentityTransform new] ifNotNil:[owner grabTransform]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/28/2000 10:53'!highlightedForDrop  ^(self valueOfProperty: #highlightedForDrop) == true! !!Morph methodsFor: 'dropping/grabbing' stamp: 'AlainPlantec 12/1/2010 09:35'!justDroppedInto: aMorph event: anEvent  "This message is sent to a dropped morph after it has been dropped on -- and been accepted by -- a drop-sensitive morph"  | aWindow  cmd |  self formerOwner: nil.  self formerPosition: nil.  (aWindow := aMorph ownerThatIsA: SystemWindow)     ifNotNil: [aWindow isActive       ifFalse: [aWindow activate]].  (self isInWorld)     ifTrue: [self world startSteppingSubmorphsOf: self].  "An object launched by certain parts-launcher mechanisms should end up fully visible..."  (self hasProperty: #beFullyVisibleAfterDrop)     ifTrue: [aMorph == ActiveWorld       ifTrue: [self goHome].      self removeProperty: #beFullyVisibleAfterDrop].! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 2/6/2001 22:12'!justGrabbedFrom: formerOwner  "The receiver was just grabbed from its former owner and is now attached to the hand. By default, we pass this message on if we're a renderer."  (self isRenderer and:[self hasSubmorphs])     ifTrue:[self firstSubmorph justGrabbedFrom: formerOwner].! !!Morph methodsFor: 'dropping/grabbing' stamp: 'AlainPlantec 12/1/2010 09:35'!rejectDropMorphEvent: evt  "The receiver has been rejected, and must be put back somewhere.  There are three cases:  (1)  It remembers its former owner and position, and goes right back there  (2)  It remembers its former position only, in which case it was torn off from a parts bin, and the UI is that it floats back to its donor position and then vanishes."  self formerOwner notNil     ifTrue: [^ self slideBackToFormerSituation: evt].  self formerPosition  "Position but no owner -- can just make it vanish"    ifNotNil: [^ self vanishAfterSlidingTo: self formerPosition event: evt].! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 1/11/1999 20:07'!repelsMorph: aMorph event: ev  ^ false! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 10/11/2000 18:24'!separateDragAndDrop  "Conversion only. Separate the old #dragNDropEnabled into #dragEnabled and #dropEnabled and remove the old property."  | dnd |  (self hasProperty: #dragNDropEnabled) ifFalse:[^self].  dnd := (self valueOfProperty: #dragNDropEnabled) == true.  self dragEnabled: dnd.  self dropEnabled: dnd.  self removeProperty: #dragNDropEnabled.! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 8/12/2003 23:35'!slideBackToFormerSituation: evt   | slideForm formerOwner formerPosition aWorld startPoint endPoint trans |  formerOwner := self formerOwner.  formerPosition := self formerPosition.  aWorld := evt hand world.  trans := formerOwner transformFromWorld.  slideForm := self imageForm offset: 0 @ 0.   startPoint := evt hand fullBounds origin.  endPoint := trans localPointToGlobal: formerPosition.  owner removeMorph: self.  aWorld displayWorld.  slideForm     slideFrom: startPoint    to: endPoint    nSteps: 12    delay: 15.  formerOwner addMorph: self.  self position: formerPosition.  self justDroppedInto: formerOwner event: evt! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 9/18/2000 18:34'!wantsToBeDroppedInto: aMorph  "Return true if it's okay to drop the receiver into aMorph. This check is symmetric to #wantsDroppedMorph:event: to give both parties a chance of figuring out whether they like each other."  ^true! !!Morph methodsFor: 'event handling' stamp: 'nk 3/10/2004 19:47'!handlerForMouseDown: anEvent   "Return the (prospective) handler for a mouse down event. The handler is temporarily   installed and can be used for morphs further down the hierarchy to negotiate whether   the inner or the outer morph should finally handle the event."  anEvent blueButtonPressed    ifTrue: [^ self handlerForBlueButtonDown: anEvent].  anEvent yellowButtonPressed    ifTrue: [^ self handlerForYellowButtonDown: anEvent].  (self handlesMouseDown: anEvent)    ifFalse: [^ nil]. "not interested"  anEvent handler    ifNil: [^ self ]. "Same priority but I am innermost"  "Nobody else was interested"  ^self mouseDownPriority >= anEvent handler mouseDownPriority    ifTrue: [ self]    ifFalse: [ nil]! !!Morph methodsFor: 'event handling' stamp: 'nk 2/14/2004 18:42'!handlesMouseDown: evt  "Do I want to receive mouseDown events (mouseDown:, mouseMove:, mouseUp:)?"  "NOTE: The default response is false, except if you have added sensitivity to mouseDown events using the on:send:to: mechanism.  Subclasses that implement these messages directly should override this one to return true."   self eventHandler ifNotNil: [^ self eventHandler handlesMouseDown: evt].  ^ false! !!Morph methodsFor: 'event handling' stamp: 'di 9/14/1998 07:31'!handlesMouseOverDragging: evt  "Return true if I want to receive mouseEnterDragging: and mouseLeaveDragging: when the hand drags something over me (button up or button down), or when the mouse button is down but there is no mouseDown recipient.  The default response is false, except if you have added sensitivity to mouseEnterLaden: or mouseLeaveLaden:, using the on:send:to: mechanism."  "NOTE:  If the hand state matters in these cases, it may be tested by constructs such as    event anyButtonPressed    event hand hasSubmorphs"  self eventHandler ifNotNil: [^ self eventHandler handlesMouseOverDragging: evt].  ^ false! !!Morph methodsFor: 'event handling' stamp: 'ar 10/22/2000 17:06'!handlesMouseStillDown: evt  "Return true if the receiver wants to get repeated #mouseStillDown: messages between #mouseDown: and #mouseUp"  self eventHandler ifNotNil: [^ self eventHandler handlesMouseStillDown: evt].  ^ false! !!Morph methodsFor: 'event handling'!transformFromWorld  "Return a transform to map world coordinates into my local coordinates"  ^ self transformFrom: nil! !!Morph methodsFor: 'event handling' stamp: 'dgd 2/22/2003 14:36'!transformFrom: uberMorph   "Return a transform to be used to map coordinates in a morph above me into my childrens coordinates, or vice-versa. This is used to support scrolling, scaling, and/or rotation. This default implementation just returns my owner's transform or the identity transform if my owner is nil.   Note:  This method cannot be used to map into the receiver's coordinate system!!"  (self == uberMorph or: [owner isNil]) ifTrue: [^IdentityTransform new].  ^owner transformFrom: uberMorph! !!Morph methodsFor: 'events-alarms' stamp: 'ar 9/11/2000 16:34'!alarmScheduler  "Return the scheduler being responsible for triggering alarms"  ^self world! !!Morph methodsFor: 'events-alarms' stamp: 'ar 9/14/2000 12:14'!removeAlarm: aSelector  "Remove the given alarm"  | scheduler |  scheduler := self alarmScheduler.  scheduler ifNotNil:[scheduler removeAlarm: aSelector for: self].! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/13/2000 17:58'!containsPoint: aPoint event: anEvent  "Return true if aPoint is considered to be inside the receiver for the given event.  The default implementation treats locked children as integral part of their owners."  (self fullBounds containsPoint: aPoint) ifFalse:[^false].  (self containsPoint: aPoint) ifTrue:[^true].  self submorphsDo:[:m|    (m isLocked and:[m fullContainsPoint:       ((m transformedFrom: self) globalPointToLocal: aPoint)]) ifTrue:[^true]].  ^false! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/13/2000 14:51'!defaultEventDispatcher  "Return the default event dispatcher to use with events that are directly sent to the receiver"  ^MorphicEventDispatcher new! !!Morph methodsFor: 'events-processing' stamp: 'AlainPlantec 12/1/2010 09:33'!handleDropMorph: anEvent  "Handle a dropping morph."  | aMorph localPt |  aMorph := anEvent contents.  "Do a symmetric check if both morphs like each other"  ((self wantsDroppedMorph: aMorph event: anEvent)  "I want her"    and: [aMorph wantsToBeDroppedInto: self])   "she wants me"    ifFalse: [^ self].  anEvent wasHandled: true.  "Transform the morph into the receiver's coordinate frame. This is currently incomplete since it only takes the offset into account where it really should take the entire transform."  localPt := (self transformedFrom: anEvent hand world) "full transform down"        globalPointToLocal: aMorph referencePosition.  aMorph referencePosition: localPt.  self acceptDroppingMorph: aMorph event: anEvent.  aMorph justDroppedInto: self event: anEvent.! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/15/2000 21:13'!handleEvent: anEvent  "Handle the given event"  ^anEvent sentTo: self.! !!Morph methodsFor: 'events-processing' stamp: 'AlainPlantec 11/16/2010 19:19'!handleMouseDown: anEvent  "System level event handling."  anEvent wasHandled ifTrue:[^self]. "not interested"  anEvent hand removePendingBalloonFor: self.  anEvent hand removePendingHaloFor: self.  anEvent wasHandled: true.    "Make me modal during mouse transitions"  anEvent hand newMouseFocus: self event: anEvent.    self mouseDown: anEvent.    (self handlesMouseStillDown: anEvent) ifTrue:[    self startStepping: #handleMouseStillDown:       at: Time millisecondClockValue + self mouseStillDownThreshold      arguments: {anEvent copy resetHandlerFields}      stepTime: self mouseStillDownStepRate ].! !!Morph methodsFor: 'events-processing' stamp: 'AlainPlantec 12/11/2009 23:33'!handleMouseEnter: anEvent  "System level event handling."  (anEvent isDraggingEvent) ifTrue:[    (self handlesMouseOverDragging: anEvent) ifTrue:[      anEvent wasHandled: true.      self mouseEnterDragging: anEvent].    ^self].  (self handlesMouseOver: anEvent) ifTrue:[    anEvent wasHandled: true.    self mouseEnter: anEvent.  ].! !!Morph methodsFor: 'events-processing' stamp: 'ar 10/6/2000 00:15'!handleMouseLeave: anEvent  "System level event handling."  anEvent hand removePendingBalloonFor: self.  anEvent hand removePendingHaloFor: self.  anEvent isDraggingEvent ifTrue:[    (self handlesMouseOverDragging: anEvent) ifTrue:[      anEvent wasHandled: true.      self mouseLeaveDragging: anEvent].    ^self].  (self handlesMouseOver: anEvent) ifTrue:[    anEvent wasHandled: true.    self mouseLeave: anEvent.  ].! !!Morph methodsFor: 'events-processing' stamp: 'nk 6/13/2004 09:16'!handleMouseMove: anEvent  "System level event handling."  anEvent wasHandled ifTrue:[^self]. "not interested"  "Rules say that by default a morph gets #mouseMove iff    * the hand is not dragging anything,      + and some button is down,      + and the receiver is the current mouse focus."  (anEvent hand hasSubmorphs) ifTrue:[^self].  (anEvent anyButtonPressed and:[anEvent hand mouseFocus == self]) ifFalse:[^self].  anEvent wasHandled: true.  self mouseMove: anEvent.  (self handlesMouseStillDown: anEvent) ifTrue:[    "Step at the new location"    self startStepping: #handleMouseStillDown:       at: Time millisecondClockValue      arguments: {anEvent copy resetHandlerFields}      stepTime: self mouseStillDownStepRate ].! !!Morph methodsFor: 'events-processing' stamp: 'ar 4/23/2001 17:24'!handleMouseOver: anEvent  "System level event handling."  anEvent hand mouseFocus == self ifTrue:[    "Got this directly through #handleFocusEvent: so check explicitly"    (self containsPoint: anEvent position event: anEvent) ifFalse:[^self]].  anEvent hand noticeMouseOver: self event: anEvent! !!Morph methodsFor: 'events-processing' stamp: 'ar 10/22/2000 17:09'!handleMouseUp: anEvent  "System level event handling."  anEvent wasHandled ifTrue:[^self]. "not interested"  anEvent hand mouseFocus == self ifFalse:[^self]. "Not interested in other parties"  anEvent hand releaseMouseFocus: self.  anEvent wasHandled: true.  anEvent blueButtonChanged    ifTrue:[self blueButtonUp: anEvent]    ifFalse:[self mouseUp: anEvent.        self stopSteppingSelector: #handleMouseStillDown:].! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/13/2000 17:14'!processEvent: anEvent  "Process the given event using the default event dispatcher."  ^self processEvent: anEvent using: self defaultEventDispatcher! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/18/2000 19:14'!processEvent: anEvent using: defaultDispatcher  "This is the central entry for dispatching events in morphic. Given some event and a default dispatch strategy, find the right receiver and let him handle it.  WARNING: This is a powerful hook. If you want to use a different event dispatcher from the default, here is the place to hook it in. Depending on how the dispatcher is written (e.g., whether it calls simply #processEvent: or #processEvent:using:) you can change the dispatch strategy for entire trees of morphs. Similarly, you can disable entire trees of morphs from receiving any events whatsoever. Read the documentation in class MorphicEventDispatcher before playing with it. "  (self rejectsEvent: anEvent) ifTrue:[^#rejected].  ^defaultDispatcher dispatchEvent: anEvent with: self! !!Morph methodsFor: 'events-processing' stamp: 'ar 10/5/2000 19:25'!rejectDropEvent: anEvent  "This hook allows the receiver to repel a drop operation currently executed. The method is called prior to checking children so the receiver must validate that the event was really designated for it.  Note that the ordering of the tests below is designed to avoid a (possibly expensive) #fullContainsPoint: test. If the receiver doesn't want to repel the morph anyways we don't need to check after all."  (self repelsMorph: anEvent contents event: anEvent) ifFalse:[^self]. "not repelled"  (self fullContainsPoint: anEvent position) ifFalse:[^self]. "not for me"  "Throw it away"  anEvent wasHandled: true.  anEvent contents rejectDropMorphEvent: anEvent.! !!Morph methodsFor: 'events-processing' stamp: 'marcus.denker 8/24/2008 22:02'!transformedFrom: uberMorph  "Return a transform to map coordinates of uberMorph, a morph above me in my owner chain, into the coordinates of MYSELF not any of my children."  "self flag: #arNote." "rename this method"  owner ifNil:[^IdentityTransform basicNew].  ^ (owner transformFrom: uberMorph)! !!Morph methodsFor: 'geometry' stamp: 'efc 2/13/2003 18:17'!bottom  " Return the y-coordinate of my bottom side "  ^ bounds bottom! !!Morph methodsFor: 'geometry' stamp: 'jm 8/3/97 15:50'!bounds  "Return the bounds of this morph."  "Note: It is best not to override this method because many methods in Morph and its subclasses use the instance variable directly rather than 'self bounds'. Instead, subclasses should be sure that the bounds instance variable is correct."  ^ bounds! !!Morph methodsFor: 'geometry' stamp: 'ar 12/14/2000 13:48'!bounds: newBounds  | oldExtent newExtent |  oldExtent := self extent.  newExtent := newBounds extent.  (oldExtent dotProduct: oldExtent) <= (newExtent dotProduct: newExtent) ifTrue:[    "We're growing. First move then resize."    self position: newBounds topLeft; extent: newExtent.  ] ifFalse:[    "We're shrinking. First resize then move."    self extent: newExtent; position: newBounds topLeft.  ].! !!Morph methodsFor: 'geometry'!extent  ^ bounds extent! !!Morph methodsFor: 'geometry'!extent: t1   | t2 |  t2 := t1 rounded.  (bounds extent closeTo: t2)    ifTrue: [^ self].  self changed.  bounds := bounds topLeft extent: t2.  self layoutChanged.  self changed! !!Morph methodsFor: 'geometry' stamp: 'ar 12/22/2001 22:43'!innerBounds  "Return the inner rectangle enclosed by the bounds of this morph excluding the space taken by its borders. For an unbordered morph, this is just its bounds."  ^ self bounds insetBy: self borderWidth! !!Morph methodsFor: 'geometry' stamp: 'efc 2/13/2003 18:16'!left  " Return the x-coordinate of my left side "  ^ bounds left! !!Morph methodsFor: 'geometry' stamp: 'ar 11/12/2000 22:06'!outerBounds  "Return the 'outer' bounds of the receiver, e.g., the bounds that need to be invalidated when the receiver changes."  | box |  box := self bounds.  self hasDropShadow ifTrue:[box := self expandFullBoundsForDropShadow: box].  self hasRolloverBorder ifTrue:[box := self expandFullBoundsForRolloverBorder: box].  ^box! !!Morph methodsFor: 'geometry'!position  ^ bounds topLeft! !!Morph methodsFor: 'geometry' stamp: 'wiz 11/25/2004 12:54'!position: aPoint   "Change the position of this morph and and all of its  submorphs. "  | delta box |  delta := aPoint asNonFractionalPoint - bounds topLeft.  (delta x = 0      and: [delta y = 0])    ifTrue: [^ self].  "Null change"  box := self fullBounds.  (delta dotProduct: delta)      > 100    ifTrue: ["e.g., more than 10 pixels moved"      self invalidRect: box.      self        invalidRect: (box translateBy: delta)]    ifFalse: [self        invalidRect: (box            merge: (box translateBy: delta))].  self privateFullMoveBy: delta.  owner    ifNotNil: [owner layoutChanged]! !!Morph methodsFor: 'geometry' stamp: 'ar 9/22/2000 20:12'!referencePosition  "Return the current reference position of the receiver"  | box |  box := self bounds.  ^box origin + (self rotationCenter * box extent).! !!Morph methodsFor: 'geometry' stamp: 'ar 9/27/2000 14:04'!referencePosition: aPosition  "Move the receiver to match its reference position with aPosition"  | newPos intPos |  newPos := self position + (aPosition - self referencePosition).  intPos := newPos asIntegerPoint.  newPos = intPos     ifTrue:[self position: intPos]    ifFalse:[self position: newPos].! !!Morph methodsFor: 'geometry' stamp: 'efc 2/13/2003 18:16'!right  " Return the x-coordinate of my right side "  ^ bounds right! !!Morph methodsFor: 'geometry' stamp: 'efc 2/13/2003 18:17'!top  " Return the y-coordinate of my top side "  ^ bounds top! !!Morph methodsFor: 'geometry' stamp: 'ar 10/22/2000 18:03'!transformedBy: aTransform  aTransform isIdentity ifTrue:[^self].  aTransform isPureTranslation ifTrue:[    ^self position: (aTransform localPointToGlobal: self position).  ].! !!Morph methodsFor: 'geometry testing'!containsPoint: aPoint  ^ self bounds containsPoint: aPoint! !!Morph methodsFor: 'geometry testing' stamp: 'di 5/3/2000 19:05'!fullContainsPoint: aPoint  (self fullBounds containsPoint: aPoint) ifFalse: [^ false].  "quick elimination"  (self containsPoint: aPoint) ifTrue: [^ true].  "quick acceptance"  submorphs do: [:m | (m fullContainsPoint: aPoint) ifTrue: [^ true]].  ^ false! !!Morph methodsFor: 'initialize' stamp: 'dgd 3/7/2003 15:06'!defaultBounds"answer the default bounds for the receiver"  ^ 0 @ 0 corner: 50 @ 40! !!Morph methodsFor: 'initialize' stamp: 'dgd 2/14/2003 22:28'!defaultColor  "answer the default color/fill style for the receiver"  ^ Color blue! !!Morph methodsFor: 'initialize' stamp: 'alain.plantec 5/28/2009 10:09'!initialize  "initialize the state of the receiver"  super initialize.  owner := nil.  submorphs := EmptyArray.  bounds := self defaultBounds.  color := self defaultColor! !!Morph methodsFor: 'initialize' stamp: 'ar 1/31/2001 13:57'!intoWorld: aWorld  "The receiver has just appeared in a new world. Note:    * aWorld can be nil (due to optimizations in other places)    * owner is already set    * owner's submorphs may not include receiver yet.  Important: Keep this method fast - it is run whenever morphs are added."  aWorld ifNil:[^self].  self wantsSteps ifTrue:[aWorld startStepping: self].  self submorphsDo:[:m| m intoWorld: aWorld].! !!Morph methodsFor: 'initialize' stamp: 'alain.plantec 6/10/2008 18:35'!openInWorld        "Add this morph to the world."        self openInWorld: self currentWorld! !!Morph methodsFor: 'initialize' stamp: 'dgd 9/1/2004 16:12'!openInWorld: aWorld  "Add this morph to the requested World."  (aWorld visibleClearArea origin ~= (0@0) and: [self position = (0@0)]) ifTrue:    [self position: aWorld visibleClearArea origin].  aWorld addMorph: self.  aWorld startSteppingSubmorphsOf: self! !!Morph methodsFor: 'initialize' stamp: 'ar 1/31/2001 13:58'!outOfWorld: aWorld  "The receiver has just appeared in a new world. Notes:    * aWorld can be nil (due to optimizations in other places)    * owner is still valid  Important: Keep this method fast - it is run whenever morphs are removed."  aWorld ifNil:[^self].  "ar 1/31/2001: We could explicitly stop stepping the receiver here but for the sake of speed I'm for now relying on the lazy machinery in the world itself."  "aWorld stopStepping: self."  self submorphsDo:[:m| m outOfWorld: aWorld].! !!Morph methodsFor: 'layout' stamp: 'ar 11/12/2000 17:34'!adjustLayoutBounds  "Adjust the receivers bounds depending on the resizing strategy imposed"  | hFit vFit box myExtent extent |  hFit := self hResizing.  vFit := self vResizing.  (hFit == #shrinkWrap or:[vFit == #shrinkWrap]) ifFalse:[^self]. "not needed"  box := self layoutBounds.  myExtent := box extent.  extent := self submorphBounds corner - box origin.  hFit == #shrinkWrap ifTrue:[myExtent := extent x @ myExtent y].  vFit == #shrinkWrap ifTrue:[myExtent := myExtent x @ extent y].  "Make sure we don't get smaller than minWidth/minHeight"  myExtent x < self minWidth ifTrue:[    myExtent := (myExtent x max:       (self minWidth - self bounds width + self layoutBounds width)) @ myExtent y].  myExtent y < self minHeight ifTrue:[    myExtent := myExtent x @ (myExtent y max:      (self minHeight - self bounds height + self layoutBounds height))].  self layoutBounds: (box origin extent: myExtent).! !!Morph methodsFor: 'layout' stamp: 'dgd 2/22/2003 14:31'!doLayoutIn: layoutBounds   "Compute a new layout based on the given layout bounds."  "Note: Testing for #bounds or #layoutBounds would be sufficient to  figure out if we need an invalidation afterwards but #outerBounds  is what we need for all leaf nodes so we use that."  | layout box priorBounds |  priorBounds := self outerBounds.  submorphs isEmpty ifTrue: [^fullBounds := priorBounds].  "Send #ownerChanged to our children"  submorphs do: [:m | m ownerChanged].  layout := self layoutPolicy.  layout ifNotNil: [layout layout: self in: layoutBounds].  self adjustLayoutBounds.  fullBounds := self privateFullBounds.  box := self outerBounds.  box = priorBounds     ifFalse: [self invalidRect: (priorBounds quickMerge: box)]! !!Morph methodsFor: 'layout' stamp: 'ar 1/1/2002 20:00'!fullBounds  "Return the bounding box of the receiver and all its children. Recompute the layout if necessary."  fullBounds ifNotNil:[^fullBounds].  "Errors at this point can be critical so make sure we catch 'em all right"  [self doLayoutIn: self layoutBounds] on: Error do:[:ex|    "This should do it unless you don't screw up the bounds"    fullBounds := bounds.    ex pass].  ^fullBounds! !!Morph methodsFor: 'layout' stamp: 'ar 11/12/2000 23:10'!layoutBounds  "Return the bounds for laying out children of the receiver"  | inset box |  inset := self layoutInset.  box := self innerBounds.  inset isZero ifTrue:[^box].  ^box insetBy: inset.! !!Morph methodsFor: 'layout' stamp: 'dgd 2/22/2003 14:33'!privateFullBounds  "Private. Compute the actual full bounds of the receiver"  | box |  submorphs isEmpty ifTrue: [^self outerBounds].  box := self outerBounds copy.  box := box quickMerge: (self clipSubmorphs             ifTrue: [self submorphBounds intersect: self clippingBounds]            ifFalse: [self submorphBounds]).  ^box origin asIntegerPoint corner: box corner asIntegerPoint! !!Morph methodsFor: 'layout' stamp: 'nice 1/5/2010 15:59'!submorphBounds  "Private. Compute the actual full bounds of the receiver"  | box |  submorphs do: [:m | | subBox |     (m visible) ifTrue: [      subBox := m fullBounds.      box         ifNil:[box := subBox copy]        ifNotNil:[box := box quickMerge: subBox]]].  box ifNil:[^self bounds]. "e.g., having submorphs but not visible"  ^ box origin asIntegerPoint corner: box corner asIntegerPoint! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 19:57'!hResizing  "Layout specific. This property describes how the receiver should be resized with respect to its owner and its children. Possible values are:    #rigid      - do not resize the receiver    #spaceFill    - resize to fill owner's available space    #shrinkWrap - resize to fit children  "  | props |  props := self layoutProperties.  ^props ifNil:[#rigid] ifNotNil:[props hResizing].! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/14/2000 16:38'!layoutInset  "Return the extra inset for layouts"  | props |  props := self layoutProperties.  ^props ifNil:[0] ifNotNil:[props layoutInset].! !!Morph methodsFor: 'layout-properties' stamp: 'md 2/27/2006 10:00'!layoutPolicy  "Layout specific. Return the layout policy describing how children   of the receiver should appear."  ^ extension ifNotNil: [ extension layoutPolicy]! !!Morph methodsFor: 'layout-properties' stamp: 'md 2/27/2006 09:58'!layoutProperties  "Return the current layout properties associated with the    receiver"  ^ extension ifNotNil: [ extension layoutProperties]! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:02'!vResizing  "Layout specific. This property describes how the receiver should be resized with respect to its owner and its children. Possible values are:    #rigid      - do not resize the receiver    #spaceFill    - resize to fill owner's available space    #shrinkWrap - resize to fit children  "  | props |  props := self layoutProperties.  ^props ifNil:[#rigid] ifNotNil:[props vResizing].! !!Morph methodsFor: 'menus' stamp: 'sw 8/30/1998 09:42'!snapToEdgeIfAppropriate  | edgeSymbol oldBounds aWorld |  (edgeSymbol := self valueOfProperty: #edgeToAdhereTo) ifNotNil:    [oldBounds := bounds.    self adhereToEdge: edgeSymbol.    bounds ~= oldBounds ifTrue: [(aWorld := self world) ifNotNil: [aWorld viewBox ifNotNil:      [aWorld displayWorld]]]]! !!Morph methodsFor: 'rotate scale and flex' stamp: 'ar 11/24/1998 14:19'!keepsTransform  "Return true if the receiver will keep it's transform while being grabbed by a hand."  ^false! !!Morph methodsFor: 'rotate scale and flex' stamp: 'AlainPlantec 5/8/2010 00:13'!rotationCenter  "Return the rotation center of the receiver. The rotation center defines the relative offset inside the receiver's bounds for locating the reference position."  ^self valueOfProperty: #rotationCenter ifAbsent: [0.5@0.5]! !!Morph methodsFor: 'rounding' stamp: 'ar 12/22/2001 22:45'!wantsRoundedCorners  "Return true if the receiver wants its corners rounded"  ^ self cornerStyle == #rounded! !!Morph methodsFor: 'settings' stamp: 'AlainPlantec 12/10/2009 13:03'!defaultYellowButtonMenuEnabled  ^ self class defaultYellowButtonMenuEnabled! !!Morph methodsFor: 'structure' stamp: 'ar 9/14/2000 16:47'!allOwnersDo: aBlock  "Evaluate aBlock with all owners of the receiver"  owner ifNotNil:[^owner withAllOwnersDo: aBlock].! !!Morph methodsFor: 'structure' stamp: 'di 11/13/2000 00:48'!firstOwnerSuchThat: conditionBlock  self allOwnersDo: [:m | (conditionBlock value: m) ifTrue: [^ m]].  ^ nil! !!Morph methodsFor: 'structure' stamp: 'ar 10/3/2000 15:36'!hasOwner: aMorph  "Return true if the receiver has aMorph in its owner chain"  aMorph ifNil:[^true].  self allOwnersDo:[:m| m = aMorph ifTrue:[^true]].  ^false! !!Morph methodsFor: 'structure' stamp: 'dgd 2/22/2003 19:05'!isInWorld  "Return true if this morph is in a world."  ^self world notNil! !!Morph methodsFor: 'structure' stamp: 'marcus.denker 7/24/2009 14:07'!outermostWorldMorph  ^World.! !!Morph methodsFor: 'structure'!owner  "Returns the owner of this morph, which may be nil."  ^ owner! !!Morph methodsFor: 'structure' stamp: 'di 11/12/2000 16:18'!ownerThatIsA: aClass  "Return the first enclosing morph that is a kind of aClass, or nil if none"  ^ self firstOwnerSuchThat: [:m | m isKindOf: aClass]! !!Morph methodsFor: 'structure' stamp: 'dgd 2/22/2003 19:06'!topRendererOrSelf  "Answer the topmost renderer for this morph, or this morph itself if it has no renderer. See the comment in Morph>isRenderer."  | top topsOwner |  owner ifNil: [^self].  self isWorldMorph ifTrue: [^self].  "ignore scaling of this world"  top := self.  topsOwner := top owner.  [topsOwner notNil and: [topsOwner isRenderer]] whileTrue:       [top := topsOwner.      topsOwner := top owner].  ^top! !!Morph methodsFor: 'structure' stamp: 'dgd 2/22/2003 14:36'!world  ^owner isNil ifTrue: [nil] ifFalse: [owner world]! !!Morph methodsFor: 'submorphs-accessing' stamp: 'AlainPlantec 2/17/2010 14:53'!allMorphs  "Return a collection containing all morphs in this composite morph (including the receiver)."  | all |  all := (Array new: submorphs size) writeStream.  self allMorphsDo: [:m | all nextPut: m].  ^ all contents! !!Morph methodsFor: 'submorphs-accessing' stamp: 'dgd 2/22/2003 14:27'!allMorphsDo: aBlock   "Evaluate the given block for all morphs in this composite morph (including the receiver)."  submorphs do: [:m | m allMorphsDo: aBlock].  aBlock value: self! !!Morph methodsFor: 'submorphs-accessing' stamp: 'dgd 8/31/2004 16:53'!dockingBars  "Answer the receiver's dockingBars"  ^ self submorphs    select: [:each | each isDockingBar]! !!Morph methodsFor: 'submorphs-accessing' stamp: 'dgd 2/22/2003 14:32'!hasSubmorphs  ^submorphs notEmpty! !!Morph methodsFor: 'submorphs-accessing' stamp: 'ar 8/13/2003 11:32'!noteNewOwner: aMorph  "I have just been added as a submorph of aMorph"! !!Morph methodsFor: 'submorphs-accessing' stamp: 'efc 8/6/2005 11:35'!submorphs  "This method returns my actual submorphs collection. Modifying the collection directly could be dangerous; make a copy if you need to alter it."  ^ submorphs ! !!Morph methodsFor: 'submorphs-accessing' stamp: 'dgd 2/22/2003 14:35'!submorphsDo: aBlock   submorphs do: aBlock! !!Morph methodsFor: 'submorphs-accessing'!submorphsReverseDo: aBlock  submorphs reverseDo: aBlock.! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 1/31/2001 12:55'!addMorphBack: aMorph  ^self privateAddMorph: aMorph atIndex: submorphs size+1! !!Morph methodsFor: 'submorphs-add/remove'!addMorph: aMorph  self addMorphFront: aMorph.! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 8/12/2003 22:01'!removedMorph: aMorph  "Notify the receiver that aMorph was just removed from its children"! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'di 10/18/2004 21:50'!removeMorph: aMorph  "Remove the given morph from my submorphs"  | aWorld |  aMorph owner == self ifFalse:[^self].  aWorld := self world.  aWorld ifNotNil:[    aMorph outOfWorld: aWorld.    self privateInvalidateMorph: aMorph.  ].  self privateRemove: aMorph.  aMorph privateOwner: nil.  self removedMorph: aMorph.! !!Morph methodsFor: 'testing' stamp: 'dgd 8/31/2004 15:00'!isDockingBar  "Return true if the receiver is a docking bar"  ^ false! !!Morph methodsFor: 'testing' stamp: 'ar 12/3/2001 12:33'!shouldDropOnMouseUp  | former |  former := self formerPosition ifNil:[^false].  ^(former dist: self position) > 10! !!Morph methodsFor: 'testing' stamp: 'StephaneDucasse 7/18/2010 16:33'!wantsSteps  "Return true if the receiver overrides the default Morph step method."  "Details: Find first class in superclass chain that implements #step and return true if it isn't class Morph."  | c |  c := self class.  [c includesSelector: #step] whileFalse: [c := c superclass].  ^ c ~= Morph! !!Morph methodsFor: 'visual properties' stamp: 'gvc 9/11/2009 17:27'!cornerStyle  "Returns one of the following symbols:    #square    #rounded  according to the current corner style."  self assureExtension.  ^extension cornerStyle ifNil: [#square]! !!Morph methodsFor: 'visual properties' stamp: 'gvc 9/11/2009 16:35'!fillStyle  "Return the current fillStyle of the receiver."    ^extension    ifNil: [^color]    ifNotNil: [extension fillStyle ifNil: [color]]! !!Morph methodsFor: 'wiw support' stamp: 'nice 1/5/2010 15:59'!addMorphInFrontOfLayer: aMorph  | targetLayer |  targetLayer := aMorph morphicLayerNumberWithin: self.  submorphs do: [ :each | | layerHere |    each == aMorph ifTrue: [^self].    layerHere := each morphicLayerNumberWithin: self.    "the <= is the difference - it insures we go to the front of our layer"    targetLayer <= layerHere ifTrue: [      ^self addMorph: aMorph inFrontOf: each    ].  ].  self addMorphBack: aMorph.! !!Morph methodsFor: 'wiw support' stamp: 'RAA 7/19/2000 20:44'!morphicLayerNumber  "helpful for insuring some morphs always appear in front of or behind others.  smaller numbers are in front"  ^(owner isNil or: [owner isWorldMorph]) ifTrue: [    self valueOfProperty: #morphicLayerNumber ifAbsent: [100]  ] ifFalse: [    owner morphicLayerNumber  ].  "leave lots of room for special things"! !!Morph methodsFor: 'private' stamp: 'nk 10/11/2003 16:08'!privateAddMorph: aMorph atIndex: index  | oldIndex myWorld itsWorld oldOwner |  ((index >= 1) and: [index <= (submorphs size + 1)])    ifFalse: [^ self error: 'index out of range'].  myWorld := self world.  oldOwner := aMorph owner.  (oldOwner == self and: [(oldIndex := submorphs indexOf: aMorph) > 0]) ifTrue:[    "aMorph's position changes within in the submorph chain"    oldIndex < index ifTrue:[      "moving aMorph to back"      submorphs replaceFrom: oldIndex to: index-2 with: submorphs startingAt: oldIndex+1.      submorphs at: index-1 put: aMorph.    ] ifFalse:[      "moving aMorph to front"      oldIndex-1 to: index by: -1 do:[:i|        submorphs at: i+1 put: (submorphs at: i)].      submorphs at: index put: aMorph.    ].  ] ifFalse:[    "adding a new morph"    oldOwner ifNotNil:[      itsWorld := aMorph world.      itsWorld ifNotNil: [self privateInvalidateMorph: aMorph].      (itsWorld == myWorld) ifFalse: [aMorph outOfWorld: itsWorld].      oldOwner privateRemove: aMorph.      oldOwner removedMorph: aMorph.    ].    aMorph privateOwner: self.    submorphs := submorphs copyReplaceFrom: index to: index-1 with: (Array with: aMorph).    (itsWorld == myWorld) ifFalse: [aMorph intoWorld: myWorld].  ].  myWorld ifNotNil:[self privateInvalidateMorph: aMorph].  self layoutChanged.  oldOwner == self ifFalse: [    self addedMorph: aMorph.    aMorph noteNewOwner: self ].! !!Morph methodsFor: 'private' stamp: 'ar 12/16/2001 21:47'!privateFullMoveBy: delta  "Private!! Relocate me and all of my subMorphs by recursion. Subclasses that implement different coordinate systems may override this method."  self privateMoveBy: delta.  1 to: submorphs size do: [:i |    (submorphs at: i) privateFullMoveBy: delta].! !!Morph methodsFor: 'private'!privateOwner: aMorph  "Private!! Should only be used by methods that maintain the ower/submorph invariant."  owner := aMorph.! !!Morph methodsFor: 'private' stamp: 'di 10/18/2004 21:49'!privateRemove: aMorph  "Private!! Should only be used by methods that maintain the ower/submorph invariant."  submorphs := submorphs copyWithout: aMorph.  self layoutChanged.! !!HandMorph methodsFor: '*Polymorph-Widgets-override' stamp: 'gvc 2/24/2009 10:36'!fullDrawOn: aCanvas   "A HandMorph has unusual drawing requirements:    1. the hand itself (i.e., the cursor) appears in front of its submorphs    2. morphs being held by the hand cast a shadow on the world/morphs below  The illusion is that the hand plucks up morphs and carries them above the world."  "Note: This version caches an image of the morphs being held by the hand for   better performance. This cache is invalidated if one of those morphs changes."  | disableCaching subBnds roundCorners rounded |  self visible ifFalse: [^self].  (aCanvas isVisible: self fullBounds) ifFalse: [^self].  disableCaching := false.  disableCaching     ifTrue:       [self nonCachingFullDrawOn: aCanvas.      ^self].  submorphs isEmpty     ifTrue:       [cacheCanvas := nil.      ^self drawOn: aCanvas]. "just draw the hand itself"  subBnds := Rectangle merging: (submorphs collect: [:m | m fullBounds]).  self updateCacheCanvas: aCanvas.  (cacheCanvas isNil     or: [cachedCanvasHasHoles and: [cacheCanvas depth = 1]])       ifTrue:         ["could not use caching due to translucency; do full draw"        self nonCachingFullDrawOn: aCanvas.        ^self].  "--> begin rounded corners hack <---"  roundCorners := cachedCanvasHasHoles == false         and: [submorphs size = 1 and: [submorphs first wantsRoundedCorners]].  roundCorners     ifTrue:       [rounded := submorphs first.      aCanvas asShadowDrawingCanvas translateBy: self shadowOffset        during:           [:shadowCanvas |           shadowCanvas roundCornersOf: rounded            during:               [(subBnds areasOutside: (rounded boundsWithinCorners                     translateBy: self shadowOffset negated))                 do: [:r | shadowCanvas fillRectangle: r color: Color black]]].      aCanvas roundCornersOf: rounded        during:           [aCanvas             drawImage: cacheCanvas form            at: subBnds origin            sourceRect: cacheCanvas form boundingBox].      ^self drawOn: aCanvas "draw the hand itself in front of morphs"].  "--> end rounded corners hack <---"  "draw the shadow"  (submorphs anySatisfy: [:m | m handlesDropShadowInHand not]) ifTrue: [    aCanvas asShadowDrawingCanvas translateBy: self shadowOffset    during:       [:shadowCanvas |       cachedCanvasHasHoles         ifTrue:           ["Have to draw the real shadow of the form"          shadowCanvas paintImage: cacheCanvas form at: subBnds origin]        ifFalse:           ["Much faster if only have to shade the edge of a solid rectangle"          (subBnds areasOutside: (subBnds translateBy: self shadowOffset negated))             do: [:r | shadowCanvas fillRectangle: r color: Color black]]]].  "draw morphs in front of the shadow using the cached Form"  aCanvas translucentImage: cacheCanvas form at: subBnds origin.  self drawOn: aCanvas  "draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'accessing' stamp: 'ar 9/25/2000 14:24'!mouseOverHandler  ^mouseOverHandler ifNil:[mouseOverHandler := MouseOverHandler new].! !!HandMorph methodsFor: 'balloon help' stamp: 'ar 10/3/2000 16:49'!balloonHelp  "Return the balloon morph associated with this hand"  ^self valueOfProperty: #balloonHelpMorph! !!HandMorph methodsFor: 'balloon help' stamp: 'ar 10/3/2000 16:51'!balloonHelp: aBalloonMorph  "Return the balloon morph associated with this hand"  | oldHelp |  oldHelp := self balloonHelp.  oldHelp ifNotNil:[oldHelp delete].  aBalloonMorph    ifNil:[self removeProperty: #balloonHelpMorph]    ifNotNil:[self setProperty: #balloonHelpMorph toValue: aBalloonMorph]! !!HandMorph methodsFor: 'balloon help' stamp: 'sw 10/15/2002 20:01'!deleteBalloonTarget: aMorph  "Delete any existing balloon help.  This is now done unconditionally, whether or not the morph supplied is the same as the current balloon target"    self balloonHelp: nil" | h |  h := self balloonHelp ifNil: [^ self].  h balloonOwner == aMorph ifTrue: [self balloonHelp: nil]"! !!HandMorph methodsFor: 'balloon help' stamp: 'ar 10/6/2000 00:14'!removePendingBalloonFor: aMorph  "Get rid of pending balloon help."  self removeAlarm: #spawnBalloonFor:.  self deleteBalloonTarget: aMorph.! !!HandMorph methodsFor: 'change reporting' stamp: 'ar 12/30/2001 17:32'!invalidRect: damageRect from: aMorph  "Note that a change has occurred and record the given damage rectangle relative to the origin this hand's cache."  hasChanged := true.  aMorph == self ifTrue:[^self].  damageRecorder recordInvalidRect: damageRect.! !!HandMorph methodsFor: 'cursor' stamp: 'di 3/6/1999 23:52'!showTemporaryCursor: cursorOrNil  "Set the temporary cursor to the given Form. If the argument is nil, revert to the normal cursor."  self showTemporaryCursor: cursorOrNil hotSpotOffset: 0@0! !!HandMorph methodsFor: 'cursor' stamp: 'JW 9/6/2005 23:12'!showTemporaryCursor: cursorOrNil hotSpotOffset: hotSpotOffset   "Set the temporary cursor to the given Form.  If the argument is nil, revert to the normal hardware cursor."  self changed.  temporaryCursorOffset     ifNotNil: [bounds := bounds translateBy: temporaryCursorOffset negated].  cursorOrNil isNil     ifTrue: [temporaryCursor := temporaryCursorOffset := hardwareCursor := nil]    ifFalse:       [temporaryCursor := cursorOrNil asCursorForm.      temporaryCursorOffset := temporaryCursor offset - hotSpotOffset.      (cursorOrNil isKindOf: Cursor) ifTrue: [hardwareCursor := cursorOrNil]].  bounds := self cursorBounds.  self    layoutChanged;    changed! !!HandMorph methodsFor: 'double click support' stamp: 'ar 9/18/2000 17:16'!resetClickState  "Reset the double-click detection state to normal (i.e., not waiting for a double-click)."  mouseClickState := nil.! !!HandMorph methodsFor: 'drawing' stamp: 'dgd 2/21/2003 22:43'!drawOn: aCanvas   "Draw the hand itself (i.e., the cursor)."  | userPic |  temporaryCursor isNil     ifTrue: [aCanvas paintImage: NormalCursor at: bounds topLeft]    ifFalse: [aCanvas paintImage: temporaryCursor at: bounds topLeft].! !!HandMorph methodsFor: 'drawing' stamp: 'ls 4/3/2000 20:30'!hasChanged  "Return true if this hand has changed, either because it has moved or because some morph it is holding has changed."  ^ hasChanged ifNil: [ true ]! !!HandMorph methodsFor: 'drawing' stamp: 'FernandoOlivero 3/6/2011 22:06'!needsToBeDrawn  "Return true if this hand must be drawn explicitely instead of being drawn via the hardware cursor. This is the case if it (a) it is a remote hand, (b) it is showing a temporary cursor, or (c) it is not empty and there are any visible submorphs. If using the software cursor, ensure that the hardware cursor is hidden."  "Details:  Return true if this hand has a saved patch to ensure that is is processed by the world. This saved patch will be deleted after one final display pass when it becomes possible to start using the hardware cursor again. This trick gives us one last display cycle to allow us to remove the software cursor and shadow from the display."  | cursor |  (savedPatch notNil    or: [ (submorphs anySatisfy: [ :ea | ea visible ])      or: [ (temporaryCursor notNil and: [hardwareCursor isNil])]])    ifTrue: [      "using the software cursor; hide the hardware one"      Cursor blank isCurrent ifFalse: [Cursor blank show].      ^ true].  "Switch from one hardware cursor to another, if needed."  cursor := hardwareCursor ifNil: [Cursor normal].  cursor isCurrent ifFalse: [cursor show].  ^ false! !!HandMorph methodsFor: 'drawing' stamp: 'FernandoOlivero 3/6/2011 22:05'!restoreSavedPatchOn: aCanvas   "Clear the changed flag and restore the part of the given canvas under this hand from the previously saved patch. If necessary, handle the transition to using the hardware cursor."  | cursor |  hasChanged := false.  savedPatch ifNotNil:       [aCanvas drawImage: savedPatch at: savedPatch offset.      submorphs notEmpty ifTrue: [^self].      (temporaryCursor notNil and: [hardwareCursor isNil]) ifTrue: [^self].      "Make the transition to using hardware cursor. Clear savedPatch and     report one final damage rectangle to erase the image of the software cursor."      super invalidRect: (savedPatch offset             extent: savedPatch extent + self shadowOffset)        from: self.      cursor := hardwareCursor ifNil: [Cursor normal].      cursor isCurrent ifFalse: [cursor show].  "show hardware cursor"      savedPatch := nil]! !!HandMorph methodsFor: 'drawing' stamp: 'dgd 2/21/2003 22:49'!savePatchFrom: aCanvas   "Save the part of the given canvas under this hand as a Form and return its bounding rectangle."  "Details: The previously used patch Form is recycled when possible to reduce the burden on storage management."  | damageRect myBnds |  damageRect := myBnds := self fullBounds.  savedPatch ifNotNil:       [damageRect := myBnds merge: (savedPatch offset extent: savedPatch extent)].  (savedPatch isNil or: [savedPatch extent ~= myBnds extent])     ifTrue:       ["allocate new patch form if needed"      savedPatch := aCanvas form allocateForm: myBnds extent].  aCanvas contentsOfArea: (myBnds translateBy: aCanvas origin)    into: savedPatch.  savedPatch offset: myBnds topLeft.  ^damageRect! !!HandMorph methodsFor: 'drawing' stamp: 'dgd 2/21/2003 22:49'!updateCacheCanvas: aCanvas   "Update the cached image of the morphs being held by this hand."  "Note: The following is an attempt to quickly get out if there's no change"  | subBnds rectList nPix |  subBnds := Rectangle merging: (submorphs collect: [:m | m fullBounds]).  rectList := damageRecorder invalidRectsFullBounds: subBnds.  damageRecorder reset.  (rectList isEmpty     and: [cacheCanvas notNil and: [cacheCanvas extent = subBnds extent]])       ifTrue: [^self].  "Always check for real translucency -- can't be cached in a form"  self submorphsDo:       [:m |       m wantsToBeCachedByHand         ifFalse:           [cacheCanvas := nil.          cachedCanvasHasHoles := true.          ^self]].  (cacheCanvas isNil or: [cacheCanvas extent ~= subBnds extent])     ifTrue:       [cacheCanvas := (aCanvas allocateForm: subBnds extent) getCanvas.      cacheCanvas translateBy: subBnds origin negated        during: [:tempCanvas | self drawSubmorphsOn: tempCanvas].      self submorphsDo:           [:m |           (m areasRemainingToFill: subBnds) isEmpty             ifTrue: [^cachedCanvasHasHoles := false]].      nPix := cacheCanvas form tallyPixelValues first.      "--> begin rounded corners hack <---"      cachedCanvasHasHoles := (nPix = 48             and: [submorphs size = 1 and: [submorphs first wantsRoundedCorners]])               ifTrue: [false]              ifFalse: [nPix > 0].      "--> end rounded corners hack <---"      ^self].  "incrementally update the cache canvas"  cacheCanvas translateBy: subBnds origin negated    during:       [:cc |       rectList do:           [:r |           cc clipBy: r            during:               [:c |               c fillColor: Color transparent.              self drawSubmorphsOn: c]]]! !!HandMorph methodsFor: 'drawing' stamp: 'nk 10/24/2003 22:12'!visible: aBoolean  self needsToBeDrawn ifFalse: [ ^self ].  super visible: aBoolean! !!HandMorph methodsFor: 'drop shadows'!shadowOffset  ^ 6@8! !!HandMorph methodsFor: 'event handling' stamp: 'ar 9/25/2000 14:27'!noticeMouseOver: aMorph event: anEvent  mouseOverHandler ifNil:[^self].  mouseOverHandler noticeMouseOver: aMorph event: anEvent.! !!HandMorph methodsFor: 'events-processing' stamp: 'tbn 3/12/2010 01:38'!handleEvent: anEvent  | evt ofs |  owner ifNil:[^self].  evt := anEvent.  EventStats ifNil:[EventStats := IdentityDictionary new].  EventStats at: #count put: (EventStats at: #count ifAbsent:[0]) + 1.  EventStats at: evt type put: (EventStats at: evt type ifAbsent:[0]) + 1.  evt isMouseOver ifTrue:[^self sendMouseEvent: evt].ShowEvents == true ifTrue:[  Display fill: (0@0 extent: 250@120) rule: Form over fillColor: Color white.  ofs := (owner hands indexOf: self) - 1 * 60.  evt printString displayAt: (0@ofs) + (evt isKeyboard ifTrue:[0@30] ifFalse:[0@0]).  self keyboardFocus printString displayAt: (0@ofs)+(0@45).].  "Notify listeners"  self sendListenEvent: evt to: self eventListeners.  evt isWindowEvent ifTrue: [    self sendEvent: evt focus: nil.    ^self mouseOverHandler processMouseOver: lastMouseEvent].    evt isKeyboard ifTrue:[    self sendListenEvent: evt to: self keyboardListeners.    self sendKeyboardEvent: evt.    ^self mouseOverHandler processMouseOver: lastMouseEvent].  evt isDropEvent ifTrue:[    self sendEvent: evt focus: nil.    ^self mouseOverHandler processMouseOver: lastMouseEvent].  evt isMouse ifTrue:[    self sendListenEvent: evt to: self mouseListeners.    lastMouseEvent := evt].  "Check for pending drag or double click operations."  mouseClickState ifNotNil:[    (mouseClickState handleEvent: evt from: self) ifFalse:[      "Possibly dispatched #click: or something and will not re-establish otherwise"      ^self mouseOverHandler processMouseOver: lastMouseEvent]].  evt isMove ifTrue:[    self position: evt position.    self sendMouseEvent: evt.  ] ifFalse:[    "Issue a synthetic move event if we're not at the position of the event"    (evt position = self position) ifFalse:[self moveToEvent: evt].    "Drop submorphs on button events"    (self hasSubmorphs)       ifTrue:[self dropMorphs: evt]      ifFalse:[self sendMouseEvent: evt].  ].  ShowEvents == true ifTrue:[self mouseFocus printString displayAt: (0@ofs) + (0@15)].  self mouseOverHandler processMouseOver: lastMouseEvent.! !!HandMorph methodsFor: 'focus handling' stamp: 'ar 10/6/2000 00:09'!keyboardFocus   ^ keyboardFocus! !!HandMorph methodsFor: 'focus handling' stamp: 'ar 10/26/2000 01:30'!keyboardFocus: aMorphOrNil  keyboardFocus := aMorphOrNil! !!HandMorph methodsFor: 'focus handling' stamp: 'ar 10/6/2000 00:10'!mouseFocus  ^mouseFocus! !!HandMorph methodsFor: 'focus handling' stamp: 'nk 2/14/2004 18:44'!mouseFocus: aMorphOrNil  mouseFocus := aMorphOrNil! !!HandMorph methodsFor: 'focus handling' stamp: 'yo 11/7/2002 19:11'!newKeyboardFocus: aMorphOrNil  "Make the given morph the new keyboard focus, canceling the previous keyboard focus if any. If the argument is nil, the current keyboard focus is cancelled."  | oldFocus |  oldFocus := self keyboardFocus.  self keyboardFocus: aMorphOrNil.  oldFocus ifNotNil: [oldFocus == aMorphOrNil ifFalse: [oldFocus keyboardFocusChange: false]].  aMorphOrNil ifNotNil: [aMorphOrNil keyboardFocusChange: true].! !!HandMorph methodsFor: 'focus handling' stamp: 'ar 10/26/2000 01:32'!newMouseFocus: aMorphOrNil  "Make the given morph the new mouse focus, canceling the previous mouse focus if any. If the argument is nil, the current mouse focus is cancelled."  self mouseFocus: aMorphOrNil.! !!HandMorph methodsFor: 'focus handling' stamp: 'dgd 2/21/2003 22:48'!newMouseFocus: aMorph event: event   aMorph isNil     ifFalse: [targetOffset := event cursorPoint - aMorph position].  ^self newMouseFocus: aMorph! !!HandMorph methodsFor: 'focus handling' stamp: 'ar 10/6/2000 00:09'!releaseKeyboardFocus  "Release the current keyboard focus unconditionally"  self newKeyboardFocus: nil.! !!HandMorph methodsFor: 'focus handling' stamp: 'ar 10/6/2000 00:10'!releaseMouseFocus  "Release the current mouse focus unconditionally."  self newMouseFocus: nil.! !!HandMorph methodsFor: 'geometry' stamp: 'ar 3/20/2001 20:34'!position  ^temporaryCursor    ifNil: [bounds topLeft]    ifNotNil: [bounds topLeft - temporaryCursorOffset]! !!HandMorph methodsFor: 'geometry' stamp: 'nk 8/20/2003 17:39'!position: aPoint  "Overridden to align submorph origins to the grid if gridding is on."  | adjustedPosition delta box |  adjustedPosition := aPoint.  temporaryCursor ifNotNil: [adjustedPosition := adjustedPosition + temporaryCursorOffset].  "Copied from Morph to avoid owner layoutChanged"  "Change the position of this morph and and all of its submorphs."  delta := adjustedPosition - bounds topLeft.  (delta x = 0 and: [delta y = 0]) ifTrue: [^ self].  "Null change"  box := self fullBounds.  (delta dotProduct: delta) > 100 ifTrue:[    "e.g., more than 10 pixels moved"    self invalidRect: box.    self invalidRect: (box translateBy: delta).  ] ifFalse:[    self invalidRect: (box merge: (box translateBy: delta)).  ].  self privateFullMoveBy: delta.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 9/14/2000 11:22'!dropMorphs: anEvent  "Drop the morphs at the hands position"  self submorphsReverseDo:[:m|    "Drop back to front to maintain z-order"    self dropMorph: m event: anEvent.  ].! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 8/13/2003 11:39'!dropMorph: aMorph event: anEvent  "Drop the given morph which was carried by the hand"  | event dropped |  (anEvent isMouseUp and:[aMorph shouldDropOnMouseUp not]) ifTrue:[^self].  "Note: For robustness in drag and drop handling we remove the morph BEFORE we drop him, but we keep his owner set to the hand. This prevents system lockups when there is a problem in drop handling (for example if there's an error in #wantsToBeDroppedInto:). THIS TECHNIQUE IS NOT RECOMMENDED FOR CASUAL USE."  self privateRemove: aMorph.  aMorph privateOwner: self.  dropped := aMorph.  event := DropEvent new setPosition: self position contents: dropped hand: self.  self sendEvent: event focus: nil.  event wasHandled ifFalse:[aMorph rejectDropMorphEvent: event].  aMorph owner == self ifTrue:[aMorph delete].  self mouseOverHandler processMouseOver: anEvent.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'AlainPlantec 5/7/2010 22:28'!grabMorph: aMorph from: formerOwner   "Grab the given morph (i.e., add it to this hand and remove it from its  current owner) without changing its position. This is used to pick up a  morph under the hand's current position, versus attachMorph: which  is used to pick up a morph that may not be near this hand."  | grabbed offset targetPoint grabTransform fullTransform |  self releaseMouseFocus.  "Break focus"  grabbed := aMorph.  aMorph keepsTransform    ifTrue: [grabTransform := fullTransform := IdentityTransform new]    ifFalse: ["Compute the transform to apply to the grabbed morph"      grabTransform := formerOwner            ifNil: [IdentityTransform new]            ifNotNil: [formerOwner grabTransform].      fullTransform := formerOwner            ifNil: [IdentityTransform new]            ifNotNil: [formerOwner transformFrom: owner]].  "targetPoint is point in aMorphs reference frame"  targetPoint := fullTransform globalPointToLocal: self position.  "but current position will be determined by grabTransform, so  compute offset"  offset := targetPoint        - (grabTransform globalPointToLocal: self position).  "apply the transform that should be used after grabbing"  grabbed := grabbed transformedBy: grabTransform.  grabbed == aMorph    ifFalse: [grabbed setProperty: #addedFlexAtGrab toValue: true].  "offset target to compensate for differences in transforms"  grabbed position: grabbed position - offset asIntegerPoint.  "And compute distance from hand's position"   targetOffset := grabbed position - self position.  self addMorphBack: grabbed.  grabbed justGrabbedFrom: formerOwner! !!HandMorph methodsFor: 'halo handling' stamp: 'ar 8/8/2001 14:49'!removePendingHaloFor: aMorph  "Get rid of pending balloon help or halo actions."  self removeAlarm: #spawnMagicHaloFor:.! !!HandMorph methodsFor: 'halos and balloon help' stamp: 'ar 10/4/2000 13:40'!halo  "Return the halo associated with this hand, if any"  ^self valueOfProperty: #halo! !!HandMorph methodsFor: 'initialization' stamp: 'marcus.denker 8/24/2008 21:41'!initForEvents  mouseOverHandler := nil.  lastMouseEvent := MouseEvent basicNew setType: #mouseMove position: 0@0 buttons: 0 hand: self.  lastEventBuffer := {1. 0. 0. 0. 0. 0. nil. nil}.  self resetClickState.! !!HandMorph methodsFor: 'initialization' stamp: 'ar 10/26/2000 14:58'!initialize  super initialize.  self initForEvents.  keyboardFocus := nil.  mouseFocus := nil.  bounds := 0@0 extent: Cursor normal extent.  damageRecorder := DamageRecorder new.  cachedCanvasHasHoles := false.  temporaryCursor := temporaryCursorOffset := nil.  self initForEvents.! !!HandMorph methodsFor: 'layout' stamp: 'jm 2/20/98 18:55'!fullBounds  "Extend my bounds by the shadow offset when carrying morphs."  | bnds |  bnds := super fullBounds.  submorphs isEmpty    ifTrue: [^ bnds ]    ifFalse: [^ bnds topLeft corner: bnds bottomRight + self shadowOffset].! !!HandMorph methodsFor: 'listeners' stamp: 'ar 10/26/2000 01:27'!eventListeners  ^eventListeners! !!HandMorph methodsFor: 'listeners' stamp: 'ar 10/26/2000 01:28'!mouseListeners  ^mouseListeners! !!HandMorph methodsFor: 'meta-actions' stamp: 'adrian_lienhard 3/5/2009 22:44'!grabMorph: aMorph  "Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."    | grabbed |  aMorph = World ifTrue: [^ self].  self releaseMouseFocus.  grabbed := aMorph aboutToBeGrabbedBy: self.  grabbed ifNil: [^self].  grabbed := grabbed topRendererOrSelf.  ^self grabMorph: grabbed from: grabbed owner! !!HandMorph methodsFor: 'nil' stamp: 'di 3/14/1999 10:03'!cursorBounds  temporaryCursor == nil    ifTrue: [^ self position extent: NormalCursor extent]    ifFalse: [^ self position + temporaryCursorOffset                extent: temporaryCursor extent]! !!HandMorph methodsFor: 'updating' stamp: 'jm 2/20/98 19:54'!changed  hasChanged := true.! !!HandMorph methodsFor: 'private events' stamp: 'marcus.denker 8/24/2008 21:40'!generateMouseEvent: evtBuf   "Generate the appropriate mouse event for the given raw event buffer"  | position buttons modifiers type trail stamp oldButtons evtChanged |  evtBuf first = lastEventBuffer first     ifTrue:       ["Workaround for Mac VM bug, *always* generating 3 events on clicks"      evtChanged := false.      3 to: evtBuf size        do: [:i | (lastEventBuffer at: i) = (evtBuf at: i) ifFalse: [evtChanged := true]].      evtChanged ifFalse: [^nil]].  stamp := evtBuf second.  stamp = 0 ifTrue: [stamp := Time millisecondClockValue].  position := evtBuf third @ evtBuf fourth.  buttons := evtBuf fifth.  modifiers := evtBuf sixth.  type := buttons = 0     ifTrue:       [lastEventBuffer fifth = 0 ifTrue: [#mouseMove] ifFalse: [#mouseUp]]    ifFalse:       [lastEventBuffer fifth = 0             ifTrue: [#mouseDown]            ifFalse: [#mouseMove]].  buttons := buttons bitOr: (modifiers bitShift: 3).  oldButtons := lastEventBuffer fifth         bitOr: (lastEventBuffer sixth bitShift: 3).  lastEventBuffer := evtBuf.  type == #mouseMove     ifTrue:       [trail := self mouseTrailFrom: evtBuf.      ^MouseMoveEvent basicNew         setType: type        startPoint: (self position)        endPoint: trail last        trail: trail        buttons: buttons        hand: self        stamp: stamp].  ^MouseButtonEvent basicNew     setType: type    position: position    which: (oldButtons bitXor: buttons)    buttons: buttons    hand: self    stamp: stamp! !!HandMorph methodsFor: 'private events' stamp: 'PavelKrivanek 6/21/2011 13:05'!mouseTrailFrom: currentBuf   "Current event, a mouse event buffer, is about to be processed.  If there are other similar mouse events queued up, then drop them from the queue, and report the positions inbetween."  | nextEvent trail |  trail := (Array new: 1) writeStream.  trail nextPut: currentBuf third @ currentBuf fourth.  [(nextEvent := Sensor peekEvent) isNil] whileFalse:       [nextEvent first = currentBuf first         ifFalse: [^trail contents "different event type"].      nextEvent fifth = currentBuf fifth         ifFalse: [^trail contents "buttons changed"].      nextEvent sixth = currentBuf sixth         ifFalse: [^trail contents "modifiers changed"].      "nextEvent is similar.  Remove it from the queue, and check the next."      nextEvent := Sensor nextEvent.      nextEvent         ifNotNil: [ trail nextPut: nextEvent third @ nextEvent fourth ]].  ^trail contents! !!HandMorph methodsFor: 'private events' stamp: 'tbn 3/12/2010 01:37'!processEvents  "Process user input events from the local input devices."  | evt evtBuf type hadAny |  ActiveEvent ifNotNil:       ["Meaning that we were invoked from within an event response.    Make sure z-order is up to date"      self mouseOverHandler processMouseOver: lastMouseEvent].  hadAny := false.  [(evtBuf := Sensor nextEvent) isNil] whileFalse:       [evt := nil.  "for unknown event types"      type := evtBuf first.      type = EventTypeMouse ifTrue: [evt := self generateMouseEvent: evtBuf].      type = EventTypeKeyboard         ifTrue: [evt := self generateKeyboardEvent: evtBuf].          "All other events are ignored"      (type ~= EventTypeDragDropFiles and: [evt isNil]) ifTrue: [^self].      evt isNil         ifFalse:           ["Finally, handle it"          self handleEvent: evt.          hadAny := true.          "For better user feedback, return immediately after a mouse event has been processed."          (evt isMouse and: [evt isMouseWheel not]) ifTrue: [^self]]].  "note: if we come here we didn't have any mouse events"  mouseClickState notNil     ifTrue:       ["No mouse events during this cycle. Make sure click states time out accordingly"      mouseClickState handleEvent: lastMouseEvent asMouseMove from: self].  hadAny     ifFalse:       ["No pending events. Make sure z-order is up to date"      self mouseOverHandler processMouseOver: lastMouseEvent]! !!HandMorph methodsFor: 'private events' stamp: 'ar 3/18/2001 01:43'!sendEvent: anEvent focus: focusHolder  "Send the event to the morph currently holding the focus, or if none to the owner of the hand."  ^self sendEvent: anEvent focus: focusHolder clear:[nil]! !!HandMorph methodsFor: 'private events' stamp: 'ar 3/18/2001 01:42'!sendEvent: anEvent focus: focusHolder clear: aBlock  "Send the event to the morph currently holding the focus, or if none to the owner of the hand."  | result |  focusHolder ifNotNil:[^self sendFocusEvent: anEvent to: focusHolder clear: aBlock].  ActiveEvent := anEvent.  result := owner processEvent: anEvent.  ActiveEvent := nil.  ^result! !!HandMorph methodsFor: 'private events' stamp: 'ar 10/26/2000 01:43'!sendListenEvent: anEvent to: listenerGroup  "Send the event to the given group of listeners"  listenerGroup ifNil:[^self].  listenerGroup do:[:listener|     listener ifNotNil:[listener handleListenEvent: anEvent copy]].! !!HandMorph methodsFor: 'private events' stamp: 'ar 3/18/2001 01:45'!sendMouseEvent: anEvent  "Send the event to the morph currently holding the focus, or if none to the owner of the hand."  ^self sendEvent: anEvent focus: self mouseFocus clear:[self mouseFocus: nil]! !!BorderedMorph methodsFor: 'accessing' stamp: 'gvc 9/11/2009 17:17'!borderStyle  "Work around the borderWidth/borderColor pair"  | style |  borderColor ifNil: [^BorderStyle default].  borderWidth isZero ifTrue: [^BorderStyle default].  self assureExtension.  style := extension borderStyle ifNil: [BorderStyle default].  (borderWidth = style width and:       ["Hah!! Try understanding this..."      borderColor == style style or:           ["#raised/#inset etc"          #simple == style style and: [borderColor = style color]]])     ifFalse:       [style := borderColor isColor         ifTrue: [BorderStyle width: borderWidth color: borderColor]        ifFalse: [(BorderStyle perform: borderColor) width: borderWidth "argh."].      extension borderStyle: style].  ^style trackColorFrom: self! !!BorderedMorph methodsFor: 'accessing' stamp: 'di 6/20/97 11:09'!borderWidth  ^ borderWidth! !!BorderedMorph methodsFor: 'accessing' stamp: 'di 6/4/1999 09:42'!borderWidth: anInteger  borderColor ifNil: [borderColor := Color black].  borderWidth := anInteger max: 0.  self changed! !!BorderedMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:53'!borderInitialize  "initialize the receiver state related to border"  borderColor:= self defaultBorderColor.  borderWidth := self defaultBorderWidth! !!BorderedMorph methodsFor: 'initialization' stamp: 'MarcusDenker 12/11/2009 23:56'!initialize  "initialize the state of the receiver"  super initialize.    self borderInitialize! !!PasteUpMorph methodsFor: '*Morphic-Basic' stamp: 'adrian_lienhard 7/19/2009 20:50'!morphToDropFrom: aMorph   "Given a morph being carried by the hand, which the hand is about to drop, answer the actual morph to be deposited.  Normally this would be just the morph itself, but several unusual cases arise, which this method is designed to service."  ^aMorph ! !!PasteUpMorph methodsFor: '*Polymorph-Widgets' stamp: 'gvc 2/3/2010 17:59'!backgroundMorph  "Answer the background morph if any."    ^backgroundMorph! !!PasteUpMorph methodsFor: '*Polymorph-Widgets' stamp: 'gvc 1/12/2007 17:06'!handlerForMouseDown: anEvent  "If we have a modal dialog then answer nil otherwise as usual.."    ^(self hasProperty: #submorphLockStates)    ifFalse: [super handlerForMouseDown: anEvent]! !!PasteUpMorph methodsFor: '*Polymorph-Widgets' stamp: 'gvc 2/3/2010 17:59'!resizeBackgroundMorph  "Resize the background morph to fit the world."  self backgroundMorph isNil ifFalse: [    self backgroundMorph extent: self extent]! !!PasteUpMorph methodsFor: '*Polymorph-Widgets-override' stamp: 'MarcusDenker 4/29/2011 00:37'!mouseDown: evt  "Handle a mouse down event."  | grabbedMorph handHadHalos |  grabbedMorph := self morphToGrab: evt.  grabbedMorph ifNotNil: [    grabbedMorph isSticky ifTrue: [^self].    ^evt hand grabMorph: grabbedMorph].  (super handlesMouseDown: evt)    ifTrue: [^super mouseDown: evt].  evt hand releaseKeyboardFocus. "shake of keyboard foci"   "explicitly ignore the event if we're not the world and we'll not select,  so that we could be picked up if need be"  evt wasHandled: false.! !!PasteUpMorph methodsFor: '*morphic-windows' stamp: 'stephane.ducasse 9/25/2008 13:35'!fullRepaintNeeded  worldState doFullRepaint."  self  windowsSatisfying: [:w | w makeMeVisible. false]."! !!PasteUpMorph methodsFor: 'alarms-scheduler' stamp: 'ar 9/11/2000 16:39'!removeAlarm: aSelector for: aTarget  "Remove the alarm with the given selector"  worldState removeAlarm: aSelector for: aTarget! !!PasteUpMorph methodsFor: 'change reporting' stamp: 'ar 1/5/2002 17:06'!invalidRect: damageRect from: aMorph        "Clip damage reports to my bounds, since drawing is clipped to my bounds."        self == self outermostWorldMorph                 ifTrue: [worldState recordDamagedRect: (damageRect intersect: self bounds)]                ifFalse: [super invalidRect: damageRect from: aMorph]! !!PasteUpMorph methodsFor: 'classification' stamp: 'di 7/27/1999 10:46'!isWorldMorph  ^ worldState notNil! !!PasteUpMorph methodsFor: 'drawing' stamp: 'MarcusDenker 11/19/2009 12:46'!drawOn: aCanvas   "Draw in order:  - background color  - grid, if any  - background sketch, if any  - Update and draw the turtleTrails form. See the comment in updateTrailsForm.  Later (in drawSubmorphsOn:) I will skip drawing the background sketch."  "draw background fill"  super drawOn: aCanvas.  "draw grid  (self griddingOn and: [self gridVisible])     ifTrue:       [aCanvas fillRectangle: self bounds        fillStyle: (self             gridFormOrigin: self gridOrigin            grid: self gridModulus            background: nil            line: Color lightGray)]."  "draw background sketch."  backgroundMorph ifNotNil: [    self clipSubmorphs ifTrue: [      aCanvas clipBy: self clippingBounds        during: [ :canvas | canvas fullDrawMorph: backgroundMorph ]]      ifFalse: [ aCanvas fullDrawMorph: backgroundMorph ]]! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'StephaneDucasse 7/18/2010 15:45'!acceptDroppingMorph: dropped event: evt  "The supplied morph, known to be acceptable to the receiver, is now to be assimilated; the precipitating event is supplied"  | aMorph |  aMorph := self morphToDropFrom: dropped.  self isWorldMorph    ifTrue: ["Add the given morph to this world and start stepping it if it wants to be."        self addMorphFront: aMorph.        (aMorph fullBounds intersects: self viewBox) ifFalse:          [Beeper beep.  aMorph position: self bounds center]]    ifFalse: [super acceptDroppingMorph: aMorph event: evt].  "aMorph submorphsDo: [:m | (m isKindOf: HaloMorph) ifTrue: [m delete]]."  self world startSteppingSubmorphsOf: aMorph.  self bringTopmostsToFront.! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 2/4/2001 00:54'!dropEnabled  "Get this morph's ability to add and remove morphs via drag-n-drop."  ^ (self valueOfProperty: #dropEnabled) ~~ false! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/11/2000 18:22'!repelsMorph: aMorph event: ev  (aMorph wantsToBeDroppedInto: self) ifFalse: [^ false].  self dropEnabled ifFalse: [^ true].  (self wantsDroppedMorph: aMorph event: ev) ifFalse: [^ true].  ^ super repelsMorph: aMorph event: ev "consults #repelling flag"! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/11/2000 18:22'!wantsDroppedMorph: aMorph event: evt  self isWorldMorph ifTrue:[^true]. "always"  self visible ifFalse: [^ false].  "will be a call to #hidden again very soon"  self dropEnabled ifFalse: [^ false].  ^ true! !!PasteUpMorph methodsFor: 'event handling' stamp: 'ar 10/3/2000 22:46'!handlesMouseDown: evt  ^true! !!PasteUpMorph methodsFor: 'event handling' stamp: 'ar 2/23/2001 16:44'!morphToGrab: event  "Return the morph to grab from a mouse down event. If none, return nil."  self submorphsDo:[:m|    ((m rejectsEvent: event) not and:[m fullContainsPoint: event cursorPoint]) ifTrue:[^m].  ].  ^nil! !!PasteUpMorph methodsFor: 'events-processing' stamp: 'ar 4/5/2001 21:42'!processEvent: anEvent using: defaultDispatcher  "Reimplemented to install the receiver as the new ActiveWorld if it is one"  | priorWorld result |  self isWorldMorph ifFalse:[^super processEvent: anEvent using: defaultDispatcher].  priorWorld := ActiveWorld.  ActiveWorld := self.  result := super processEvent: anEvent using: defaultDispatcher.  ActiveWorld := priorWorld.  ^result! !!PasteUpMorph methodsFor: 'geometry' stamp: 'RAA 6/20/2000 12:42'!extent: aPoint  super extent: aPoint.  worldState ifNotNil: [    worldState viewBox ifNotNil: [      worldState canvas: nil.      worldState viewBox: bounds    ].  ].! !!PasteUpMorph methodsFor: 'geometry' stamp: 'RAA 6/1/2000 10:28'!position: aPoint  "Prevent moving a world (e.g. via HandMorph>>specialGesture:)"  "for now, let's allow it and see what happens"  self isWorldMorph ifFalse: [^super position: aPoint].  super position: aPoint.  self viewBox ifNotNil: [self viewBox: (aPoint extent: self viewBox extent)].! !!PasteUpMorph methodsFor: 'gridding' stamp: 'di 8/24/2000 13:15'!griddingOn  ^ griddingOn ifNil: [false]! !!PasteUpMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:35'!defaultBorderColor  "answer the default border color/fill style for the receiver"  ^ Color    r: 0.861    g: 1.0    b: 0.722! !!PasteUpMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:38'!defaultBorderWidth  "answer the default border width for the receiver"  ^ 1! !!PasteUpMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:29'!defaultColor  "answer the default color/fill style for the receiver"  ^ Color    r: 0.8    g: 1.0    b: 0.6! !!PasteUpMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 7/18/2010 15:20'!initialize  "initialize the state of the receiver"    super initialize.  self enableDragNDrop.  self clipSubmorphs: true! !!PasteUpMorph methodsFor: 'project state' stamp: 'nk 7/4/2003 16:47'!handsDo: aBlock  ^ worldState ifNotNil: [ worldState handsDo: aBlock ]! !!PasteUpMorph methodsFor: 'project state' stamp: 'sw 9/5/2000 06:45'!listOfSteppingMorphs  ^ worldState listOfSteppingMorphs"self currentWorld listOfSteppingMorphs"! !!PasteUpMorph methodsFor: 'project state' stamp: 'sw 9/5/2000 09:56'!stepListSize  ^ worldState stepListSize"Transcript cr; show: self currentWorld stepListSize printString, ' items on steplist as of ', Date dateAndTimeNow printString"! !!PasteUpMorph methodsFor: 'project state' stamp: 'sw 9/5/2000 09:59'!steppingMorphsNotInWorld  | all |  all := self allMorphs.  ^ self listOfSteppingMorphs select: [:m | (all includes: m) not]  "self currentWorld steppingMorphsNotInWorld do: [:m | m delete]"! !!PasteUpMorph methodsFor: 'project state' stamp: 'AlainPlantec 10/17/2009 20:31'!viewBox  "This tortured workaround arises from a situation encountered   in which a PasteUpMorph was directliy lodged as a submorph   of another PasteUpMorph of identical size"  ^ worldState    ifNil: [super viewBox]    ifNotNil: [worldState viewBox]! !!PasteUpMorph methodsFor: 'project state' stamp: 'dgd 2/22/2003 14:12'!viewBox: newViewBox   "I am now displayed within newViewBox; react."  self isWorldMorph     ifTrue:       [(self viewBox isNil or: [self viewBox extent ~= newViewBox extent])         ifTrue: [worldState canvas: nil].      worldState viewBox: newViewBox].  super position: newViewBox topLeft.  fullBounds := bounds := newViewBox.  "Paragraph problem workaround; clear selections to avoid screendroppings."  self flag: #arNote. "Probably unnecessary"  self isWorldMorph     ifTrue:       [worldState handsDo: [:hand | hand releaseKeyboardFocus].      self fullRepaintNeeded]! !!PasteUpMorph methodsFor: 'stepping' stamp: 'StephaneDucasse 6/4/2011 11:59'!cleanseOtherworldlySteppers  "If the current project is a morphic one, then remove from its steplist  those morphs that are not really in the world"  "Utilities cleanseOtherworldlySteppers"  | old delta |  old := self currentWorld stepListSize.  self currentWorld steppingMorphsNotInWorld    do: [:m | m delete].  self currentWorld cleanseStepList.  (delta := old - self currentWorld stepListSize) > 0    ifTrue: [ self crLog: delta asString , ' morphs removed from steplist' ]! !!PasteUpMorph methodsFor: 'stepping' stamp: 'AlainPlantec 10/17/2009 18:13'!cleanseStepList  "Remove morphs from the step list that are not in this World."  worldState cleanseStepListForWorld: self! !!PasteUpMorph methodsFor: 'stepping' stamp: 'RAA 5/24/2000 10:27'!runStepMethods  worldState runStepMethodsIn: self! !!PasteUpMorph methodsFor: 'structure' stamp: 'di 7/27/1999 10:46'!activeHand  ^ worldState ifNotNil: [worldState activeHand] ifNil: [super activeHand]! !!PasteUpMorph methodsFor: 'structure' stamp: 'GuillermoPolito 9/1/2010 18:42'!world  worldState ifNil: [^super world].  ^self! !!PasteUpMorph methodsFor: 'submorphs-accessing' stamp: 'RAA 5/24/2000 12:09'!allMorphsDo: aBlock  "Enumerate all morphs in the world, including those held in hands."  super allMorphsDo: aBlock.  self isWorldMorph    ifTrue: [worldState handsReverseDo: [:h | h allMorphsDo: aBlock]].! !!PasteUpMorph methodsFor: 'submorphs-add/remove' stamp: 'RAA 12/16/2000 18:37'!addMorphFront: aMorph  ^self addMorphInFrontOfLayer: aMorph! !!PasteUpMorph methodsFor: 'viewing' stamp: 'dgd 4/4/2006 13:58'!bringTopmostsToFront  submorphs    select:[:m| m wantsToBeTopmost]    thenDo:[:m| self addMorphInLayer: m].! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 10/26/2000 14:52'!addHand: aHandMorph  "Add the given hand to the list of hands for this world."  aHandMorph owner ifNotNil:[aHandMorph owner removeHand: aHandMorph].  worldState addHand: aHandMorph.  aHandMorph privateOwner: self.! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/25/2000 15:43'!displayWorld  self outermostWorldMorph privateOuterDisplayWorld! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/24/2000 12:23'!displayWorldSafely  worldState displayWorldSafely: self.! !!PasteUpMorph methodsFor: 'world state' stamp: 'ls 5/6/2003 16:51'!doOneCycle  "see the comment in doOneCycleFor:"  worldState doOneCycleFor: self! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/25/2000 15:43'!privateOuterDisplayWorld  worldState displayWorld: self submorphs: submorphs! !!PasteUpMorph methodsFor: 'world state' stamp: 'gvc 2/3/2010 18:00'!restoreMorphicDisplay  DisplayScreen startUp.  self    extent: Display extent;    viewBox: Display boundingBox;    handsDo: [:h | h visible: true; showTemporaryCursor: nil];    resizeBackgroundMorph;    fullRepaintNeeded.      WorldState    addDeferredUIMessage: [Cursor normal show].! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 6/1/2000 19:01'!startSteppingSubmorphsOf: aMorph  "Ensure that all submorphs of the given morph that want to be stepped are added to the step list.   Typically used after adding a morph to the world."  aMorph allMorphsDo: [:m |    m wantsSteps ifTrue: [m arrangeToStartSteppingIn: m world].  ]! !!Morph class methodsFor: 'initialize-release'!initialize  "Morph initialize"  "this empty array object is shared by all morphs with no submorphs:"  EmptyArray := Array new.! !!Morph class methodsFor: 'settings' stamp: 'AlainPlantec 12/10/2009 13:09'!defaultYellowButtonMenuEnabled  ^ DefaultYellowButtonMenuEnabled ifNil: [DefaultYellowButtonMenuEnabled := false]! !!HandMorph class methodsFor: 'class initialization' stamp: 'kfr 7/13/2003 14:15'!initialize  "HandMorph initialize"  PasteBuffer := nil.  DoubleClickTime := 350.  NormalCursor := CursorWithMask normal asCursorForm.! !!PasteUpMorph class methodsFor: 'project' stamp: 'RAA 5/25/2000 15:26'!disableDeferredUpdates  ^DisableDeferredUpdates ifNil: [DisableDeferredUpdates := false]! !!FormCanvas methodsFor: '*Polymorph-Widgets' stamp: 'IgorStasenko 7/18/2011 18:14'!fillRectangle: aRectangle basicFillStyle: aFillStyle  "Fill the given rectangle with the given, non-composite, fill style."    | pattern |  (aFillStyle isKindOf: InfiniteForm) ifTrue: [    ^self infiniteFillRectangle: aRectangle fillStyle: aFillStyle  ].  (aFillStyle isSolidFill)     ifTrue:[^self fillRectangle: aRectangle color: aFillStyle asColor].  "We have a very special case for filling with infinite forms"  (aFillStyle isBitmapFill and:[aFillStyle origin = (0@0)]) ifTrue:[    pattern := aFillStyle form.    (aFillStyle direction = (pattern width @ 0)       and:[aFillStyle normal = (0@pattern height)]) ifTrue:[        "Can use an InfiniteForm"        ^self fillRectangle: aRectangle color: (InfiniteForm with: pattern)].  ].  ! !!FormCanvas methodsFor: 'accessing' stamp: 'ar 5/28/2000 17:11'!allocateForm: extentPoint  "Allocate a new form which is similar to the receiver"  ^form allocateForm: extentPoint! !!FormCanvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 14:06'!clipRect  "Return the currently active clipping rectangle"  ^ clipRect translateBy: origin negated! !!FormCanvas methodsFor: 'accessing' stamp: 'ar 12/31/2001 03:26'!contentsOfArea: aRectangle into: aForm  | bb |  self flush.  bb := BitBlt toForm: aForm.  bb sourceForm: form; combinationRule: Form over;    sourceX: (aRectangle left + origin x); sourceY: (aRectangle top + origin y);    width: aRectangle width; height: aRectangle height;    copyBits.  ^aForm! !!FormCanvas methodsFor: 'accessing'!depth  ^ form depth! !!FormCanvas methodsFor: 'accessing'!extent  ^ form extent! !!FormCanvas methodsFor: 'accessing'!form  ^ form! !!FormCanvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 14:10'!origin  "Return the current origin for drawing operations"  ^ origin! !!FormCanvas methodsFor: 'copying' stamp: 'ar 6/17/1999 02:51'!copyClipRect: aRectangle  ^ self copyOrigin: origin clipRect: (aRectangle translateBy: origin)! !!FormCanvas methodsFor: 'copying' stamp: 'ar 6/17/1999 02:52'!copyOffset: aPoint  ^ self copyOrigin: origin + aPoint clipRect: clipRect! !!FormCanvas methodsFor: 'copying' stamp: 'ar 6/17/1999 02:52'!copyOrigin: aPoint clipRect: aRectangle  "Return a copy of this canvas with the given origin. The clipping rectangle of this canvas is the intersection of the given rectangle and the receiver's current clipping rectangle. This allows the clipping rectangles of nested clipping morphs to be composed."  ^ self copy    setOrigin: aPoint    clipRect: (clipRect intersect: aRectangle)! !!FormCanvas methodsFor: 'copying' stamp: 'nice 1/13/2010 21:21'!postCopy  "The copy share same underlying Form but with its own grafPort."  super postCopy.  self resetGrafPort! !!FormCanvas methodsFor: 'drawing' stamp: 'ar 5/14/2000 15:50'!fillColor: c  "Note: This always fills, even if the color is transparent."  self setClearColor: c.  port fillRect: form boundingBox offset: origin.! !!FormCanvas methodsFor: 'drawing-general' stamp: 'IgorStasenko 7/18/2011 17:29'!roundCornersOf: aMorph in: bounds during: aBlock  ^ aBlock value! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 5/14/2000 15:50'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor  | rect |  rect := r translateBy: origin.  "draw the border of the rectangle"  borderColor isTransparent ifFalse:[    self setFillColor: borderColor.    (r area > 10000 or: [fillColor isTranslucent]) ifTrue: [      port frameRect: rect borderWidth: borderWidth.    ] ifFalse: ["for small rectangles, it's faster to fill the entire outer rectangle          than to compute and fill the border rects"          port fillRect: rect offset: origin]].  "fill the inside"  fillColor isTransparent ifFalse:    [self setFillColor: fillColor.    port fillRect: (rect insetBy: borderWidth) offset: origin].! !!FormCanvas methodsFor: 'drawing-support' stamp: 'ar 6/17/1999 03:02'!clipBy: aRectangle during: aBlock  "Set a clipping rectangle active only during the execution of aBlock.  Note: In the future we may want to have more general clip shapes - not just rectangles"  ^aBlock value: (self copyClipRect: aRectangle)! !!FormCanvas methodsFor: 'drawing-support' stamp: 'ar 6/17/1999 03:02'!translateBy: delta during: aBlock  "Set a translation only during the execution of aBlock."  ^aBlock value: (self copyOffset: delta)! !!FormCanvas methodsFor: 'initialization' stamp: 'ar 5/27/2000 21:51'!finish  "If there are any pending operations on the receiver complete them. Do not return before all modifications have taken effect."  form finish! !!FormCanvas methodsFor: 'initialization' stamp: 'ar 2/17/2000 00:21'!reset  origin := 0@0.              "origin of the top-left corner of this cavas"  clipRect := (0@0 corner: 10000@10000).    "default clipping rectangle"  self shadowColor: nil.! !!FormCanvas methodsFor: 'testing' stamp: 'ar 6/22/1999 14:08'!isVisible: aRectangle  "Optimization"  (aRectangle right + origin x) < clipRect left ifTrue: [^ false].  (aRectangle left + origin x) > clipRect right ifTrue: [^ false].  (aRectangle bottom + origin y) < clipRect top ifTrue: [^ false].  (aRectangle top + origin y) > clipRect bottom ifTrue: [^ false].  ^ true! !!FormCanvas methodsFor: 'private' stamp: 'ar 5/14/2001 23:34'!image: aForm at: aPoint sourceRect: sourceRect rule: rule   "Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."  port colorMap: (aForm colormapIfNeededFor: form); fillColor: nil.  port image: aForm at: aPoint + origin sourceRect: sourceRect rule: rule.! !!FormCanvas methodsFor: 'private' stamp: 'pavel.krivanek 11/21/2008 16:55'!portClass    "Return the class used as port"  ^ UIManager default grafPort! !!FormCanvas methodsFor: 'private' stamp: 'ar 5/25/2000 17:25'!resetGrafPort  "Private!! Create a new grafPort for a new copy."  port := self portClass toForm: form.  port clipRect: clipRect.! !!FormCanvas methodsFor: 'private' stamp: 'tpr 9/15/2004 10:28'!setClearColor: aColor  "Install a new clear color - e.g., a color is used for clearing the background"  | clearColor |  clearColor := aColor ifNil:[Color transparent].  clearColor isColor ifFalse:[    (clearColor isKindOf: InfiniteForm) ifFalse:[^self error:'Cannot install color'].    ^port fillPattern: clearColor; combinationRule: Form over].  "Okay, so clearColor really *is* a color"  port sourceForm: nil.  port combinationRule: Form over.  port fillPattern: clearColor.  self depth = 8 ifTrue:[    "Use a stipple pattern"    port fillColor: (form balancedPatternFor: clearColor)].! !!FormCanvas methodsFor: 'private' stamp: 'IgorStasenko 7/18/2011 18:15'!setFillColor: aColor  "Install a new color used for filling."  | screen patternWord fillColor |  fillColor := aColor.  fillColor ifNil:[fillColor := Color transparent].  fillColor isColor ifFalse:[    (fillColor isKindOf: InfiniteForm) ifFalse:[^self error:'Cannot install color'].    ^port fillPattern: fillColor; combinationRule: Form over].  "Okay, so fillColor really *is* a color"  port sourceForm: nil.  fillColor isTranslucent ifFalse:[    port combinationRule: Form over.    port fillPattern: fillColor.    self depth = 8 ifTrue:[      "In 8 bit depth it's usually a good idea to use a stipple pattern"      port fillColor: (form balancedPatternFor: fillColor)].    ^self].  "fillColor is some translucent color"  self depth > 8 ifTrue:[    "BitBlt setup for alpha masked transfer"    port fillPattern: fillColor.    self depth = 16      ifTrue:[port alphaBits: fillColor privateAlpha; combinationRule: 30]      ifFalse:[port combinationRule: Form blend].    ^self].  "Can't represent actual transparency -- use stipple pattern"  screen := Color translucentMaskFor: fillColor alpha depth: self depth.  patternWord := form pixelWordFor: fillColor.  port fillPattern: (screen collect: [:maskWord | maskWord bitAnd: patternWord]).  port combinationRule: Form paint.! !!FormCanvas methodsFor: 'private' stamp: 'ar 5/25/2000 17:25'!setForm: aForm  self reset.  form := aForm.  port := self portClass toForm: form.! !!FormCanvas methodsFor: 'private' stamp: 'ar 6/22/1999 14:06'!setOrigin: aPoint clipRect: aRectangle  origin := aPoint.  clipRect := aRectangle.  port clipRect: aRectangle.! !!FormCanvas class methodsFor: 'instance creation'!extent: extent depth: depth  ^ self new setForm: (Form extent: extent depth: depth)! !!FormCanvas class methodsFor: 'instance creation' stamp: 'jm 8/2/97 13:54'!on: aForm  ^ self new setForm: aForm! !!MouseEvent class methodsFor: 'constants' stamp: 'NS 5/19/2003 15:16'!anyButton  ^ 7! !!MouseEvent class methodsFor: 'constants' stamp: 'NS 5/19/2003 15:16'!blueButton  ^ 1! !!MouseEvent class methodsFor: 'constants' stamp: 'NS 5/19/2003 15:16'!yellowButton  ^ 2! !'From Pharo1.4a of ''16 June 2011'' [Latest update: #14080] on 12 August 2011 at 9:41:22 pm'!!KeyboardEvent methodsFor: 'dispatching' stamp: 'ar 9/15/2000 21:13'!sentTo: anObject  "Dispatch the receiver into anObject"  type == #keystroke ifTrue:[^anObject handleKeystroke: self].  type == #keyDown ifTrue:[^anObject handleKeyDown: self].  type == #keyUp ifTrue:[^anObject handleKeyUp: self].  ^super sentTo: anObject.! !!KeyboardEvent methodsFor: 'initialize' stamp: 'michael.rueger 2/24/2009 14:08'!scanCode: anInt  scanCode := anInt! !!KeyboardEvent methodsFor: 'testing' stamp: 'ar 9/13/2000 15:49'!isKeyboard  ^true! !!KeyboardEvent methodsFor: 'private' stamp: 'michael.rueger 2/23/2009 11:49'!setType: aSymbol buttons: anInteger position: pos keyValue: aValue charCode: anInt hand: aHand stamp: stamp  type := aSymbol.  buttons := anInteger.  position := pos.  keyValue := aValue.  charCode := anInt.  source := aHand.  wasHandled := false.  timeStamp := stamp.! !!Morph methodsFor: 'event handling' stamp: 'ar 10/28/2000 22:18'!handlesKeyboard: evt  "Return true if the receiver wishes to handle the given keyboard event"  self eventHandler ifNotNil: [^ self eventHandler handlesKeyboard: evt].  ^ false! !!Morph methodsFor: 'event handling' stamp: 'KTT 6/1/2004 11:41'!keyUp: anEvent  "Handle a key up event. The default response is to do nothing."! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/15/2000 23:01'!handleKeyUp: anEvent  "System level event handling."  anEvent wasHandled ifTrue:[^self].  (self handlesKeyboard: anEvent) ifFalse:[^self].  anEvent wasHandled: true.  ^self keyUp: anEvent! !!PasteUpMorph methodsFor: 'event handling' stamp: 'AlainPlantec 12/10/2009 15:28'!handlesKeyboard: evt  ^self isWorldMorph or:[evt keyCharacter == Character tab]! !!HandMorph methodsFor: 'listeners' stamp: 'ar 10/26/2000 01:28'!keyboardListeners  ^keyboardListeners! !!HandMorph methodsFor: 'private events' stamp: 'HenrikSperreJohansen 5/9/2011 12:46'!generateKeyboardEvent: evtBuf  "Generate the appropriate mouse event for the given raw event buffer"  | buttons modifiers type pressType stamp charCode keyValue keyEvent |  stamp := evtBuf second.  stamp = 0 ifTrue: [stamp := Time millisecondClockValue].  pressType := evtBuf fourth.  pressType = EventKeyDown    ifTrue: [      type := #keyDown.      lastKeyScanCode := evtBuf third].  pressType = EventKeyUp ifTrue: [type := #keyUp].  pressType = EventKeyChar ifTrue: [    type := #keystroke].  modifiers := evtBuf fifth.  buttons := modifiers bitShift: 3.  keyValue := evtBuf third.   charCode := evtBuf sixth.    "Adjustments to provide consistent key value data for different VM's:  - charCode always contains unicode code point.   - keyValue contains 0 if input is outside legacy range"  "If there is no unicode data in the event, assume keyValue contains a correct (<256) Unicode codepoint, and use that"  (charCode isNil    or: [charCode = 0])    ifTrue: [charCode := keyValue].  "If charCode is not single-byte, we definately have Unicode input. Nil keyValue to avoid garbage values from som VMs."    charCode > 255 ifTrue: [keyValue := 0].  type = #keystroke    ifTrue: [combinedChar      ifNil: [        | peekedEvent |        peekedEvent := Sensor peekEvent.        (peekedEvent notNil          and: [peekedEvent fourth = EventKeyDown])          ifTrue: [            (CombinedChar isCompositionCharacter: charCode)              ifTrue: [                combinedChar := CombinedChar new.                combinedChar simpleAdd: charCode asCharacter.                (combinedChar combinesWith: peekedEvent third asCharacter)                  ifTrue: [^nil].                ]]]      ifNotNil: [        (combinedChar simpleAdd: charCode asCharacter)          ifTrue: [charCode := combinedChar combined charCode].        combinedChar := nil]].  (type = #keystroke and: [(buttons anyMask: 16)       and: [charCode = 30 or: [charCode = 31]]])    ifTrue: [^MouseWheelEvent new           setType: #mouseWheel          position: lastMouseEvent cursorPoint          direction: (charCode = 30 ifTrue: [#up] ifFalse: [#down])          buttons: buttons          hand: self          stamp: stamp].    keyEvent := KeyboardEvent new    setType: type    buttons: buttons    position: self position    keyValue: keyValue    charCode: charCode    hand: self    stamp: stamp.  keyEvent scanCode: lastKeyScanCode.  ^keyEvent! !!HandMorph methodsFor: 'private events' stamp: 'AlainPlantec 1/7/2010 19:44'!sendKeyboardEvent: anEvent   "Send the event to the morph currently holding the focus, or if none to  the owner of the hand."  ^ self    sendEvent: anEvent    focus: self keyboardFocus    clear: [self keyboardFocus: nil]! !!Morph methodsFor: 'stepping and presenter' stamp: 'ar 2/12/2001 17:04'!step  "Do some periodic activity. Use startStepping/stopStepping to start and stop getting sent this message. The time between steps is specified by this morph's answer to the stepTime message.  The generic version dispatches control to the player, if any.  The nasty circumlocation about owner's transformation is necessitated by the flexing problem that the player remains in the properties dictionary both of the flex and the real morph.  In the current architecture, only the top renderer's pointer to the player should actually be honored for the purpose of firing."! !!Morph methodsFor: 'testing' stamp: 'stephane.ducasse 11/27/2008 22:31'!stepTime  "Answer the desired time between steps in milliseconds. This default implementation requests that the 'step' method be called once every second."  ^ 1000 ! !!CompiledMethodTrailer methodsFor: 'decoding' stamp: 'Igor.Stasenko 12/13/2009 11:25'!decodeSourcePointer  "Trailer is a source pointer"  | msz |    size := 4.  msz := method size.  data := (method at: msz) - 251 << 8 + (method at: msz-1) << 8   + (method at: msz-2) << 8 + (method at: msz-3).  ! !!SmalltalkImage methodsFor: 'cleaning' stamp: 'PavelKrivanek 9/23/2010 10:30'!cleanUpAfterMorphicInitialization  Author fullName: 'Mr.Cleaner'. DataStream initialize.  Behavior flushObsoleteSubclasses.  MethodChangeRecord allInstancesDo: [ :x | x noteNewMethod: nil ].  World cleanseOtherworldlySteppers.  Smalltalk organization removeEmptyCategories. Smalltalk globals flushClassNameCache.  NaturalLanguageTranslator classPool at: #AllKnownPhrases put: nil.  3 timesRepeat: [     Smalltalk garbageCollect.    Symbol compactSymbolTable ].  HashedCollection rehashAll.    ChangeSet removeChangeSetsNamedSuchThat: [ :each | true ].  ChangeSet resetCurrentToNewUnnamedChangeSet.  Smalltalk garbageCollect.! !'From Pharo1.4a of ''16 June 2011'' [Latest update: #14080] on 21 August 2011 at 9:24:06 pm'!MouseEvent subclass: #MouseWheelEvent  instanceVariableNames: 'direction'  classVariableNames: ''  poolDictionaries: ''  category: 'Morphic-Events'!!MouseWheelEvent commentStamp: 'gvc 9/23/2008 11:46' prior: 0!A mouse event generated by intercepting the keyboard events (ctrl+up/down arrow) generated by the VM in response to mouse wheel activity.!!MouseWheelEvent methodsFor: 'accessing' stamp: 'gvc 1/25/2008 17:40'!direction  "Answer the value of direction"  ^ direction! !!MouseWheelEvent methodsFor: 'accessing' stamp: 'gvc 1/25/2008 17:40'!direction: anObject  "Set the value of direction"  direction := anObject! !!MouseWheelEvent methodsFor: 'as yet unclassified' stamp: 'gvc 1/28/2008 13:14'!isMouseWheel  "Answer whether the receiver is a mouse wheel event."    ^true! !!MouseWheelEvent methodsFor: 'as yet unclassified' stamp: 'gvc 1/25/2008 17:42'!sentTo: anObject  "Dispatch the receiver into anObject"    type == #mouseWheel ifTrue:[^anObject handleMouseWheel: self].  ^super sentTo: anObject.! !!MouseWheelEvent methodsFor: 'as yet unclassified' stamp: 'gvc 1/28/2008 15:31'!setType: evtType position: evtPos direction: dirSymbol buttons: evtButtons hand: evtHand stamp: stamp  "Set the state for the receiver."    type := evtType.  position := evtPos.  buttons := evtButtons.  source := evtHand.  wasHandled := false.  direction := dirSymbol.  timeStamp := stamp.! !!MorphExtension methodsFor: 'accessing' stamp: 'gvc 9/11/2009 17:08'!borderStyle: anObject  "Set the value of borderStyle"  borderStyle := anObject! !!BorderStyle methodsFor: 'accessing' stamp: 'ar 8/25/2001 17:51'!style  ^#none! !!BorderStyle class methodsFor: 'instance creation' stamp: 'ar 8/25/2001 16:19'!width: aNumber color: aColor  ^SimpleBorder new color: aColor; width: aNumber; yourself! !MessageSend subclass: #MorphicAlarm  instanceVariableNames: 'scheduledTime numArgs'  classVariableNames: ''  poolDictionaries: ''  category: 'Morphic-Events'!!MorphicAlarm commentStamp: 'LaurentLaffont 3/4/2011 22:45' prior: 0!I represent a message to be scheduled by the WorldState.For example, you can see me in action with the following example which print 'alarm test' on Transcript one second after evaluating the code:Transcript open.MorphicUIManager currentWorld        addAlarm: #show:         withArguments: #('alarm test')         for: Transcript         at: (Time millisecondClockValue + 1000).* Note *Compared to doing:[(Delay forMilliseconds: 1000) wait. Transcript show: 'alarm test'] forkAt: Processor activeProcess priority +1.the alarm system has several distinctions:- Runs with the step refresh rate resolution.- Alarms only run for the active world. (Unless a non-standard scheduler is in use)- Alarms with the same scheduled time are guaranteed to be executed in the order they were added!!MorphicAlarm methodsFor: 'accessing' stamp: 'ar 9/11/2000 16:44'!scheduledTime  "Return the time (in milliseconds) that the receiver is scheduled to be executed"  ^scheduledTime! !!MorphicAlarm methodsFor: 'accessing' stamp: 'ar 9/11/2000 16:45'!scheduledTime: msecs  "Set the time (in milliseconds) that the receiver is scheduled to be executed"  scheduledTime := msecs! !!MorphicAlarm methodsFor: 'evaluating' stamp: 'GuillermoPolito 9/1/2010 18:45'!value: anArgument  | nArgs |  numArgs ifNil:[numArgs := selector numArgs].  nArgs := arguments ifNil:[0] ifNotNil:[arguments size].  nArgs = numArgs ifTrue:[    "Ignore extra argument"    ^self value].  ^arguments ifNil: [receiver perform: selector with: anArgument]    ifNotNil: [receiver perform: selector withArguments: (arguments copyWith: anArgument)]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MorphicAlarm class  instanceVariableNames: ''!!MorphicAlarm class methodsFor: 'instance creation' stamp: 'ar 9/11/2000 16:44'!scheduledAt: scheduledTime receiver: aTarget selector: aSelector arguments: argArray  ^(self receiver: aTarget selector: aSelector arguments: argArray)    scheduledTime: scheduledTime.! !!WorldState methodsFor: 'stepping' stamp: 'ar 10/22/2000 16:23'!adjustWakeupTimes: now  "Fix the wakeup times in my step list. This is necessary when this world has been restarted after a pause, say because some other view had control, after a snapshot, or because the millisecond clock has wrapped around. (The latter is a rare occurence with a 32-bit clock!!)"  | deltaTime |  deltaTime := now - lastStepTime.  stepList do:[:entry| entry scheduledTime: entry scheduledTime + deltaTime].  lastStepTime := now.! !!Morph methodsFor: 'wiw support' stamp: 'ar 3/18/2001 00:14'!shouldGetStepsFrom: aWorld  ^self world == aWorld! !!PasteUpMorph methodsFor: 'wiw support' stamp: 'RAA 8/14/2000 12:10'!shouldGetStepsFrom: aWorld  (self isWorldMorph and: [owner notNil]) ifTrue: [    ^self outermostWorldMorph == aWorld  ].  ^super shouldGetStepsFrom: aWorld! !!FormCanvas methodsFor: 'copying' stamp: 'ar 6/17/1999 02:52'!copyOffset: aPoint clipRect: sourceClip  "Make a copy of me offset by aPoint, and further clipped  by sourceClip, a rectangle in the un-offset coordinates"  ^ self copyOrigin: aPoint + origin    clipRect: ((sourceClip translateBy: origin) intersect: clipRect)! !!WorldState methodsFor: 'update cycle' stamp: 'alain.plantec 6/2/2008 08:45'!handleFatalDrawingError: errMsg  "Handle a fatal drawing error."  Display deferUpdates: false. "Just in case"  self primitiveError: errMsg.  "Hm... we should jump into a 'safe' worldState here, but how do we find it?!!"! !!PasteUpMorph methodsFor: 'world state' stamp: 'alain.plantec 5/30/2008 14:07'!handleFatalDrawingError: errMsg  "Handle a fatal drawing error."  Display deferUpdates: false. "Just in case"  self primitiveError: errMsg.  "Hm... we should jump into a 'safe' worldState here, but how do we find it?!!"! !!PasteUpMorph methodsFor: 'world state' stamp: 'nice 1/5/2010 15:59'!flashRects: rectangleList color: aColor  "For testing. Flashes the given list of rectangles on the Display so you can watch incremental redisplay at work."  "Details: Uses two reverses so that the display is restored to its original state. This is necessary when in deferred update mode."  | blt |  blt := (BitBlt current toForm: Display)    sourceForm: nil;    sourceOrigin: 0@0;    clipRect: self viewBox;    combinationRule: Form reverse.  rectangleList do: [:r | | screenRect |    screenRect := r translateBy: self viewBox origin.    blt destRect: screenRect; copyBits.    Display forceToScreen: screenRect; forceDisplayUpdate.    (Delay forMilliseconds: 15) wait.    blt destRect: screenRect; copyBits.    Display forceToScreen: screenRect; forceDisplayUpdate].! !!PasteUpMorph methodsFor: 'stepping' stamp: 'RAA 5/24/2000 11:08'!stopStepping: aMorph  "Remove the given morph from the step list."  worldState stopStepping: aMorph! !!WorldState methodsFor: 'stepping' stamp: 'ar 10/22/2000 16:10'!stopStepping: aMorph  "Remove the given morph from the step list."  lastStepMessage ifNotNil:[    (lastStepMessage receiver == aMorph) ifTrue:[lastStepMessage := nil]].  stepList removeAll: (stepList select:[:stepMsg| stepMsg receiver == aMorph]).! !!FormCanvas methodsFor: 'other' stamp: 'ar 5/28/2000 12:09'!showAt: pt invalidRects: updateRects  | blt |  blt := (BitBlt current toForm: Display)    sourceForm: form;    combinationRule: Form over.  updateRects do:    [:rect |    blt sourceRect: rect;      destOrigin: rect topLeft + pt;      copyBits]! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/24/2000 10:45'!assuredCanvas    ^worldState assuredCanvas! !!WorldState methodsFor: 'canvas' stamp: 'stephane.ducasse 9/25/2008 18:10'!assuredCanvas  (canvas isNil or: [(canvas extent ~= viewBox extent) or: [canvas form depth ~= Display depth]])    ifTrue:      ["allocate a new offscreen canvas the size of the window"      self canvas: (Display defaultCanvasClass extent: viewBox extent)].  ^ self canvas! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 7/27/1999 10:46'!canvas  ^ worldState canvas! !!WorldState methodsFor: 'canvas' stamp: 'di 6/7/1999 17:44'!canvas  ^ canvas! !!Morph methodsFor: '*Polymorph-Widgets' stamp: 'gvc 1/25/2008 17:34'!handlesMouseWheel: evt  "Do I want to receive mouseWheel events?."   ^false! !!Morph methodsFor: '*Polymorph-Widgets' stamp: 'gvc 1/28/2008 17:21'!handleMouseWheel: anEvent  "System level event handling."    anEvent wasHandled ifTrue:[^self].  (self handlesMouseWheel: anEvent) ifTrue:[    anEvent wasHandled: true.    self mouseWheel: anEvent]! !!Morph methodsFor: 'accessing - properties' stamp: 'md 2/27/2006 09:47'!otherProperties  "answer the receiver's otherProperties"  ^ extension ifNotNil: [extension otherProperties]! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'dgd 2/16/2003 21:04'!otherProperties  "answer the receiver's otherProperties"  ^ otherProperties! !!Morph methodsFor: 'stepping and presenter' stamp: 'sw 3/22/2000 14:26'!arrangeToStartSteppingIn: aWorld  "Start getting sent the 'step' message in aWorld.  Like startSteppingIn:, but without the initial one to get started'"  aWorld ifNotNil:    [aWorld startStepping: self.    self changed]! !MorphicAlarm subclass: #StepMessage  instanceVariableNames: 'stepTime'  classVariableNames: ''  poolDictionaries: ''  category: 'Morphic-Events'!!StepMessage commentStamp: 'LaurentLaffont 3/15/2011 20:49' prior: 0!I'm a MorphicAlarm to be queued in WorldState list of stepping actions. I hold the stepTime (refresh period) of my receiver / Morph (if nil, the #stepTime value of my receiver is used).See - WordState>>runLocalStepMethodsIn:   (where the stepping actions are sent).- WorldState>>startStepping:at:selector:arguments:stepTime:  (to queue a new StepMessage)Example:MorphicUIManager currentWorld        startStepping: (Morph new openInWorld)        at: Time millisecondClockValue        selector: #toggleVisible        arguments: nil        stepTime: 500.!!StepMessage methodsFor: 'accessing' stamp: 'ar 10/22/2000 16:56'!stepTime: aNumber  "Set the step time for this message. If nil, the receiver of the message will be asked for its #stepTime."  stepTime := aNumber! !!StepMessage methodsFor: 'printing' stamp: 'ar 10/22/2000 15:59'!printOn: aStream  super printOn: aStream.  aStream     nextPut: $(;    print: receiver;    space;    print: selector;    space;    print: scheduledTime;    nextPut: $).! !!StepMessage methodsFor: 'testing' stamp: 'ar 10/22/2000 16:56'!stepTime  "Return the step time for this message. If nil, the receiver of the message will be asked for its #stepTime."  ^stepTime! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StepMessage class  instanceVariableNames: ''!!StepMessage class methodsFor: 'instance creation' stamp: 'ar 10/22/2000 15:48'!scheduledAt: scheduledTime stepTime: stepTime receiver: aTarget selector: aSelector arguments: argArray  ^(self receiver: aTarget selector: aSelector arguments: argArray)    scheduledTime: scheduledTime;    stepTime: stepTime! !!WorldState methodsFor: 'stepping' stamp: 'ar 10/22/2000 16:36'!startStepping: aMorph at: scheduledTime selector: aSelector arguments: args stepTime: stepTime  "Add the given morph to the step list. Do nothing if it is already being stepped."  self stopStepping: aMorph selector: aSelector.  self adjustWakeupTimesIfNecessary.  stepList add:(    StepMessage       scheduledAt: scheduledTime      stepTime: stepTime      receiver: aMorph      selector: aSelector      arguments: args)! !!PasteUpMorph methodsFor: 'stepping' stamp: 'ar 10/22/2000 16:39'!startStepping: aMorph  "Add the given morph to the step list. Do nothing if it is already being stepped."  ^self startStepping: aMorph at: Time millisecondClockValue selector: #stepAt: arguments: nil stepTime: nil! !!PasteUpMorph methodsFor: 'stepping' stamp: 'ar 10/22/2000 16:36'!startStepping: aMorph at: scheduledTime selector: aSelector arguments: args stepTime: stepTime  worldState startStepping: aMorph at: scheduledTime selector: aSelector arguments: args stepTime: stepTime.! !!WorldState methodsFor: 'stepping' stamp: 'ar 10/22/2000 16:10'!stopStepping: aMorph selector: aSelector  "Remove the given morph from the step list."  lastStepMessage ifNotNil:[    (lastStepMessage receiver == aMorph and:[lastStepMessage selector == aSelector])      ifTrue:[lastStepMessage := nil]].  stepList removeAll: (stepList select:[:stepMsg| stepMsg receiver == aMorph and:[stepMsg selector == aSelector]]).! !!PasteUpMorph methodsFor: 'stepping' stamp: 'ar 10/22/2000 16:40'!stopStepping: aMorph selector: aSelector  "Remove the given morph from the step list."  worldState stopStepping: aMorph selector: aSelector! !!WorldState methodsFor: 'stepping' stamp: 'ar 10/22/2000 15:22'!adjustWakeupTimesIfNecessary  "Fix the wakeup times in my step list if necessary. This is needed after a snapshot, after a long pause (say because some other view had control or because the user was selecting from an MVC-style menu) or when the millisecond clock wraps around (a very rare occurence with a 32-bit clock!!)."  | now |  now := Time millisecondClockValue.  ((now < lastStepTime) or: [(now - lastStepTime) > 5000])     ifTrue: [self adjustWakeupTimes: now].  "clock slipped"! !!GrafPort methodsFor: 'accessing' stamp: 'ar 2/17/2000 01:07'!alphaBits: a  alpha := a! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/17/2000 14:44'!frameRect: rect borderWidth: borderWidth  sourceX := 0.  sourceY := 0.  (rect areasOutside: (rect insetBy: borderWidth)) do:    [:edgeStrip | self destRect: edgeStrip; copyBits].! !!GrafPort methodsFor: 'accessing' stamp: 'ar 2/17/2000 01:07'!alphaBits: a  alpha := a! !!GrafPort methodsFor: 'copying' stamp: 'ar 12/30/2001 20:32'!clippedBy: aRectangle  ^ self copy clipBy: aRectangle! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/15/2000 23:01'!handleKeyDown: anEvent  "System level event handling."  anEvent wasHandled ifTrue:[^self].  (self handlesKeyboard: anEvent) ifFalse:[^self].  anEvent wasHandled: true.  ^self keyDown: anEvent! !!Morph methodsFor: 'events-processing' stamp: 'md 8/2/2006 18:57'!handleKeystroke: anEvent   "System level event handling."    anEvent wasHandled    ifTrue: [^ self].  (self handlesKeyboard: anEvent)    ifFalse: [^ self].  anEvent wasHandled: true.  ^ self keyStroke: anEvent! !!Morph methodsFor: 'event handling' stamp: 'ar 9/14/2000 18:23'!keyDown: anEvent  "Handle a key down event. The default response is to do nothing."! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:05'!keyStroke: anEvent  "Handle a keystroke event.  The default response is to let my eventHandler, if any, handle it."  self eventHandler ifNotNil:    [self eventHandler keyStroke: anEvent fromMorph: self].! !Object subclass: #LayoutPolicy  instanceVariableNames: ''  classVariableNames: ''  poolDictionaries: ''  category: 'Morphic-Layouts'!!LayoutPolicy commentStamp: '<historical>' prior: 0!A LayoutPolicy defines how submorphs of some morph should be arranged. Subclasses of the receiver define concrete layout policies.!!LayoutPolicy methodsFor: 'layout' stamp: 'ar 1/27/2001 14:39'!flushLayoutCache  "Flush any cached information associated with the receiver"! !!LayoutPolicy methodsFor: 'layout' stamp: 'ar 10/28/2000 19:12'!layout: aMorph in: newBounds  "Compute the layout for the given morph based on the new bounds"! !!LayoutPolicy methodsFor: 'layout' stamp: 'ar 10/31/2000 19:59'!minExtentOf: aMorph in: newBounds  "Return the minimal size aMorph's children would require given the new bounds"  ^0@0! !!LayoutPolicy methodsFor: 'testing' stamp: 'ar 10/29/2000 01:28'!isProportionalLayout  ^false! !!LayoutPolicy methodsFor: 'testing' stamp: 'ar 10/29/2000 01:28'!isTableLayout  ^false! !!LayoutPolicy methodsFor: 'utilities' stamp: 'ar 10/29/2000 17:31'!indexForInserting: aMorph at: aPoint in: someMorph  "Return the insertion index based on the layout strategy defined for some morph. Used for drop insertion."  ^1 "front-most"! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 1/31/2001 12:45'!addMorph: newMorph inFrontOf: aMorph  "Add a morph to the list of submorphs in front of the specified morph"  ^self privateAddMorph: newMorph atIndex: ((submorphs indexOf: aMorph) max: 1).! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 10/5/2000 16:23'!removeHand: aHandMorph  "Remove the given hand from the list of hands for this world."  (worldState hands includes: aHandMorph) ifFalse: [^self].  aHandMorph dropMorphs.  self invalidRect: aHandMorph fullBounds.  worldState removeHand: aHandMorph.! !!WorldState methodsFor: 'hands' stamp: 'ar 1/22/2001 14:26'!removeHand: aHandMorph  "Remove the given hand from the list of hands for this world."  (hands includes: aHandMorph) ifFalse: [^self].  hands := hands copyWithout: aHandMorph.  ActiveHand == aHandMorph ifTrue: [ActiveHand := nil].! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 10/5/2000 16:23'!dropMorphs  "Drop the morphs at the hands position"  self dropMorphs: lastMouseEvent.! !!UserInputEvent methodsFor: 'initialize' stamp: 'ar 9/13/2000 15:54'!copyHandlerState: anEvent  "Copy the handler state from anEvent. Used for quickly transferring handler information between transformed events."  handler := anEvent handler.  wasHandled := anEvent wasHandled.! !!MorphicEvent methodsFor: 'initialize' stamp: 'ar 10/10/2000 01:18'!copyHandlerState: anEvent  "Copy the handler state from anEvent. Used for quickly transferring handler information between transformed events."! !!DropEvent methodsFor: 'initialize' stamp: 'ar 10/10/2000 01:19'!copyHandlerState: anEvent  "Copy the handler state from anEvent. Used for quickly transferring handler information between transformed events."  wasHandled := anEvent wasHandled.! !!Morph methodsFor: 'layout' stamp: 'dgd 2/16/2003 21:52'!minHeight  "answer the receiver's minHeight"  ^ self    valueOfProperty: #minHeight    ifAbsent: [2]! !!Morph methodsFor: 'layout' stamp: 'ar 10/31/2000 21:09'!layoutBounds: aRectangle  "Set the bounds for laying out children of the receiver.  Note: written so that #layoutBounds can be changed without touching this method"  | outer inner |  outer := self bounds.  inner := self layoutBounds.  bounds := aRectangle origin + (outer origin - inner origin) corner:        aRectangle corner + (outer corner - inner corner).! !!Morph methodsFor: 'layout' stamp: 'dgd 2/16/2003 21:54'!minWidth  "answer the receiver's minWidth"  ^ self    valueOfProperty: #minWidth    ifAbsent: [2]! !!Morph methodsFor: 'submorphs-accessing' stamp: 'dgd 2/22/2003 14:31'!firstSubmorph  ^submorphs first! !!Morph methodsFor: 'structure' stamp: 'ar 9/14/2000 16:48'!withAllOwnersDo: aBlock  "Evaluate aBlock with the receiver and all of its owners"  aBlock value: self.  owner ifNotNil:[^owner withAllOwnersDo: aBlock].! !Object subclass: #EventHandler  instanceVariableNames: 'mouseDownRecipient mouseDownSelector mouseMoveRecipient mouseMoveSelector mouseStillDownRecipient mouseStillDownSelector mouseUpRecipient mouseUpSelector mouseEnterRecipient mouseEnterSelector mouseLeaveRecipient mouseLeaveSelector mouseEnterDraggingRecipient mouseEnterDraggingSelector mouseLeaveDraggingRecipient mouseLeaveDraggingSelector keyStrokeRecipient keyStrokeSelector valueParameter startDragRecipient startDragSelector doubleClickSelector doubleClickRecipient doubleClickTimeoutSelector doubleClickTimeoutRecipient clickSelector clickRecipient'  classVariableNames: ''  poolDictionaries: ''  category: 'Morphic-Events'!!EventHandler commentStamp: '<historical>' prior: 0!Events in Morphic originate in a Hand, pass to a target morph, and are then dispatched by an EventHandler.  EventHandlers support redirection of mouse and keyboard activity by specifying and independent recipient object and message selector for each of the possible events.  In addition each eventHandler can supply an optional value parameter for distinguishing between, eg, events from a number of otherwise identical source morphs.The basic protocol of an event handler is to receive a message of the form  mouseDown: event in: targetMorphand redirect this as one of  mouseDownRecipient perform: mouseDownSelector0  mouseDownRecipient perform: mouseDownSelector1 with: event  mouseDownRecipient perform: mouseDownSelector2 with: event with: targetMorph  mouseDownRecipient perform: mouseDownSelector3 with: event with: targetMorph with: valueParameterdepending on the arity of the mouseDownSelector.!!EventHandler methodsFor: 'access' stamp: 'ar 10/25/2000 17:33'!allRecipients  "Answer a list, without duplication, of all the objects serving as recipients to any of the events I handle.  Intended for debugging/documentation use only"  | aList |  aList := OrderedCollection with: mouseDownRecipient with: mouseStillDownRecipient with: mouseUpRecipient with: mouseEnterRecipient with: mouseLeaveRecipient.  aList addAll: (OrderedCollection with:  mouseEnterDraggingRecipient with: mouseLeaveDraggingRecipient with: doubleClickRecipient with: keyStrokeRecipient).  aList add: mouseMoveRecipient.  ^ (aList copyWithout: nil) asSet asArray! !!EventHandler methodsFor: 'access' stamp: 'ar 10/25/2000 17:34'!firstMouseSelector  "Answer the selector corresponding to the first mouse-handling selector fielded.  Created in support of providing balloon-help for halo handles, triggered by the selector handled"  mouseDownSelector ifNotNil: [^ mouseDownSelector].  mouseMoveSelector ifNotNil:[^mouseMoveSelector].  mouseStillDownSelector ifNotNil: [^ mouseStillDownSelector].  mouseUpSelector ifNotNil: [^ mouseUpSelector].  mouseEnterSelector ifNotNil: [^ mouseEnterSelector].  mouseLeaveSelector ifNotNil: [^ mouseLeaveSelector].  mouseEnterDraggingSelector ifNotNil: [^ mouseEnterDraggingSelector].  mouseLeaveDraggingSelector ifNotNil: [^ mouseLeaveDraggingSelector].  doubleClickSelector ifNotNil: [^ doubleClickSelector].  ^ nil! !!EventHandler methodsFor: 'access'!messageList  "Return a list of 'Class selector' for each message I can send. tk   9/13/97"  | list |  self flag: #mref.  "is this still needed? I replaced the one use that I could spot with   #methodRefList "  list := SortedCollection new.  mouseDownRecipient    ifNotNil: [list add: (mouseDownRecipient class whichClassIncludesSelector: mouseDownSelector) name , ' ' , mouseDownSelector].  mouseMoveRecipient    ifNotNil: [list add: (mouseMoveRecipient class whichClassIncludesSelector: mouseMoveSelector) name , ' ' , mouseMoveSelector].  mouseStillDownRecipient    ifNotNil: [list add: (mouseStillDownRecipient class whichClassIncludesSelector: mouseStillDownSelector) name , ' ' , mouseStillDownSelector].  mouseUpRecipient    ifNotNil: [list add: (mouseUpRecipient class whichClassIncludesSelector: mouseUpSelector) name , ' ' , mouseUpSelector].  mouseEnterRecipient    ifNotNil: [list add: (mouseEnterRecipient class whichClassIncludesSelector: mouseEnterSelector) name , ' ' , mouseEnterSelector].  mouseLeaveRecipient    ifNotNil: [list add: (mouseLeaveRecipient class whichClassIncludesSelector: mouseLeaveSelector) name , ' ' , mouseLeaveSelector].  mouseEnterDraggingRecipient    ifNotNil: [list add: (mouseEnterDraggingRecipient class whichClassIncludesSelector: mouseEnterDraggingSelector) name , ' ' , mouseEnterDraggingSelector].  mouseLeaveDraggingRecipient    ifNotNil: [list add: (mouseLeaveDraggingRecipient class whichClassIncludesSelector: mouseLeaveDraggingSelector) name , ' ' , mouseLeaveDraggingSelector].  doubleClickRecipient    ifNotNil: [list add: (doubleClickRecipient class whichClassIncludesSelector: doubleClickSelector) name , ' ' , doubleClickSelector].  keyStrokeRecipient    ifNotNil: [list add: (keyStrokeRecipient class whichClassIncludesSelector: keyStrokeSelector) name , ' ' , keyStrokeSelector].  ^ list! !!EventHandler methodsFor: 'access' stamp: 'StephaneDucasse 8/21/2011 17:50'!methodRefList  "Return a MethodReference for each message I can send. tk 9/13/97, raa   5/29/01 "  | list adder |  list := SortedCollection new.  adder := [:recip :sel | recip        ifNotNil: [list            add: (RGMethodDefinition                realClass: (recip class whichClassIncludesSelector: sel)                selector: sel)]].  adder value: mouseDownRecipient value: mouseDownSelector.  adder value: mouseMoveRecipient value: mouseMoveSelector.  adder value: mouseStillDownRecipient value: mouseStillDownSelector.  adder value: mouseUpRecipient value: mouseUpSelector.  adder value: mouseEnterRecipient value: mouseEnterSelector.  adder value: mouseLeaveRecipient value: mouseLeaveSelector.  adder value: mouseEnterDraggingRecipient value: mouseEnterDraggingSelector.  adder value: mouseLeaveDraggingRecipient value: mouseLeaveDraggingSelector.  adder value: doubleClickRecipient value: doubleClickSelector.  adder value: keyStrokeRecipient value: keyStrokeSelector.  ^ list! !!EventHandler methodsFor: 'access' stamp: 'di 9/14/1998 08:32'!mouseDownSelector  ^ mouseDownSelector! !!EventHandler methodsFor: 'access' stamp: 'ar 10/25/2000 18:27'!mouseStillDownRecipient  ^mouseStillDownRecipient! !!EventHandler methodsFor: 'access' stamp: 'ar 10/25/2000 18:27'!mouseStillDownSelector  ^mouseStillDownSelector! !!EventHandler methodsFor: 'access' stamp: 'di 9/14/1998 08:32'!mouseUpSelector  ^ mouseUpSelector! !!EventHandler methodsFor: 'copying' stamp: 'tk 1/22/2001 17:43'!veryDeepFixupWith: deepCopier  | old |  "ALL inst vars were weakly copied.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.1 to: self class instSize do:  [:ii | old := self instVarAt: ii.  self instVarAt: ii put: (deepCopier references at: old ifAbsent: [old])].! !!EventHandler methodsFor: 'events' stamp: 'ar 10/7/2000 22:55'!click: event fromMorph: sourceMorph   "This message is sent only when double clicks are handled."  ^ self    send: clickSelector    to: clickRecipient    withEvent: event    fromMorph: sourceMorph! !!EventHandler methodsFor: 'events' stamp: 'LC 2/14/2000 08:38'!doubleClick: event fromMorph: sourceMorph   ^ self    send: doubleClickSelector    to: doubleClickRecipient    withEvent: event    fromMorph: sourceMorph! !!EventHandler methodsFor: 'events' stamp: 'jcg 9/21/2001 13:06'!doubleClickTimeout: event fromMorph: sourceMorph   ^ self    send: doubleClickTimeoutSelector    to: doubleClickTimeoutRecipient    withEvent: event    fromMorph: sourceMorph! !!EventHandler methodsFor: 'events'!keyStroke: event fromMorph: sourceMorph  ^ self send: keyStrokeSelector to: keyStrokeRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'events' stamp: 'ar 10/7/2000 22:54'!mouseDown: event fromMorph: sourceMorph   "Take double-clicks into account."  ((self handlesClickOrDrag: event) and:[event redButtonPressed]) ifTrue:[    event hand waitForClicksOrDrag: sourceMorph event: event.  ].  ^self    send: mouseDownSelector    to: mouseDownRecipient    withEvent: event    fromMorph: sourceMorph.! !!EventHandler methodsFor: 'events'!mouseEnter: event fromMorph: sourceMorph  ^ self send: mouseEnterSelector to: mouseEnterRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'events' stamp: 'di 9/15/1998 16:35'!mouseEnterDragging: event fromMorph: sourceMorph  ^ self send: mouseEnterDraggingSelector to: mouseEnterDraggingRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'events'!mouseLeave: event fromMorph: sourceMorph  ^ self send: mouseLeaveSelector to: mouseLeaveRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'events' stamp: 'di 9/15/1998 16:35'!mouseLeaveDragging: event fromMorph: sourceMorph  ^ self send: mouseLeaveDraggingSelector to: mouseLeaveDraggingRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'events' stamp: 'ar 10/25/2000 17:32'!mouseMove: event fromMorph: sourceMorph  ^ self send: mouseMoveSelector to: mouseMoveRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'events'!mouseStillDown: event fromMorph: sourceMorph  ^ self send: mouseStillDownSelector to: mouseStillDownRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'events'!mouseUp: event fromMorph: sourceMorph  ^ self send: mouseUpSelector to: mouseUpRecipient withEvent: event fromMorph: sourceMorph! !!EventHandler methodsFor: 'events' stamp: 'ar 3/17/2001 14:34'!send: selector to: recipient withEvent: event fromMorph: sourceMorph  | arity |  recipient ifNil: [^ self].  arity := selector numArgs.  arity = 0 ifTrue:    [^ recipient perform: selector].  arity = 1 ifTrue:    [^ recipient perform: selector with: event].  arity = 2 ifTrue:    [^ recipient perform: selector with: event with: sourceMorph].  arity = 3 ifTrue:    [^ recipient perform: selector with: valueParameter with: event with: sourceMorph].  self error: 'Event handling selectors must be Symbols and take 0-3 arguments'! !!EventHandler methodsFor: 'events' stamp: 'mir 5/23/2000 17:43'!startDrag: event fromMorph: sourceMorph   ^ self    send: startDragSelector    to: startDragRecipient    withEvent: event    fromMorph: sourceMorph! !!EventHandler methodsFor: 'fixups' stamp: 'stephane.ducasse 11/18/2008 21:50'!fixReversedValueMessages  "ar 3/18/2001: Due to the change in the ordering of the value parameter old event handlers may have messages that need to be fixed up. Do this here."  self replaceSendsIn: #( renameCharAction:sourceMorph:requestor: makeGetter:from:forPart: makeSetter:from:forPart: clickOnLine:evt:envelope: limitHandleMoveEvent:from:index: mouseUpEvent:linkMorph:formData: mouseUpEvent:linkMorph:browserAndUrl: mouseDownEvent:noteMorph:pitch: mouseMoveEvent:noteMorph:pitch: mouseUpEvent:noteMorph:pitch: dragVertex:fromHandle:vertIndex: dropVertex:fromHandle:vertIndex: newVertex:fromHandle:afterVert: prefMenu:rcvr:pref: event:arrow:upDown:)      with: #( renameCharAction:event:sourceMorph: makeGetter:event:from: makeSetter:event:from:  clickOn:evt:from: limitHandleMove:event:from: mouseUpFormData:event:linkMorph: mouseUpBrowserAndUrl:event:linkMorph: mouseDownPitch:event:noteMorph: mouseMovePitch:event:noteMorph: mouseUpPitch:event:noteMorph: dragVertex:event:fromHandle: dropVertex:event:fromHandle: newVertex:event:fromHandle: prefMenu:event:rcvr: upDown:event:arrow:)."sw 3/28/2001 extended Andreas's original lists by one item"! !!EventHandler methodsFor: 'fixups' stamp: 'ar 3/18/2001 17:18'!replaceSendsIn: array1 with: array2  "Replace all the sends that occur in array1 with those in array2. Used for fixing old event handlers in files."  | old index |  1 to: self class instSize do:[:i|    old := self instVarAt: i.    index := array1 identityIndexOf: old.    index > 0 ifTrue:[self instVarAt: i put: (array2 at: index)]].! !!EventHandler methodsFor: 'initialization' stamp: 'nk 2/15/2004 08:16'!on: eventName send: selector to: recipient  eventName == #mouseDown ifTrue:    [mouseDownRecipient := recipient.  mouseDownSelector := selector. ^ self].  eventName == #mouseMove ifTrue:    [mouseMoveRecipient := recipient.  mouseMoveSelector := selector. ^ self].  eventName == #mouseStillDown ifTrue:    [mouseStillDownRecipient := recipient.  mouseStillDownSelector := selector. ^ self].  eventName == #mouseUp ifTrue:    [mouseUpRecipient := recipient.  mouseUpSelector := selector. ^ self].  eventName == #mouseEnter ifTrue:    [mouseEnterRecipient := recipient.  mouseEnterSelector := selector. ^ self].  eventName == #mouseLeave ifTrue:    [mouseLeaveRecipient := recipient.  mouseLeaveSelector := selector. ^ self].  eventName == #mouseEnterDragging ifTrue:    [mouseEnterDraggingRecipient := recipient.  mouseEnterDraggingSelector := selector. ^ self].  eventName == #mouseLeaveDragging ifTrue:    [mouseLeaveDraggingRecipient := recipient.  mouseLeaveDraggingSelector := selector. ^ self].  eventName == #click ifTrue:    [clickRecipient := recipient. clickSelector := selector. ^ self].  eventName == #doubleClick ifTrue:    [doubleClickRecipient := recipient. doubleClickSelector := selector. ^ self].  eventName == #doubleClickTimeout ifTrue:    [doubleClickTimeoutRecipient := recipient. doubleClickTimeoutSelector := selector. ^ self].  eventName == #startDrag ifTrue:    [startDragRecipient := recipient. startDragSelector := selector. ^ self].  eventName == #keyStroke ifTrue:    [keyStrokeRecipient := recipient.  keyStrokeSelector := selector. ^ self].  eventName == #gesture ifTrue:    [ ^self onGestureSend: selector to: recipient ].  self error: 'Event name, ' , eventName , ' is not recognizable.'! !!EventHandler methodsFor: 'initialization' stamp: 'wiz 8/21/2005 01:44'!on: eventName send: selector to: recipient withValue: value  selector numArgs = 3 ifFalse:    [self halt: 'Warning: value parameters are passed as first of 3 arguments'].  self on: eventName send: selector to: recipient.  valueParameter := value! !!EventHandler methodsFor: 'initialization' stamp: 'nk 2/15/2004 08:59'!onGestureSend: selector to: recipient! !!EventHandler methodsFor: 'printing' stamp: 'nice 1/5/2010 15:59'!printOn: aStream   | recipients |  super printOn: aStream.  #('mouseDownSelector' 'mouseStillDownSelector' 'mouseUpSelector' 'mouseEnterSelector' 'mouseLeaveSelector' 'mouseEnterDraggingSelector' 'mouseLeaveDraggingSelector' 'doubleClickSelector' 'keyStrokeSelector')     do:       [:aName | | aVal |       (aVal := self instVarNamed: aName) notNil         ifTrue: [aStream nextPutAll: '; ' , aName , '=' , aVal]].  (recipients := self allRecipients) notEmpty     ifTrue:       [aStream nextPutAll: ' recipients: '.      recipients printOn: aStream]! !!EventHandler methodsFor: 'testing' stamp: 'ar 10/7/2000 22:56'!handlesClickOrDrag: evt  clickRecipient ifNotNil:[^true].  doubleClickRecipient ifNotNil:[^true].  startDragRecipient ifNotNil:[^true].  ^false! !!EventHandler methodsFor: 'testing' stamp: 'nk 2/15/2004 08:57'!handlesGestureStart: evt  "Does the associated morph want to handle gestures?"  ^false! !!EventHandler methodsFor: 'testing' stamp: 'ar 10/28/2000 22:17'!handlesKeyboard: evt  keyStrokeRecipient ifNotNil: [^ true].  ^ false! !!EventHandler methodsFor: 'testing' stamp: 'nk 2/15/2004 08:13'!handlesMouseDown: evt  mouseDownRecipient ifNotNil: [^ true].  mouseStillDownRecipient ifNotNil: [^ true].  mouseUpRecipient ifNotNil: [^ true].  (self handlesClickOrDrag: evt) ifTrue:[^true].  ^self handlesGestureStart: evt! !!EventHandler methodsFor: 'testing' stamp: 'ar 10/25/2000 17:33'!handlesMouseMove: evt  ^mouseMoveRecipient notNil and:[mouseMoveSelector notNil]! !!EventHandler methodsFor: 'testing'!handlesMouseOver: evt  mouseEnterRecipient ifNotNil: [^ true].  mouseLeaveRecipient ifNotNil: [^ true].  ^ false! !!EventHandler methodsFor: 'testing' stamp: 'di 9/15/1998 16:35'!handlesMouseOverDragging: evt  mouseEnterDraggingRecipient ifNotNil: [^ true].  mouseLeaveDraggingRecipient ifNotNil: [^ true].  ^ false! !!EventHandler methodsFor: 'testing' stamp: 'ar 10/22/2000 17:05'!handlesMouseStillDown: evt  ^mouseStillDownRecipient notNil and:[mouseStillDownSelector notNil]! !!HandMorph methodsFor: 'double click support' stamp: 'nk 7/26/2004 10:29'!waitForClicksOrDrag: aMorph event: evt  "Wait for mouse button and movement events, informing aMorph about events interesting to it via callbacks.  This message is typically sent to the Hand by aMorph when it first receives a mouse-down event.  The callback methods invoked on aMorph (which are passed a copy of evt) are:    #click: sent when the mouse button goes up within doubleClickTime.    #doubleClick: sent when the mouse goes up, down, and up again all within DoubleClickTime.    #doubleClickTimeout:  sent when the mouse does not have a doubleClick within DoubleClickTime.    #startDrag: sent when the mouse moves more than 10 pixels from evt's position within DoubleClickTime.  Note that mouseMove: and mouseUp: events are not sent to aMorph until it becomes the mouse focus,  which is typically done by aMorph in its click:, doubleClick:, or drag: methods."    ^self waitForClicksOrDrag: aMorph event: evt selectors: #( #click: #doubleClick: #doubleClickTimeout: #startDrag:) threshold: 10! !!Morph methodsFor: '*Polymorph-Widgets' stamp: 'gvc 4/20/2009 18:42'!boundsWithinCorners  "Changed to be more realistic..."    ^self bounds insetBy: 2! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:50'!enableDrag: aBoolean  self setProperty: #dragEnabled toValue: aBoolean! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 10/11/2000 18:18'!dragEnabled: aBool  ^self enableDrag: aBool! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 10/11/2000 18:18'!dropEnabled: aBool  ^self enableDrop: aBool! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:51'!enableDrop: aBoolean  self setProperty: #dropEnabled toValue: aBoolean! !!Morph methodsFor: 'dropping/grabbing' stamp: 'adrian_lienhard 7/19/2009 17:35'!vanishAfterSlidingTo: aPosition event: evt  | aForm aWorld startPoint endPoint |  aForm := self imageForm offset: 0@0.  aWorld := self world.  startPoint := evt hand fullBounds origin.  self delete.  aWorld displayWorld.  endPoint := aPosition.  aForm slideFrom: startPoint  to: endPoint nSteps: 12 delay: 15.! !!Morph methodsFor: 'menus' stamp: 'wiz 10/19/2006 00:35'!adhereToEdge: edgeSymbol   | edgeMessage |  (owner isNil or: [owner isHandMorph]) ifTrue: [^self].  (owner class canUnderstand:  edgeSymbol) ifFalse:  [^self].  (self class canUnderstand: ( edgeMessage := (edgeSymbol , ':') asSymbol ))     ifFalse:  [^self].    self perform: edgeMessage    withArguments: (Array with: (owner perform: edgeSymbol))! !!HandMorph methodsFor: 'drawing' stamp: 'nice 1/5/2010 15:59'!nonCachingFullDrawOn: aCanvas    "A HandMorph has unusual drawing requirements:    1. the hand itself (i.e., the cursor) appears in front of its submorphs    2. morphs being held by the hand cast a shadow on the world/morphs below  The illusion is that the hand plucks up morphs and carries them above the world."  "Note: This version does not cache an image of the morphs being held by the hand.   Thus, it is slower for complex morphs, but consumes less space."  submorphs isEmpty ifTrue: [^ self drawOn: aCanvas].  "just draw the hand itself"  aCanvas asShadowDrawingCanvas    translateBy: self shadowOffset during:[:shadowCanvas| | shadowForm |    "Note: We use a shadow form here to prevent drawing    overlapping morphs multiple times using the transparent    shadow color."    shadowForm := self shadowForm."shadowForm displayAt: shadowForm offset negated. Display forceToScreen: (0@0 extent: shadowForm extent)."    shadowCanvas paintImage: shadowForm at: shadowForm offset.  "draw shadows"  ].  "draw morphs in front of shadows"  self drawSubmorphsOn: aCanvas.  self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'private events' stamp: 'ar 3/18/2001 01:42'!sendFocusEvent: anEvent to: focusHolder clear: aBlock  "Send the event to the morph currently holding the focus"  | result w |  w := focusHolder world ifNil:[^ aBlock value].  w becomeActiveDuring:[    ActiveHand := self.    ActiveEvent := anEvent.    result := focusHolder handleFocusEvent:       (anEvent transformedBy: (focusHolder transformedFrom: self)).  ].  ^result! !!PasteUpMorph methodsFor: 'initialization' stamp: 'AlexandreBergel 7/30/2008 14:17'!becomeActiveDuring: aBlock  "Make the receiver the ActiveWorld during the evaluation of aBlock.  Note that this method does deliberately *not* use #ensure: to prevent  re-installation of the world on project switches."  | priorWorld priorHand priorEvent |  priorWorld := ActiveWorld.  priorHand := ActiveHand.  priorEvent := ActiveEvent.  ActiveWorld := self.  ActiveHand := self hands first. "default"  ActiveEvent := nil. "not in event cycle"  [aBlock value]    on: Error    do: [:ex |       ActiveWorld := priorWorld.      ActiveEvent := priorEvent.      ActiveHand := priorHand.      ex pass]! !!Morph methodsFor: 'events-processing' stamp: 'ar 10/4/2000 18:48'!handleFocusEvent: anEvent  "Handle the given event. This message is sent if the receiver currently has the focus and is therefore receiving events directly from some hand."  ^self handleEvent: anEvent! !!Morph methodsFor: 'events-processing' stamp: 'ar 9/16/2000 14:22'!handleListenEvent: anEvent  "Handle the given event. This message is sent if the receiver is a registered listener for the given event."  ^anEvent sentTo: self.! !!Morph methodsFor: 'wiw support' stamp: 'RAA 6/29/2000 10:49'!addMorphInLayer: aMorph  submorphs do: [ :each |    each == aMorph ifTrue: [^self].    aMorph morphicLayerNumber < each morphicLayerNumber ifTrue: [      ^self addMorph: aMorph inFrontOf: each    ].  ].  self addMorphBack: aMorph! !!PasteUpMorph methodsFor: 'wiw support' stamp: 'dgd 8/31/2004 16:25'!addMorphInLayer: aMorph  super addMorphInLayer: aMorph.  aMorph wantsToBeTopmost ifFalse:[self bringTopmostsToFront].! !!Morph methodsFor: 'classification'!isHandMorph  ^ false! !!HandMorph methodsFor: 'classification'!isHandMorph  ^ true! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/28/2000 10:52'!dropHighlightColor  ^ Color blue! !!Canvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/18/1999 07:33'!frameRectangle: r color: c  self frameRectangle: r width: 1 color: c.! !!HandMorph methodsFor: 'drawing' stamp: 'JW 7/12/2005 20:13'!shadowForm  "Return a 1-bit shadow of my submorphs.  Assumes submorphs is not empty"  | bnds canvas |  bnds := Rectangle merging: (submorphs collect: [:m | m fullBounds]).  canvas := (Display defaultCanvasClass extent: bnds extent depth: 1)     asShadowDrawingCanvas: Color black.  canvas translateBy: bnds topLeft negated    during:[:tempCanvas| self drawSubmorphsOn: tempCanvas].  ^ canvas form offset: bnds topLeft! !!Morph methodsFor: 'drawing' stamp: 'JW 7/12/2005 20:12'!shadowForm  "Return a form representing the 'shadow' of the receiver - e.g., all pixels that are occupied by the receiver are one, all others are zero."  | canvas |  canvas := (Display defaultCanvasClass extent: self fullBounds extent depth: 1)        asShadowDrawingCanvas: Color black. "Color black represents one for 1bpp"  canvas translateBy: bounds topLeft negated    during:[:tempCanvas| tempCanvas fullDrawMorph: self].  ^ canvas form offset: bounds topLeft! !!Morph methodsFor: 'submorphs-accessing' stamp: 'alain.plantec 6/8/2009 23:41'!allMorphsInto: aSet  "Return a set of all submorphs.  Don't forget the hidden ones. Consider only objects that are in memory (see allNonSubmorphMorphs)."   submorphs do: [:m | m allMorphsInto: aSet].  self allNonSubmorphMorphs do: [:m |       (aSet includes: m) ifFalse: ["Stop infinite recursion"        m allMorphsInto: aSet]].  aSet add: self.  ^ aSet! !!Morph methodsFor: 'submorphs-accessing' stamp: 'alain.plantec 6/8/2009 23:44'!allNonSubmorphMorphs  "Return a collection containing all morphs in this morph which are not currently in the submorph containment hierarchy"  ^ OrderedCollection new! !!Morph methodsFor: 'geniestubs' stamp: 'nk 3/11/2004 17:30'!mouseStillDownStepRate  "At what rate do I want to receive #mouseStillDown: notifications?"  ^1! !Object subclass: #MouseClickState  instanceVariableNames: 'clickClient clickState firstClickDown firstClickUp firstClickTime clickSelector dblClickSelector dblClickTime dblClickTimeoutSelector dragSelector dragThreshold'  classVariableNames: ''  poolDictionaries: ''  category: 'Morphic-Kernel'!!MouseClickState commentStamp: '<historical>' prior: 0!MouseClickState is a simple class managing the distinction between clicks, double clicks, and drag operations. It has been factored out of HandMorph due to the many instVars.Instance variables:  clickClient   <Morph>   The client wishing to receive #click:, #dblClick:, or #drag messages  clickState  <Symbol>  The internal state of handling the last event (#firstClickDown, #firstClickUp, #firstClickTimedOut)  firstClickDown  <MorphicEvent>  The #mouseDown event after which the client wished to receive #click: or similar messages  firstClickUp  <MorphicEvent>  The first mouse up event which came in before the double click time out was exceeded (it is sent if there is a timout after the first mouse up event occured)  firstClickTime  <Integer> The millisecond clock value of the first event  clickSelector   <Symbol>  The selector to use for sending #click: messages  dblClickSelector  <Symbol>  The selector to use for sending #doubleClick: messages  dblClickTime  <Integer> Timout in milliseconds for a double click operation  dragSelector  <Symbol>  The selector to use for sending #drag: messages  dragThreshold   <Integer> Threshold used for determining if a #drag: message is sent (pixels!!)!!MouseClickState methodsFor: 'as yet unclassified' stamp: 'nk 7/26/2004 09:13'!printOn: aStream  super printOn: aStream.  aStream nextPut: $[; print: clickState; nextPut: $]! !!MouseClickState methodsFor: 'event handling' stamp: 'jcg 9/21/2001 11:23'!click  clickSelector ifNotNil: [clickClient perform: clickSelector with: firstClickDown]! !!MouseClickState methodsFor: 'event handling' stamp: 'jcg 9/21/2001 11:24'!doubleClick  dblClickSelector ifNotNil: [clickClient perform: dblClickSelector with: firstClickDown]! !!MouseClickState methodsFor: 'event handling' stamp: 'jcg 9/21/2001 13:09'!doubleClickTimeout  dblClickTimeoutSelector ifNotNil: [    clickClient perform: dblClickTimeoutSelector with: firstClickDown]! !!MouseClickState methodsFor: 'event handling' stamp: 'jcg 9/21/2001 11:27'!drag: event  dragSelector ifNotNil: [clickClient perform: dragSelector with: event]! !!MouseClickState methodsFor: 'event handling' stamp: 'nk 7/26/2004 10:21'!handleEvent: evt from: aHand  "Process the given mouse event to detect a click, double-click, or drag.  Return true if the event should be processed by the sender, false if it shouldn't.  NOTE: This method heavily relies on getting *all* mouse button events."  | localEvt timedOut isDrag |  timedOut := (evt timeStamp - firstClickTime) > dblClickTime.  localEvt := evt transformedBy: (clickClient transformedFrom: aHand owner).  isDrag := (localEvt position - firstClickDown position) r > dragThreshold.  clickState == #firstClickDown ifTrue: [    "Careful here - if we had a slow cycle we may have a timedOut mouseUp event"    (timedOut and:[localEvt isMouseUp not]) ifTrue:[      "timeout before #mouseUp -> keep waiting for drag if requested"      clickState := #firstClickTimedOut.      dragSelector ifNil:[        aHand resetClickState.        self doubleClickTimeout; click "***"].      ^true].    localEvt isMouseUp ifTrue:[      (timedOut or:[dblClickSelector isNil]) ifTrue:[        self click.        aHand resetClickState.        ^true].      "Otherwise transfer to #firstClickUp"      firstClickUp := evt copy.      clickState := #firstClickUp.      "If timedOut or the client's not interested in dbl clicks get outta here"      self click.      aHand handleEvent: firstClickUp.      ^false].    isDrag ifTrue:["drag start"      self doubleClickTimeout. "***"      aHand resetClickState.      dragSelector "If no drag selector send #click instead"        ifNil: [self click]        ifNotNil: [self drag: firstClickDown].      ^true].    ^false].  clickState == #firstClickTimedOut ifTrue:[    localEvt isMouseUp ifTrue:["neither drag nor double click"      aHand resetClickState.      self doubleClickTimeout; click. "***"      ^true].    isDrag ifTrue:["drag start"      aHand resetClickState.      self doubleClickTimeout; drag: firstClickDown. "***"      ^true].    ^false].  clickState = #firstClickUp ifTrue:[    (timedOut) ifTrue:[      "timed out after mouseUp - signal timeout and pass the event"      aHand resetClickState.      self doubleClickTimeout. "***"      ^true].    localEvt isMouseDown ifTrue:["double click"      clickState := #secondClickDown.      ^false]].  clickState == #secondClickDown ifTrue: [    timedOut ifTrue:[      "timed out after second mouseDown - pass event after signaling timeout"      aHand resetClickState.      self doubleClickTimeout. "***"      ^true].    isDrag ifTrue: ["drag start"      self doubleClickTimeout. "***"      aHand resetClickState.      dragSelector "If no drag selector send #click instead"        ifNil: [self click]        ifNotNil: [self drag: firstClickDown].      ^true].    localEvt isMouseUp ifTrue: ["double click"      aHand resetClickState.      self doubleClick.      ^false]  ].  ^true! !!MouseClickState methodsFor: 'initialize' stamp: 'jcg 9/21/2001 13:08'!client: aMorph click: aClickSelector dblClick: aDblClickSelector dblClickTime: timeOut dblClickTimeout: aDblClickTimeoutSelector drag: aDragSelector threshold: aNumber event: firstClickEvent  clickClient := aMorph.  clickSelector := aClickSelector.  dblClickSelector := aDblClickSelector.  dblClickTime := timeOut.  dblClickTimeoutSelector := aDblClickTimeoutSelector.  dragSelector := aDragSelector.  dragThreshold := aNumber.  firstClickDown := firstClickEvent.  firstClickTime := firstClickEvent timeStamp.  clickState := #firstClickDown.! !!Morph methodsFor: '*Polymorph-Widgets' stamp: 'gvc 1/25/2008 17:35'!mouseWheel: evt   "Handle a mouseWheel event."! !!Morph methodsFor: 'stepping and presenter' stamp: 'ar 10/22/2000 16:36'!startStepping: aSelector at: scheduledTime arguments: args stepTime: stepTime  "Start stepping the receiver"  | w |  w := self world.  w ifNotNil: [    w startStepping: self at: scheduledTime selector: aSelector arguments: args stepTime: stepTime.    self changed].! !!Morph methodsFor: 'event handling' stamp: 'ar 10/25/2000 18:02'!mouseStillDownThreshold  "Return the number of milliseconds after which mouseStillDown: should be sent"  ^200! !!UserInputEvent methodsFor: 'initialize' stamp: 'ar 9/13/2000 15:54'!resetHandlerFields  "Reset anything that is used to cross-communicate between two eventual handlers during event dispatch"  handler := nil.  wasHandled := false.! !!MorphicEvent methodsFor: 'initialize' stamp: 'ar 10/10/2000 01:18'!resetHandlerFields  "Reset anything that is used to cross-communicate between two eventual handlers during event dispatch"! !!DropEvent methodsFor: 'initialize' stamp: 'ar 10/10/2000 01:18'!resetHandlerFields  "Reset anything that is used to cross-communicate between two eventual handlers during event dispatch"  wasHandled := false.! !!Morph methodsFor: 'event handling' stamp: 'ar 10/25/2000 18:04'!mouseMove: evt  "Handle a mouse move event. The default response is to let my eventHandler, if any, handle it."  self eventHandler ifNotNil:    [self eventHandler mouseMove: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:05'!mouseUp: evt  "Handle a mouse up event. The default response is to let my eventHandler, if any, handle it."  self eventHandler ifNotNil:    [self eventHandler mouseUp: evt fromMorph: self].! !!Morph methodsFor: 'meta-actions' stamp: 'ar 9/15/2000 20:25'!blueButtonUp: anEvent  "Ignored. Theoretically we should never get here since control is transferred to the halo on #blueButtonDown: but subclasses may implement this differently."! !!Morph methodsFor: 'stepping and presenter' stamp: 'ar 12/15/2000 00:00'!stopSteppingSelector: aSelector  "Stop getting sent the given message."  | w |  w := self world.  w ifNotNil: [w stopStepping: self selector: aSelector].! !!HandMorph methodsFor: 'focus handling' stamp: 'ar 10/6/2000 00:10'!releaseMouseFocus: aMorph  "If the given morph had the mouse focus before, release it"  self mouseFocus == aMorph ifTrue:[self releaseMouseFocus].! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:00'!mouseEnter: evt  "Handle a mouseEnter event, meaning the mouse just entered my bounds with no button pressed. The default response is to let my eventHandler, if any, handle it."  self eventHandler ifNotNil:    [self eventHandler mouseEnter: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'di 9/14/1998 07:33'!mouseEnterDragging: evt  "Handle a mouseEnterDragging event, meaning the mouse just entered my bounds with a button pressed or laden with submorphs.  The default response is to let my eventHandler, if any, handle it, or else to do nothing."  self eventHandler ifNotNil:    [^ self eventHandler mouseEnterDragging: evt fromMorph: self].! !!Morph methodsFor: 'event handling' stamp: 'tk 8/10/1998 16:01'!mouseLeave: evt  "Handle a mouseLeave event, meaning the mouse just left my bounds with no button pressed. The default response is to let my eventHandler, if any, handle it."  self eventHandler ifNotNil:    [self eventHandler mouseLeave: evt fromMorph: self].! !!KeyboardEvent methodsFor: 'keyboard' stamp: 'michael.rueger 3/11/2009 11:21'!keyCharacter  "Answer the character corresponding this keystroke. This is defined only for keystroke events."  ^Unicode value: charCode! !!Morph methodsFor: 'drawing' stamp: 'ar 11/8/2000 19:29'!expandFullBoundsForRolloverBorder: aRectangle  | delta |  delta := self valueOfProperty: #rolloverWidth ifAbsent: [10@10].  ^aRectangle expandBy: delta.! !!Morph methodsFor: '*Polymorph-Widgets' stamp: 'gvc 2/16/2009 11:15'!expandFullBoundsForDropShadow: aRectangle  "Return an expanded rectangle for an eventual drop shadow."    ^(aRectangle expandBy: self shadowOffsetRectangle)    quickMerge: aRectangle! !!Morph methodsFor: '*Polymorph-Widgets' stamp: 'gvc 2/15/2009 13:35'!shadowOffsetRectangle  "Answer a rectangle describing the offsets to the  receiver's bounds for a drop shadow."  ^self shadowOffset negated corner: self shadowOffset! !!Morph methodsFor: 'geometry' stamp: 'MarcusDenker 3/21/2010 20:15'!goHome  | box fb |  owner isNil ifTrue: [^ self].  self visible ifFalse: [^ self].  box := owner visibleClearArea.  fb := self fullBounds.  fb left < box left    ifTrue: [self left: box left - fb left + self left].  fb right > box right    ifTrue: [self right: box right - fb right + self right].  fb top < box top    ifTrue: [self top: box top - fb top + self top].  fb bottom > box bottom    ifTrue: [self bottom: box bottom - fb bottom + self bottom].! !!Morph methodsFor: 'event handling' stamp: 'nk 3/10/2004 19:48'!handlerForYellowButtonDown: anEvent   "Return the (prospective) handler for a mouse down event with the yellow button pressed.  The   handler is temporarily installed and can be used for morphs further   down the hierarchy to negotiate whether the inner or the outer   morph should finally handle the event."  (self handlesMouseDown: anEvent)    ifFalse: [ ^ nil].  "Not interested."  anEvent handler    ifNil: [^ self].  "Nobody else was interested"  "Same priority but I am innermost."  ^ self mouseDownPriority >= anEvent handler mouseDownPriority    ifFalse: [nil ]    ifTrue: [self]! !!Morph methodsFor: 'events-processing' stamp: 'StephaneDucasse 7/18/2010 16:22'!mouseDownPriority  "Return the default mouse down priority for the receiver"  ^ 0! !!Morph methodsFor: 'meta-actions' stamp: 'StephaneDucasse 2/9/2011 18:06'!handlerForBlueButtonDown: anEvent  "Return the (prospective) handler for a mouse down event. The handler is temporarily installed and can be used for morphs further down the hierarchy to negotiate whether the inner or the outer morph should finally handle the event.  Note: Halos handle blue button events themselves so we will only be asked if there is currently no halo on top of us.  Check whtehr halods are enabled (for deployment)."    "anEvent handler ifNil:[^self]."  (anEvent shiftPressed)    ifFalse:[^nil] "let outer guy have it"    ifTrue:[^self] "let me have it"! !!Morph methodsFor: 'event handling' stamp: 'di 9/14/1998 07:38'!mouseLeaveDragging: evt  "Handle a mouseLeaveLaden event, meaning the mouse just left my bounds with a button pressed or laden with submorphs. The default response is to let my eventHandler, if any, handle it; else to do nothing."  self eventHandler ifNotNil:    [self eventHandler mouseLeaveDragging: evt fromMorph: self]! !!Morph methodsFor: 'drawing' stamp: 'IgorStasenko 8/8/2011 17:21'!drawDropShadowOn: aCanvas  aCanvas     translateBy: self shadowOffset     during: [ :shadowCanvas |      (shadowCanvas isVisible: self bounds) ifTrue: [        aCanvas fillRectangle: self bounds fillStyle: self shadowColor.      ]    ].! !!Canvas methodsFor: 'testing' stamp: 'di 9/24/2000 16:10'!seesNothingOutside: aRectangle  "Return true if this canvas will not touch anything outside aRectangle"  ^ aRectangle containsRect: self clipRect! !!Morph methodsFor: 'drawing' stamp: 'ar 4/2/1999 13:13'!drawErrorOn: aCanvas  "The morph (or one of its submorphs) had an error in its drawing method."  aCanvas    frameAndFillRectangle: bounds    fillColor: Color red    borderWidth: 1    borderColor: Color yellow.  aCanvas line: bounds topLeft to: bounds bottomRight width: 1 color: Color yellow.  aCanvas line: bounds topRight to: bounds bottomLeft width: 1 color: Color yellow.! !!Morph methodsFor: 'drawing' stamp: 'IgorStasenko 7/18/2011 18:44'!drawRolloverBorderOn: aCanvas   | colorToUse offsetToUse myShadow newForm f |  colorToUse := self        valueOfProperty: #rolloverColor        ifAbsent: [Color blue alpha: 0.5].  offsetToUse := self        valueOfProperty: #rolloverWidth        ifAbsent: [10 @ 10].  self hasRolloverBorder: false.  myShadow := self shadowForm.  self hasRolloverBorder: true.  myShadow offset: 0 @ 0.  f := ColorForm extent: myShadow extent depth: 1.  myShadow displayOn: f.  f colors: {Color transparent. colorToUse}.  newForm := Form extent: offsetToUse * 2 + myShadow extent depth: 32.  (WarpBlt current toForm: newForm) sourceForm: f;     cellSize: 1;     combinationRule: 3;     copyQuad: f boundingBox innerCorners toRect: newForm boundingBox.  aCanvas    translateBy: offsetToUse negated    during: [:shadowCanvas |       (shadowCanvas asShadowDrawingCanvas: colorToUse)          paintImage: newForm at: self position]      ! !!Morph methodsFor: 'drop shadows' stamp: 'RAA 11/7/2000 15:54'!hasRolloverBorder: aBool  aBool    ifTrue:[self setProperty: #hasRolloverBorder toValue: true]    ifFalse:[self removeProperty: #hasRolloverBorder]! !!Canvas methodsFor: 'drawing' stamp: 'ar 6/17/1999 01:31'!line: pt1 to: pt2 width: w color: c  "Draw a line using the given width and color"  ^self subclassResponsibility! !!FormCanvas methodsFor: 'drawing' stamp: 'ar 2/16/2000 22:07'!line: pt1 to: pt2 width: w color: c  | offset |  offset := origin - (w // 2) asPoint.  self setFillColor: c.  port width: w; height: w;    drawFrom: (pt1 + offset) to: (pt2 + offset)! !!Morph methodsFor: 'drop shadows' stamp: 'ar 10/26/2000 18:59'!shadowColor  ^self valueOfProperty: #shadowColor ifAbsent:[Color black]! !!HandMorph methodsFor: 'double click support' stamp: 'nk 7/26/2004 10:32'!waitForClicksOrDrag: aMorph event: evt selectors: clickAndDragSelectors threshold: threshold  "Wait for mouse button and movement events, informing aMorph about events interesting to it via callbacks.  This message is typically sent to the Hand by aMorph when it first receives a mouse-down event.  The callback methods, named in clickAndDragSelectors and passed a copy of evt, are:    1   (click) sent when the mouse button goes up within doubleClickTime.    2 (doubleClick) sent when the mouse goes up, down, and up again all within DoubleClickTime.    3 (doubleClickTimeout) sent when the mouse does not have a doubleClick within DoubleClickTime.    4 (startDrag) sent when the mouse moves more than threshold pixels from evt's position within DoubleClickTime.  Note that mouseMove: and mouseUp: events are not sent to aMorph until it becomes the mouse focus,  which is typically done by aMorph in its click:, doubleClick:, or drag: methods."    mouseClickState :=     MouseClickState new      client: aMorph       click: clickAndDragSelectors first       dblClick: clickAndDragSelectors second       dblClickTime: DoubleClickTime       dblClickTimeout: clickAndDragSelectors third      drag: clickAndDragSelectors fourth       threshold: threshold       event: evt.! !!MouseEvent methodsFor: 'converting' stamp: 'marcus.denker 8/24/2008 21:41'!asMouseMove  "Convert the receiver into a mouse move"  ^MouseMoveEvent basicNew setType: #mouseMove startPoint: position endPoint: position trail: {position. position} buttons: buttons hand: source stamp: Time millisecondClockValue.! !!FormCanvas methodsFor: '*Polymorph-Widgets-override' stamp: 'gvc 10/7/2008 14:02'!infiniteFillRectangle: aRectangle fillStyle: aFillStyle  | additionalOffset rInPortTerms clippedPort targetTopLeft clipOffset ex |  "this is a bit of a kludge to get the form to be aligned where I *think* it should be.  something better is needed, but not now"  additionalOffset := 0@0.  ex := aFillStyle form extent.  rInPortTerms := (aRectangle intersect: aFillStyle boundingBox) translateBy: origin.  clippedPort := port clippedBy: rInPortTerms.  targetTopLeft := clippedPort clipRect topLeft truncateTo: ex.  clipOffset := rInPortTerms topLeft - targetTopLeft.  additionalOffset := (clipOffset \\ ex) - ex.  ^aFillStyle    displayOnPort: clippedPort    offsetBy: additionalOffset! !!HandMorph methodsFor: 'private events' stamp: 'marcus.denker 8/24/2008 21:40'!moveToEvent: anEvent  "Issue a mouse move event to make the receiver appear at the given position"  self handleEvent: (MouseMoveEvent basicNew    setType: #mouseMove     startPoint: self position     endPoint: anEvent position     trail: (Array with: self position with: anEvent position)    buttons: anEvent buttons    hand: self    stamp: anEvent timeStamp)! !!UserInputEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 15:45'!buttons  "Return the a word encoding the mouse and modifier buttons for this event."  ^ buttons! !!Morph methodsFor: 'event handling'!keyboardFocusChange: aBoolean  "The message is sent to a morph when its keyboard focus change. The given argument indicates that the receiver is gaining keyboard focus (versus losing) the keyboard focus. Morphs that accept keystrokes should change their appearance in some way when they are the current keyboard focus. This default implementation does nothing."! !Object subclass: #CombinedChar  instanceVariableNames: 'codes combined'  classVariableNames: 'Compositions Decompositions Diacriticals'  poolDictionaries: ''  category: 'Multilingual-Scanning'!!CombinedChar commentStamp: 'StephaneDucasse 3/27/2010 21:50' prior: 0!Compositions classVar is a:<Dictionary       key: firstLetter charCode       value: (Dictionary                key: diacritical charCode                 value: combined charCode)>  combined instVar is a <Character>!!CombinedChar methodsFor: 'accessing' stamp: 'StephaneDucasse 3/27/2010 21:51'!base  ^ codes first! !!CombinedChar methodsFor: 'accessing' stamp: 'StephaneDucasse 3/27/2010 21:51'!combined  ^ combined! !!CombinedChar methodsFor: 'composition' stamp: 'StephaneDucasse 4/4/2010 15:04'!add: char  | dict elem |  codes ifNil:       [ codes := Array with: char.       combined := char.       ^ true].  dict := Compositions at: combined charCode ifAbsent: [^ false].  elem := dict at: char charCode ifAbsent: [^ false].  codes := codes copyWith: char.  combined := Character leadingChar: self base leadingChar code: elem.  ^ true! !!CombinedChar methodsFor: 'composition' stamp: 'StephaneDucasse 3/27/2010 21:57'!combinesWith: char  | dict |  codes ifNil: [^false].  dict := Compositions at: combined charCode ifAbsent: [^false].  dict at: char charCode ifAbsent: [^false].  ^true! !!CombinedChar methodsFor: 'composition' stamp: 'StephaneDucasse 3/27/2010 21:56'!simpleAdd: char  | dict elem |  codes ifNil:     [codes := Array with: char.     combined := char.     ^ true].  dict := Compositions at: combined charCode ifAbsent: [^ false].  elem := dict at: char charCode ifAbsent: [^ false].  combined := Character leadingChar: self base leadingChar code: elem.  codes at: 1 put: combined.  ^ true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CombinedChar class  instanceVariableNames: ''!!CombinedChar class methodsFor: 'testing' stamp: 'michael.rueger 3/2/2009 10:13'!isCompositionCharacter: charCode  ^Compositions includesKey: charCode! !!CombinedChar class methodsFor: 'testing' stamp: 'yo 12/31/2002 19:21'!isDiacriticals: unicode  ^ Diacriticals includes: unicode.! !!CombinedChar class methodsFor: 'utility' stamp: 'HenrikSperreJohansen 6/12/2010 02:36'!parseCompositionMappingFrom: stream"  self halt.  self parseCompositionMapping"  | line fieldEnd point fieldStart compositions toNumber diacritical result |  toNumber := [:quad | ('16r', quad) asNumber].  Compositions := IdentityDictionary new: 2048.  Decompositions := IdentityDictionary new: 2048.  Diacriticals := IdentitySet new: 2048.  [(line := stream nextLine) size > 0] whileTrue: [    fieldEnd := line indexOf: $; startingAt: 1.    point := ('16r', (line copyFrom: 1 to: fieldEnd - 1)) asNumber.    2 to: 6 do: [:i |      fieldStart := fieldEnd + 1.      fieldEnd := line indexOf: $; startingAt: fieldStart.    ].    compositions := line copyFrom: fieldStart to: fieldEnd - 1.    (compositions size > 0 and: [compositions first ~= $<]) ifTrue: [      compositions := compositions substrings collect: toNumber.      compositions size > 1 ifTrue: [        diacritical := compositions first.        Diacriticals add: diacritical.        result := compositions second.        (Decompositions includesKey: point) ifTrue: [          self error: 'should not happen'.        ] ifFalse: [          Decompositions at: point put: (Array with: diacritical with: result).        ].        (Compositions includesKey: diacritical) ifTrue: [          (Compositions at: diacritical) at: result put: point.        ] ifFalse: [          Compositions at: diacritical            put: (IdentityDictionary new at: result put: point; yourself).        ].      ].    ].  ].! !BorderStyle subclass: #SimpleBorder  instanceVariableNames: 'baseColor color width'  classVariableNames: ''  poolDictionaries: ''  category: 'Morphic-Borders'!!SimpleBorder commentStamp: 'kfr 10/27/2003 10:17' prior: 0!see BorderedMorph!!SimpleBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 18:19'!baseColor  ^baseColor ifNil:[Color transparent]! !!SimpleBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 18:23'!baseColor: aColor  | cc |  cc := aColor isTransparent ifTrue:[nil] ifFalse:[aColor].  baseColor = cc ifTrue:[^self].  baseColor := cc.  self releaseCachedState.  self color: cc.! !!SimpleBorder methodsFor: 'accessing' stamp: 'gvc 1/31/2007 13:50'!bottomRightColor  "Changed from direct access to color since, if nil,  self color is transparent."  ^self color! !!SimpleBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 18:19'!color  ^color ifNil:[Color transparent]! !!SimpleBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:10'!color: aColor  color = aColor ifTrue:[^self].  color := aColor.  self releaseCachedState.! !!SimpleBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 17:52'!style  ^#simple! !!SimpleBorder methodsFor: 'accessing' stamp: 'gvc 1/31/2007 13:50'!topLeftColor  "Changed from direct access to color since, if nil,  self color is transparent."  ^self color! !!SimpleBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:35'!width  ^width! !!SimpleBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:10'!width: aNumber  width = aNumber ifTrue:[^self].  width := aNumber truncated max: (width isPoint ifTrue:[0@0] ifFalse:[0]).  self releaseCachedState.! !!SimpleBorder methodsFor: 'drawing' stamp: 'aoy 2/17/2003 01:14'!drawLineFrom: startPoint to: stopPoint on: aCanvas   | lineColor |  lineColor := (stopPoint truncated quadrantOf: startPoint truncated) > 2         ifTrue: [self topLeftColor]        ifFalse: [self bottomRightColor].  aCanvas     line: startPoint    to: stopPoint     width: self width    color: lineColor! !!SimpleBorder methodsFor: 'drawing' stamp: 'ar 8/25/2001 16:27'!frameRectangle: aRectangle on: aCanvas  aCanvas frameAndFillRectangle: aRectangle    fillColor: Color transparent    borderWidth: self width    topLeftColor: self topLeftColor    bottomRightColor: self bottomRightColor.! !!SimpleBorder methodsFor: 'initialize' stamp: 'sd 11/25/2008 14:47'!initialize  super initialize.  color := Color transparent  ! !!BorderStyle methodsFor: 'initialize' stamp: 'ar 8/25/2001 16:06'!releaseCachedState  "Release any associated cached state"! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 2/16/2000 22:07'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor  | w h rect |  "First use quick code for top and left borders and fill"  self frameAndFillRectangle: r    fillColor: fillColor    borderWidth: borderWidth    borderColor: topLeftColor.  "Now use slow code for bevelled bottom and right borders"  bottomRightColor isTransparent ifFalse: [    borderWidth isNumber      ifTrue: [w := h := borderWidth]      ifFalse: [w := borderWidth x.   h := borderWidth y].    rect := r translateBy: origin.    self setFillColor: bottomRightColor.    port        frameRectRight: rect width: w;       frameRectBottom: rect height: h].! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/17/2000 01:08'!frameRectRight: rect width: w  width := 1.  height := rect height - 1.  destX := rect right - 1.  destY := rect top + 1.  1 to: w do: [:i |    self copyBits.    destX := destX - 1.    destY := destY + 1.    height := height - 2].! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/17/2000 01:08'!frameRectBottom: rect height: h  destX := rect left + 1.  destY := rect bottom - 1.  width := rect width - 2.  height := 1.  1 to: h do: [:i |    self copyBits.    destX := destX + 1.    destY := destY - 1.    width := width - 2].! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 7/27/1999 10:46'!hands  ^ worldState hands! !!UserInputEvent methodsFor: 'modifier state' stamp: 'ar 9/13/2000 15:44'!shiftPressed  "Answer true if the shift key on the keyboard was being held down when this event occurred."  ^ buttons anyMask: 8! !'From Pharo1.4a of ''16 June 2011'' [Latest update: #14382] on 9 March 2012 at 10:01:30 pm'!!MorphicUIManager methodsFor: 'ui process' stamp: 'MarcusDenker 12/2/2011 16:35'!spawnNewProcess  UIProcess := [    [World doOneCycle.  Processor yield.  false] whileFalse: [].  ] newProcess priority: Processor userSchedulingPriority.  UIProcess resume! !'From Pharo1.4a of ''16 June 2011'' [Latest update: #14382] on 9 March 2012 at 10:01:37 pm'!!MorphicUIManager methodsFor: 'ui process' stamp: 'MarcusDenker 12/2/2011 16:28'!uiProcess  " Answer the currently active UI process for morphic world.  Client should check explicitly if #uiProcess answers nil or not (see other implementations)"  ^ UIProcess! !BitBlt class removeSelector: #benchmark.BitBlt class removeSelector: #benchmark2.BitBlt class removeSelector: #benchmark3.ThreadSafeTranscript removeSelector: #openAsMorphLabel:.ThreadSafeTranscript removeSelector: #open.String removeSelector: #displayOn:at:textColor:.String removeSelector: #displayOn:at:."MailMessage removeSelector: #viewImageInBody.""MailMessage removeSelector: #viewBody.""ImageSegment removeSelector: #findRogueRootsPrep."TextStyle class removeSelector: #replaceStyle:with:.TextStyle class removeSelector: #looseFontsFromFamily:. TextStyle class removeSelector: #replaceFontsIn:with:.HandMorph initialize!Morph initialize!ShortRunArray initialize!WorldState initialize!ShortIntegerArray initialize!| accuny prj world info dif difDict lines dict unimplemented sends unsent newUnimp |[UIManager default progressBarEnabled: true."CommnadLine initialize."TextStyle initialize.HandMorph initialize.Morph initialize.ShortIntegerArray initialize.ShortRunArray initialize.WorldState initialize.Cursor initTarget.Cursor initialize.DataStream initialize.UIManager default: MorphicUIManager new."BalloonMorph setBalloonColorTo: Color yellow.""prj := Project new.Project classPool at: #CurrentProject put: prj."world := PasteUpMorph new.world instVarNamed: #worldState put: WorldState new.world world addHand: HandMorph new.world activeHand.Smalltalk at: #World put: world.Smalltalk at: #ActiveWorld put: world.Smalltalk at: #ActiveHand put: world activeHand.Smalltalk at: #ActiveEvent put: nil.world viewBox: Display boundingBox.Sensor flushAllButDandDEvents.world world handsDo: [:h | h initForEvents].world borderWidth: 0.MorphicUIManager new spawnNewProcess.Display newDepth: 32.world displayWorldSafely.world displayWorldSafely.UIManager default uiProcess resume.Smalltalk cleanUpAfterMorphicInitialization.Display newDepth: 32.(world instVarNamed: #worldState) canvas: nil.UIManager default restoreDisplay.Morph new openInWorld.info := FileStream forceNewFileNamed: 'info.txt'.info nextPutAll: oldUndec size asString; cr; cr.info nextPutAll: Undeclared size asString; cr; cr.dif := Undeclared keys copyWithoutAll: oldUndec keys.difDict := Dictionary new.dif do: [:k | difDict at: k put: (Undeclared at: k)].info nextPutAll: difDict size asString; cr; cr.dict := IdentityDictionary new.Smalltalk allClassesAndTraits do: [:c |  c localSelectors do: [:sel |     dict at: (c compiledMethodAt: sel) put: (c -> sel)].  c isTrait ifFalse: [    c class localSelectors do: [:sel |       dict at: (c class compiledMethodAt: sel) put: (c class -> sel)]]].lines := SortedCollection new.difDict associations do: [:assoc |  info nextPutAll: assoc key; cr.  [  ((assoc pointersTo) select: [:ref | ref class = CompiledMethod]) do: [:cm |     info nextPutAll: ' - ', (dict at: cm ifAbsent: ['method not found']) asString; cr.     lines add: (dict at: cm) key asString, ' >> ', (dict at: cm) value asString, ' (', assoc key asString, ')'. ]   ] ifError: [info nextPutAll: '--error--'; cr.]].info cr; nextPutAll: 'new Undeclared sorted by class:'; cr.     lines do: [:l | info nextPutAll: l asString; cr.].info cr.info nextPutAll: 'Obsolete:'; cr.info nextPutAll: SystemNavigation default obsoleteClasses asString; cr; cr.newUnimp := (SystemNavigation default allUnimplementedCalls) copyWithoutAll: oldUnimp.info nextPutAll: 'new Unimplemented calls size:'; space.info nextPutAll: newUnimp size asString.info cr; cr.info nextPutAll: 'Unimplemented calls:'; cr; cr.unimplemented := newUnimp asSortedCollection.sends := OrderedCollection new.unimplemented do: [:call |  | pos |  pos := (call findString:  ' calls: ').  ((call allButFirst: (pos + 7)) findTokens: ' ') do: [:send |    sends add: (send asString, ' calledBy: ', (call first: pos))].  info nextPutAll: call asString; cr.].info cr.sends asSortedCollection do: [:call |  info nextPutAll: call asString; cr.].  "unsent := SystemNavigation default allUnsentMessages.info cr; nextPutAll: 'Unsent messages size: '; nextPutAll: unsent size asString; cr; cr.info cr; nextPutAll: 'Unsent messages:'; cr.unsent asSortedCollection do: [:message | info nextPutAll: message; cr. ]."info cr; nextPutAll: 'finished...'.info close."Smalltalk snapshot: true andQuit: true."WorldState addDeferredUIMessage: [World restoreMorphicDisplay].Smalltalk saveImageInNewContext.] ifError: [:e |  | rep |  rep := FileStream forceNewFileNamed: 'PharoDebug.log'.  rep nextPutAll: 'info.st'; cr.  rep nextPutAll: 'Error:'; cr.  rep nextPutAll: e asString; cr.  rep nextPutAll: thisContext stack size asString.  thisContext stack copy withIndexDo: [:stck :i |    [rep nextPutAll: i asString; space; nextPutAll: stck asString; cr] ifError: []].  rep close.   Smalltalk quitPrimitive].