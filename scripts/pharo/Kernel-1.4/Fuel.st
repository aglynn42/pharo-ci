SystemOrganization addCategory: #'Fuel-Collections'!SystemOrganization addCategory: #'Fuel-Core'!SystemOrganization addCategory: #'Fuel-Core-Clusters'!SystemOrganization addCategory: #'Fuel-Core-Clusters-InternalMetalevel'!SystemOrganization addCategory: #'Fuel-Core-Clusters-Optionals'!SystemOrganization addCategory: #'Fuel-Core-Errors'!SystemOrganization addCategory: #'Fuel-Core-Mappers'!SystemOrganization addCategory: #'Fuel-Streams'!SystemOrganization addCategory: #'Fuel-Utilities'!!ByteSymbol methodsFor: '*Fuel' stamp: 'MartinDias 8/6/2011 19:15'!fuelAccept: aVisitor	^aVisitor visitSymbol: self! !!Set methodsFor: '*Fuel' stamp: 'MartinDias 9/9/2011 14:46'!addIfNotPresent: anObject ifPresentDo: aBlock	"Include anObject as one of the receiver's elements and then value aBlock, but only if there	is no such element already. Anwser anObject."	| index |	index := self scanFor: anObject.	(array at: index) 		ifNil: [self atNewIndex: index put: anObject asSetElement]		ifNotNil: [ aBlock value ].	^ anObject	"Sets in Pharo 1.2 can't' contain nil, so this implementation is wrong in that version. This is the right one (in Pharo 1.2):	| index |	anObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].	index := self findElementOrNil: anObject.	(array at: index) 		ifNil: [ self atNewIndex: index put: anObject ]		ifNotNil: [ aBlock value ].	^ anObject"! !!CompiledMethod methodsFor: '*Fuel' stamp: 'MartinDias 8/6/2011 19:13'!fuelAccept: aVisitor	^aVisitor visitCompiledMethod: self! !!CompiledMethod methodsFor: '*Fuel' stamp: 'MartinDias 10/22/2010 12:56'!isNamedPrimitive 	^ self primitive = 117! !!Character methodsFor: '*Fuel' stamp: 'MartinDias 8/6/2011 19:17'!fuelAccept: aVisitor	^aVisitor visitCharacter: self! !!ByteArray methodsFor: '*Fuel' stamp: 'MartinDias 8/6/2011 19:12'!fuelAccept: aVisitor	^aVisitor visitBytesObject: self! !!TimeStamp methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 9/2/2011 15:39'!fuelAccept: aVisitor	^ aVisitor visitFixedObject: self! !Error subclass: #FLBadSignature	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Errors'!!FLBadSignature commentStamp: 'MarianoMartinezPeck 10/23/2011 14:32' prior: 0!I represent an error produced during materialization when the serialized signature doesn't match the materializer's signature (accessible via FLMaterializer>>signature). A signature is a byte prefix that should prefix a well-serialized stream.!!FLBadSignature class methodsFor: 'signaling' stamp: 'MarianoMartinezPeck 10/23/2011 14:23'!signalCurrentSignature: currentSignature streamSignature: streamSignature	self signal: 'Current signature is ', currentSignature asString, ' but the signature in the stream is ', streamSignature asString! !Error subclass: #FLBadVersion	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Errors'!!FLBadVersion commentStamp: 'MarianoMartinezPeck 10/23/2011 14:33' prior: 0!I represent an error produced during materialization when the serialized version doesn't match the materializer's version (accessible via FLMaterializer>>version). A version is encoded in 16 bits and is enconded heading the serialized stream, after the signature.!!FLBadVersion class methodsFor: 'signaling' stamp: 'MarianoMartinezPeck 10/23/2011 14:20'!signalCurrentVersion: currentVersion streamVersion: streamVersion	^ self signal: 'Current version is ', currentVersion asString, ' but the version in the stream is ', streamVersion asString ! !Error subclass: #FLClassNotFound	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Errors'!!FLClassNotFound commentStamp: 'MarianoMartinezPeck 10/23/2011 14:34' prior: 0!I represent an error produced during materialization when a serialized class or trait name doesn't exist.!!FLClassNotFound class methodsFor: 'signaling' stamp: 'MartinDias 10/24/2011 17:56'!signalWithName: className	^ self signal: 'Class ', className printString, ' not found at materialization'! !Error subclass: #FLGlobalNotFound	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Errors'!!FLGlobalNotFound commentStamp: 'MarianoMartinezPeck 10/23/2011 14:35' prior: 0!I represent an error produced during materialization when a serialized global name doesn't exist (at Slammtalk globals).!!FLGlobalNotFound class methodsFor: 'signaling' stamp: 'MartinDias 10/24/2011 17:56'!signalWithName: aName	^ self signal: 'Global ', aName printString, ' not found at materialization'! !!WriteStream methodsFor: '*Fuel' stamp: 'MartinDias 8/13/2011 14:28'!nextBytesPutAll: aCollection	"Append the bytes of aCollection to the sequence of bytes accessible 	by the receiver. Answer aCollection."  	| newEnd | 	collection class instSpec == aCollection class instSpec ifFalse: 		[^ super nextPutAll: aCollection ].  	newEnd := position + aCollection size. 	newEnd > writeLimit ifTrue: 		[self growTo: newEnd + 10].  	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: 1. 	position := newEnd.		^ aCollection! !!Behavior methodsFor: '*Fuel' stamp: 'MartinDias 6/13/2011 01:04'!fuelIgnoredInstanceVariableNames	"Indicates which variables have to be ignored during serialization."	^#()! !!StandardFileStream methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 9/6/2011 12:42'!fuelNextWordsInto: aWordObject	"This method is the same as nextWordsInto: but the restoreEndianness is only done if needed"	self next: aWordObject basicSize into: aWordObject startingAt: 1.	^ aWordObject! !!StandardFileStream methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 10/10/2011 12:24'!nextBytesPutAll: aCollection	self nextPutAll: aCollection! !!UndefinedObject methodsFor: '*Fuel' stamp: 'MartinDias 8/6/2011 19:42'!fuelAccept: aVisitor	^aVisitor visitUndefinedObject: self! !!Association methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 9/9/2011 18:52'!fuelAccept: aVisitor	^ aVisitor visitAssociation: self! !!PositionableStream methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 9/6/2011 17:02'!fuelNextWordsInto: aWordObject 	"This method is the same as nextWordsInto: but the restoreEndianness is only done if needed"	| blt pos source byteSize |	byteSize := aWordObject byteSize.	"is the test on collection basicSize \\ 4 necessary?"		((self position bitAnd: 3) = 0 and: [ (collection basicSize bitAnd: 3) = 0])		ifTrue: [source := collection.			pos := self position.			self skip: byteSize]		ifFalse: ["forced to copy it into a buffer"			source := self next: byteSize.			pos := 0].	"Now use BitBlt to copy the bytes to the bitmap."	blt := (BitBlt current				toForm: (Form new hackBits: aWordObject))				sourceForm: (Form new hackBits: source).	blt combinationRule: Form over. "store"	blt sourceX: 0;		 sourceY: pos // 4;		 height: byteSize // 4;		 width: 4.	blt destX: 0;		 destY: 0.	blt copyBits.	^ aWordObject 	! !!PositionableStream methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 10/6/2011 21:16'!int64	"Answer the next signed, 32-bit integer from this (binary) stream."	"Details: As a fast check for negative number, check the high bit of the first digit"	| n firstDigit |	n := firstDigit := self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	firstDigit >= 128 ifTrue: [n := -16r10000000000000000 + n].  "decode negative 64-bit integer"	^ n! !!PositionableStream methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 10/6/2011 21:16'!int8	| val |	val := self next.	val >= 128 ifTrue: [^(256 - val) negated].	^val! !!PositionableStream methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 10/6/2011 21:17'!uint64	"Answer the next unsigned, 64-bit integer from this (binary) stream."	| n |	n := self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	^ n! !!PositionableStream methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 10/6/2011 20:31'!uint64: anInteger	"Store the given unsigned, 64-bit integer on this (binary) stream."	(anInteger < 0) | (anInteger >= 16r10000000000000000)		ifTrue: [self error: 'outside unsigned 64-bit integer range'].			self nextPut: (anInteger digitAt: 8).	self nextPut: (anInteger digitAt: 7).	self nextPut: (anInteger digitAt: 6).	self nextPut: (anInteger digitAt: 5).	self nextPut: (anInteger digitAt: 4).	self nextPut: (anInteger digitAt: 3).	self nextPut: (anInteger digitAt: 2).	self nextPut: (anInteger digitAt: 1).! !!PositionableStream methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 10/6/2011 21:15'!uint8	"Answer the next unsigned, 16-bit integer from this (binary) stream."	^ self next.! !!Collection methodsFor: '*Fuel' stamp: 'MartinDias 5/19/2011 23:41'!addIfNotPresent: anObject ifPresentDo: aBlock	"Include anObject as one of the receiver's elements and then value aBlock, but only if there	is no such element already. Anwser anObject."	(self includes: anObject) 		ifFalse: [ self add: anObject ]		ifTrue: [ aBlock value ].	^ anObject! !!SystemDictionary methodsFor: '*Fuel' stamp: 'MartinDias 8/6/2011 19:40'!fuelAccept: aVisitor	^aVisitor visitSystemDictionary: self! !!Boolean methodsFor: '*Fuel' stamp: 'MartinDias 8/6/2011 19:35'!fuelAccept: aVisitor	^aVisitor visitBoolean: self! !!Rectangle methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 9/8/2011 22:55'!fuelAccept: aVisitor	^ aVisitor visitRectangle: self! !!Quadrangle methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 9/8/2011 22:55'!fuelAccept: aVisitor	^ aVisitor visitFixedObject: self! !!Trait methodsFor: '*Fuel' stamp: 'MartinDias 7/1/2011 04:32'!basicEnvironment	^self environment ! !!Trait methodsFor: '*Fuel' stamp: 'MartinDias 8/6/2011 19:33'!fuelAccept: aVisitor	^aVisitor visitTrait: self! !!Float methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 9/6/2011 18:15'!fuelAccept: aVisitor	^aVisitor visitFloat: self! !!Metaclass methodsFor: '*Fuel' stamp: 'MartinDias 8/6/2011 19:26'!fuelAccept: aVisitor	^aVisitor visitMetaclass: self! !!ContextPart class methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 5/22/2011 23:44'!newFromFrameSize: aFrameSize		^ super basicNew: aFrameSize! !Stream subclass: #FLBufferedWriteStream	instanceVariableNames: 'stream buffer position streamRespondsToNextPutAllStartingAt'	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Streams'!!FLBufferedWriteStream commentStamp: 'MarianoMartinezPeck 6/5/2011 12:41' prior: 0!FLBufferedWriteStream is a buffered write stream we use for Fuel serialization. Instead of directly using the stream provided to FLSerializer at creation time by the user, we create an instance of FLBufferedWriteStream for that stream.MultiByteFileStream has no real buffer and goes to disk too frequently. With FLBufferedWriteStream we keep stuff in a cache and only go to disk when this is full.The way of using it is jut FLBufferedWriteStream on: aWriteStream. For example:FLBufferedWriteStream on: (FileDirectory default forceNewFileNamed:  'TestFile') binaryWith the message #sizeBuffer: you can set the size of the buffer.Make sure to always send #flush or #close when you're done, otherwise the last buffer might not yet have been written.!!FLBufferedWriteStream class methodsFor: 'instance creation' stamp: 'MarianoMartinezPeck 5/17/2011 23:32'!on: writeStream	^ self basicNew		on: writeStream;		yourself! !!FLBufferedWriteStream class methodsFor: 'convenience' stamp: 'MarianoMartinezPeck 5/17/2011 23:32'!on: writeStream do: block	"Execute block with as argument a ZnBufferedWriteStream on writeStream,	making sure #flush is called at the end."		| bufferedWriteStream |	bufferedWriteStream := self on: writeStream.	block value: bufferedWriteStream.	bufferedWriteStream flush! !!FLBufferedWriteStream methodsFor: 'private' stamp: 'MarianoMartinezPeck 5/17/2011 23:32'!buffer	buffer isNil 		ifTrue: [ self sizeBuffer: self defaultBufferSize ].	^ buffer! !!FLBufferedWriteStream methodsFor: 'accessing' stamp: 'MarianoMartinezPeck 9/23/2011 22:34'!bufferFreeSize	^ buffer size - position! !!FLBufferedWriteStream methodsFor: 'initialize-release' stamp: 'MarianoMartinezPeck 5/17/2011 23:32'!close	self flushBuffer.	stream close! !!FLBufferedWriteStream methodsFor: 'private' stamp: 'MarianoMartinezPeck 9/8/2011 15:35'!copyWordObjectToBuffer: aWordObject	| blt |		blt := (BitBlt current				toForm: (Form new hackBits: self buffer))				sourceForm: (Form new hackBits: aWordObject).	blt combinationRule: Form over. "store"	blt sourceX: 0;		 sourceY: 0;		 height: aWordObject byteSize // 4;		 width: 4.	blt destX: 0;		 destY:  position // 4 .	blt copyBits.! !!FLBufferedWriteStream methodsFor: 'accessing' stamp: 'MarianoMartinezPeck 5/17/2011 23:32'!defaultBufferSize	^ 8192 "2 raisedTo: 13  "	! !!FLBufferedWriteStream methodsFor: 'accessing' stamp: 'MarianoMartinezPeck 5/17/2011 23:32'!flush	self flushBuffer.	stream flush! !!FLBufferedWriteStream methodsFor: 'private' stamp: 'MarianoMartinezPeck 10/22/2011 12:46'!flushBuffer	position = 0 ifTrue: [ ^ self ].	position = buffer size		ifTrue: [			stream nextPutAll: buffer ]		ifFalse: [			streamRespondsToNextPutAllStartingAt				ifTrue: [ stream next: position putAll: buffer startingAt: 1 ]				ifFalse: [ stream nextPutAll: (buffer copyFrom: 1 to: position) ] ].	position := 0! !!FLBufferedWriteStream methodsFor: 'private' stamp: 'MarianoMartinezPeck 9/23/2011 22:35'!flushBufferIfFull	position = buffer size 		ifTrue: [ self flushBuffer ]! !!FLBufferedWriteStream methodsFor: 'initialize-release' stamp: 'MarianoMartinezPeck 10/22/2011 12:46'!initializeStream: aWriteStream	stream := aWriteStream.	"This is ugly, but it is an optimization for #flushBuffer"	streamRespondsToNextPutAllStartingAt := (stream respondsTo: #next:putAll:startingAt:).! !!FLBufferedWriteStream methodsFor: 'reading' stamp: 'MarianoMartinezPeck 10/6/2011 20:50'!int16	"Answer the next signed, 16-bit integer from this (binary) stream."	| n |	n := self next.	n := (n bitShift: 8) + (self next).	n >= 16r8000 ifTrue: [n := n - 16r10000].	^ n! !!FLBufferedWriteStream methodsFor: 'reading' stamp: 'MarianoMartinezPeck 9/9/2011 17:15'!int32	"Read a 32-bit signed integer from the next 4 bytes"	| s |	s := 0.	1 to: 4 do: [:i | s := (s bitShift: 8) + self next].	(s bitAnd: 16r80000000) = 0		ifTrue: [^ s]		ifFalse: [^ -1 - s bitInvert32]! !!FLBufferedWriteStream methodsFor: 'writing' stamp: 'mariano 10/6/2011 11:39'!int32: int32	"Write a signed integer to the next 4 bytes"	| pos |	pos := int32 < 0		ifTrue: [(0-int32) bitInvert32 + 1]		ifFalse: [int32].	1 to: 4 do: [:i | self nextPut: (pos digitAt: 5-i)].	^ int32! !!FLBufferedWriteStream methodsFor: 'reading' stamp: 'MarianoMartinezPeck 10/6/2011 20:51'!int64	"Answer the next signed, 32-bit integer from this (binary) stream."	"Details: As a fast check for negative number, check the high bit of the first digit"	| n firstDigit |	n := firstDigit := self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	firstDigit >= 128 ifTrue: [n := -16r10000000000000000 + n].  "decode negative 64-bit integer"	^ n! !!FLBufferedWriteStream methodsFor: 'writing' stamp: 'MarianoMartinezPeck 10/6/2011 20:35'!int64: anInteger	"Store the given signed, 64-bit integer on this (binary) stream."	| n |	(anInteger < -16r8000000000000000) | (anInteger >= 16r8000000000000000)		ifTrue: [self error: 'outside 64-bit integer range'].	anInteger < 0		ifTrue: [n := 16r10000000000000000 + anInteger]		ifFalse: [n := anInteger].	self nextPut: (n digitAt: 8).	self nextPut: (n digitAt: 7).	self nextPut: (n digitAt: 6).	self nextPut: (n digitAt: 5).	self nextPut: (n digitAt: 4).	self nextPut: (n digitAt: 3).	self nextPut: (n digitAt: 2).	self nextPut: (n digitAt: 1).! !!FLBufferedWriteStream methodsFor: 'reading' stamp: 'MarianoMartinezPeck 10/22/2011 12:17'!int8	| val |	val := self next.	val >= 128 ifTrue: [^(256 - val) negated].	^val! !!FLBufferedWriteStream methodsFor: 'writing' stamp: 'MarianoMartinezPeck 10/9/2011 22:47'!nextBytesPutAll: collection	self flushBufferIfFull.	collection size <= self bufferFreeSize		ifTrue: [			self buffer replaceFrom: position + 1 to: position + collection size with: collection.			position := position + collection size ]		ifFalse: [			self flushBuffer.			collection size > (self buffer size / 2)				ifTrue: [ stream nextBytesPutAll: collection ]				ifFalse: [ self nextBytesPutAll: collection ] ]! !!FLBufferedWriteStream methodsFor: 'writing' stamp: 'MarianoMartinezPeck 10/6/2011 11:49'!nextNumber: n put: v 	"Append to the receiver the argument, v, which is a positive 	SmallInteger or a LargePositiveInteger, as the next n bytes.	Possibly pad with leading zeros."	1 to: n do: [:i | self nextPut: (v digitAt: n+1-i)].	^ v! !!FLBufferedWriteStream methodsFor: 'writing' stamp: 'MarianoMartinezPeck 5/17/2011 23:32'!nextPut: object	self flushBufferIfFull.	position := position + 1.	self buffer at: position put: object! !!FLBufferedWriteStream methodsFor: 'writing' stamp: 'MarianoMartinezPeck 9/23/2011 22:35'!nextPutAll: collection	self flushBufferIfFull.	collection size <= self bufferFreeSize		ifTrue: [			self buffer replaceFrom: position + 1 to: position + collection size with: collection.			position := position + collection size ]		ifFalse: [			self flushBuffer.			collection size > (self buffer size / 2)				ifTrue: [ stream nextPutAll: collection ]				ifFalse: [ self nextPutAll: collection ] ]! !!FLBufferedWriteStream methodsFor: 'writing' stamp: 'MarianoMartinezPeck 10/10/2011 12:33'!nextStringPut: s 	"Append the string, s, to the receiver.  Only used by DataStream.  Max size of 64*256*256*256."	| length |	(length := s size) < 192		ifTrue: [self nextPut: length]		ifFalse: 			[self nextPut: (length digitAt: 4)+192.			self nextPut: (length digitAt: 3).			self nextPut: (length digitAt: 2).			self nextPut: (length digitAt: 1)].	self nextBytesPutAll: s .	^s! !!FLBufferedWriteStream methodsFor: 'writing' stamp: 'MarianoMartinezPeck 9/23/2011 22:35'!nextWordsPut: aWordObject	| byteSize |	byteSize := aWordObject byteSize.	"Ensure we are at bigger than the words added, with size next power-of-two"	byteSize > buffer size ifTrue: [ self sizeBuffer: 1 << ( byteSize highBit )].		"BitBlt needs word-aligned access of object. Flushing the buffer is a very good idea because after the position will be zero, which is word aligned.  Word objects always have a full number of words of data to write. (otherwise they'd be variableByte objects or something :P) So as long as the size you write per instance also takes N words, the position will always be aligned (except when writing the first object of a cluster) . After that, we flush when an object larger than current buffer is encountered (statistically rare), or if the buffer is full (which we do anyways).	Finally, we also need enough free space in the buffer"	((position bitAnd: 3) = 0 and: [byteSize < self bufferFreeSize])      	ifFalse: [self flushBuffer].	self copyWordObjectToBuffer: aWordObject.	position := position +  byteSize.! !!FLBufferedWriteStream methodsFor: 'initialize-release' stamp: 'MarianoMartinezPeck 10/22/2011 12:46'!on: writeStream	self initializeStream: writeStream.	position := 0! !!FLBufferedWriteStream methodsFor: 'printing' stamp: 'MarianoMartinezPeck 5/17/2011 23:32'!printOn: aStream	aStream 		nextPutAll: 'a '; 		nextPutAll: self class name! !!FLBufferedWriteStream methodsFor: 'accessing' stamp: 'MarianoMartinezPeck 9/8/2011 15:55'!sizeBuffer: size    buffer ifNotNil: [self flushBuffer].    buffer := (stream isBinary ifTrue: [ ByteArray ] ifFalse: [ String ]) new: size.! !!FLBufferedWriteStream methodsFor: 'accessing' stamp: 'MarianoMartinezPeck 5/17/2011 23:32'!space	self nextPut: Character space! !!FLBufferedWriteStream methodsFor: 'accessing' stamp: 'MartinDias 9/27/2011 20:49'!target	^ stream! !!FLBufferedWriteStream methodsFor: 'reading' stamp: 'sfdas 9/23/2011 20:46'!uint16	"Answer the next unsigned, 16-bit integer from this (binary) stream."	| n |	n := self next.	n := (n bitShift: 8) + (self next).	^ n! !!FLBufferedWriteStream methodsFor: 'writing' stamp: 'mariano 10/6/2011 11:39'!uint16: anInteger	"Append to the receiver an Integer as the next two bytes."	self nextPut: (anInteger bitShift: -8).	self nextPut: (anInteger bitAnd: 255).	^anInteger! !!FLBufferedWriteStream methodsFor: 'reading' stamp: 'MarianoMartinezPeck 9/9/2011 17:16'!uint32	"Read a 32-bit signed integer from the next 4 bytes"	| s |	s := 0.	1 to: 4 do: [:i | s := (s bitShift: 8) + self next].	^ s! !!FLBufferedWriteStream methodsFor: 'writing' stamp: 'mariano 10/6/2011 11:39'!uint32: anInteger	"Append to the receiver an Integer as the next 4 bytes."	self nextPut: (anInteger bitShift: -24);		nextPut: ((anInteger bitShift: -16) bitAnd: 255);		nextPut: ((anInteger bitShift: -8) bitAnd: 255);		nextPut: (anInteger bitAnd: 255).	^ anInteger! !!FLBufferedWriteStream methodsFor: 'reading' stamp: 'MarianoMartinezPeck 10/6/2011 20:53'!uint64	"Answer the next unsigned, 64-bit integer from this (binary) stream."	| n |	n := self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	n := (n bitShift: 8) + self next.	^ n! !!FLBufferedWriteStream methodsFor: 'writing' stamp: 'MarianoMartinezPeck 10/6/2011 20:31'!uint64: anInteger	"Store the given unsigned, 64-bit integer on this (binary) stream."	(anInteger < 0) | (anInteger >= 16r10000000000000000)		ifTrue: [self error: 'outside unsigned 64-bit integer range'].			self nextPut: (anInteger digitAt: 8).	self nextPut: (anInteger digitAt: 7).	self nextPut: (anInteger digitAt: 6).	self nextPut: (anInteger digitAt: 5).	self nextPut: (anInteger digitAt: 4).	self nextPut: (anInteger digitAt: 3).	self nextPut: (anInteger digitAt: 2).	self nextPut: (anInteger digitAt: 1).! !!FLBufferedWriteStream methodsFor: 'reading' stamp: 'MarianoMartinezPeck 10/6/2011 20:52'!uint8	"Answer the next unsigned, 16-bit integer from this (binary) stream."	^ self next.! !!Stream methodsFor: '*Fuel' stamp: 'MartinDias 8/13/2011 14:29'!nextBytesPutAll: aCollection	"Append the bytes of aCollection to the sequence of bytes accessible 	by the receiver. Answer aCollection."	^self nextPutAll: aCollection! !!ClassTrait methodsFor: '*Fuel' stamp: 'MartinDias 8/6/2011 19:23'!fuelAccept: aVisitor	^aVisitor visitClassTrait: self! !!Bitmap methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 9/8/2011 17:45'!fuelAccept: aVisitor	^aVisitor visitBitmap: self! !!Array methodsFor: '*Fuel' stamp: 'MartinDias 8/15/2011 22:52'!fuelAccept: aVisitor	^aVisitor visitVariableObject: self! !!MethodContext methodsFor: '*Fuel' stamp: 'MartinDias 8/6/2011 19:28'!fuelAccept: aVisitor	^aVisitor visitMethodContext: self! !!MethodContext methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 5/22/2011 22:11'!method: aMethod	method := aMethod ! !!Time methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 9/2/2011 10:32'!fuelAccept: aVisitor	^ aVisitor visitTime: self! !!Duration methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 9/2/2011 10:31'!fuelAccept: aVisitor	^ aVisitor visitDuration: self! !!SmallInteger methodsFor: '*Fuel' stamp: 'MartinDias 8/6/2011 19:31'!fuelAccept: aVisitor	^aVisitor visitSmallInteger: self! !!Date class methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 9/2/2011 10:28'!fuelFromjulianDayNumber: aJulianDayNumber	^ self starting: (DateAndTime julianDayNumber: aJulianDayNumber) midnight duration: (Duration days: 1)! !!Date methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 9/2/2011 10:31'!fuelAccept: aVisitor	^ aVisitor visitDate: self! !!HashedCollection methodsFor: '*Fuel' stamp: 'MartinDias 6/13/2011 02:43'!fuelAfterMaterialization	self rehash! !!Point methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 9/8/2011 21:42'!fuelAccept: aVisitor	^ aVisitor visitPoint: self! !!DateAndTime class methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 9/2/2011 15:14'!fuelFrom: julianDayNumber nanoSecond: nanoSeconds seconds: seconds offset: anOffset	^ self basicNew		fuelSet: julianDayNumber nanoSecond: nanoSeconds seconds: seconds offset: anOffset! !!DateAndTime methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 9/2/2011 15:17'!fuelAccept: aVisitor	^ aVisitor visitDateAndTime: self! !!DateAndTime methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 9/2/2011 15:15'!fuelSet: julianDayNumber nanoSecond: nanoSeconds seconds: numberOfSeconds offset: anOffset	jdn := julianDayNumber.	nanos := nanoSeconds.	seconds := numberOfSeconds.	offset := anOffset.! !!LargePositiveInteger methodsFor: '*Fuel' stamp: 'MartinDias 8/6/2011 19:39'!fuelAccept: aVisitor	^aVisitor visitLargeInteger: self! !!ByteString methodsFor: '*Fuel' stamp: 'MartinDias 8/15/2011 17:20'!fuelAccept: aVisitor	^aVisitor visitByteString: self! !!MethodDictionary methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 9/20/2011 09:41'!fuelAfterMaterialization	self fuelRehashWithoutBecome! !!MethodDictionary methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 9/27/2011 20:52'!fuelRehashWithoutBecome	"The original #rehash method in Pharo 1.0 to 1.3 is terrible slow because it uses a #become. Since Pharo 1.4 14155 there is a new version that avoids the #become and uses instead a #copyFrom, which is MUCH faster. The following code is exactly that new version of #rehash. We put it here in order to be compatible with previous versions of Pharo. In the future, it must be removed and directly use #rehash instead."	  | newInstance |	  newInstance := (self species basicNew: self basicSize) initialize: self basicSize.        1 to: self basicSize do: [ :index |                 (self basicAt: index) ifNotNil: [ :key |                        newInstance at: key put: (array at: index) ] ].        self copyFrom: newInstance! !!TPureBehavior methodsFor: '*Fuel' stamp: 'MartinDias 8/29/2011 04:06'!fuelInitializeTraitComposition	self traitComposition traits do: [:each | each addUser: self]! !!ClassDescription methodsFor: '*Fuel' stamp: 'MartinDias 7/30/2011 19:23'!basicInstVarNames: anArray	instanceVariables := anArray! !!ClassDescription methodsFor: '*Fuel' stamp: 'MartinDias 7/27/2011 22:33'!fuelInstVarNamesAndOffsetsDo: aBinaryBlock	"This is part of the interface between the compiler and a class's instance or field names.	 The class should enumerate aBinaryBlock with the instance variable name strings and	 their integer offsets.  The order is important. Names evaluated later will override the	 same names occurring earlier."	| superInstSize |	(superInstSize := superclass notNil ifTrue: [superclass instSize] ifFalse: [0]) > 0 ifTrue:		[superclass fuelInstVarNamesAndOffsetsDo: aBinaryBlock].	1 to: self instSize - superInstSize do:		[:i| aBinaryBlock value: (instanceVariables at: i) value: i + superInstSize]! !!Class methodsFor: '*Fuel' stamp: 'MartinDias 7/30/2011 18:23'!basicClassPool	"Answer nil or the dictionary of class variables."	^classPool! !!Class methodsFor: '*Fuel' stamp: 'MarianoMartinezPeck 6/29/2011 11:04'!basicEnvironment	^ environment! !!Class methodsFor: '*Fuel' stamp: 'MartinDias 7/30/2011 18:23'!basicSharedPools	"Answer nil or a Set of the pool dictionaries declared in the receiver."	^sharedPools! !!Class methodsFor: '*Fuel' stamp: 'MartinDias 5/14/2011 21:44'!basicSubclasses	^ subclasses! !!Class methodsFor: '*Fuel' stamp: 'MartinDias 5/14/2011 21:45'!basicSubclasses: anArray	subclasses := anArray! !!Class methodsFor: '*Fuel' stamp: 'MartinDias 8/6/2011 19:22'!fuelAccept: aVisitor	^aVisitor visitClass: self! !Object subclass: #FLAnalysis	instanceVariableNames: 'objectStack firstMapper clusterization root'	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core'!!FLAnalysis commentStamp: 'MartinDias 8/29/2011 19:15' prior: 0!I am responsible of traversing the graph of references starting from a root object. I will produce a clusterization which the serializer will store on a stream.An example of use is:	(FLAnalyzer newDefault 		clusterizationOf: (Array with: 1@2 with: 3@4))		clusters.!!FLAnalysis class methodsFor: 'instance creation' stamp: 'MartinDias 9/9/2011 22:13'!newWith: aMapper root: anObject	^self basicNew		initializeWith: aMapper root: anObject;		yourself.! !!FLAnalysis methodsFor: 'analyzing' stamp: 'MartinDias 8/7/2011 20:18'!clusterFor: anObject	^firstMapper chainedClusterFor: anObject! !!FLAnalysis methodsFor: 'accessing' stamp: 'MartinDias 9/9/2011 21:47'!clusterization	^clusterization! !!FLAnalysis methodsFor: 'initialize-release' stamp: 'MartinDias 9/9/2011 22:03'!initializeWith: aMapper root: anObject	super initialize.	firstMapper := aMapper.	root := anObject.	objectStack := FLSimpleStack new.	clusterization := FLClusterization new.! !!FLAnalysis methodsFor: 'analyzing' stamp: 'MartinDias 8/20/2011 22:22'!mapAndTrace: anObject	"Map an object to its cluster. Trace its references."	| aCluster |	aCluster := self clusterFor: anObject.	clusterization add: aCluster traceWith: self.	aCluster add: anObject traceWith: self.! !!FLAnalysis methodsFor: 'analyzing' stamp: 'MartinDias 9/10/2011 18:08'!run	objectStack push: root.	[ objectStack isEmpty ] 		whileFalse: [ self mapAndTrace: objectStack pop ].! !!FLAnalysis methodsFor: 'analyzing' stamp: 'MartinDias 8/20/2011 22:11'!trace: anObject	objectStack push: anObject! !Object subclass: #FLAnalyzer	instanceVariableNames: 'internalClasses pluggableSubstitutions globalMappersFactory analysisFactory'	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core'!!FLAnalyzer commentStamp: 'MartinDias 8/29/2011 19:15' prior: 0!I am responsible of traversing the graph of references starting from a root object. I will produce a clusterization which the serializer will store on a stream.An example of use is:	(FLAnalyzer newDefault 		clusterizationOf: (Array with: 1@2 with: 3@4))		clusters.!!FLAnalyzer class methodsFor: 'instance creation' stamp: 'MartinDias 9/9/2011 21:25'!newDefault	"Returns an instance with default configuration."	^self new! !!FLAnalyzer methodsFor: 'protected' stamp: 'MarianoMartinezPeck 10/22/2011 12:53'!allGlobalMappers	^ (Array with: FLGlobalAssociationMapper with: FLClassPoolAssociationMapper with: FLGlobalMapper with: FLGlobalBehaviorMapper) 		collect: [:aMapperClass | aMapperClass new internalObjects: internalClasses; yourself ]! !!FLAnalyzer methodsFor: 'analyzing' stamp: 'MartinDias 9/14/2011 00:15'!analysisFor: anObject	^analysisFactory value: anObject! !!FLAnalyzer methodsFor: 'configuring' stamp: 'MartinDias 9/11/2011 12:33'!considerGlobalMinimaly	globalMappersFactory := [self minimalGlobalsMappers]! !!FLAnalyzer methodsFor: 'configuring' stamp: 'MartinDias 9/11/2011 11:19'!considerGlobalWhenPossible	globalMappersFactory := [self allGlobalMappers]! !!FLAnalyzer methodsFor: 'configuring' stamp: 'MartinDias 9/11/2011 11:26'!considerInternalAll: classes	internalClasses addAll: classes.	self considerGlobalWhenPossible.! !!FLAnalyzer methodsFor: 'defaults' stamp: 'MartinDias 9/10/2011 17:57'!defaultMapper	^FLDefaultMapper new! !!FLAnalyzer methodsFor: 'analyzing' stamp: 'MartinDias 9/10/2011 18:10'!firstInMapperChain	^self mappers		reduceRight: [:left :right | left next: right ];		first! !!FLAnalyzer methodsFor: 'protected' stamp: 'MartinDias 9/11/2011 11:22'!globalMappers		^globalMappersFactory value! !!FLAnalyzer methodsFor: 'initialize-release' stamp: 'MartinDias 9/13/2011 19:25'!initialize	super initialize.	self setDefaultAnalysis.	self considerGlobalMinimaly.	pluggableSubstitutions := OrderedCollection new.	internalClasses := OrderedCollection new.! !!FLAnalyzer methodsFor: 'protected' stamp: 'MartinDias 9/10/2011 17:59'!mappers	| mappers |	mappers := OrderedCollection new.	mappers addAll: self pluggableSubstitutionMappers.	mappers addAll: self globalMappers.	mappers add: self defaultMapper.	^mappers! !!FLAnalyzer methodsFor: 'protected' stamp: 'MartinDias 9/11/2011 12:33'!minimalGlobalsMappers	^Array with: FLLightGlobalMapper new! !!FLAnalyzer methodsFor: 'protected' stamp: 'MartinDias 9/10/2011 17:55'!pluggableSubstitutionMappers	^pluggableSubstitutions collect: [:aLink |		FLPluggableSubstitutionMapper 			when: aLink key			substituteBy: aLink value]! !!FLAnalyzer methodsFor: 'protected' stamp: 'MartinDias 9/14/2011 00:24'!setDefaultAnalysis	analysisFactory := [:anObject | 		(FLAnalysis 			newWith: self firstInMapperChain 			root: anObject)			run;			yourself ]! !!FLAnalyzer methodsFor: 'configuring' stamp: 'MartinDias 9/10/2011 17:04'!when: aCondition substituteBy: aFactory	pluggableSubstitutions add: aCondition -> aFactory! !Object subclass: #FLCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLCluster commentStamp: 'MartinDias 8/29/2011 19:20' prior: 0!I represent a cluster of objects grouped by some specific similarity. I know how to serialize and materialize them all together.!!FLCluster methodsFor: 'analyzing' stamp: 'MartinDias 10/13/2011 16:26'!add: anObject traceWith: aAnalysis	"Add an object to the cluster and trace references."	self subclassResponsibility! !!FLCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!afterMaterializationStepWith: aMaterialization! !!FLCluster methodsFor: 'analyzing' stamp: 'MartinDias 8/29/2011 00:54'!clusterBucketIn: aClusterization	"Answer in which clusters bucket place this cluster. This defines the sort order in which the clusters will be ordered. See FLAnalyzer >> clusteredObjects for more information."	self subclassResponsibility ! !!FLCluster methodsFor: 'analyzing' stamp: 'MartinDias 8/29/2011 00:54'!clusterReferencesDo: aBlock	"Evaluate a block with each object referenced by the cluster"! !!FLCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializeInstancesStepWith: aMaterialization	self subclassResponsibility ! !!FLCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializePostInstancesStepWith: aMaterialization! !!FLCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializeReferencesStepWith: aMaterialization! !!FLCluster methodsFor: 'accessing' stamp: 'MartinDias 8/29/2011 00:50'!objects	"Answer the objects that this cluster groups."	self subclassResponsibility! !!FLCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 8/29/2011 01:23'!registerIndexesOn: aDictionary	"Maps objects with indexes in the dictionary."! !!FLCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeInstancesStepWith: aSerialization	self subclassResponsibility ! !!FLCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializePostInstancesStepWith: aSerialization! !!FLCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeReferencesStepWith: aSerialization! !FLCluster subclass: #FLIteratingCluster	instanceVariableNames: 'objects'	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLIteratingCluster commentStamp: '<historical>' prior: 0!I am a template class whose algorithm for serialize a collection of objects consists on delegate the serialization of each individual object to the subclass.!FLIteratingCluster subclass: #FLBehaviorCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters-InternalMetalevel'!!FLBehaviorCluster commentStamp: 'MartinDias 7/30/2011 20:31' prior: 0!I have the common behavior for serializing class and trait behaviors in full detail.!!FLBehaviorCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:22'!afterMaterializationStepWith: aMaterialization	objects do:	[ :aClassOrTrait | 		aClassOrTrait fuelInitializeTraitComposition.		aClassOrTrait fuelAfterMaterialization ]! !!FLBehaviorCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializePostInstance: aClassOrTrait with: aMaterialization	self subclassResponsibility! !!FLBehaviorCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializePostInstancesStepWith: aMaterialization	objects do:	[ :aClassOrTrait | self materializePostInstance: aClassOrTrait with: aMaterialization ]! !!FLBehaviorCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:22'!materializeReferencesOf: aClassOrTrait with: aMaterialization	aClassOrTrait methodDictionary: aMaterialization nextEncodedReference.	aClassOrTrait organization: aMaterialization nextEncodedReference.	aClassOrTrait basicLocalSelectors: aMaterialization nextEncodedReference.	aClassOrTrait traitComposition: aMaterialization nextEncodedReference.! !!FLBehaviorCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializeReferencesStepWith: aMaterialization	objects do:	[ :aClassOrTrait | self materializeReferencesOf: aClassOrTrait with: aMaterialization ]! !!FLBehaviorCluster methodsFor: 'analyzing' stamp: 'MartinDias 7/30/2011 20:17'!referencesOf: aClassOrTrait do: aBlock	aBlock value: aClassOrTrait methodDictionary.	aBlock value: aClassOrTrait organization.	aBlock value: aClassOrTrait traitComposition.	aBlock value: aClassOrTrait basicLocalSelectors.! !!FLBehaviorCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializePostInstance: aClassOrTrait with: aSerialization	self subclassResponsibility! !!FLBehaviorCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializePostInstancesStepWith: aSerialization  	objects do:	[ :aClassOrTrait | self serializePostInstance: aClassOrTrait with: aSerialization ]! !!FLBehaviorCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeReferencesOf: aClassOrTrait with: aSerialization	aSerialization encodeReferenceTo: aClassOrTrait methodDictionary.	aSerialization encodeReferenceTo: aClassOrTrait organization. 	aSerialization encodeReferenceTo: aClassOrTrait basicLocalSelectors.	aSerialization encodeReferenceTo: aClassOrTrait traitComposition.! !!FLBehaviorCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeReferencesStepWith: aSerialization	objects do:	[ :aClassOrTrait | self serializeReferencesOf: aClassOrTrait with: aSerialization ]! !FLBehaviorCluster subclass: #FLClassCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters-InternalMetalevel'!!FLClassCluster commentStamp: 'MartinDias 7/30/2011 20:31' prior: 0!I am a cluster for storing classes in full detail.!!FLClassCluster methodsFor: 'analyzing' stamp: 'MartinDias 9/17/2011 00:27'!clusterBucketIn: aClusterization	^aClusterization metalevelInstanceSideBucket! !!FLClassCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializeInstanceWith: aMaterialization	| aMetaclass |	aMetaclass := aMaterialization nextEncodedReference.	^aMetaclass new! !!FLClassCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializePostInstance: aClass with: aMaterialization	| superclass category name instanceVariableNames format |	superclass := aMaterialization nextEncodedReference.	category := aMaterialization nextEncodedReference.	name := aMaterialization nextEncodedReference.	format := aMaterialization nextEncodedReference.	instanceVariableNames := aMaterialization stream nextString subStrings: ' '.	aClass 		superclass: superclass;		setFormat: format;		setName: name;		basicInstVarNames: instanceVariableNames;		basicCategory: category; 		methodDict: MethodDictionary new.		! !!FLClassCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializeReferencesOf: aClass with: aMaterialization	super materializeReferencesOf: aClass with: aMaterialization.	aClass classPool: aMaterialization nextEncodedReference.	aClass sharedPools: aMaterialization nextEncodedReference.	aClass environment: aMaterialization nextEncodedReference.	aClass basicSubclasses: aMaterialization nextEncodedReference.		Class class instSize + 1 to: aClass class instSize 		do: [ :index | aClass instVarAt: index put: aMaterialization nextEncodedReference ]! !!FLClassCluster methodsFor: 'analyzing' stamp: 'MartinDias 9/28/2011 19:41'!referencesOf: aClass do: aBlock	super referencesOf: aClass do: aBlock.	aBlock value: aClass classSide.	aBlock value: aClass superclass.	aBlock value: aClass basicClassPool.	aBlock value: aClass basicSharedPools. 	aBlock value: aClass basicCategory.	aBlock value: aClass name.	aBlock value: aClass format.		aBlock value: aClass basicEnvironment.	aBlock value: aClass basicSubclasses.		Class class instSize + 1 to: aClass class instSize 		do: [ :index | aBlock value: (aClass instVarAt: index) ]! !!FLClassCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeInstance: aClass with: aSerialization	aSerialization encodeReferenceTo: aClass classSide! !!FLClassCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializePostInstance: aClass with: aSerialization	aSerialization encodeReferenceTo: aClass superclass.	aSerialization encodeReferenceTo: aClass basicCategory.	aSerialization encodeReferenceTo: aClass name.	aSerialization encodeReferenceTo: aClass format.		aSerialization stream nextStringPut: aClass instanceVariablesString.	self flag: #todo. "The array of variable names represents a circularity problem between clusters: if we encode the reference to such array, then the cluster for arrays should be before of Class cluster. But this would disable us to serialize an array of internal classes."! !!FLClassCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeReferencesOf: aClass with: aSerialization	super serializeReferencesOf: aClass with: aSerialization.	aSerialization encodeReferenceTo: aClass basicClassPool. 	aSerialization encodeReferenceTo: aClass basicSharedPools. 	aSerialization encodeReferenceTo: aClass basicEnvironment.	aSerialization encodeReferenceTo: aClass basicSubclasses. 	Class class instSize + 1 to: aClass class instSize 		do: [ :index | aSerialization encodeReferenceTo: (aClass instVarAt: index) ]! !FLBehaviorCluster subclass: #FLClassTraitCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters-InternalMetalevel'!!FLClassTraitCluster commentStamp: 'MartinDias 7/30/2011 20:30' prior: 0!I am a cluster for storing class traits in full detail.!!FLClassTraitCluster methodsFor: 'analyzing' stamp: 'MartinDias 9/17/2011 00:27'!clusterBucketIn: aClusterization	^aClusterization metalevelClassSideBucket! !!FLClassTraitCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializeInstanceWith: aMaterialization	^ClassTrait basicNew! !!FLClassTraitCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializePostInstance: aClassTrait with: aMaterialization	aClassTrait 		initialize.! !!FLClassTraitCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeInstances: aSerialization! !!FLClassTraitCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializePostInstance: aClassTrait with: aSerialization! !FLBehaviorCluster subclass: #FLMetaclassCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters-InternalMetalevel'!!FLMetaclassCluster commentStamp: 'MartinDias 7/30/2011 20:30' prior: 0!I am a cluster for storing metaclasses in full detail.!!FLMetaclassCluster methodsFor: 'analyzing' stamp: 'MartinDias 9/17/2011 00:27'!clusterBucketIn: aClusterization	^aClusterization metalevelClassSideBucket! !!FLMetaclassCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializeInstanceWith: aMaterialization	^Metaclass new! !!FLMetaclassCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializePostInstance: aMetaclass with: aMaterialization	| superclass instanceVariableNames format |	superclass := aMaterialization nextEncodedReference.	instanceVariableNames := aMaterialization stream nextString subStrings: ' '.	format := aMaterialization stream uint16.	aMetaclass		superclass: superclass 		methodDictionary: MethodDictionary new 		format: format;		basicInstVarNames: instanceVariableNames.! !!FLMetaclassCluster methodsFor: 'analyzing' stamp: 'MartinDias 7/29/2011 21:12'!referencesOf: aMetaclass do: aBlock	super referencesOf: aMetaclass do: aBlock.		aBlock value: aMetaclass superclass.! !!FLMetaclassCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeInstances: aSerialization! !!FLMetaclassCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializePostInstance: aMetaclass with: aSerialization	aSerialization encodeReferenceTo: aMetaclass superclass.	aSerialization stream nextStringPut: aMetaclass instanceVariablesString.	aSerialization stream uint16: aMetaclass format.	! !FLBehaviorCluster subclass: #FLTraitCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters-InternalMetalevel'!!FLTraitCluster commentStamp: 'MartinDias 7/30/2011 20:30' prior: 0!I am a cluster for storing traits in full detail.!!FLTraitCluster methodsFor: 'analyzing' stamp: 'MartinDias 9/17/2011 00:27'!clusterBucketIn: aClusterization	^aClusterization metalevelInstanceSideBucket! !!FLTraitCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializeInstanceWith: aMaterialization	^Trait basicNew! !!FLTraitCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializePostInstance: aTrait with: aMaterialization	| classTrait category name environment |	classTrait := aMaterialization nextEncodedReference.	category := aMaterialization nextEncodedReference.	name := aMaterialization nextEncodedReference.	environment := aMaterialization nextEncodedReference.		aTrait 		initialize;		name: name;		basicCategory: category asSymbol;		classTrait: classTrait;		environment: environment.		classTrait baseTrait: aTrait.! !!FLTraitCluster methodsFor: 'analyzing' stamp: 'MartinDias 9/16/2011 23:48'!referencesOf: aTrait do: aBlock	super referencesOf: aTrait do: aBlock.	aBlock value: aTrait classSide.	aBlock value: aTrait basicEnvironment.	aBlock value: aTrait basicCategory.	aBlock value: aTrait name.! !!FLTraitCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeInstances: aSerialization! !!FLTraitCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializePostInstance: aTrait with: aSerialization	aSerialization encodeReferenceTo: aTrait classSide.	aSerialization encodeReferenceTo: aTrait basicCategory.	aSerialization encodeReferenceTo: aTrait name.	aSerialization encodeReferenceTo: aTrait basicEnvironment.! !FLIteratingCluster subclass: #FLClassPoolAssociationCluster	instanceVariableNames: 'ownerClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLClassPoolAssociationCluster commentStamp: 'MartinDias 5/30/2011 01:17' prior: 0!I am a cluster for class variable associations, i.e. bindings that belong to the class pool of a Class included on Smalltalk globals.!!FLClassPoolAssociationCluster class methodsFor: 'instance creation' stamp: 'MarianoMartinezPeck 10/24/2011 16:35'!for: aClass	^ self basicNew		initializeWith: aClass;		yourself.! !!FLClassPoolAssociationCluster methodsFor: 'analyzing' stamp: 'MartinDias 8/20/2011 22:24'!clusterBucketIn: aClusterization	^aClusterization baselevelBucket! !!FLClassPoolAssociationCluster methodsFor: 'analyzing' stamp: 'MartinDias 6/5/2011 03:03'!clusterReferencesDo: aBlock	aBlock value: ownerClass! !!FLClassPoolAssociationCluster methodsFor: 'initialize-release' stamp: 'MarianoMartinezPeck 10/24/2011 16:39'!initializeWith: aClass	super initialize.	ownerClass := aClass! !!FLClassPoolAssociationCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializeInstanceWith: aMaterialization	| keyName |	ownerClass := aMaterialization nextEncodedReference.	keyName := aMaterialization stream nextString.	^ ownerClass classPool associationAt: keyName asSymbol ! !!FLClassPoolAssociationCluster methodsFor: 'printing' stamp: 'MarianoMartinezPeck 10/24/2011 10:57'!printNameOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."		super printNameOn: aStream.	aStream nextPut: $[.	ownerClass printOn: aStream.	aStream nextPut: $].	! !!FLClassPoolAssociationCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeInstance: anAssociation with: aSerialization	aSerialization encodeReferenceTo: ownerClass.	aSerialization stream nextStringPut: anAssociation key! !FLIteratingCluster subclass: #FLCompiledMethodCluster	instanceVariableNames: 'trailerEncoder'	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters-InternalMetalevel'!!FLCompiledMethodCluster commentStamp: 'MartinDias 5/30/2011 01:17' prior: 0!I am a cluster for CompiledMethod instances.!!FLCompiledMethodCluster class methodsFor: 'instance creation' stamp: 'MarianoMartinezPeck 9/23/2011 16:39'!withNoSource	^ self new initializeWithEncoder: FLCompiledMethodTrailerEncoderNoSource new.! !!FLCompiledMethodCluster class methodsFor: 'instance creation' stamp: 'MarianoMartinezPeck 9/23/2011 16:38'!withNoTrailerChange	^ self new initializeWithEncoder: FLCompiledMethodTrailerEncoderNoChange new.! !!FLCompiledMethodCluster methodsFor: 'analyzing' stamp: 'MarianoMartinezPeck 9/17/2011 19:31'!clusterBucketIn: aClusterization	^aClusterization primitivesBucket! !!FLCompiledMethodCluster methodsFor: 'initialize-release' stamp: 'MarianoMartinezPeck 9/23/2011 16:12'!initializeWithEncoder: aTrailerEncoder	trailerEncoder := aTrailerEncoder.! !!FLCompiledMethodCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializeInstanceWith: aMaterialization	| compiledMethod header bytecodesPlusTrailerSize aReadStream |	aReadStream := aMaterialization stream.	header := aReadStream uint32.	bytecodesPlusTrailerSize := aReadStream uint16.	compiledMethod := CompiledMethod newMethod: bytecodesPlusTrailerSize header: header.	compiledMethod initialPC to: compiledMethod size		do: [ :index | compiledMethod at: index put: aReadStream next ].			^ compiledMethod! !!FLCompiledMethodCluster methodsFor: 'protected' stamp: 'MartinDias 10/13/2011 16:23'!materializeLiteralsTo: compiledMethod with: aMaterialization	1 to: compiledMethod numLiterals 		do: [ :index | compiledMethod literalAt: index put: aMaterialization nextEncodedReference ]! !!FLCompiledMethodCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializeReferencesStepWith: aMaterialization	objects do: [ :aCompiledMethod | self materializeLiteralsTo: aCompiledMethod with: aMaterialization ]! !!FLCompiledMethodCluster methodsFor: 'analyzing' stamp: 'MartinDias 3/26/2011 16:27'!referencesOf: anObject do: aBlock	1 to: anObject numLiterals		do: [ :index | aBlock value: (anObject literalAt: index) ]! !!FLCompiledMethodCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeInstance: aCompiledMethodToSerialize with: aSerialization	| header aWriteStream bytecodesPlusTrailerSize cmSize cmInitialPC aCompiledMethod |	aWriteStream := aSerialization stream.	aCompiledMethod := trailerEncoder compiledMethodToSerialize: aCompiledMethodToSerialize.	header := aCompiledMethod header.	cmSize := aCompiledMethod size.	cmInitialPC := aCompiledMethod initialPC.	bytecodesPlusTrailerSize := cmSize - cmInitialPC + 1.	aWriteStream 		uint32: header;		uint16: bytecodesPlusTrailerSize.		cmInitialPC to: cmSize		do: [ :index | aWriteStream nextPut: (aCompiledMethod at: index) ].! !!FLCompiledMethodCluster methodsFor: 'protected' stamp: 'MartinDias 10/13/2011 16:20'!serializeLiteralsOf: aCompiledMethod with: aSerialization	1 to: aCompiledMethod numLiterals 		do: [ :index | aSerialization encodeReferenceTo: (aCompiledMethod literalAt: index) ]! !!FLCompiledMethodCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeReferencesStepWith: aSerialization	objects do: [ :aCompiledMethod | self serializeLiteralsOf: aCompiledMethod with: aSerialization ]! !FLCompiledMethodCluster subclass: #FLNamedPrimitiveMethodCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters-InternalMetalevel'!!FLNamedPrimitiveMethodCluster commentStamp: 'MartinDias 5/30/2011 01:17' prior: 0!I am a cluster for CompiledMethods which are <primitive:module:> primitives.For example, Integer >> bitAnd: should be serialized with me.!!FLNamedPrimitiveMethodCluster methodsFor: 'protected' stamp: 'MartinDias 10/13/2011 16:23'!materializeLiteralsTo: compiledMethod with: aMaterialization	| module name |	module := aMaterialization nextEncodedReference.	name := aMaterialization nextEncodedReference.	"The third element of the array is Obsolete. We can put whatever we want since it is not used anymore by the VM. It used to be a session ID. The forth element is the primitive index in a externalPrimitiveTable and it is IMPORTANT to put it in zero. Always. Otherwise there can be errors. Putting a zero means that the VM will not try to directly execute the primitive from the table and it will always try to load the module. It is the safer thing to do. For more details, read the method #primitiveExternalCall in VMMaker"	compiledMethod literalAt: 1 put: (Array with: module with: name with: 0 with: 0).	2 to: compiledMethod numLiterals 		do: [ :index | compiledMethod literalAt: index put: aMaterialization nextEncodedReference ]! !!FLNamedPrimitiveMethodCluster methodsFor: 'analyzing' stamp: 'MartinDias 11/11/2010 18:31'!referencesOf: anObject do: aBlock	aBlock 		value: (anObject literalAt: 1) first;		value: (anObject literalAt: 1) second. 	2 to: anObject numLiterals		do: [ :index | aBlock value: (anObject literalAt: index) ]! !!FLNamedPrimitiveMethodCluster methodsFor: 'protected' stamp: 'MartinDias 10/13/2011 16:20'!serializeLiteralsOf: aCompiledMethod with: aSerialization	| primitiveArguments |		primitiveArguments := aCompiledMethod literalAt: 1.	aSerialization 		encodeReferenceTo: primitiveArguments first;		encodeReferenceTo: primitiveArguments second.	2 to: aCompiledMethod numLiterals 		do: [ :index | aSerialization encodeReferenceTo: (aCompiledMethod literalAt: index) ]! !!FLIteratingCluster methodsFor: 'analyzing' stamp: 'MartinDias 10/13/2011 16:26'!add: anObject traceWith: aAnalysis	"Add an object to the cluster and trace references."	objects addIfNotPresent: anObject ifPresentDo: [ ^self ].	self referencesOf: anObject do: [ :aChild | aAnalysis trace: aChild ].! !!FLIteratingCluster methodsFor: 'initialize-release' stamp: 'MartinDias 8/29/2011 00:47'!initialize	super initialize.	objects := self newSerializingCollection.! !!FLIteratingCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:22'!materializeInstanceWith: aMaterialization	"Hook method that each subclass should customize for its special way of materializing"	^ self subclassResponsibility! !!FLIteratingCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:22'!materializeInstancesStepWith: aMaterialization	| instanceCount |	instanceCount := aMaterialization nextEncodedPositiveInteger.		objects := self newMaterializingCollection: instanceCount.  		instanceCount timesRepeat: [ 		objects add: (self materializeInstanceWith: aMaterialization) ].! !!FLIteratingCluster methodsFor: 'serialize/materialize' stamp: 'MarianoMartinezPeck 9/15/2011 12:36'!newMaterializingCollection: instanceCount	^(OrderedCollection new: instanceCount)		resetTo: 1; "This avoids prematures #makeRoomAtLast. In fact, this has already been fixed in Pharo 1.4: http://code.google.com/p/pharo/issues/detail?id=1686"		yourself.! !!FLIteratingCluster methodsFor: 'analyzing' stamp: 'MartinDias 8/29/2011 00:48'!newSerializingCollection	"Answer a collection for the objects that correspond to this cluster."	^IdentitySet new! !!FLIteratingCluster methodsFor: 'accessing' stamp: 'MartinDias 8/29/2011 00:59'!objects	^objects! !!FLIteratingCluster methodsFor: 'printing' stamp: 'MartinDias 8/29/2011 01:16'!printNameOn: aStream	super printOn: aStream! !!FLIteratingCluster methodsFor: 'printing' stamp: 'MartinDias 8/29/2011 00:52'!printOn: aStream	self printNameOn: aStream.	aStream nextPutAll: '->'.	objects printElementsOn: aStream! !!FLIteratingCluster methodsFor: 'analyzing' stamp: 'MartinDias 8/29/2011 00:56'!referencesOf: anObject do: aBlock	"Evaluate a block with each object referenced by anObject"! !!FLIteratingCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 8/29/2011 01:22'!registerIndexesOn: aDictionary	self objects do: [ :instance | aDictionary at: instance put: aDictionary size + 1 ].! !!FLIteratingCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeInstance: anObject with: aSerialization	"Hook method that each subclass should customize for its special way of serializing"	self subclassResponsibility ! !!FLIteratingCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeInstances: aSerialization	objects do: [ :instance | self serializeInstance: instance with: aSerialization ]! !!FLIteratingCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeInstancesStepWith: aSerialization	aSerialization encodePositiveInteger: objects size.	self serializeInstances: aSerialization! !FLIteratingCluster subclass: #FLObjectCluster	instanceVariableNames: 'theClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLObjectCluster commentStamp: 'MartinDias 8/29/2011 19:20' prior: 0!I implement a generic way of serializing and materializing an object, for those that do not need more special way of doing it.!FLObjectCluster subclass: #FLBitsObjectCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLBitsObjectCluster commentStamp: 'MartinDias 8/1/2011 02:59' prior: 0!I have the common behavior for generic storing and loading variable bits objects.!!FLBitsObjectCluster methodsFor: 'analyzing' stamp: 'MartinDias 10/13/2011 16:26'!add: anObject traceWith: aAnalysis	"Add an object to the cluster. We know the object doesn't have references."	objects addLast: anObject! !!FLBitsObjectCluster methodsFor: 'analyzing' stamp: 'MarianoMartinezPeck 9/27/2011 11:06'!newSerializingCollection	"Answer a collection for the objects that correspond to this cluster."	^OrderedCollection new! !!FLBitsObjectCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:26'!registerIndexesOn: aDictionary	self flag: #todo. "Converting objects collection here in this method is a bit confusing. This is because since this cluster is for primitives, they do not have pointers to other objects. Hence, instead of storing them in a IdentitySet we can use an OrderedCollection and then just convert them at the end. For more details see FLBitsObjectCluster >> #add: anObject traceWith: aAnalysis"	objects := objects asIdentitySet.	super registerIndexesOn: aDictionary.! !FLBitsObjectCluster subclass: #FLByteObjectCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLByteObjectCluster commentStamp: 'MartinDias 8/1/2011 02:59' prior: 0!I am the generic cluster for storing and loading variable byte objects.!!FLByteObjectCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializeInstanceWith: aMaterialization	| instance size |	size := aMaterialization nextEncodedPositiveInteger.	instance := theClass basicNew: size.	aMaterialization stream next: size into: instance.	^ instance! !!FLByteObjectCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeInstance: anObject with: aSerialization	aSerialization encodePositiveInteger: anObject basicSize.	aSerialization stream nextBytesPutAll: anObject.! !FLBitsObjectCluster subclass: #FLWordObjectCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLWordObjectCluster commentStamp: 'MarianoMartinezPeck 9/6/2011 22:50' prior: 0!I am the generic cluster for storing and loading variable word objects. Most word-like objects are subclasses from ArrayedCollection. Hence, we may have used the method #writeOn: to serialize, and #newFromStream: to materialize. #writeOn: is slow because it ALWAYS encode wors in a big endian format. Most machines today are even little endian. Even worst, #newFromStream: has to always do a #restoreEndianness. #newFromStream: is fast because it uses the method #nextWordsInto: which is a hack but that is really fast. The problem is that #nextWordsInto: has to always do the #restoreEndianness when we are in little endian machines (most of the time).Hence, this cluster provives the best of both worlds: the serialization is done with a platform-dependen way, that is, the endianness will be the same of the machine where we are serializing. In addition, we serialize with the same hack that #nextWordsInto: uses, that is, the Bitmap >> hackBits:And the materialization will use a variation of #nextWordsInto:  (#fuelNextWordsInto:) that ONLY does the #restoreEndianness if the machine where we are materializing has a different endianness than where we have serialized the object. To do this, while serializing, we store in the header of the Fuel stream, the endianness. Then in materialization, we compare agains that. Conclusion: we only restore endianness when needed.Notice, in addition, that the method #newFromStream: sends the message #restoreEndianness. This method EXPECTS that the object was serialized in big endian format, and it will only change the endianness if we are materializing in a little endian machine. This means that if you serialize in little endian and materialize in big endian, you are screw.  For this reason, this cluster uses a method that always change the endianness, Bitmap class >> swapBytesIn:from:to: Future work: maybe we can modify and use the Bitmap hackBits:   not only for materialization but also for serialization. !!FLWordObjectCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializeInstanceWith: aMaterialization	| inst wideSize |	wideSize :=  aMaterialization nextEncodedPositiveInteger.	inst := theClass basicNew: wideSize.		aMaterialization stream fuelNextWordsInto: inst. 	(aMaterialization isBigEndian = Smalltalk isBigEndian asBit)		ifTrue: [^ inst ]		ifFalse: [ ^ self swapBytesOf: inst ] 	! !!FLWordObjectCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeInstance: aWordObject with: aSerialization	aSerialization encodePositiveInteger: aWordObject basicSize.	aSerialization stream nextWordsPut: aWordObject! !!FLWordObjectCluster methodsFor: 'endianness' stamp: 'MarianoMartinezPeck 9/6/2011 12:34'!swapBytesOf: aWordObject	Bitmap                swapBytesIn: aWordObject                from: 1                to: aWordObject basicSize.	^ aWordObject! !!FLObjectCluster class methodsFor: 'instance creation' stamp: 'MarianoMartinezPeck 10/24/2011 16:40'!for: aClass	^ self basicNew		initializeWith:aClass;		yourself.! !!FLObjectCluster methodsFor: 'analyzing' stamp: 'MartinDias 9/17/2011 18:09'!clusterBucketIn: aClusterization	^aClusterization baselevelBucket ! !!FLObjectCluster methodsFor: 'analyzing' stamp: 'MartinDias 5/30/2011 03:45'!clusterReferencesDo: aBlock	aBlock value: theClass! !!FLObjectCluster methodsFor: 'initialize-release' stamp: 'MarianoMartinezPeck 10/24/2011 16:42'!initializeWith: aClass	super initialize.	theClass := aClass! !!FLObjectCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializeInstancesStepWith: aMaterialization	theClass := aMaterialization nextEncodedReference.	super materializeInstancesStepWith: aMaterialization.! !!FLObjectCluster methodsFor: 'printing' stamp: 'MarianoMartinezPeck 10/24/2011 10:58'!printNameOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."		super printNameOn: aStream.	aStream nextPut: $[.	theClass printOn: aStream.	aStream nextPut: $].	! !!FLObjectCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeInstancesStepWith: aSerialization	aSerialization encodeReferenceTo: theClass.	super serializeInstancesStepWith: aSerialization.! !FLObjectCluster subclass: #FLPointerObjectCluster	instanceVariableNames: 'variablesMapping'	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLPointerObjectCluster commentStamp: 'MartinDias 8/1/2011 03:00' prior: 0!I have the common behavior for storing and loading pointer objects.!FLPointerObjectCluster subclass: #FLFixedObjectCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLFixedObjectCluster commentStamp: 'MartinDias 5/30/2011 01:25' prior: 0!I am a generic cluster for objects without indexable variables.!!FLFixedObjectCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializeInstanceWith: aMaterialization	^theClass basicNew! !!FLFixedObjectCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeInstances: aSerialization! !!FLPointerObjectCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!afterMaterializationStepWith: aMaterialization  	objects do: [ :anObject | anObject fuelAfterMaterialization ]! !!FLPointerObjectCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializeInstancesStepWith: aMaterialization	"Template method that let to the subclass the materialization using the received materializer"	super materializeInstancesStepWith: aMaterialization.			variablesMapping := FLVariablesMapping for: theClass.	variablesMapping materializeMappingFrom: aMaterialization stream.! !!FLPointerObjectCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializeReferencesOf: anObject with: aMaterialization	variablesMapping materializeReferencesOf: anObject with: aMaterialization! !!FLPointerObjectCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializeReferencesStepWith: aMaterialization	objects do: [ :anObject | self materializeReferencesOf: anObject with: aMaterialization ]! !!FLPointerObjectCluster methodsFor: 'analyzing' stamp: 'MartinDias 7/27/2011 22:32'!referencesOf: anObject do: aBlock	| ignoredInstanceVariableNames |	ignoredInstanceVariableNames := theClass fuelIgnoredInstanceVariableNames.		theClass fuelInstVarNamesAndOffsetsDo: [:name :index | 		(ignoredInstanceVariableNames includes: name) 			ifFalse: [ aBlock value: (anObject instVarAt: index) ]]! !!FLPointerObjectCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeInstancesStepWith: aSerialization	super serializeInstancesStepWith: aSerialization.		variablesMapping := FLVariablesMapping for: theClass.	variablesMapping serializeMappingOn: aSerialization stream.! !!FLPointerObjectCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeReferencesOf: anObject with: aSerialization		variablesMapping serializeReferencesOf: anObject with: aSerialization! !!FLPointerObjectCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeReferencesStepWith: aSerialization	objects do: [ :anObject | self serializeReferencesOf: anObject with: aSerialization ]! !FLPointerObjectCluster subclass: #FLVariableObjectCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLVariableObjectCluster commentStamp: 'MartinDias 5/30/2011 01:25' prior: 0!I am a generic cluster for objects with indexable variables.!FLVariableObjectCluster subclass: #FLMethodContextCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLMethodContextCluster commentStamp: 'MartinDias 5/30/2011 01:18' prior: 0!I am a cluster for MethodContexts.!!FLMethodContextCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializeInstanceWith: aMaterialization	^ theClass newFromFrameSize: aMaterialization stream next! !!FLMethodContextCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeInstance: aMethodContext with: aSerialization	aSerialization stream nextPut: aMethodContext method frameSize.! !!FLVariableObjectCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializeInstanceWith: aMaterialization	^theClass basicNew: aMaterialization nextEncodedPositiveInteger! !!FLVariableObjectCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializeReferencesOf: anObject with: aMaterialization	super materializeReferencesOf: anObject with: aMaterialization.	1 to: anObject basicSize 		do: [ :index | anObject basicAt: index put: aMaterialization nextEncodedReference ]! !!FLVariableObjectCluster methodsFor: 'analyzing' stamp: 'MartinDias 8/1/2011 01:36'!referencesOf: anObject do: aBlock	super referencesOf: anObject do: aBlock.	aBlock value: anObject basicSize.	1 to: anObject basicSize 		do: [ :index | aBlock value: (anObject basicAt: index) ]! !!FLVariableObjectCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeInstance: anObject with: aSerialization	aSerialization encodePositiveInteger: anObject basicSize! !!FLVariableObjectCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeReferencesOf: anObject with: aSerialization	super serializeReferencesOf: anObject with: aSerialization.		1 to: anObject basicSize do: [ :index |		aSerialization encodeReferenceTo: (anObject basicAt: index) ]! !FLIteratingCluster subclass: #FLOptimizedObjectCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters-Optionals'!FLOptimizedObjectCluster subclass: #FLAssociationCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters-Optionals'!!FLAssociationCluster commentStamp: 'MarianoMartinezPeck 10/23/2011 13:58' prior: 0!I am a specialized cluster for instances of Association.!!FLAssociationCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:22'!materializeInstanceWith: aMaterialization	"Since in Pharo #@ is associated with a special bytecode, it is faster than doing  Point basicNew"	^ Association basicNew	! !!FLAssociationCluster methodsFor: 'serialize/materialize' stamp: 'MarianoMartinezPeck 10/22/2011 20:23'!materializeReferencesOf: anAssociation with: aMaterialization		anAssociation key: aMaterialization nextEncodedReference value: aMaterialization nextEncodedReference.	! !!FLAssociationCluster methodsFor: 'analyzing' stamp: 'MarianoMartinezPeck 9/9/2011 18:17'!referencesOf: anAssociation do: aBlock	aBlock value: anAssociation key.	aBlock value: anAssociation value.	! !!FLAssociationCluster methodsFor: 'serialize/materialize' stamp: 'MarianoMartinezPeck 10/22/2011 20:20'!serializeReferencesOf: anAssociation with: aSerialization		aSerialization encodeReferenceTo: anAssociation key.		aSerialization encodeReferenceTo: anAssociation value.! !!FLOptimizedObjectCluster methodsFor: 'analyzing' stamp: 'MarianoMartinezPeck 10/22/2011 20:11'!clusterBucketIn: aClusterization	^aClusterization baselevelBucket! !!FLOptimizedObjectCluster methodsFor: 'serialize/materialize' stamp: 'MarianoMartinezPeck 10/22/2011 20:22'!materializeReferencesStepWith: aMaterialization	objects do: [ :anObject | self materializeReferencesOf: anObject with: aMaterialization ]! !!FLOptimizedObjectCluster methodsFor: 'analyzing' stamp: 'MarianoMartinezPeck 10/22/2011 20:23'!referencesOf: aRectangle do: aBlock	^ self subclassResponsibility ! !!FLOptimizedObjectCluster methodsFor: 'serialize/materialize' stamp: 'MarianoMartinezPeck 10/22/2011 20:11'!serializeInstances: aSerialization! !!FLOptimizedObjectCluster methodsFor: 'serialize/materialize' stamp: 'MarianoMartinezPeck 10/22/2011 20:22'!serializeReferencesOf: anObject with: aSerialization	^ self subclassResponsibility ! !!FLOptimizedObjectCluster methodsFor: 'serialize/materialize' stamp: 'MarianoMartinezPeck 10/22/2011 20:18'!serializeReferencesStepWith: aSerialization	objects do: [ :anObject | self serializeReferencesOf: anObject with: aSerialization ]! !FLOptimizedObjectCluster subclass: #FLPointCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters-Optionals'!!FLPointCluster commentStamp: 'MarianoMartinezPeck 9/8/2011 22:33' prior: 0!FLPointCluster is an optional class that optimizes Point instances, since there are a lot of instances in the system, it makes sense to optimize them. We take advantage of bytecode optimizations done by Pharo for messages like #@, #x and #y. In addition, we avoid the overhead of class reshape, etc. !!FLPointCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializeInstanceWith: aMaterialization	"Since in Pharo #@ is associated with a special bytecode, it is faster than doing  Point basicNew"	^ 0@0 	! !!FLPointCluster methodsFor: 'serialize/materialize' stamp: 'MarianoMartinezPeck 10/22/2011 20:23'!materializeReferencesOf: aPoint with: aMaterialization		aPoint setX: aMaterialization nextEncodedReference setY: aMaterialization nextEncodedReference.	! !!FLPointCluster methodsFor: 'analyzing' stamp: 'MarianoMartinezPeck 9/8/2011 21:37'!referencesOf: aPoint do: aBlock	aBlock value: aPoint x.	aBlock value: aPoint y.	! !!FLPointCluster methodsFor: 'serialize/materialize' stamp: 'MarianoMartinezPeck 10/22/2011 20:21'!serializeReferencesOf: aPoint with: aSerialization		aSerialization encodeReferenceTo: aPoint x.		aSerialization encodeReferenceTo: aPoint y.! !FLOptimizedObjectCluster subclass: #FLRectangleCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters-Optionals'!!FLRectangleCluster commentStamp: 'MarianoMartinezPeck 9/8/2011 22:53' prior: 0!FLRectangleCluster is an optional class that optimizes Rectangle instances, since there are a lot of instances in the system, it makes sense to optimize them. We take advantage of bytecode optimizations done by Pharo for messages like #new, #@, #x and #y. In addition, we avoid the overhead of class reshape, etc. !!FLRectangleCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializeInstanceWith: aMaterialization	"Since in Pharo #@ is associated with a special bytecode, it is faster than doing  Point basicNew"	^ Rectangle basicNew! !!FLRectangleCluster methodsFor: 'serialize/materialize' stamp: 'MarianoMartinezPeck 10/22/2011 20:23'!materializeReferencesOf: aRectangle with: aMaterialization				aRectangle 			setOrigin: aMaterialization nextEncodedReference @ aMaterialization nextEncodedReference			 	corner: aMaterialization nextEncodedReference @ aMaterialization nextEncodedReference.		 ! !!FLRectangleCluster methodsFor: 'analyzing' stamp: 'MarianoMartinezPeck 9/8/2011 22:45'!referencesOf: aRectangle do: aBlock	aBlock value: aRectangle origin x.	aBlock value: aRectangle origin y.	aBlock value: aRectangle corner x.	aBlock value: aRectangle corner y.! !!FLRectangleCluster methodsFor: 'serialize/materialize' stamp: 'MarianoMartinezPeck 10/22/2011 20:21'!serializeReferencesOf: aRectangle with: aSerialization		aSerialization encodeReferenceTo: aRectangle origin x.		aSerialization encodeReferenceTo: aRectangle origin y.		aSerialization encodeReferenceTo: aRectangle corner x.		aSerialization encodeReferenceTo: aRectangle corner y.! !FLIteratingCluster subclass: #FLPrimitiveCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLPrimitiveCluster commentStamp: 'MartinDias 8/29/2011 19:21' prior: 0!I am a cluster that serializes and materializes interacting directly with the stream.!FLPrimitiveCluster subclass: #FLBitmapCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters-Optionals'!!FLBitmapCluster commentStamp: 'MarianoMartinezPeck 9/6/2011 15:38' prior: 0!FLBitmapCluster is an optional cluster that optimizes Bitmap serialization. Bitmap are word-like objects, hence, they could use FLWordObjectCluster.  This optimization takes advantange of the existance of methods in Bitmap that can compress and uncompress the bitmap. The method Bitmap >> writeOn:   uses the method #compressToByteArray  and  Bitmap class >> newFromStream:  uses the method #decompressFromByteArray:  !!FLBitmapCluster methodsFor: 'serialize/materialize' stamp: 'MarianoMartinezPeck 9/16/2011 19:26'!materializeFrom: aReadStream	^Bitmap newFromStream: aReadStream! !!FLBitmapCluster methodsFor: 'serialize/materialize' stamp: 'MarianoMartinezPeck 9/16/2011 19:26'!serialize: aBitmap on: aWriteStream	aBitmap writeOn: aWriteStream! !FLPrimitiveCluster subclass: #FLByteStringCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLByteStringCluster commentStamp: 'MartinDias 5/30/2011 01:27' prior: 0!I am a cluster for ByteString.!!FLByteStringCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 8/15/2011 17:18'!materializeFrom: aReadStream	^ aReadStream nextString! !!FLByteStringCluster methodsFor: 'serialize/materialize' stamp: 'MarianoMartinezPeck 8/25/2011 13:20'!serialize: aSymbol on: aWriteStream	aWriteStream nextStringPut: aSymbol! !FLPrimitiveCluster subclass: #FLCharacterCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLCharacterCluster commentStamp: 'MartinDias 5/30/2011 01:27' prior: 0!I am a cluster for Character.!!FLCharacterCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2010 11:06'!materializeFrom: aReadStream	^Character value: aReadStream next! !!FLCharacterCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 11/22/2010 17:33'!serialize: aCharacter on: aWriteStream	aWriteStream nextPut: aCharacter codePoint! !FLPrimitiveCluster subclass: #FLDateAndTimeCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters-Optionals'!!FLDateAndTimeCluster commentStamp: 'MarianoMartinezPeck 9/2/2011 15:42' prior: 0!FLDateAndTimeCluster is an optional cluster that optimizes the serialization of DateAndTime instances. This cluster can be removed and the regular serialization will still work.We can do this cluster because we are sure that:(DateAndTime allInstances collect: [:each | each julianDayNumber class]) asSet.  -> a Set(SmallInteger)(DateAndTime allInstances collect: [:each | each nanoSecond class]) asSet. -> a Set(SmallInteger)(DateAndTime allInstances collect: [:each | each secondsSinceMidnight class]) asSet. -> a Set(SmallInteger)(DateAndTime allInstances collect: [:each | each offset class]) asSet. -> a Set(Duration)Notice that we need to fix the subclasses of DateAndTime. In this case, TimeStamp. Otherwise, if subclasses add instance variables, they will answer #acceptFuel: of this class which follows a #visitDate. And that is not correct. Even more, FLDateAndTimeStamp directly uses the class DateAndTime to materialize.  !!FLDateAndTimeCluster methodsFor: 'serialize/materialize' stamp: 'MarianoMartinezPeck 9/9/2011 17:15'!materializeFrom: aReadStream	^ DateAndTime 		fuelFrom: (aReadStream int32)		nanoSecond: (aReadStream int32)		seconds: (aReadStream int32)		offset: (Duration seconds: (aReadStream int32) nanoSeconds: (aReadStream int32) ).! !!FLDateAndTimeCluster methodsFor: 'serialize/materialize' stamp: 'MarianoMartinezPeck 9/9/2011 17:14'!serialize: aDateAndTime on: aWriteStream	aWriteStream 		int32: aDateAndTime julianDayNumber;		int32: aDateAndTime nanoSecond;		int32: aDateAndTime secondsSinceMidnight;		int32: aDateAndTime offset asSeconds;		int32: aDateAndTime offset nanoSeconds.! !FLPrimitiveCluster subclass: #FLDateCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters-Optionals'!!FLDateCluster commentStamp: 'MarianoMartinezPeck 9/2/2011 14:36' prior: 0!FLDateCluster is an optional cluster that optimizes the serialization of Date instances. This cluster can be removed and the regular serialization will still work.We can do this cluster because we are sure that:(Date allInstances collect: [:each | each julianDayNumber class]) asSet.answers only SmallInteger. And also because there are no subclasses. Otherwise, if subclasses add instance variables, they will answer #acceptFuel: of this class which follows a #visitDate. And that is not correct. !!FLDateCluster methodsFor: 'serialize/materialize' stamp: 'MarianoMartinezPeck 9/9/2011 17:15'!materializeFrom: aReadStream		^ Date fuelFromjulianDayNumber: (aReadStream int32)! !!FLDateCluster methodsFor: 'serialize/materialize' stamp: 'MarianoMartinezPeck 9/9/2011 17:14'!serialize: aDate on: aWriteStream	aWriteStream 		int32: aDate julianDayNumber.! !FLPrimitiveCluster subclass: #FLDurationCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters-Optionals'!!FLDurationCluster commentStamp: 'MarianoMartinezPeck 9/2/2011 14:36' prior: 0!FLDurationCluster is an optional cluster that optimizes the serialization of Duration instances. This cluster can be removed and the regular serialization will still work.We can do this cluster because we are sure that:(Duration allInstances collect: [:each | each asSeconds class]) asSet.(Duration allInstances collect: [:each | each nanoSeconds class]) asSet.both answer only SmallInteger. And also because there are no subclasses. Otherwise, if subclasses add instance variables, they will answer #acceptFuel: of this class which follows a #visitDuration. And that is not correct. !!FLDurationCluster methodsFor: 'serialize/materialize' stamp: 'MarianoMartinezPeck 9/9/2011 17:15'!materializeFrom: aReadStream	^ Duration seconds: (aReadStream int32) nanoSeconds: (aReadStream int32) 	! !!FLDurationCluster methodsFor: 'serialize/materialize' stamp: 'MarianoMartinezPeck 9/9/2011 17:14'!serialize: aDuration on: aWriteStream	aWriteStream 		int32: aDuration asSeconds;		int32: aDuration nanoSeconds	! !FLPrimitiveCluster subclass: #FLFloatCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters-Optionals'!!FLFloatCluster commentStamp: 'MarianoMartinezPeck 9/6/2011 18:13' prior: 0!I am a cluster for 8-byte Floats. Implementation extracted from ReferenceStream.Notice that this cluster is optional, since the current version of FLWordObjectCluster supports Floats as well. But be aware that it is not common that the regular way of serializing word objects will work also with floats. Float is special. Read Float >> basicAt:  and #basicAt:put:  for more details. Conclusion: it is optional because FLWordObjectCluster has a special way to serialize word objects which supports Float, but it may not be the case in other implementations. !!FLFloatCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/21/2010 13:27'!materializeFrom: aReadStream	^ (Float new: 2)		at: 1 put: (aReadStream nextNumber: 4);		at: 2 put: (aReadStream nextNumber: 4);		yourself.! !!FLFloatCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/21/2010 10:39'!serialize: aFloat on: aWriteStream	aWriteStream 		nextNumber: 4 put: (aFloat at: 1);		nextNumber: 4 put: (aFloat at: 2).! !FLPrimitiveCluster subclass: #FLGlobalCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLGlobalCluster commentStamp: 'MartinDias 9/16/2011 14:49' prior: 0!I am a cluster for objects that are reachables from Smalltalk global dictionary.!FLGlobalCluster subclass: #FLGlobalAssociationCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLGlobalAssociationCluster commentStamp: 'MartinDias 5/30/2011 01:28' prior: 0!I am a cluster for variable bindings that belong to Smalltalk global dictionary.For example, 	Smalltalk globals associationAt: #Transcript 	could be serialized and materialized by me.!!FLGlobalAssociationCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 9/19/2011 14:35'!materializeFrom: aReadStream	^self materializeGlobalAssociationFrom: aReadStream! !!FLGlobalAssociationCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 9/19/2011 14:35'!serialize: anAssociation on: aWriteStream		self serializeGlobalAssociationKeyed: anAssociation key on: aWriteStream ! !FLGlobalCluster subclass: #FLGlobalClassCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLGlobalClassCluster commentStamp: 'MartinDias 5/30/2011 01:28' prior: 0!I am a cluster for classes that should be present when materializing. In other words, it only serializes a reference to the class, using its name.!!FLGlobalClassCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 9/19/2011 14:35'!materializeFrom: aReadStream	^self materializeGlobalClassFrom: aReadStream ! !!FLGlobalClassCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 9/19/2011 14:35'!serialize: aClass on: aWriteStream		self serializeGlobalClass: aClass on: aWriteStream! !FLGlobalCluster subclass: #FLGlobalClassSideCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLGlobalClassSideCluster commentStamp: 'MartinDias 8/1/2011 02:57' prior: 0!I am a cluster for those Metaclasses and ClassTrait who are not stored in detail.!!FLGlobalClassSideCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 9/19/2011 14:35'!materializeFrom: aReadStream	^(self materializeGlobalClassFrom: aReadStream) classSide! !!FLGlobalClassSideCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 9/19/2011 14:35'!serialize: aClassOrTraitClassSide on: aWriteStream	self serializeGlobalClass: aClassOrTraitClassSide instanceSide on: aWriteStream! !!FLGlobalCluster methodsFor: 'analyzing' stamp: 'MartinDias 9/15/2011 20:16'!clusterBucketIn: aClusterization	^aClusterization globalsBucket ! !!FLGlobalCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/24/2011 17:55'!materializeGlobalAssociationFrom: aStream	| globalName |	globalName := aStream nextString asSymbol.	^Smalltalk globals 		associationAt: globalName		ifAbsent: [ FLGlobalNotFound signalWithName: globalName ]! !!FLGlobalCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/24/2011 17:52'!materializeGlobalClassFrom: aStream	| className |	className := aStream nextString asSymbol.	^ Smalltalk globals 		at: className		ifAbsent: [ FLClassNotFound signalWithName: className ]! !!FLGlobalCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 9/19/2011 14:35'!serializeGlobalAssociationKeyed: aSymbol on: aStream		aStream nextStringPut: aSymbol! !!FLGlobalCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 9/19/2011 14:35'!serializeGlobalClass: aClass on: aStream		aStream nextStringPut: aClass name ! !FLGlobalCluster subclass: #FLGlobalSendCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLGlobalSendCluster commentStamp: 'MarianoMartinezPeck 10/23/2011 14:39' prior: 0!I clusterize objects that will be obtained on materialization via a message send to a global object. Explained with an example:Suppose we have a special instance of User that represents the admin user, and it is a unique instance in the image. In case the admin user is referenced in our graph, we want to treat that object as a global. We can do that in this way:User >> fuelAccept: aVisitor    ^self == User admin        ifTrue: [aVisitor visitGlobalSend: self]        ifFalse: [super fuelAccept: aVisitor]User >> fuelGlobalName    ^#UserUser >> fuelSelector    ^#adminSo what will happen is that during serialization, the admin user won't be completly serialized (with all its intance variables) but instead its global name and selector are stored. Then, at materialization time, Fuel will send the selector #admin to the class User, and use what that answers as the admin user of the materialized graph.We test this feature in FLGlobalSendSerializationTest.!!FLGlobalSendCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/5/2011 15:36'!materializeFrom: aReadStream	| global selector |	global := (self materializeGlobalAssociationFrom: aReadStream) value.		selector := aReadStream nextString asSymbol.	^ global perform: selector! !!FLGlobalSendCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/5/2011 15:43'!serialize: anObject on: aWriteStream		self serializeGlobalAssociationKeyed: anObject fuelGlobalName on: aWriteStream.	aWriteStream nextStringPut: anObject fuelSelector.! !FLGlobalCluster subclass: #FLGlobalValueCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLGlobalValueCluster commentStamp: 'MartinDias 5/30/2011 01:28' prior: 0!I am a cluster for known objects that belong to Smalltalk global dictionary.For example, Transcript could be serialized and materialized by me.!!FLGlobalValueCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 9/19/2011 14:35'!materializeFrom: aReadStream	^(self materializeGlobalAssociationFrom: aReadStream) value! !!FLGlobalValueCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 9/19/2011 14:35'!serialize: anObject on: aWriteStream		self serializeGlobalAssociationKeyed: (Smalltalk keyAtValue: anObject) on: aWriteStream! !!FLPrimitiveCluster methodsFor: 'analyzing' stamp: 'MartinDias 10/13/2011 16:26'!add: anObject traceWith: aAnalysis	"Add an object to the cluster. We know the object doesn't have references."	objects addLast: anObject! !!FLPrimitiveCluster methodsFor: 'analyzing' stamp: 'MartinDias 9/17/2011 00:28'!clusterBucketIn: aClusterization	^aClusterization primitivesBucket ! !!FLPrimitiveCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2010 13:30'!materializeFrom: aReadStream	"Hook method that each subclass should customize for its special way of materializing"		self subclassResponsibility ! !!FLPrimitiveCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:23'!materializeInstanceWith: aMaterialization		^self materializeFrom: aMaterialization stream.  ! !!FLPrimitiveCluster methodsFor: 'analyzing' stamp: 'MartinDias 9/19/2011 14:06'!newSerializingCollection	"Answer a collection for the objects that correspond to this cluster."	^OrderedCollection new! !!FLPrimitiveCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:26'!registerIndexesOn: aDictionary	self flag: #todo. "Converting objects collection here in this method is a bit confusing. This is because since this cluster is for primitives, they do not have pointers to other objects. Hence, instead of storing them in a IdentitySet we can use an OrderedCollection and then just convert them at the end. For more details see FLPrimitiveCluster >> #add: anObject traceWith: aAnalysis"	objects := objects asIdentitySet.	super registerIndexesOn: aDictionary.! !!FLPrimitiveCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2010 13:29'!serialize: anObject on: aWriteStream	"Hook method that each subclass should customize for its special way of serializing"		self subclassResponsibility! !!FLPrimitiveCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeInstance: anObject with: aSerialization	self serialize: anObject on: aSerialization stream! !FLPrimitiveCluster subclass: #FLSmallIntegerCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLSmallIntegerCluster commentStamp: '<historical>' prior: 0!I don't have so much sense as a class, but I know which of my subclasses corresponds to each SmallInteger.!FLSmallIntegerCluster subclass: #FLNegativeSmallIntegerCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLNegativeSmallIntegerCluster commentStamp: 'MartinDias 5/30/2011 01:29' prior: 0!I am a cluster for negative SmallInteger instances.!!FLNegativeSmallIntegerCluster methodsFor: 'serialize/materialize' stamp: 'mariano 10/6/2011 11:43'!materializeFrom: aReadStream		^ aReadStream uint32 negated ! !!FLNegativeSmallIntegerCluster methodsFor: 'serialize/materialize' stamp: 'mariano 10/6/2011 11:43'!serialize: anInteger on: aWriteStream		aWriteStream uint32: anInteger abs! !FLSmallIntegerCluster subclass: #FLPositiveSmallIntegerCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLPositiveSmallIntegerCluster commentStamp: 'MartinDias 5/30/2011 01:29' prior: 0!I am a cluster for positive SmallInteger instances.!!FLPositiveSmallIntegerCluster methodsFor: 'serialize/materialize' stamp: 'mariano 10/6/2011 11:43'!materializeFrom: aReadStream	^ aReadStream uint32! !!FLPositiveSmallIntegerCluster methodsFor: 'serialize/materialize' stamp: 'mariano 10/6/2011 11:43'!serialize: anInteger on: aWriteStream	aWriteStream uint32: anInteger! !!FLSmallIntegerCluster class methodsFor: 'instance creation' stamp: 'mariano 10/6/2011 17:30'!for: aSmallInteger	"Returns the right subclass instance"	^ ((aSmallInteger bitAnd: 16rFFFF) = aSmallInteger)		ifTrue: [ ^ FLUInt16Cluster new ]		ifFalse: [ ^ FLPositiveSmallIntegerCluster new]	! !FLSmallIntegerCluster subclass: #FLUInt16Cluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLUInt16Cluster commentStamp: 'MartinDias 5/30/2011 01:29' prior: 0!I am a cluster for SmallInteger instances between 0 and 16rFFFF.!!FLUInt16Cluster methodsFor: 'serialize/materialize' stamp: 'mariano 10/6/2011 11:44'!materializeFrom: aReadStream	^ aReadStream uint16! !!FLUInt16Cluster methodsFor: 'serialize/materialize' stamp: 'mariano 10/6/2011 11:44'!serialize: anInteger on: aWriteStream	aWriteStream uint16: anInteger! !FLPrimitiveCluster subclass: #FLSymbolCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLSymbolCluster commentStamp: 'MartinDias 5/30/2011 01:29' prior: 0!I am a cluster for Symbol instances.!!FLSymbolCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/26/2010 14:22'!materializeFrom: aReadStream	^ aReadStream nextString asSymbol! !!FLSymbolCluster methodsFor: 'serialize/materialize' stamp: 'MarianoMartinezPeck 8/25/2011 13:21'!serialize: aSymbol on: aWriteStream	aWriteStream nextStringPut: aSymbol! !FLPrimitiveCluster subclass: #FLTimeCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters-Optionals'!!FLTimeCluster commentStamp: 'MarianoMartinezPeck 9/2/2011 14:36' prior: 0!FLTimeCluster is an optional cluster that optimizes the serialization of Time instances. This cluster can be removed and the regular serialization will still work.We can do this cluster because we are sure that:(Time allInstances collect: [:each | each asSeconds class]) asSet.answers only SmallInteger. And also because there are no subclasses. Otherwise, if subclasses add instance variables, they will answer #acceptFuel: of this class which follows a #visitTime. And that is not correct. !!FLTimeCluster methodsFor: 'serialize/materialize' stamp: 'MarianoMartinezPeck 9/20/2011 20:51'!materializeFrom: aReadStream		^ Time seconds:  (aReadStream int32) nanoSeconds:  (aReadStream int32)! !!FLTimeCluster methodsFor: 'serialize/materialize' stamp: 'MarianoMartinezPeck 9/20/2011 20:51'!serialize: aTime on: aWriteStream	aWriteStream 		int32: aTime asSeconds;		int32: aTime nanoSecond.! !FLCluster subclass: #FLSubstitutionCluster	instanceVariableNames: 'substitutions'	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLSubstitutionCluster commentStamp: 'MartinDias 8/29/2011 19:25' prior: 0!I am a cluster for objects that have to be replaced in the object graph by a substitute object.!FLSubstitutionCluster subclass: #FLHookSubstitutionCluster	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLHookSubstitutionCluster commentStamp: 'MartinDias 8/29/2011 19:30' prior: 0!I am a cluster for substituted objects, where such substitution is provided by a method hook.Suppose you want to substitute instances of WriteStream by nil. In such case, WriteStream has to implement these two methods:fuelAccept: aVisitor	^aVisitor visitSubstitution: selffuelSubstitution	^nil!!FLHookSubstitutionCluster methodsFor: 'accessing' stamp: 'MartinDias 8/21/2011 00:46'!substitutionFor: anObject		^anObject fuelSubstitution! !FLSubstitutionCluster subclass: #FLPluggableSubstitutionCluster	instanceVariableNames: 'factory'	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLPluggableSubstitutionCluster commentStamp: 'MartinDias 8/29/2011 19:32' prior: 0!I am a cluster for substituted objects, where such substitution is provided by a factory block.Suppose you want to substitute every integer in the graph by its string representation. In such case you should configure the analyzer through:anAnalyzer when: [:x | x isInteger] substituteBy: [:x | x printString].In this way, when you serialize #(1 2), you will then materialize #('1' '2')!!FLPluggableSubstitutionCluster class methodsFor: 'instance creation' stamp: 'MarianoMartinezPeck 10/24/2011 16:41'!with: aFactory	^self basicNew		initializeWith: aFactory;		yourself.! !!FLPluggableSubstitutionCluster methodsFor: 'initialize-release' stamp: 'MarianoMartinezPeck 10/24/2011 16:42'!initializeWith: aFactory	super initialize.	factory := aFactory! !!FLPluggableSubstitutionCluster methodsFor: 'accessing' stamp: 'MartinDias 8/21/2011 00:45'!substitutionFor: anObject		^factory value: anObject! !!FLSubstitutionCluster methodsFor: 'analyzing' stamp: 'MartinDias 10/13/2011 16:26'!add: anObject traceWith: aAnalysis	substitutions 		at: anObject 		ifAbsent: [ 			| substitution |			substitution := self substitutionFor: anObject.			substitutions at: anObject put: substitution.			aAnalysis trace: substitution ] ! !!FLSubstitutionCluster methodsFor: 'analyzing' stamp: 'MartinDias 8/20/2011 22:50'!clusterBucketIn: aClusterization	^aClusterization substitutionsBucket! !!FLSubstitutionCluster methodsFor: 'initialize-release' stamp: 'MartinDias 8/20/2011 23:17'!initialize	super initialize.	substitutions := IdentityDictionary new.! !!FLSubstitutionCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:22'!materializeInstancesStepWith: aMaterialization	"This cluster does nothing."! !!FLSubstitutionCluster methodsFor: 'accessing' stamp: 'MartinDias 8/29/2011 01:04'!objects	"This cluster does not have objects"		^#()! !!FLSubstitutionCluster methodsFor: 'printing' stamp: 'MartinDias 8/29/2011 01:16'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '->'.	substitutions printElementsOn: aStream! !!FLSubstitutionCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 8/20/2011 23:18'!registerIndexesOn: aDictionary	substitutions keysAndValuesDo: [ :anObject :theSubstitution | 		| substitutionIndex |		substitutionIndex := aDictionary at: theSubstitution.		aDictionary at: anObject put: substitutionIndex. ].! !!FLSubstitutionCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeInstancesStepWith: aSerialization	"This cluster does nothing."! !!FLSubstitutionCluster methodsFor: 'accessing' stamp: 'MartinDias 8/21/2011 00:45'!substitutionFor: anObject		self subclassResponsibility! !FLCluster subclass: #FLWellKnownObjectsCluster	instanceVariableNames: ''	classVariableNames: 'WellKnownObjects'	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLWellKnownObjectsCluster commentStamp: 'MartinDias 8/1/2011 03:00' prior: 0!I am a cluster for some well known objects like nil, true and false. They have a special treatment because they are so common in the image.!!FLWellKnownObjectsCluster class methodsFor: 'class initialization' stamp: 'MartinDias 8/30/2011 00:53'!initialize	WellKnownObjects := Array		with: nil		with: true		with: false		with: Smalltalk globals! !!FLWellKnownObjectsCluster methodsFor: 'analyzing' stamp: 'MartinDias 10/13/2011 16:26'!add: anObject traceWith: aAnalysis	"Do nothing. THis is an optimization. As you see, anObject is not added. In the conrary, #registerIndexesOn: directly serializes all the array of WellKnownObjects. See #objects"! !!FLWellKnownObjectsCluster methodsFor: 'analyzing' stamp: 'MartinDias 9/17/2011 00:28'!clusterBucketIn: aClusterization	^aClusterization primitivesBucket! !!FLWellKnownObjectsCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:22'!materializeInstancesStepWith: aMaterialization! !!FLWellKnownObjectsCluster methodsFor: 'accessing' stamp: 'MarianoMartinezPeck 9/28/2011 23:15'!objects	" This is an optimization. We always serialize all the WellKnownObjects"	^WellKnownObjects! !!FLWellKnownObjectsCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 8/30/2011 00:46'!registerIndexesOn: aDictionary	self objects do: [ :instance | aDictionary at: instance put: aDictionary size + 1 ].! !!FLWellKnownObjectsCluster methodsFor: 'serialize/materialize' stamp: 'MartinDias 10/13/2011 16:20'!serializeInstancesStepWith: aSerialization! !Object subclass: #FLClusterization	instanceVariableNames: 'baselevelBucket substitutionsBucket globalsBucket metalevelInstanceSideBucket metalevelClassSideBucket primitivesBucket'	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core'!!FLClusterization commentStamp: 'MartinDias 8/29/2011 19:12' prior: 0!I manage the clusters collected during the analysis step of serialization.!!FLClusterization methodsFor: 'analyzing' stamp: 'MartinDias 8/20/2011 22:16'!add: aCluster traceWith: anAnalyzer	| clusterBucket |	clusterBucket := aCluster clusterBucketIn: self.		clusterBucket 		addIfNotPresent: aCluster 		ifPresentDo: [ ^self ].	aCluster clusterReferencesDo: [ :aChild | anAnalyzer trace: aChild ]! !!FLClusterization methodsFor: 'cluster buckets' stamp: 'MartinDias 8/20/2011 22:27'!baselevelBucket		^ baselevelBucket! !!FLClusterization methodsFor: 'accessing' stamp: 'MartinDias 9/17/2011 00:29'!clusterBuckets	"Answer a new collection with all the clusters that have been collected in trace. Note that order is imporant."	^ OrderedCollection new 		add: globalsBucket;		add: primitivesBucket;		add: metalevelClassSideBucket;		add: metalevelInstanceSideBucket;		add: baselevelBucket;		add: substitutionsBucket;		yourself.! !!FLClusterization methodsFor: 'accessing' stamp: 'MartinDias 8/20/2011 19:47'!clusters	"Returns collection with all the clustered objects, in Association instances."		^self clusterBuckets inject: OrderedCollection new into: [:c :d | c addAll: d. c ].! !!FLClusterization methodsFor: 'cluster buckets' stamp: 'MartinDias 9/15/2011 20:16'!globalsBucket		^ globalsBucket ! !!FLClusterization methodsFor: 'initialize-release' stamp: 'MarianoMartinezPeck 9/23/2011 23:15'!initialize	super initialize.	primitivesBucket := IdentitySet new.	baselevelBucket := IdentitySet new.	globalsBucket := IdentitySet new.	metalevelInstanceSideBucket := IdentitySet new.	metalevelClassSideBucket := IdentitySet new.	substitutionsBucket := IdentitySet new.! !!FLClusterization methodsFor: 'cluster buckets' stamp: 'MartinDias 9/17/2011 00:27'!metalevelClassSideBucket		^ metalevelClassSideBucket! !!FLClusterization methodsFor: 'cluster buckets' stamp: 'MartinDias 9/17/2011 00:27'!metalevelInstanceSideBucket		^ metalevelInstanceSideBucket ! !!FLClusterization methodsFor: 'accessing' stamp: 'MartinDias 8/20/2011 22:49'!objectCount	^self clusterBuckets sum: [ :aClusterBucket | 		aClusterBucket			inject: 0 			into: [ :sum :aCluster | sum + aCluster objects size ] ].! !!FLClusterization methodsFor: 'cluster buckets' stamp: 'MartinDias 9/17/2011 00:29'!primitivesBucket		^ primitivesBucket! !!FLClusterization methodsFor: 'cluster buckets' stamp: 'MartinDias 8/20/2011 22:52'!substitutionsBucket		^ substitutionsBucket! !Object subclass: #FLCompiledMethodTrailerEncoderNoChange	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters-InternalMetalevel'!!FLCompiledMethodTrailerEncoderNoChange methodsFor: 'method encoding' stamp: 'MarianoMartinezPeck 9/23/2011 16:37'!compiledMethodToSerialize: aCompiledMethod	^ aCompiledMethod! !Object subclass: #FLCompiledMethodTrailerEncoderNoSource	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters-InternalMetalevel'!!FLCompiledMethodTrailerEncoderNoSource methodsFor: 'method encoding' stamp: 'MarianoMartinezPeck 9/23/2011 23:21'!compiledMethodToSerialize: aCompiledMethod	^ aCompiledMethod copyWithTrailerBytes: CompiledMethodTrailer empty.! !Object subclass: #FLMapper	instanceVariableNames: 'next'	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Mappers'!!FLMapper commentStamp: 'MartinDias 8/11/2011 03:09' prior: 0!The purpose of my hierarchy is to map objects with clusters.!FLMapper subclass: #FLClassPoolAssociationMapper	instanceVariableNames: 'internalClasses classPoolBindings clustersByClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Mappers'!!FLClassPoolAssociationMapper commentStamp: 'MartinDias 5/30/2011 01:14' prior: 0!I map variable class variable associations, i.e. bindings that belong to the class pool of a Class existent on Smalltalk globals. !!FLClassPoolAssociationMapper methodsFor: 'accessing' stamp: 'MartinDias 8/18/2011 20:31'!accepts: anObject	^ anObject isVariableBinding and: [ (self isClassVariableBinding: anObject) and: [ self isExternal: anObject ] ]! !!FLClassPoolAssociationMapper methodsFor: 'accessing' stamp: 'MartinDias 8/7/2011 16:39'!clusterFor: anObject		| theClass |	theClass := classPoolBindings at: anObject.		^clustersByClass 		at: theClass 		ifAbsentPut: [ FLClassPoolAssociationCluster for: theClass ]! !!FLClassPoolAssociationMapper methodsFor: 'initialize-release' stamp: 'MartinDias 8/18/2011 20:32'!initialize	super initialize.	clustersByClass := IdentityDictionary new.	internalClasses := OrderedCollection new.	classPoolBindings := IdentityDictionary new.	Smalltalk allClassesAndTraitsDo: [ :aClass | 				aClass classPool associationsDo: [ :aBinding | 					classPoolBindings at: aBinding put: aClass ] ].! !!FLClassPoolAssociationMapper methodsFor: 'accessing' stamp: 'MarianoMartinezPeck 7/6/2011 14:31'!internalObjects: internalGlobalObjects	internalClasses := internalGlobalObjects select: [ :anObject | anObject isBehavior ]! !!FLClassPoolAssociationMapper methodsFor: 'private' stamp: 'eem 6/8/2011 11:50'!isClassVariableBinding: anObject	^classPoolBindings includesKey: anObject! !!FLClassPoolAssociationMapper methodsFor: 'private' stamp: 'eem 6/8/2011 11:50'!isExternal: anObject	^ (internalClasses includes: (classPoolBindings at: anObject)) not! !FLMapper subclass: #FLDefaultMapper	instanceVariableNames: 'wellKnownObjectCluster characterCluster classCluster classTraitCluster compiledMethodCluster namedCompiledMethodCluster floatCluster metaclassCluster shortCluster symbolCluster traitCluster byteObjectClusters variableObjectClusters fixedObjectClusters wordObjectClusters byteStringCluster hookSubstitutionCluster dateCluster timeCluster durationCluster dateAndTimeCluster bitmapCluster pointCluster rectangleCluster associationCluster globalSendCluster positiveSmallIntegerCluster negativeSmallIntegerCluster'	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Mappers'!!FLDefaultMapper commentStamp: 'MartinDias 8/7/2011 12:24' prior: 0!I know how to map an object to its default cluster. I can map every object.!!FLDefaultMapper methodsFor: 'accessing' stamp: 'MartinDias 8/7/2011 12:22'!accepts: anObject	^ true! !!FLDefaultMapper methodsFor: 'accessing' stamp: 'MartinDias 8/11/2011 03:02'!chainedClusterFor: anObject	^anObject fuelAccept: self! !!FLDefaultMapper methodsFor: 'accessing' stamp: 'MartinDias 8/7/2011 12:47'!clusterFor: anObject	^anObject fuelAccept: self! !!FLDefaultMapper methodsFor: 'initialize-release' stamp: 'MarianoMartinezPeck 10/6/2011 11:51'!initialize	super initialize.	fixedObjectClusters := IdentityDictionary new.	variableObjectClusters := IdentityDictionary new.	byteObjectClusters := IdentityDictionary new.	wordObjectClusters := IdentityDictionary new.	globalSendCluster := FLGlobalSendCluster new.		wellKnownObjectCluster := FLWellKnownObjectsCluster new.	characterCluster := FLCharacterCluster new.	classCluster := FLClassCluster new.	classTraitCluster := FLClassTraitCluster new.	compiledMethodCluster := FLCompiledMethodCluster withNoTrailerChange.	namedCompiledMethodCluster := FLNamedPrimitiveMethodCluster withNoTrailerChange.	floatCluster := FLFloatCluster new.	metaclassCluster := FLMetaclassCluster new.	shortCluster := FLUInt16Cluster new.	positiveSmallIntegerCluster := FLPositiveSmallIntegerCluster new.	negativeSmallIntegerCluster := FLNegativeSmallIntegerCluster new.	symbolCluster := FLSymbolCluster new.	traitCluster := FLTraitCluster new.	byteStringCluster := FLByteStringCluster new.	hookSubstitutionCluster := FLHookSubstitutionCluster new.	dateCluster := FLDateCluster new.	timeCluster := FLTimeCluster new. 	durationCluster := FLDurationCluster new.	dateAndTimeCluster := FLDateAndTimeCluster new.	bitmapCluster := FLBitmapCluster new.	pointCluster := FLPointCluster new.	rectangleCluster := FLRectangleCluster new.	associationCluster := FLAssociationCluster new.! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MarianoMartinezPeck 9/9/2011 18:18'!visitAssociation: anAssociation	^associationCluster! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MarianoMartinezPeck 9/6/2011 15:09'!visitBitmap: aBitmap	^bitmapCluster	! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MartinDias 8/11/2011 02:36'!visitBoolean: aBoolean	^wellKnownObjectCluster! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MartinDias 8/15/2011 17:20'!visitByteString: aSymbol	^byteStringCluster! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MartinDias 8/11/2011 03:04'!visitBytesObject: anObject	^byteObjectClusters		at: anObject class		ifAbsentPut: [ FLByteObjectCluster for: anObject class ]! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MartinDias 8/11/2011 03:06'!visitCharacter: aCharacter	^aCharacter isOctetCharacter 		ifTrue: [ characterCluster ]		ifFalse: [ 			fixedObjectClusters				at: aCharacter class				ifAbsentPut: [ FLFixedObjectCluster for: aCharacter class ]]! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MartinDias 8/11/2011 02:38'!visitClass: aClass	^classCluster! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MartinDias 8/11/2011 02:38'!visitClassTrait: aClassTrait	^classTraitCluster! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MartinDias 8/11/2011 02:39'!visitCompiledMethod: aCompiledMethod	^aCompiledMethod isNamedPrimitive		ifTrue:  [ namedCompiledMethodCluster ]		ifFalse: [ compiledMethodCluster ]! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MarianoMartinezPeck 9/1/2011 20:45'!visitDate: aDate	^dateCluster! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MarianoMartinezPeck 9/2/2011 15:15'!visitDateAndTime: aDateAndTime	^dateAndTimeCluster! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MarianoMartinezPeck 9/1/2011 23:20'!visitDuration: aTime	^durationCluster! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MartinDias 8/11/2011 03:05'!visitFixedObject: anObject	^fixedObjectClusters		at: anObject class		ifAbsentPut: [ FLFixedObjectCluster for: anObject class ]! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MartinDias 8/11/2011 02:39'!visitFloat: aFloat	^floatCluster! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MartinDias 10/5/2011 15:39'!visitGlobalSend: anObject	^globalSendCluster! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MartinDias 8/11/2011 03:05'!visitLargeInteger: anObject	^byteObjectClusters		at: anObject class		ifAbsentPut: [ FLByteObjectCluster for: anObject class ]! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MartinDias 8/11/2011 02:39'!visitMetaclass: aMetaclass	^metaclassCluster! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MartinDias 8/11/2011 03:05'!visitMethodContext: aMethodContext	^variableObjectClusters		at: aMethodContext class		ifAbsentPut: [ FLMethodContextCluster for: aMethodContext class ]! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MarianoMartinezPeck 9/8/2011 21:31'!visitPoint: aDate	^pointCluster! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MarianoMartinezPeck 9/8/2011 22:47'!visitRectangle: aRectangle	^ rectangleCluster! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'mariano 10/6/2011 11:23'!visitSmallInteger: aSmallInteger    	((aSmallInteger bitAnd: 16rFFFF) = aSmallInteger)		ifTrue: [ ^shortCluster ].	^aSmallInteger > 0 		ifTrue: [ positiveSmallIntegerCluster ]		ifFalse: [ negativeSmallIntegerCluster ]		! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MartinDias 8/21/2011 01:08'!visitSubstitution: anObject	^hookSubstitutionCluster! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MartinDias 8/11/2011 02:43'!visitSymbol: aSymbol	^symbolCluster! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MartinDias 8/11/2011 02:43'!visitSystemDictionary: anObject	^wellKnownObjectCluster! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MarianoMartinezPeck 9/1/2011 21:09'!visitTime: aTime	^timeCluster! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MartinDias 8/11/2011 02:43'!visitTrait: aTrait	^traitCluster! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MartinDias 8/11/2011 02:43'!visitUndefinedObject: anObject	^wellKnownObjectCluster! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MarianoMartinezPeck 9/2/2011 14:44'!visitVariableObject: anObject	^variableObjectClusters		at: anObject class		ifAbsentPut: [ FLVariableObjectCluster for: anObject class ]! !!FLDefaultMapper methodsFor: 'visiting' stamp: 'MartinDias 8/11/2011 03:07'!visitWordsObject: anObject	^wordObjectClusters		at: anObject class		ifAbsentPut: [ FLWordObjectCluster for: anObject class ]! !FLMapper subclass: #FLGlobalAssociationMapper	instanceVariableNames: 'internalAssociations cluster'	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Mappers'!!FLGlobalAssociationMapper commentStamp: 'MartinDias 5/30/2011 01:15' prior: 0!I map variable bindings that belong to Smalltalk global dictionary.For example, 	Smalltalk globals associationAt: #Transcript 	is mapped by me.!!FLGlobalAssociationMapper methodsFor: 'accessing' stamp: 'MartinDias 5/30/2011 02:01'!accepts: anObject	^ anObject isVariableBinding and: [(self isGlobalAssociation: anObject) and: [ self isExternalAssociation: anObject ]].! !!FLGlobalAssociationMapper methodsFor: 'accessing' stamp: 'MartinDias 8/11/2011 02:34'!clusterFor: anObject	^cluster! !!FLGlobalAssociationMapper methodsFor: 'initialize-release' stamp: 'MartinDias 8/11/2011 02:34'!initialize	super initialize.	internalAssociations := OrderedCollection new.	cluster := FLGlobalAssociationCluster new.! !!FLGlobalAssociationMapper methodsFor: 'accessing' stamp: 'MarianoMartinezPeck 7/6/2011 14:30'!internalObjects: aCollection	internalAssociations := aCollection collect: [:aGlobal | Smalltalk globals associationAt: aGlobal name ]! !!FLGlobalAssociationMapper methodsFor: 'private' stamp: 'MartinDias 5/20/2011 04:10'!isExternalAssociation: anObject	^ (internalAssociations includes: anObject ) not! !!FLGlobalAssociationMapper methodsFor: 'private' stamp: 'MartinDias 5/20/2011 04:13'!isGlobalAssociation: anObject	^ Smalltalk globals includesAssociation: anObject! !FLMapper subclass: #FLGlobalBehaviorMapper	instanceVariableNames: 'internalGlobals globalBehaviors classSideCluster instanceSideCluster'	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Mappers'!!FLGlobalBehaviorMapper commentStamp: 'MartinDias 8/6/2011 23:51' prior: 0!I map classes that belong to Smalltalk global dictionary.For example, Integer is mapped by me.!!FLGlobalBehaviorMapper methodsFor: 'accessing' stamp: 'MartinDias 8/6/2011 23:56'!accepts: anObject	^(anObject isBehavior or: [ anObject isTrait ]) 		and: [(self isGlobal: anObject) and: [self isExternal: anObject ]]! !!FLGlobalBehaviorMapper methodsFor: 'accessing' stamp: 'MartinDias 8/11/2011 02:35'!clusterFor: anObject	^anObject isClassSide		ifTrue: [ classSideCluster ]		ifFalse: [ instanceSideCluster ]! !!FLGlobalBehaviorMapper methodsFor: 'initialize-release' stamp: 'MartinDias 9/15/2011 19:51'!initialize	super initialize.	internalGlobals := OrderedCollection new.	globalBehaviors := IdentitySet new.	Smalltalk globals allClassesAndTraitsDo: [:each | globalBehaviors add: each].	classSideCluster := FLGlobalClassSideCluster new.	instanceSideCluster := FLGlobalClassCluster new.! !!FLGlobalBehaviorMapper methodsFor: 'accessing' stamp: 'MartinDias 8/6/2011 20:34'!internalObjects: anObject	internalGlobals := anObject! !!FLGlobalBehaviorMapper methodsFor: 'private' stamp: 'MartinDias 8/6/2011 23:28'!isExternal: anObject	^(internalGlobals includes: anObject instanceSide) not! !!FLGlobalBehaviorMapper methodsFor: 'private' stamp: 'MartinDias 8/6/2011 23:31'!isGlobal: anObject	^globalBehaviors includes: anObject instanceSide! !FLMapper subclass: #FLGlobalMapper	instanceVariableNames: 'cluster'	classVariableNames: 'Globals'	poolDictionaries: ''	category: 'Fuel-Core-Mappers'!!FLGlobalMapper commentStamp: 'MartinDias 8/18/2011 20:46' prior: 0!I map global objects that belong to Smalltalk dictionary.For example, Transcript is mapped by me.!!FLGlobalMapper class methodsFor: 'class initialization' stamp: 'MarianoMartinezPeck 9/28/2011 11:49'!defaultGlobals	^ IdentitySet new		add: Display;		add: World;		add: Smalltalk;		add: Transcript;		add: SourceFiles;		add: Processor;		add: ImageImports;		add: TextConstants;		add: Undeclared;		add: SystemOrganization;		add: Sensor;		add: ActiveWorld;		add: ActiveHand;		yourself! !!FLGlobalMapper class methodsFor: 'class initialization' stamp: 'MartinDias 8/18/2011 20:27'!initialize	self initializeGlobals ! !!FLGlobalMapper class methodsFor: 'class initialization' stamp: 'MarianoMartinezPeck 9/28/2011 11:49'!initializeGlobals	Globals := self defaultGlobals.! !!FLGlobalMapper methodsFor: 'accessing' stamp: 'MartinDias 8/18/2011 20:29'!accepts: anObject	^Globals includes: anObject! !!FLGlobalMapper methodsFor: 'accessing' stamp: 'MartinDias 8/11/2011 02:36'!clusterFor: anObject	^cluster! !!FLGlobalMapper methodsFor: 'initialize-release' stamp: 'MartinDias 9/15/2011 19:51'!initialize	super initialize.	cluster := FLGlobalValueCluster new.		! !FLMapper subclass: #FLLightGlobalMapper	instanceVariableNames: 'classSideCluster instanceSideCluster globalCluster'	classVariableNames: 'Globals'	poolDictionaries: ''	category: 'Fuel-Core-Mappers'!!FLLightGlobalMapper commentStamp: 'MartinDias 8/20/2011 23:43' prior: 0!I map classes, traits, and global objects that belong to Smalltalk dictionary. I am included in FLAnalyzer newLight behavior. I am a fast simplified replace to this four clusters included in FLAnaluzer newFull behavior: - FLGlobalMapper- FLGlobalBehaviorMapper- FLClassPoolAssociationMapper- FLGlobalAssociationMapper For example, the global Transcript as well as any class in the image, are mapped by me.!!FLLightGlobalMapper class methodsFor: 'class initialization' stamp: 'MartinDias 8/18/2011 20:12'!initialize	self initializeGlobals! !!FLLightGlobalMapper class methodsFor: 'class initialization' stamp: 'MartinDias 8/18/2011 20:20'!initializeGlobals	Globals := IdentitySet new		add: Display;		add: World;		add: Smalltalk;		add: Transcript;		add: SourceFiles;		add: Processor;		add: ImageImports;		add: TextConstants;		add: Undeclared;		add: SystemOrganization;		add: Sensor;		add: ActiveWorld;		add: ActiveHand;		yourself! !!FLLightGlobalMapper methodsFor: 'accessing' stamp: 'MartinDias 8/18/2011 20:19'!chainedClusterFor: anObject	"Uses the Chain of Responsibility pattern to answer the cluster which maps with the received object."	(anObject isBehavior or: [ anObject isTrait ]) ifTrue: [		^anObject isClassSide			ifTrue: [ classSideCluster ]			ifFalse: [ instanceSideCluster ]].	(Globals includes: anObject) ifTrue: [ ^globalCluster ].		^next chainedClusterFor: anObject.! !!FLLightGlobalMapper methodsFor: 'initialize-release' stamp: 'MartinDias 9/15/2011 19:51'!initialize	super initialize.	classSideCluster := FLGlobalClassSideCluster new.	instanceSideCluster := FLGlobalClassCluster new.	globalCluster := FLGlobalValueCluster new.! !!FLMapper methodsFor: 'accessing' stamp: 'MartinDias 5/30/2011 02:01'!accepts: anObject	"Tells if the received object is handled by this analyzer"	self subclassResponsibility ! !!FLMapper methodsFor: 'accessing' stamp: 'MartinDias 8/7/2011 20:21'!chainedClusterFor: anObject	"Uses the Chain of Responsibility pattern to answer the cluster which maps with the received object."	^(self accepts: anObject)		ifTrue: [ self clusterFor: anObject ]		ifFalse: [ next chainedClusterFor: anObject ].! !!FLMapper methodsFor: 'accessing' stamp: 'MartinDias 8/7/2011 20:19'!clusterFor: anObject	"Answers the cluster which maps with the received object."	self subclassResponsibility ! !!FLMapper methodsFor: 'accessing' stamp: 'MartinDias 8/6/2011 20:37'!internalObjects: aCollection! !!FLMapper methodsFor: 'accessing' stamp: 'MartinDias 8/7/2011 17:19'!next	^ next! !!FLMapper methodsFor: 'accessing' stamp: 'MartinDias 8/7/2011 17:19'!next: anObject	next := anObject! !FLMapper subclass: #FLPluggableSubstitutionMapper	instanceVariableNames: 'condition substitutionCluster'	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Mappers'!!FLPluggableSubstitutionMapper commentStamp: 'MartinDias 8/20/2011 23:45' prior: 0!I map substituted objects. For example, suppose you want to substitute instances of WriteStream by nil. In such case, I will map every WriteStream instance to my substitutions cluster, and its factory block will value to nil with any argument.!!FLPluggableSubstitutionMapper class methodsFor: 'instance creation' stamp: 'MarianoMartinezPeck 10/24/2011 16:43'!when: aCondition substituteBy: aFactory	^self basicNew		initializeWith: aCondition substitutionCluster: (FLPluggableSubstitutionCluster with: aFactory);		yourself! !!FLPluggableSubstitutionMapper methodsFor: 'accessing' stamp: 'MartinDias 8/20/2011 19:37'!accepts: anObject	^condition value: anObject! !!FLPluggableSubstitutionMapper methodsFor: 'accessing' stamp: 'MartinDias 8/20/2011 20:31'!clusterFor: anObject	^substitutionCluster! !!FLPluggableSubstitutionMapper methodsFor: 'initialize-release' stamp: 'MarianoMartinezPeck 10/24/2011 16:44'!initializeWith: aCondition substitutionCluster: aSubstitutionCluster	super initialize.	condition := aCondition.	substitutionCluster := aSubstitutionCluster ! !Object subclass: #FLMaterialization	instanceVariableNames: 'stream clusterCount indexCluster clusters root objects isBigEndian'	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core'!!FLMaterialization commentStamp: 'MarianoMartinezPeck 10/23/2011 14:42' prior: 0!I implement the algorithm for materializing an object graph on a stream. FLMaterializer known how to build instances of me.!!FLMaterialization class methodsFor: 'instance creation' stamp: 'MartinDias 9/10/2011 18:32'!on: aReadStream	^self basicNew		initializeWith: aReadStream;		yourself! !!FLMaterialization methodsFor: 'private' stamp: 'MartinDias 9/9/2011 01:58'!afterMaterializationStep	clusters do: [ :aCluster | aCluster afterMaterializationStepWith: self ]! !!FLMaterialization methodsFor: 'private' stamp: 'MartinDias 9/9/2011 01:58'!clusterInstancesStep	| aCluster |	aCluster := self nextEncodedCluster.	aCluster materializeInstancesStepWith: self.	self registerAll: aCluster objects.	aCluster materializePostInstancesStepWith: self.	clusters add: aCluster.! !!FLMaterialization methodsFor: 'private' stamp: 'mariano 10/6/2011 17:10'!headerStep	indexCluster := self nextEncodedCluster.	objects := OrderedCollection new: self nextEncodedPositiveInteger.	objects resetTo: 1. "Hack that avoids OrderedCollection>>makeRoomAtLast. In fact, this has already been fixed in Pharo 1.4: http://code.google.com/p/pharo/issues/detail?id=1686"	clusterCount := self nextEncodedPositiveInteger.	clusters := OrderedCollection new: clusterCount.	clusters resetTo: 1. "Hack that avoids OrderedCollection>>makeRoomAtLast"		isBigEndian := self nextEncodedPositiveInteger.! !!FLMaterialization methodsFor: 'initialize-release' stamp: 'MartinDias 9/10/2011 18:33'!initializeWith: aReadStream	self initialize.	stream := aReadStream.! !!FLMaterialization methodsFor: 'private' stamp: 'MartinDias 9/9/2011 01:58'!instancesStep	clusterCount timesRepeat: [ self clusterInstancesStep ]! !!FLMaterialization methodsFor: 'accessing' stamp: 'MartinDias 9/9/2011 01:58'!isBigEndian	^ isBigEndian ! !!FLMaterialization methodsFor: 'accessing' stamp: 'MarianoMartinezPeck 9/27/2011 17:17'!materializedInstances	^ objects! !!FLMaterialization methodsFor: 'decoding' stamp: 'MartinDias 9/9/2011 01:58'!nextEncodedCluster	^(Smalltalk classNamed: stream nextString) new! !!FLMaterialization methodsFor: 'decoding' stamp: 'MartinDias 9/11/2011 19:33'!nextEncodedPositiveInteger		^ stream uint32! !!FLMaterialization methodsFor: 'decoding' stamp: 'mariano 10/6/2011 17:02'!nextEncodedReference 	^ objects at: (indexCluster materializeFrom: stream)! !!FLMaterialization methodsFor: 'accessing' stamp: 'MartinDias 9/9/2011 01:58'!objects	"Answer a collection with the materialized objects."	^ objects ! !!FLMaterialization methodsFor: 'private' stamp: 'MartinDias 9/9/2011 01:58'!referencesStep	clusters do: [ :aCluster | aCluster materializeReferencesStepWith: self ]! !!FLMaterialization methodsFor: 'private' stamp: 'MartinDias 9/9/2011 01:58'!registerAll: materializedObjects		objects addAll: materializedObjects ! !!FLMaterialization methodsFor: 'accessing' stamp: 'MartinDias 9/9/2011 01:58'!root	^ root ! !!FLMaterialization methodsFor: 'materializing' stamp: 'MarianoMartinezPeck 9/27/2011 16:50'!run	self headerStep.	self instancesStep.	self referencesStep.	self trailerStep.	self afterMaterializationStep.! !!FLMaterialization methodsFor: 'accessing' stamp: 'MartinDias 9/9/2011 01:58'!stream	^ stream! !!FLMaterialization methodsFor: 'private' stamp: 'MartinDias 9/9/2011 01:58'!trailerStep	root := self nextEncodedReference! !Object subclass: #FLMaterializer	instanceVariableNames: 'materializationFactory streamFactory streamFinalizer signature version'	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core'!!FLMaterializer commentStamp: 'MartinDias 8/29/2011 19:06' prior: 0!I am a binary object materializer. See an example of use in FLSerializer's documentation.!!FLMaterializer class methodsFor: 'protected' stamp: 'MarianoMartinezPeck 10/9/2011 14:26'!currentVersion	"If you change this method, you should also create a version in ConfigurationOfFuel and FLSerializer >> currentVersion"	^ 17! !!FLMaterializer class methodsFor: 'protected' stamp: 'MartinDias 10/6/2011 23:31'!defaultSignature	^ 'FUEL'! !!FLMaterializer class methodsFor: 'materializing-shortcuts' stamp: 'MarianoMartinezPeck 9/27/2011 17:14'!materializationFromFileNamed: aFilename	^StandardFileStream 		oldFileNamed: aFilename 		do: [:aFileStream | 			(self newDefault materializeFrom: aFileStream binary) ]! !!FLMaterializer class methodsFor: 'materializing-shortcuts' stamp: 'MartinDias 9/9/2011 20:25'!materializeFromByteArray: byteArray	^(self newDefault materializeFrom: byteArray readStream) root! !!FLMaterializer class methodsFor: 'materializing-shortcuts' stamp: 'MarianoMartinezPeck 9/27/2011 17:15'!materializeFromFileNamed: aFilename	^ (self materializationFromFileNamed: aFilename) root! !!FLMaterializer class methodsFor: 'instance creation' stamp: 'MartinDias 9/10/2011 18:16'!newDefault	^self new! !!FLMaterializer methodsFor: 'initialize-release' stamp: 'MartinDias 10/6/2011 23:32'!initialize	super initialize.	self setDefaultMaterialization.	self readDirectly.	self signature: self class defaultSignature.	self version: self class currentVersion.! !!FLMaterializer methodsFor: 'materializing' stamp: 'MarianoMartinezPeck 10/22/2011 12:51'!materializeFrom: sourceStream	| aStream |	aStream := streamFactory value: sourceStream.	[	self verifySignatureFrom: aStream.		self verifyVersionFrom: aStream.		^ materializationFactory value: aStream ] ensure: [ 		streamFinalizer value: aStream ]! !!FLMaterializer methodsFor: 'configuring-stream' stamp: 'MartinDias 9/27/2011 20:31'!readDirectly	streamFactory := [:aStream | aStream ].	streamFinalizer := [:aStream | ].! !!FLMaterializer methodsFor: 'protected' stamp: 'MartinDias 9/14/2011 00:23'!setDefaultMaterialization	materializationFactory := [:aStream | (FLMaterialization on: aStream) run; yourself ]		! !!FLMaterializer methodsFor: 'accessing' stamp: 'MartinDias 10/6/2011 22:57'!signature	^ signature! !!FLMaterializer methodsFor: 'accessing' stamp: 'MartinDias 10/6/2011 22:57'!signature: anObject	signature := anObject! !!FLMaterializer methodsFor: 'protected' stamp: 'MarianoMartinezPeck 10/23/2011 14:19'!verifySignatureFrom: aStream	| streamSignature |	streamSignature := aStream next: self signature size.	(self signature asByteArray = streamSignature) ifFalse: [ FLBadSignature signalCurrentSignature: self signature streamSignature: streamSignature  ].! !!FLMaterializer methodsFor: 'protected' stamp: 'MarianoMartinezPeck 10/23/2011 14:03'!verifyVersionFrom: aStream	| streamVersion |	streamVersion := aStream uint16.	(self version = streamVersion) ifFalse: [ FLBadVersion signalCurrentVersion: self version streamVersion: streamVersion ]! !!FLMaterializer methodsFor: 'accessing' stamp: 'MartinDias 10/6/2011 22:57'!version	^ version! !!FLMaterializer methodsFor: 'accessing' stamp: 'MartinDias 10/6/2011 22:57'!version: anObject	version := anObject! !Object subclass: #FLSerialization	instanceVariableNames: 'stream indexCluster root objectsIndexes clusters objectCount analyzer'	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core'!!FLSerialization commentStamp: 'MarianoMartinezPeck 10/23/2011 14:42' prior: 0!I implement the algorithm for serializing an object graph on a stream. FLSerializer known how to build instances of me.!!FLSerialization class methodsFor: 'instance creation' stamp: 'MartinDias 9/10/2011 18:06'!root: anObject on: aWriteStream analyzer: anAnalyzer		^ self basicNew		initializeRoot: anObject		on: aWriteStream		analyzer: anAnalyzer;		yourself! !!FLSerialization methodsFor: 'private' stamp: 'mariano 10/6/2011 17:07'!analysisStep	| anAnalysis |	anAnalysis := analyzer analysisFor: root.	clusters := anAnalysis clusterization clusters.	objectCount := anAnalysis clusterization objectCount.	objectsIndexes := IdentityDictionary new: objectCount.	indexCluster := FLSmallIntegerCluster for: objectCount.! !!FLSerialization methodsFor: 'private' stamp: 'MartinDias 9/9/2011 01:11'!clusterInstancesStepOf: aCluster	self encodeIdOf: aCluster.	aCluster serializeInstancesStepWith: self.	aCluster serializePostInstancesStepWith: self.! !!FLSerialization methodsFor: 'accessing' stamp: 'MartinDias 9/13/2011 16:34'!clusters	^ clusters! !!FLSerialization methodsFor: 'encoding' stamp: 'MartinDias 9/9/2011 01:11'!encodeIdOf: aCluster	stream nextStringPut: aCluster class name! !!FLSerialization methodsFor: 'encoding' stamp: 'MartinDias 9/11/2011 19:33'!encodePositiveInteger: anInteger	stream uint32: anInteger! !!FLSerialization methodsFor: 'encoding' stamp: 'mariano 10/6/2011 17:01'!encodeReferenceTo: anObject	indexCluster 		serialize: (objectsIndexes at: anObject) 		on: stream! !!FLSerialization methodsFor: 'private' stamp: 'MarianoMartinezPeck 10/6/2011 21:14'!headerStep		self encodeIdOf: indexCluster.	self encodePositiveInteger: objectCount.	self encodePositiveInteger: clusters size.	self encodePositiveInteger: Smalltalk isBigEndian asBit.! !!FLSerialization methodsFor: 'initialize-release' stamp: 'MartinDias 9/12/2011 00:12'!initializeRoot: anObject on: aWriteStream analyzer: anAnalyzer		self initialize.	root := anObject.	stream := aWriteStream.	analyzer := anAnalyzer.! !!FLSerialization methodsFor: 'private' stamp: 'MartinDias 9/9/2011 01:11'!instancesStep	clusters do: [ :aCluster | aCluster registerIndexesOn: objectsIndexes ].	clusters do: [ :aCluster | self clusterInstancesStepOf: aCluster ]! !!FLSerialization methodsFor: 'accessing' stamp: 'MarianoMartinezPeck 9/27/2011 17:18'!objectsIndexes	^ objectsIndexes ! !!FLSerialization methodsFor: 'private' stamp: 'MartinDias 9/9/2011 01:11'!referencesStep	clusters do: [ :aCluster | aCluster serializeReferencesStepWith: self ]! !!FLSerialization methodsFor: 'accessing' stamp: 'MartinDias 9/9/2011 01:33'!root	^ root! !!FLSerialization methodsFor: 'serializing' stamp: 'MartinDias 9/27/2011 20:27'!run	"Serialize the graph starting at the root object."	self analysisStep.	self headerStep.	self instancesStep.	self referencesStep.	self trailerStep.! !!FLSerialization methodsFor: 'accessing' stamp: 'MartinDias 9/9/2011 01:11'!stream	^ stream! !!FLSerialization methodsFor: 'private' stamp: 'MartinDias 9/9/2011 01:11'!trailerStep	self encodeReferenceTo: root! !Object subclass: #FLSerializer	instanceVariableNames: 'analyzer streamFactory serializationFactory streamFinalizer signature version'	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core'!!FLSerializer commentStamp: 'MartinDias 8/29/2011 19:10' prior: 0!I am a binary object serializer.An example of use:| sourceArray loadedArray |sourceArray := 	Array 		with: 'a string' 		with: Transcript		with: [ Transcript show: 'a string' ]."Store to the file"FLSerializer serialize: sourceArray toFileNamed: 'example.FL'. "Load from the file"loadedArray := FLMaterializer materializeFromFileNamed: 'example.FL'. "The arrays are not the same"[ sourceArray ~~ loadedArray ] assert."The strings are not the same"[ sourceArray first ~~ loadedArray first ] assert.[ sourceArray first = loadedArray first ] assert."The global instance Transcript is the same"[ sourceArray second == loadedArray second ] assert."Appreciate in Transcript that the loaded block prints a string"loadedArray third value.!!FLSerializer class methodsFor: 'protected' stamp: 'MarianoMartinezPeck 10/9/2011 14:26'!currentVersion	"If you change this method, you should also create a version in ConfigurationOfFuel and FLMaterializer >> currentVersion"	^ 17! !!FLSerializer class methodsFor: 'protected' stamp: 'MartinDias 10/6/2011 23:28'!defaultSignature	^ 'FUEL'! !!FLSerializer class methodsFor: 'instance creation' stamp: 'MartinDias 9/25/2011 20:12'!newDefault	^self newLight! !!FLSerializer class methodsFor: 'instance creation' stamp: 'MartinDias 9/25/2011 20:12'!newFull	| aSerializer |	aSerializer := self new.	aSerializer analyzer considerGlobalWhenPossible.	^aSerializer! !!FLSerializer class methodsFor: 'instance creation' stamp: 'MartinDias 9/25/2011 20:12'!newLight	^self new! !!FLSerializer class methodsFor: 'serializing-shortcuts' stamp: 'MartinDias 9/9/2011 18:25'!serialize: anObject toFileNamed: aFilename	StandardFileStream 		fileNamed: aFilename 		do: [ :aFileStream | 			self newDefault serialize: anObject on: aFileStream binary ]! !!FLSerializer class methodsFor: 'serializing-shortcuts' stamp: 'MartinDias 10/12/2011 11:58'!serializeToByteArray: anObject	"No stream is needed by the user. An internal in-memory stream will be used. This method returns a ByteArray representing the serialization"		| aStream |	aStream := (ByteArray new: 100) writeStream.		self newDefault serialize: anObject on: aStream.		^aStream contents! !!FLSerializer methodsFor: 'accessing' stamp: 'MarianoMartinezPeck 10/3/2011 16:18'!analyzer	analyzer isNil ifTrue: [ analyzer := self defaultAnalyzer ].	^ analyzer! !!FLSerializer methodsFor: 'accessing' stamp: 'MartinDias 8/20/2011 17:33'!analyzer: anObject	analyzer := anObject! !!FLSerializer methodsFor: 'protected' stamp: 'MartinDias 9/13/2011 19:26'!defaultAnalyzer	^FLAnalyzer newDefault! !!FLSerializer methodsFor: 'protected' stamp: 'MarianoMartinezPeck 10/3/2011 16:29'!defaultSerialization	^ serializationFactory := [:anObject :aStream | 		(FLSerialization 			root: anObject 			on: aStream			analyzer: self analyzer)			run;			yourself ]! !!FLSerializer methodsFor: 'initialize-release' stamp: 'MartinDias 10/6/2011 23:29'!initialize	super initialize.	self writeBuffered.	self signature: self class defaultSignature.	self version: self class currentVersion.! !!FLSerializer methodsFor: 'protected' stamp: 'MartinDias 10/6/2011 23:34'!nextPutSignatureOn: aStream	aStream nextPutAll: self signature asByteArray! !!FLSerializer methodsFor: 'protected' stamp: 'MartinDias 10/6/2011 23:34'!nextPutVersionOn: aStream	aStream uint16: self version! !!FLSerializer methodsFor: 'accessing' stamp: 'MarianoMartinezPeck 10/3/2011 16:29'!serializationFactory	serializationFactory isNil ifTrue: [ serializationFactory := self defaultSerialization ].	^ serializationFactory! !!FLSerializer methodsFor: 'serializing' stamp: 'MarianoMartinezPeck 10/22/2011 12:50'!serialize: anObject on: destinationStream 	"Serialize the graph starting at the root object received."	| aStream |	aStream := streamFactory value: destinationStream.	[	self nextPutSignatureOn: aStream.		self nextPutVersionOn: aStream.		self serializationFactory value: anObject value: aStream ] ensure: [ 		streamFinalizer value: aStream ]! !!FLSerializer methodsFor: 'accessing' stamp: 'MartinDias 10/6/2011 22:56'!signature	^ signature! !!FLSerializer methodsFor: 'accessing' stamp: 'MartinDias 10/6/2011 22:56'!signature: anObject	signature := anObject! !!FLSerializer methodsFor: 'accessing' stamp: 'MartinDias 10/6/2011 22:56'!version	^ version! !!FLSerializer methodsFor: 'accessing' stamp: 'MartinDias 10/6/2011 22:56'!version: anObject	version := anObject! !!FLSerializer methodsFor: 'configuring-stream' stamp: 'MartinDias 9/9/2011 20:18'!writeBuffered	self writeBufferedSize: 4096  ! !!FLSerializer methodsFor: 'configuring-stream' stamp: 'MartinDias 9/27/2011 20:28'!writeBufferedSize: aSize	streamFactory := [:aStream | 		(FLBufferedWriteStream on: aStream)			sizeBuffer: aSize;			yourself ].	streamFinalizer := [:aBufferedStream | aBufferedStream flush ].! !Object subclass: #FLSimpleStack	instanceVariableNames: 'array slotIndex'	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Collections'!!FLSimpleStack commentStamp: 'MarianoMartinezPeck 6/5/2011 12:29' prior: 0!FLSimpleStack is a simple stack used in Fuel to avoid a recursion while traversing the graph to serialize. While analizing the content of an object (inst vars) we can encounter simple objects (direct string representation) or complex objects (composite). In the latter case we start analizing those instVars.So... Imagine object X with two instVars Y and Z. Imagine the method of the traverse is called #analye:.  So you do #analize: X.  Then, in such method you check whether X has regular pointers to regular objects, and if true, you analize them. So in this case you would send #analyze: Y and #analize: Z, generating the recursion. Right ?  Notice that the time between analyse: Y and analyse: Z is dependent on the graph that is attached to Y. Y can have objects that have further objects etc. So leaving X aside, Y can be the first object to serialize and Z the last.With this FLSimpleStack, instead of sending #analyze: Y and #analize: Z  what Fuel does is just to do a push on a stack:   #push: Y  and #push: Z. And then we are done with X, so we pop from the stack and we continue with the next object (at some point in the future we will pop Y and Z) When there are no more objects in the stack it means we are done. !!FLSimpleStack class methodsFor: 'instance creation' stamp: 'MartinDias 5/15/2011 23:11'!hintSize	^64! !!FLSimpleStack class methodsFor: 'instance creation' stamp: 'MartinDias 5/15/2011 23:11'!new		^ self new: self hintSize! !!FLSimpleStack class methodsFor: 'instance creation' stamp: 'MartinDias 5/15/2011 23:09'!new: nElements	"Create a Set large enough to hold nElements without growing"	^ self basicNew initialize: nElements! !!FLSimpleStack methodsFor: 'accessing' stamp: 'MartinDias 5/15/2011 23:08'!capacity	^ array size! !!FLSimpleStack methodsFor: 'adding' stamp: 'MartinDias 5/15/2011 23:15'!grow	"Become larger in capacity."	| newArray |	newArray := Array new: array size * 2.	newArray replaceFrom: 1 to: array size with: array startingAt: 1.	array := newArray! !!FLSimpleStack methodsFor: 'initialize-release' stamp: 'MartinDias 5/15/2011 23:10'!initialize: hintSize	array := Array new: hintSize.	slotIndex := 1.! !!FLSimpleStack methodsFor: 'accessing' stamp: 'MartinDias 5/15/2011 22:54'!isEmpty	^ 1 = slotIndex! !!FLSimpleStack methodsFor: 'removing' stamp: 'MartinDias 5/15/2011 22:52'!pop	"Returns the first element and remove it from the stack."	slotIndex := slotIndex - 1.		^ array at: slotIndex ! !!FLSimpleStack methodsFor: 'printing' stamp: 'MartinDias 6/3/2011 20:25'!printOn: aStream 	"Append a sequence of characters that identify the receiver to aStream."	super printOn: aStream.	array printElementsOn: aStream! !!FLSimpleStack methodsFor: 'adding' stamp: 'MartinDias 5/15/2011 22:44'!push: anObject 	"Adds a new object of any kind on top of the stack."	array at: slotIndex put: anObject.	array size = slotIndex ifTrue: [ self grow ].	slotIndex := slotIndex + 1.	^ anObject.! !Object subclass: #FLVariablesMapping	instanceVariableNames: 'mapping theClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Core-Clusters'!!FLVariablesMapping commentStamp: 'MartinDias 8/1/2011 03:01' prior: 0!I am used to materialize instance variables in an object, tolerating "class shape changing".Cases tolerated are:- instance variable added- instance variable order change- instance variable removed!!FLVariablesMapping class methodsFor: 'instance creation' stamp: 'MarianoMartinezPeck 10/24/2011 16:45'!for: aClass		^ self basicNew		initializeWith: aClass;		yourself.! !!FLVariablesMapping methodsFor: 'initialize-release' stamp: 'MarianoMartinezPeck 10/24/2011 16:46'!initializeWith: aClass	super initialize.	theClass := aClass! !!FLVariablesMapping methodsFor: 'private' stamp: 'MartinDias 7/27/2011 23:21'!instanceVariableNamesToSerialize	| ignoredInstanceVariableNames instanceVariableNamesToSerialize |	ignoredInstanceVariableNames := theClass fuelIgnoredInstanceVariableNames.	instanceVariableNamesToSerialize := OrderedCollection new.	theClass fuelInstVarNamesAndOffsetsDo: [:name :index | 		(ignoredInstanceVariableNames includes: name) 			ifFalse: [ instanceVariableNamesToSerialize add: name ]].	^ instanceVariableNamesToSerialize! !!FLVariablesMapping methodsFor: 'serialize/materialize' stamp: 'MartinDias 7/27/2011 23:22'!materializeMappingFrom: aStream	| instanceVariableNamesSerialized |	instanceVariableNamesSerialized := (1 to: aStream next) collect: [ :index | aStream nextString ].	mapping := instanceVariableNamesSerialized  		collect: [ :name | theClass instVarIndexFor: name ifAbsent: [ nil ] ].! !!FLVariablesMapping methodsFor: 'serialize/materialize' stamp: 'MartinDias 7/27/2011 20:37'!materializeReferencesOf: anObject with: aMaterializer 	mapping do: [ :index | 			| reference |			reference := aMaterializer nextEncodedReference.			index ifNotNil: [				anObject 					instVarAt: index					put: reference ]].! !!FLVariablesMapping methodsFor: 'serialize/materialize' stamp: 'MartinDias 7/27/2011 23:22'!serializeMappingOn: aStream	| instanceVariableNamesToSerialize |	instanceVariableNamesToSerialize := self instanceVariableNamesToSerialize.	aStream nextPut: instanceVariableNamesToSerialize size.		instanceVariableNamesToSerialize do: [ :name | aStream nextStringPut: name ].	mapping := instanceVariableNamesToSerialize 		collect: [ :name | theClass instVarIndexFor: name ].! !!FLVariablesMapping methodsFor: 'serialize/materialize' stamp: 'MartinDias 7/27/2011 20:02'!serializeReferencesOf: anObject with: aSerializer 	mapping do: [ :index | 		aSerializer encodeReferenceTo: (anObject instVarAt: index) ].! !Object subclass: #FuelUtilities	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Fuel-Utilities'!!FuelUtilities commentStamp: 'MarianoMartinezPeck 6/5/2011 12:25' prior: 0!FuelUtilities is a class that contains utilities when developing Fuel. Right now the only usage is to do some cleanings. Sometimes updating versions from Monticello bring problems with traits or things like that. Right now the only usage is:FuelUtilities cleanUpEverything.!!FuelUtilities class methodsFor: 'cleaning' stamp: 'mariano 10/6/2011 11:45'!cleanUpEverything	"Sometimes when updating Fuel versions Monticello gets stupid and we need to do some cleanups."	3 timesRepeat: [Smalltalk garbageCollect].	Smalltalk fixObsoleteReferences.	(PackageInfo named: 'Fuel') classes,	(PackageInfo named: 'FuelFameExtension') classes,	(PackageInfo named: 'FuelContainer') classes,	(PackageInfo named: 'FuelMooseExtension') classes	    do: [:c | c compileAll ].	((PackageInfo named: 'Fuel') classes select: [:each | each isBehavior ]) do: [:each | each initialize]! !!Object methodsFor: '*Fuel' stamp: 'MartinDias 8/6/2011 19:43'!fuelAccept: aVisitor	self class isFixed		ifTrue: [ ^aVisitor visitFixedObject: self ].	self class isPointers		ifTrue: [ ^aVisitor visitVariableObject: self ].	self class isBytes		ifTrue: [ ^aVisitor visitBytesObject: self ].	self class isWords		ifTrue: [	 ^aVisitor visitWordsObject: self ].	self error: 'Something is wrong!!'! !!Object methodsFor: '*Fuel' stamp: 'MartinDias 8/27/2011 19:03'!fuelAfterMaterialization	"Materialization process will send this message after materializing instances of my class"! !FLGlobalMapper initialize!FLLightGlobalMapper initialize!FLWellKnownObjectsCluster initialize!