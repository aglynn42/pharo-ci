'From Pharo1.4a of ''16 June 2011'' [Latest update: #14301] on 24 February 2012 at 11:43:32 pm'!Object variableSubclass: #BlockClosure	uses: TTyped	instanceVariableNames: '(ContextPart)outerContext (Integer)startpc (Integer)numArgs'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!!BlockClosure commentStamp: '<historical>' prior: 0!I am a block closure for Eliot's closure implementation.  Not to be confused with the old BlockClosure.!!BlockClosure methodsFor: '*Tools' stamp: 'EstebanAllende 2/24/2012 00:05'!(TimeProfiler) timeProfile	^Smalltalk tools timeProfiler onBlock: self! !!BlockClosure methodsFor: '*Tools' stamp: 'EstebanAllende 2/24/2012 00:06'!(Integer) timeToRunWithoutGC	"Answer the number of milliseconds taken to execute this block without GC time." 	^ Smalltalk vm totalGCTime + self timeToRun -  Smalltalk vm totalGCTime! !!BlockClosure methodsFor: '*compatibility' stamp: 'SeanDeNigris 8/31/2011 14:20'!fixTemps	"Fix the values of the temporary variables used in the block that	 are  ordinarily shared with the method in which the block is defined.	 This is a no-op for closures, provided for backward-compatibility with	 old BlockContexts that needed the fixTemps hack to persist."	self deprecated: 'BlockClosure does not need to fixTemps' on: '10 February 2010' in: 'Pharo1.2'! !!BlockClosure methodsFor: '*compiler-extensions' stamp: 'EstebanAllende 2/24/2012 00:07'!(BlockNode) decompile	^self method methodClass decompilerClass new decompileBlock: self! !!BlockClosure methodsFor: '*petitparser-core-converting' stamp: 'EstebanAllende 2/24/2012 00:08'!(PPPluggableParser) asParser	"Answer a parser implemented in the receiving one-argument block."	^ PPPluggableParser on: self! !!BlockClosure methodsFor: 'accessing' stamp: 'EstebanAllende 2/23/2012 21:32'!(Integer) argumentCount	"Answer the number of arguments that must be used to evaluate this block"	^numArgs	! !!BlockClosure methodsFor: 'accessing' stamp: 'EstebanAllende 2/23/2012 21:32'!(Object) copiedValueAt: (Integer)i	<primitive: 60>	^self basicAt: i! !!BlockClosure methodsFor: 'accessing' stamp: 'EstebanAllende 2/23/2012 21:34'!(ContextPart) home	^outerContext home! !!BlockClosure methodsFor: 'accessing' stamp: 'EstebanAllende 2/23/2012 21:35'!(Boolean) isBlock	^ true! !!BlockClosure methodsFor: 'accessing' stamp: 'EstebanAllende 2/23/2012 21:35'!(CompiledMethod) method	^outerContext method! !!BlockClosure methodsFor: 'accessing' stamp: 'EstebanAllende 2/23/2012 21:35'!(Integer) numArgs	"Answer the number of arguments that must be used to evaluate this block"	^numArgs! !!BlockClosure methodsFor: 'accessing' stamp: 'EstebanAllende 2/23/2012 21:35'!(Integer) numCopiedValues	"Answer the number of copied values of the receiver.  Since these are	 stored in the receiver's indexable fields this is the receiver's basic size.	 Primitive. Answer the number of indexable variables in the receiver. 	 This value is the same as the largest legal subscript."	<primitive: 62>	^self basicSize! !!BlockClosure methodsFor: 'accessing' stamp: 'EstebanAllende 2/23/2012 21:35'!(ContextPart) outerContext	^outerContext! !!BlockClosure methodsFor: 'accessing' stamp: 'EstebanAllende 2/23/2012 21:36'!(Object) receiver	^outerContext receiver! !!BlockClosure methodsFor: 'accessing' stamp: 'EstebanAllende 2/23/2012 21:36'!(Integer) startpc	^startpc! !!BlockClosure methodsFor: 'controlling' stamp: 'EstebanAllende 2/23/2012 21:39'!(?) doWhileFalse: (→Boolean)conditionBlock	"Evaluate the receiver once, then again as long the value of conditionBlock is false." 	| (?)result |	[result := self value.	conditionBlock value] whileFalse.	^ result! !!BlockClosure methodsFor: 'controlling' stamp: 'EstebanAllende 2/23/2012 21:51'!(?) doWhileTrue: (→Boolean) conditionBlock	"Evaluate the receiver once, then again as long the value of conditionBlock is true." 	| (?)result |	[result := self value.	conditionBlock value] whileTrue.	^ result! !!BlockClosure methodsFor: 'controlling' stamp: 'EstebanAllende 2/23/2012 21:50'!(Self) repeat	"Evaluate the receiver repeatedly, ending only if the block explicitly returns."	[self value. true] whileTrue! !!BlockClosure methodsFor: 'controlling' stamp: 'EstebanAllende 2/23/2012 21:49'!(UndefinedObject) repeatWithGCIf: (?→Boolean) testBlock	| (?) ans |	"run the receiver, and if testBlock returns true, garbage collect and run the receiver again"	ans := self value.	(testBlock value: ans) ifTrue: [ Smalltalk garbageCollect. ans := self value ].	^ans! !!BlockClosure methodsFor: 'controlling' stamp: 'EstebanAllende 2/23/2012 21:47'!(UndefinedObject) whileFalse	"Ordinarily compiled in-line, and therefore not overridable.	This is in case the message is sent to other than a literal block.	Evaluate the receiver, as long as its value is false." 	^ [self value] whileFalse: []! !!BlockClosure methodsFor: 'controlling' stamp: 'EstebanAllende 2/23/2012 21:47'!(UndefinedObject) whileFalse: (→Object) aBlock 	"Ordinarily compiled in-line, and therefore not overridable.	This is in case the message is sent to other than a literal block.	Evaluate the argument, aBlock, as long as the value of the receiver is false."	^ [self value] whileFalse: [aBlock value]! !!BlockClosure methodsFor: 'controlling' stamp: 'EstebanAllende 2/23/2012 21:46'!(UndefinedObject) whileNil: (→Object) aBlock 	"Unlike #whileTrue/False: this is not compiled inline."	^ [self value isNil] whileTrue: [aBlock value]	! !!BlockClosure methodsFor: 'controlling' stamp: 'EstebanAllende 2/23/2012 21:45'!(UndefinedObject) whileNotNil: (→ Object) aBlock 	"Unlike #whileTrue/False: this is not compiled inline."	^ [self value notNil] whileTrue: [aBlock value]	! !!BlockClosure methodsFor: 'controlling' stamp: 'EstebanAllende 2/23/2012 21:42'!(UndefinedObject) whileTrue	"Ordinarily compiled in-line, and therefore not overridable.	This is in case the message is sent to other than a literal block.	Evaluate the receiver, as long as its value is true." 	^ [self value] whileTrue: []! !!BlockClosure methodsFor: 'controlling' stamp: 'EstebanAllende 2/23/2012 21:46'!(UndefinedObject) whileTrue: (→Object) aBlock 	"Ordinarily compiled in-line, and therefore not overridable.	This is in case the message is sent to other than a literal block.	Evaluate the argument, aBlock, as long as the value of the receiver is true."	^ [self value] whileTrue: [aBlock value]! !!BlockClosure methodsFor: 'debugger access' stamp: 'EstebanAllende 2/23/2012 21:52'!(ContextPart) sender	"Answer the context that sent the message that created the receiver."	^outerContext sender! !!BlockClosure methodsFor: 'error handing' stamp: 'EstebanAllende 2/23/2012 21:53'!(Self) numArgsError: (Integer)numArgsForInvocation	| (Integer → String) printNArgs |	printNArgs := [:(Integer)n| n printString, ' argument', (n = 1 ifTrue: [''] ifFalse:['s'])]. 	self error: 			'This block accepts ', (printNArgs value: numArgs), 			', but was called with ', (printNArgs value: numArgsForInvocation), '.'! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/24/2012 23:43'!(String) bench	"Return how many times the receiver can get executed in 5 seconds.  Answer a meaningful description."	"[3.14 printString] bench"		| (Integer) startTime (Integer)endTime (Integer)count (Integer → String) roundTo3Digits  |	roundTo3Digits := [:(Integer) num |               | (Integer)rounded (Integer)lowDigit |               rounded := (num * 1000) rounded. "round to 1/1000"               lowDigit := (rounded numberOfDigitsInBase: 10) - 3. "keep only first 3 digits"               rounded := (<Integer>rounded roundTo:(10 raisedTo: lowDigit)).               (lowDigit >= 3 or: [rounded \\ 1000 = 0]) "display fractional part only when needed"                       ifTrue: [(rounded // 1000) asStringWithCommas]                       ifFalse: [(rounded / 1000.0) printString]].	count := 0.	endTime := Time millisecondClockValue + 5000.	startTime := Time millisecondClockValue.	[ Time millisecondClockValue > endTime ] whileFalse: [ self value.  count := count + 1 ].	endTime := Time millisecondClockValue.	^count = 1		ifTrue: [ (roundTo3Digits value: (endTime - startTime) / 1000) , ' seconds.' ]		ifFalse:  [ (roundTo3Digits value: (count * 1000) / (endTime - startTime)) , ' per second.' ]! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 21:57'!(?) cull: (?)anArg	^numArgs = 0 		ifTrue: [self value]		ifFalse: [self value: anArg]	! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 21:57'!(?) cull: (?)firstArg cull: (?)secondArg	^numArgs < 2 		ifTrue: [self cull: firstArg]		ifFalse: [self value: firstArg value: secondArg]	! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 21:57'!(?) cull: (?)firstArg cull: (?)secondArg cull: (?)thirdArg	^numArgs < 3 		ifTrue: [self cull: firstArg cull: secondArg]		ifFalse: [self value: firstArg value: secondArg value: thirdArg]	! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 21:58'!(?) cull: (?)firstArg cull: (?)secondArg cull: (?)thirdArg cull: (?)fourthArg	"Execute the receiver with four or less arguments. Check cull:cull: for examples"		^numArgs < 4 		ifTrue: [self cull: firstArg cull: secondArg cull: thirdArg]		ifFalse: [self value: firstArg value: secondArg value: thirdArg value: fourthArg]	! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 21:59'!(Integer) durationToRun	"Answer the duration taken to execute this block."	^ Duration milliSeconds: self timeToRun! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 22:00'!(?)ifError: (BlockClosure)errorHandlerBlock	"Evaluate the block represented by the receiver, and normally return it's value.  If an error occurs, the errorHandlerBlock is evaluated, and it's value is instead returned.  The errorHandlerBlock must accept zero, one, or two parameters (the error message and the receiver)."	"Examples:		[1 whatsUpDoc] ifError: [:err :rcvr | 'huh?'].		[1 / 0] ifError: [:err :rcvr |			'ZeroDivide' = err				ifTrue: [Float infinity]				ifFalse: [self error: err]]"	^ self on: Error do: [:(Error)ex |		errorHandlerBlock cull: ex description cull: ex receiver]! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 22:04'!(?) once	"Answer and remember the receiver value, answering exactly the same object in any further sends	 of once or value until the receiver become uncached.  This allows one to intern values with the idiom		myResourceMethod			^[expression] once.	 The expression will be evaluated once and its result returned for any subsequent evaluations.	 Originally by Travis Griggs, from whom we copy this idea with thanks."		numArgs ~= 0 ifTrue:		[self error: 'once should only be used with niladic blocks'].	self becomeCached.	^self once! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 22:08'!(?) silentlyValue	"evaluates the receiver but avoiding progress bar notifications to show up."		^[ self value ] 		on: ProgressInitiationException		do: [ :(ProgressInitiationException)ex | 			ex sendNotificationsTo: [ :(Integer)min :(Integer)max :(Integer)curr |				self traceCr: min printString,'  ',max printString,'  ',curr printString.			].		].! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 22:42'!(MethodContext) simulateValueWithArguments: (Array) anArray caller: (ContextPart)aContext	|(MethodContext)newContext (Integer)sz |	(anArray class ~~ Array	 or: [numArgs ~= anArray size]) ifTrue:		[^ContextPart primitiveFailToken].	newContext := (MethodContext newForMethod: outerContext method)						setSender: aContext						receiver: outerContext receiver						method: outerContext method						closure: self						startpc: startpc.	sz := self basicSize.	newContext stackp: sz + numArgs.	1 to: numArgs do:		[:(Integer)i| newContext at: i put: (anArray at: i)].	1 to: sz do:		[:(Integer)i| newContext at: i + numArgs put: (self at: i)].	^newContext! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 22:42'!(Integer) timeToRun	"Answer the number of milliseconds taken to execute this block."	^ Time millisecondsToRun: self! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 22:43'!(?) value	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this message.	 Supply the copied values to the activation as its arguments and copied temps.	 Primitive. Optional (but you're going to want this for performance)."	<primitive: 201>	numArgs ~= 0 ifTrue:		[self numArgsError: 0].	^self primitiveFailed! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 22:43'!(?)value: (?)anArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this message.	 Supply the argument and copied values to the activation as its arguments and copied temps.	 Primitive. Optional (but you're going to want this for performance)."	<primitive: 202>	numArgs ~= 1 ifTrue:		[self numArgsError: 1].	self primitiveFailed! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 22:44'!(?)value: (?)firstArg value: (?)secondArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this message.	 Supply the arguments and copied values to the activation as its arguments and copied temps.	 Primitive. Optional (but you're going to want this for performance)."	<primitive: 203>	numArgs ~= 2 ifTrue:		[self numArgsError: 2].	^self primitiveFailed! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 22:44'!(?) value: (?)firstArg value: (?)secondArg value: (?)thirdArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this message.	 Supply the arguments and copied values to the activation as its arguments and copied temps.	 Primitive. Optional (but you're going to want this for performance)."	<primitive: 204>	numArgs ~= 3 ifTrue:		[self numArgsError: 3].	^self primitiveFailed! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 22:45'!(?) value: (?)firstArg value: (?)secondArg value: (?)thirdArg value: (?)fourthArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this message.	 Supply the arguments and copied values to the activation as its arguments and copied temps.	 Primitive. Optional (but you're going to want this for performance)."	<primitive: 205>	numArgs ~= 4 ifTrue:		[self numArgsError: 4].	^self primitiveFailed! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 22:50'!(?) valueAt: (Integer)blockPriority 	"Evaluate the receiver (block), with another priority as the actual one 	and restore it afterwards. The caller should be careful with using 	higher priorities."	| (Process)activeProcess (Object)result (Integer)outsidePriority |	activeProcess := Processor activeProcess.	outsidePriority := activeProcess priority.	activeProcess priority: blockPriority.	result := self ensure: [activeProcess priority: outsidePriority].	"Yield after restoring lower priority to give the preempted processes a  	chance to run."	blockPriority > outsidePriority		ifTrue: [Processor yield].	^ result! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 22:50'!(?) valueNoContextSwitch	"An exact copy of BlockClosure>>value except that this version will not preempt	 the current process on block activation if a higher-priority process is runnable.	 Primitive. Essential."	<primitive: 221>	numArgs ~= 0 ifTrue:		[self numArgsError: 0].	self primitiveFailed! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 22:51'!(?) valueNoContextSwitch: anArg	"An exact copy of BlockClosure>>value: except that this version will not preempt	 the current process on block activation if a higher-priority process is runnable.	 Primitive. Essential."	<primitive: 222>	numArgs ~= 1 ifTrue:		[self numArgsError: 1].	self primitiveFailed! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 22:55'!(?) valueSupplyingAnswer: (Object)anObject	^ (anObject isCollection and: [anObject isString not])		ifTrue: [self valueSupplyingAnswers: {anObject}]		ifFalse: [self valueSupplyingAnswers: {{'*'. anObject}}]! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 22:55'!(?) valueSupplyingAnswers: (Array) aListOfPairs	"evaluate the block using a list of questions / answers that might be called upon to	automatically respond to Object>>confirm: or FillInTheBlank requests"	^ [self value] 		on: ProvideAnswerNotification		do: 			[:(ProvideAnswerNotification)notify | | (Array)answer (String)caption |						caption := notify messageText withSeparatorsCompacted. "to remove new lines"			answer := aListOfPairs				detect: 					[:(Array)each | caption = each first or:						[(caption includesSubstring: each first caseSensitive: false) or:						[(each first match: caption) or:						[(String includesSelector: #matchesRegex:) and: 						[ [ caption matchesRegex: each first ] on: Error do: [:(Error)ignored | false ]]]]]]					ifNone: [nil].			answer				ifNotNil: [notify resume: answer second]				ifNil: 					[ | (Object)outerAnswer |					outerAnswer := ProvideAnswerNotification signal: notify messageText.					outerAnswer 						ifNil: [notify resume] 						ifNotNil: [notify resume: outerAnswer]]]! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 22:55'!(?) valueSuppressingAllMessages	^ self valueSuppressingMessages: #('*')! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 22:56'!(?)valueSuppressingMessages: (Array)aListOfStrings	^ self		valueSuppressingMessages: aListOfStrings		supplyingAnswers: #()! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 22:56'!(?)valueSuppressingMessages: (Array)aListOfStrings supplyingAnswers: (Array)aListOfPairs	^ self valueSupplyingAnswers: aListOfPairs, (aListOfStrings collect: [:(String)each | {each. true}])! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 22:58'!(?)valueWithArguments: (Collection)anArray	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this message.	 Supply the arguments in an anArray and copied values to the activation as its arguments and copied temps.	 Primitive. Optional (but you're going to want this for performance)."	| (ContextPart)newContext (Integer)ncv |	<primitive: 206>	numArgs ~= anArray size ifTrue:		[self numArgsError: anArray size].	newContext := self asContextWithSender: thisContext sender.	ncv := self numCopiedValues.	newContext stackp: ncv + numArgs.	1 to: numArgs do:		[:(Integer)i| newContext at: i put: (anArray at: i)].	1 to: ncv do:		[:(Integer)i| newContext at: i + numArgs put: (self at: i)].	thisContext privSender: newContext! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 23:00'!(?)valueWithEnoughArguments: (Array)anArray	"call me with enough arguments from anArray"	| (Array)args |	(anArray size == self numArgs)		ifTrue: [ ^self valueWithArguments: anArray ].	args := Array new: self numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self valueWithArguments: args! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 23:01'!(?) valueWithExit 	  self value: [ ^nil ]! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 23:01'!(?)valueWithPossibleArgs: (Array)anArray 	^numArgs = 0		ifTrue: [self value]		ifFalse:			[self valueWithArguments:				(numArgs = anArray size					ifTrue: [anArray]					ifFalse:						[numArgs > anArray size							ifTrue: [anArray, (Array new: numArgs - anArray size)]							ifFalse: [anArray copyFrom: 1 to: numArgs]])]! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 23:01'!(?) valueWithPossibleArgument: (Object)anArg 	"Evaluate the block represented by the receiver. 	 If the block requires one argument, use anArg, if it requires more than one,	 fill up the rest with nils."	| (Array)a |	numArgs = 0 ifTrue: [^self value].	numArgs = 1 ifTrue: [^self value: anArg].	a := Array new: numArgs.	a at: 1 put: anArg.	^self valueWithArguments: a! !!BlockClosure methodsFor: 'evaluating' stamp: 'EstebanAllende 2/23/2012 23:18'!(?) valueWithin: (Duration)aDuration onTimeout: (→?) timeoutBlock	"Evaluate the receiver.	If the evaluation does not complete in less than aDuration evaluate the timeoutBlock instead"	| (Process)theProcess (Delay)delay (Process)watchdog |	aDuration <= Duration zero ifTrue: [^ timeoutBlock value ].	"the block will be executed in the current process"	theProcess := Processor activeProcess.	delay := aDuration asDelay.	"make a watchdog process"	watchdog := [		delay wait. 	"wait for timeout or completion"		theProcess ifNotNil:[ theProcess signalException: TimedOut ] 	] newProcess.	"Watchdog needs to run at high priority to do its job (but not at timing priority)"	watchdog priority: Processor timingPriority-1.	"catch the timeout signal"	^ [	watchdog resume.				"start up the watchdog"		self ensure:[						"evaluate the receiver"			theProcess := nil.				"it has completed, so ..."			delay delaySemaphore signal.	"arrange for the watchdog to exit"		]] on: TimedOut do: [ :(TimedOut)e | timeoutBlock value ].! !!BlockClosure methodsFor: 'exceptions' stamp: 'EstebanAllende 2/23/2012 23:19'!(Self) assert	self value ifFalse: [AssertionFailure signal: 'Assertion failed']! !!BlockClosure methodsFor: 'exceptions' stamp: 'EstebanAllende 2/23/2012 23:20'!(Self) assertWithDescription: (Object)aStringOrABlock	self value ifFalse: [		|(String)value|		value := aStringOrABlock value.		AssertionFailure signal: value]! !!BlockClosure methodsFor: 'exceptions' stamp: 'EstebanAllende 2/23/2012 23:25'!(?) ensure: (→Object)aBlock	"Evaluate a termination block after evaluating the receiver, regardless of	 whether the receiver's evaluation completes.  N.B.  This method is *not*	 implemented as a primitive.  Primitive 198 always fails.  The VM uses prim	 198 in a context's method as the mark for an ensure:/ifCurtailed: activation."	| (Boolean)complete (?)returnValue |	<primitive: 198>	returnValue := self valueNoContextSwitch.	complete ifNil:[		complete := true.		aBlock value.	].	^ returnValue! !!BlockClosure methodsFor: 'exceptions' stamp: 'EstebanAllende 2/23/2012 23:28'!(?) ifCurtailed: (→Object)aBlock	"Evaluate the receiver with an abnormal termination action.	 Evaluate aBlock only if execution is unwound during execution	 of the receiver.  If execution of the receiver finishes normally do	 not evaluate aBlock.  N.B.  This method is *not* implemented as a	 primitive.  Primitive 198 always fails.  The VM uses prim 198 in a	 context's method as the mark for an ensure:/ifCurtailed: activation."	| (Boolean)complete (?)result |	<primitive: 198>	result := self valueNoContextSwitch.	complete := true.	^result! !!BlockClosure methodsFor: 'exceptions' stamp: 'EstebanAllende 2/23/2012 23:34'!(?) on: (Exception)exception do: (BlockClosure)handlerAction	"Evaluate the receiver in the scope of an exception handler."	|(Boolean) handlerActive |	<primitive: 199>  "just a marker, fail and execute the following"	handlerActive := true.	^ self value! !!BlockClosure methodsFor: 'exceptions' stamp: 'EstebanAllende 2/23/2012 23:38'!(?) on: (Exception)exception fork: (BlockClosure)handlerAction	"Activate the receiver. In case of exception, fork a new process, which will handle an error.	An original process will continue running as if receiver evaluation finished and answered nil,	i.e., an expression like:		[ self error: 'some error'] on: Error fork: [:ex |  123 ] 		will always answer nil for original process, not 123.	The context stack , starting from context which sent this message to receiver and	up to the top of the stack will be transferred to forked process, with handlerAction on top.	(so when the forked process will be resuming, it will enter the handlerAction)	 "			^ self on: exception do: [:(Exception)ex |		| (Object)copy (ContextPart)onDoCtx (Process)process (ContextPart)handler (ContextPart)bottom (ContextPart)thisCtx |				onDoCtx := thisContext.		thisCtx := onDoCtx home.		"find the context on stack for which this method's is sender"		[ onDoCtx sender == thisCtx] whileFalse: [ 			onDoCtx := onDoCtx sender.			onDoCtx ifNil: [ 				"Can't find our home context. seems like we're already forked				and handling another exception in new thread. In this case, just pass it through handler."				^ handlerAction cull: ex ]		 ].		bottom := [ Processor terminateActive ] asContext.		onDoCtx privSender: bottom.		handler := [ handlerAction cull: ex ] asContext.		handler privSender: thisContext sender.		(Process forContext: handler priority: Processor activePriority) resume.		"cut the stack of current process"		thisContext privSender: thisCtx.		nil	]! !!BlockClosure methodsFor: 'exceptions' stamp: 'EstebanAllende 2/23/2012 23:40'!(?)onDNU: (Symbol)selector do: (BlockClosure)handleBlock	"Catch MessageNotUnderstood exceptions but only those of the given selector (DNU stands for doesNotUnderstand:)"	^ self on: MessageNotUnderstood do: [:(MessageNotUnderstood)exception |		exception message selector = selector			ifTrue: [handleBlock cull: exception]			ifFalse: [exception pass]	  ]! !!BlockClosure methodsFor: 'exceptions' stamp: 'EstebanAllende 2/23/2012 23:41'!(?) valueUninterruptably	"Prevent remote returns from escaping the sender.  Even attempts to terminate (unwind) this process will be halted and the process will resume here.  A terminate message is needed for every one of these in the sender chain to get the entire process unwound."	^ self ifCurtailed: [^ self]! !!BlockClosure methodsFor: 'initialize-release' stamp: 'EstebanAllende 2/23/2012 23:42'!(Self) outerContext: (ContextPart)aContext startpc: (Integer)aStartpc numArgs: (Integer)argCount copiedValues: (Array)anArrayOrNil	outerContext := aContext.	startpc := aStartpc.	numArgs := argCount.	1 to: self numCopiedValues do:		[:(Integer)i|		self at: i put: (anArrayOrNil at: i)]! !!BlockClosure methodsFor: 'printing' stamp: 'EstebanAllende 2/23/2012 23:42'!(Text) asText	^ self asString asText! !!BlockClosure methodsFor: 'printing' stamp: 'EstebanAllende 2/23/2012 23:51'!(Self) fullPrintOn: (WriteStream)aStream	aStream print: self; cr.	(self decompile ifNil: ['--source missing--']) printOn: aStream indent: 0! !!BlockClosure methodsFor: 'printing' stamp: 'EstebanAllende 2/23/2012 23:51'!(Self) printOn: (Stream)aStream	self decompile printAsIfCompiledOn: aStream.! !!BlockClosure methodsFor: 'scheduling' stamp: 'EstebanAllende 2/23/2012 21:34'!(MethodContext) asContext	"Create a MethodContext that is ready to execute self.  Assumes self takes no args (if it does the args will be nil)"	^self asContextWithSender: nil! !!BlockClosure methodsFor: 'scheduling' stamp: 'EstebanAllende 2/23/2012 23:51'!(Process) fork	"Create and schedule a Process running the code in the receiver."	^ self newProcess resume! !!BlockClosure methodsFor: 'scheduling' stamp: 'EstebanAllende 2/23/2012 23:52'!(Self) forkAndWait	"Suspend current process and execute self in new process, when it completes resume current process"	| (Semaphore)semaphore |	semaphore := Semaphore new.	[self ensure: [semaphore signal]] fork.	semaphore wait.! !!BlockClosure methodsFor: 'scheduling' stamp: 'EstebanAllende 2/23/2012 23:52'!(Process) forkAt: (Integer) priority 	"Create and schedule a Process running the code in the receiver at the given priority. Answer the newly created process."	^ self newProcess		priority: priority;		resume! !!BlockClosure methodsFor: 'scheduling' stamp: 'EstebanAllende 2/23/2012 23:53'!(Process) forkAt: (Integer)priority named: (String)name	"Create and schedule a Process running the code in the receiver at the	given priority and having the given name. Answer the newly created 	process."	| forkedProcess |	forkedProcess := self newProcess.	forkedProcess priority: priority.	forkedProcess name: name.	^ forkedProcess resume! !!BlockClosure methodsFor: 'scheduling' stamp: 'EstebanAllende 2/23/2012 23:53'!(Process) forkNamed: (String)aString	"Create and schedule a Process running the code in the receiver and	having the given name."	^ self newProcess name: aString; resume! !!BlockClosure methodsFor: 'scheduling' stamp: 'EstebanAllende 2/23/2012 23:54'!(Process) newProcess	"Answer a Process running the code in the receiver. The process is not 	scheduled."	<primitive: 19> "Simulation guard"	^Process		forContext: 			[self value.			Processor terminateActive] asContext		priority: Processor activePriority! !!BlockClosure methodsFor: 'scheduling' stamp: 'EstebanAllende 2/23/2012 23:55'!(Process) newProcessWith: (Array)anArray 	"Answer a Process running the code in the receiver. The receiver's block 	arguments are bound to the contents of the argument, anArray. The 	process is not scheduled."	<primitive: 19> "Simulation guard"	^Process		forContext: 			[self valueWithArguments: anArray.			Processor terminateActive] asContext		priority: Processor activePriority! !!BlockClosure methodsFor: 'splitjoin' stamp: 'EstebanAllende 2/23/2012 23:57'!(OrderedCollection) split: (SequenceableCollection)aSequenceableCollection 	| (OrderedCollection)result (Integer)position |	result := OrderedCollection new.	position := 1.	aSequenceableCollection		withIndexDo: [:(Object)element :(Integer)idx |			(self value: element)				ifTrue: [result add: (aSequenceableCollection copyFrom: position to: idx - 1).					position := idx + 1]].	result add: (aSequenceableCollection copyFrom: position to: aSequenceableCollection size).	^ result! !!BlockClosure methodsFor: 'testing' stamp: 'EstebanAllende 2/24/2012 00:01'!(Boolean) hasMethodReturn	"Answer whether the receiver has a method-return ('^') in its code."	| (CompiledMethod)myMethod (InstructionStream)scanner (Message)preceedingBytecodeMessage (Integer)end |	"Determine end of block from the instruction preceding it.	 Find the instruction by using an MNU handler to capture	 the instruction message sent by the scanner."	myMethod := outerContext method.	scanner := InstructionStream new method: myMethod pc: myMethod initialPC.	[scanner pc < startpc] whileTrue:		[[scanner interpretNextInstructionFor: nil]			on: MessageNotUnderstood			do: [:(MessageNotUnderstood)ex| preceedingBytecodeMessage := ex message]].	end := preceedingBytecodeMessage arguments last + startpc - 1.	scanner method: myMethod pc: startpc.	scanner scanFor: [:(SmallInteger)byte | (byte between: 120 and: 124) or: [scanner pc > end]].	^scanner pc <= end! !!BlockClosure methodsFor: 'testing' stamp: 'EstebanAllende 2/24/2012 00:01'!(Boolean) isClosure	^true! !!BlockClosure methodsFor: 'testing' stamp: 'EstebanAllende 2/24/2012 00:01'!(Boolean) isDead	"Has self finished"	^false! !!BlockClosure methodsFor: 'private' stamp: 'EstebanAllende 2/24/2012 00:02'!(MethodContext)asContextWithSender: (ContextPart)aContext	"Inner private support method for evaluation.  Do not use unless you know what you're doing."	^(MethodContext newForMethod: outerContext method)		setSender: aContext		receiver: outerContext receiver		method: outerContext method		closure: self		startpc: startpc;		privRefresh! !!BlockClosure methodsFor: 'private' stamp: 'EstebanAllende 2/24/2012 00:02'!(BlockClosure) asMinimalRepresentation	"Answer the receiver."	^self! !!BlockClosure methodsFor: 'private' stamp: 'EstebanAllende 2/24/2012 00:03'!(Self) becomeCached	self becomeForward: ((CachedBlockClosure new: self size)						outerContext: outerContext						startpc: startpc						numArgs: numArgs						cachedValue: self value						copiedValues: self)! !!BlockClosure methodsFor: 'private' stamp: 'EstebanAllende 2/24/2012 00:03'!(Self) becomeUncached	"The receiver is already uncached."	^self! !!BlockClosure methodsFor: 'private' stamp: 'EstebanAllende 2/24/2012 00:03'!(Self) copyForSaving	"Answer a copy of the receiver suitable for serialization.	 Notionally, if the receiver's outerContext has been returned from then nothing	 needs to be done and we can use the receiver. But there's a race condition	 determining if the receiver has been returned from (it could be executing in a	 different process). So answer a copy anyway."	^self shallowCopy postCopy! !!BlockClosure methodsFor: 'private' stamp: 'EstebanAllende 2/24/2012 00:03'!(Boolean) isValid	"Answer the receiver."	^true! !!BlockClosure methodsFor: 'private' stamp: 'EstebanAllende 2/24/2012 00:03'!(Self) reentrant	"Answer a version of the recever that can be reentered.	 Closures are reentrant (unlike BlockContect) so simply answer self."	^self! !!BlockClosure methodsFor: 'private' stamp: 'EstebanAllende 2/24/2012 00:05'!(?) valueUnpreemptively	"Evaluate the receiver (block), without the possibility of preemption by higher priority processes. Use this facility VERY sparingly!!"	"Think about using Block>>valueUninterruptably first, and think about using Semaphore>>critical: before that, and think about redesigning your application even before that!! 	After you've done all that thinking, go right ahead and use it..."	| (Process)activeProcess (Integer)oldPriority (?)result (Semaphore)semaphore |	activeProcess := Processor activeProcess.	oldPriority := activeProcess priority.	activeProcess priority: Processor highestPriority.	result := self ensure: [activeProcess priority: oldPriority].		"Yield after restoring priority to give the preempted processes a chance to run.	We inline the code of Processor yield here, but without the primitive.	The reason: the yield primitive does not take into account a change of priority as done above" 	semaphore := Semaphore new.	[semaphore signal] fork.	semaphore wait.	^result! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BlockClosure class	uses: TTyped classTrait	instanceVariableNames: ''!!BlockClosure class methodsFor: 'instance creation' stamp: 'eem 9/3/2008 14:02'!outerContext: aContext startpc: aStartpc numArgs: argCount copiedValues: anArrayOrNil	^(self new: anArrayOrNil basicSize)		outerContext: aContext		startpc: aStartpc		numArgs: argCount		copiedValues: anArrayOrNil! !