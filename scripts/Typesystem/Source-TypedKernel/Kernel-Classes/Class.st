'From Pharo1.4a of ''16 June 2011'' [Latest update: #14301] on 28 February 2012 at 8:46:32 pm'!ClassDescription subclass: #Class	uses: TBehaviorCategorization + TTyped	instanceVariableNames: '(Array)subclasses (Symbol)name (Dictionary)classPool (OrderedCollection)sharedPools (SystemDictionary)environment (Symbol)category (TraitComposition)traitComposition (Set)localSelectors'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Classes'!!Class commentStamp: '<historical>' prior: 0!I add a number of facilities to those in ClassDescription:	A set of all my subclasses (defined in ClassDescription, but only used here and below)	A name by which I can be found in a SystemDictionary	A classPool for class variables shared between this class and its metaclass	A list of sharedPools which probably should be supplanted by some better mechanism.My instances describe the representation and behavior of objects. I add more comprehensive programming support facilities to the basic attributes of Behavior and the descriptive facilities of ClassDescription.The slot 'subclasses' is a redundant structure.  It is never used during execution, but is used by the development system to simplify or speed certain operations.  !!Class methodsFor: '*HelpSystem-Core' stamp: 'EstebanAllende 2/28/2012 03:43'!(HelpTopic) asHelpTopic	^SystemReference forClass: self! !!Class methodsFor: '*Monticello' stamp: 'EstebanAllende 2/28/2012 03:44'!(MCClassDefinition) asClassDefinition	^ MCClassDefinition		name: self name		superclassName: self superclass name		traitComposition: self traitCompositionString		classTraitComposition: self class traitCompositionString		category: self category 		instVarNames: self instVarNames		classVarNames: self classVarNames		poolDictionaryNames: self poolDictionaryNames		classInstVarNames: self class instVarNames		type: self typeOfClass		comment: self organization classComment	 asString		commentStamp: self organization commentStamp	! !!Class methodsFor: '*Monticello' stamp: 'EstebanAllende 2/28/2012 03:44'!(Array) classDefinitions	^ Array with: self asClassDefinition! !!Class methodsFor: '*Monticello' stamp: 'EstebanAllende 2/28/2012 03:44'!(OrderedCollection) poolDictionaryNames	^ self sharedPools collect: [:(Class)ea | self environment keyAtIdentityValue: ea]! !!Class methodsFor: '*Ring-Core-Kernel' stamp: 'EstebanAllende 2/28/2012 11:20'!asFullRingDefinition	"A behavior is converted to a ring class including its variables, methods, direct superclass, direct subclasses and the package in which is loaded.	Active methods are generated and each knows its package as well.	Note that for its direct superclass and subclasses no full definitions are requested. If you need to traverse hierarchies use #asRingDefinitionWithMethods:withSuperclasses:withSubclasses:withPackages:"		| rgClass rgSuper rgSub rgMethod packageKeys |	rgClass:= self asRingDefinition.	rgClass package: (RGContainer packageOfClass: rgClass).		self superclass notNil ifTrue: [ 			rgSuper := (<Class>self superclass) asRingDefinition.			rgClass superclass: rgSuper ].	self subclasses do:[ :each |		rgSub := each asRingDefinition.		rgSub superclass: rgClass ].		packageKeys := RGContainer packageKeys.	self methodsDo:[ :mth|  			rgMethod := mth asActiveRingDefinition.			rgClass addMethod: rgMethod.			rgMethod package: (RGContainer packageOfMethod: rgMethod using: packageKeys) ].	self theMetaClass methodsDo:[ :mth|  			rgMethod := mth asActiveRingDefinition.			rgClass theMetaClass addMethod: rgMethod.			rgMethod package: (RGContainer packageOfMethod: rgMethod using: packageKeys) ].		^ rgClass! !!Class methodsFor: '*Ring-Core-Kernel' stamp: 'EstebanAllende 2/28/2012 03:47'!(RGClassDefinition) asRingDefinition	"A behavior is converted to a ring class. Only the receiver and its variables (instance, class, pools) are converted.	Methods, superclasses, subclasses are not generated"		| (RGClassDefinition)ring |	ring := (RGFactory current createClassNamed: self name)		category: self category;		superclassName: self superclass name;  		traitCompositionSource: self traitCompositionString;		addInstanceVariables: self instVarNames;		addClassVariables: self classVarNames;		addPoolDictionaries: self poolDictionaryNames;		comment: self organization classComment;		stamp: self organization commentStamp;		definitionSource: self definition;		withMetaclass.	ring theMetaClass 		traitCompositionSource: self theMetaClass traitCompositionString;		definitionSource: self theMetaClass definition;		addInstanceVariables: self theMetaClass instVarNames.  	^ ring! !!Class methodsFor: '*Ring-Core-Kernel' stamp: 'EstebanAllende 2/28/2012 03:57'!(RGClassDefinition)asRingDefinitionWithMethods: (Boolean)methodsBoolean withSuperclasses: (Boolean)supersBoolean withSubclasses: (Boolean)subsBoolean withPackageKeys: (OrderedCollection)packageKeys in: (RGContainer)aRGSlice		| (RGClassDefinition)rgClass (RGMethodDefinition)rgMethod (RGClassDefinition)rgSuper (RGClassDefinition)rgSub (Array)subs |		rgClass := self asRingDefinition.	aRGSlice loadClass: rgClass using: packageKeys.	methodsBoolean ifTrue: [		self methodsDo:[ :(CompiledMethod)mth|  			rgMethod := mth asActiveRingDefinition.			aRGSlice loadMethod: rgMethod inClass: rgClass using: packageKeys ].		self theMetaClass methodsDo:[ :(CompiledMethod)mth|  			rgMethod := mth asActiveRingDefinition.			aRGSlice loadMethod: rgMethod inClass: rgClass theMetaClass using: packageKeys ] ].	supersBoolean ifTrue: [		self superclass isNil			ifFalse:[				rgSuper := aRGSlice classNamed: self superclass name.				rgSuper isNil ifTrue: [				 	rgSuper := (<Class>self superclass) asRingDefinitionWithMethods: methodsBoolean withSuperclasses: supersBoolean withSubclasses: subsBoolean withPackageKeys: packageKeys in: aRGSlice ].				rgClass superclass: rgSuper ] ].		subsBoolean ifTrue: [		subs := self subclasses select:[ :(ClassDescription)sub| sub isMeta not ].		rgClass name = #Trait ifTrue: [ subs := aRGSlice environment allTraits ].		subs do:[ :(?)each|			rgSub := aRGSlice classNamed: each name.			rgSub isNil ifTrue: [				rgSub := each asRingDefinitionWithMethods: methodsBoolean withSuperclasses: supersBoolean withSubclasses: subsBoolean withPackageKeys: packageKeys in: aRGSlice ].			rgSub superclass: rgClass ] ].		^rgClass! !!Class methodsFor: '*Ring-Core-Kernel' stamp: 'EstebanAllende 2/28/2012 03:57'!(RGClassDefinition) asRingDefinitionWithMethods: (Boolean)methodsBoolean withSuperclasses: (Boolean)supersBoolean withSubclasses: (Boolean)subsBoolean withPackages: (Boolean)packsBoolean	"Retrieves a ring class based on the receiver.	The data loaded in the class (active methods, superclasses, subclasses and packages) is requested by the users.	As it may need to traverse hierarchies for retrieving super and subclasses a ring slice is created as the container for every class, method and package.	To retrieve the slice:  aRGClass environment "	| (RGClassDefinition)rgClass (RGContainer)rgSlice (OrderedCollection)rgPackageKeys |		rgSlice := RGSlice named: #fromImage.	packsBoolean ifTrue: [ 		rgPackageKeys := rgSlice loadPackagesFromImage ].	rgClass := self asRingDefinitionWithMethods: methodsBoolean withSuperclasses: supersBoolean withSubclasses: subsBoolean withPackageKeys: rgPackageKeys in: rgSlice.	rgSlice cleanEmptyPackages.	rgSlice loadTraitUsers.			^ rgClass! !!Class methodsFor: '*System-Object Storage' stamp: 'EstebanAllende 2/28/2012 11:01'!(DiskProxy) objectForDataStream: (Stream)refStrm	"I am about to be written on an object file.  Write a reference to a class in Smalltalk instead."	^ DiskProxy global: self theNonMetaClass name selector: #withClassVersion:		args: {self classVersion}	! !!Class methodsFor: '*System-Object Storage' stamp: 'EstebanAllende 2/28/2012 11:01'!(Self) storeDataOn: (DataStream)aDataStream	"I don't get stored.  Use a DiskProxy"	self error: 'use a DiskProxy to store a Class'! !!Class methodsFor: '*compiler-extensions' stamp: 'EstebanAllende 2/28/2012 11:03'!(Class) duplicateClassWithNewName: (Symbol)aSymbol	| (Symbol)copysName (Class)class (String)newDefinition |	copysName := aSymbol asSymbol.	copysName = self name		ifTrue: [ ^ self ].	(Smalltalk globals includesKey: copysName)		ifTrue: [ ^ self error: copysName , ' already exists' ].	newDefinition := self definition copyReplaceAll: '#' , self name asString with: '#' , copysName asString.	"class := "	class := EvaluateRequest evaluateAndLog: newDefinition.	class class instanceVariableNames: self class instanceVariablesString.	class copyAllCategoriesFrom: self.	class class copyAllCategoriesFrom: self class.	^ class! !!Class methodsFor: '*typesystem-compiler-subclass creation' stamp: 'EstebanAllende 2/28/2012 03:35'!(Self) subclass: (Symbol)t instanceVariableNames: (String)f classVariableNames: (String)d poolDictionaries: (String)s category: (String)cat 	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver)."	|(Self)class (VariablesParser)varParser|	varParser :=( (VariablesParser new)		class: t;		ivar: f;		cvar: d).	class := (ClassBuilder new)		superclass: self		subclass: t		instanceVariableNames: varParser oldIvar		classVariableNames: varParser oldCvar		poolDictionaries: s		category: cat.		"Here we must check if all old instances comply with the type specification"	varParser annotateVars.	^class! !!Class methodsFor: '*typesystem-compiler-subclass creation' stamp: 'EstebanAllende 2/28/2012 03:37'!(Self) variableByteSubclass: (Symbol)t instanceVariableNames: (String)f classVariableNames: (String)d poolDictionaries: (String)s category: (String)cat 	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."		|(Self)class (VariablesParser)varParser|	varParser :=( (VariablesParser new)		class: t;		ivar: f;		cvar: d).	class := (ClassBuilder new)		superclass: self		variableByteSubclass: t		instanceVariableNames: varParser oldIvar		classVariableNames: varParser oldCvar		poolDictionaries: s		category: cat.		"Here we must check if all old instances comply with the type specification"	varParser annotateVars.	^class."	^(ClassBuilder new)		superclass: self		variableByteSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat"! !!Class methodsFor: '*typesystem-compiler-subclass creation' stamp: 'EstebanAllende 2/28/2012 03:37'!(Self) variableSubclass: (Symbol)t instanceVariableNames: (String)f classVariableNames: (String)d poolDictionaries: (String)s category: (String)cat 	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."		|(Self)class (VariablesParser)varParser|	varParser :=( (VariablesParser new)		class: t;		ivar: f;		cvar: d).			class := (ClassBuilder new)		superclass: self		variableSubclass: t		instanceVariableNames: varParser oldIvar		classVariableNames: varParser oldCvar		poolDictionaries: s		category: cat.		"Here we must check if all old instances comply with the type specification"	varParser annotateVars.	^class	"^(ClassBuilder new)		superclass: self		variableSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat"! !!Class methodsFor: '*typesystem-compiler-subclass creation' stamp: 'EstebanAllende 2/28/2012 03:37'!(Self) variableWordSubclass: (Symbol)t instanceVariableNames: (String)f classVariableNames: (String)d poolDictionaries: (String)s category: (String)cat 	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."	|(Self)class (VariablesParser)varParser|	varParser :=( (VariablesParser new)		class: t;		ivar: f;		cvar: d)."	^(ClassBuilder new)		superclass: self		variableWordSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat"					class := (ClassBuilder new)		superclass: self		variableWordSubclass: t		instanceVariableNames: varParser oldIvar		classVariableNames: varParser oldCvar		poolDictionaries: s		category: cat.		"Here we must check if all old instances comply with the type specification"	varParser annotateVars.	^class! !!Class methodsFor: '*typesystem-compiler-subclass creation' stamp: 'EstebanAllende 2/28/2012 03:37'!(Self) weakSubclass: (Symbol)t instanceVariableNames: (String)f classVariableNames: (String)d poolDictionaries: (String)s category: (String)cat 	"This is the standard initialization message for creating a new class as a subclass of an existing class (the receiver) in which the subclass is to have weak indexable pointer variables.""	^(ClassBuilder new)		superclass: self		weakSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat"			|(Self)class (VariablesParser)varParser|	varParser :=( (VariablesParser new)		class: t;		ivar: f;		cvar: d).	class := (ClassBuilder new)		superclass: self		weakSubclass: t		instanceVariableNames: varParser oldIvar		classVariableNames: varParser oldCvar		poolDictionaries: s		category: cat.		"Here we must check if all old instances comply with the type specification"	varParser annotateVars.	^class! !!Class methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 02:04'!(Symbol) basicCategory	^category! !!Class methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 02:04'!(Self) basicCategory: (Symbol)aSymbol	category := aSymbol! !!Class methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 02:04'!(Set) basicLocalSelectors	"Direct accessor for the instance variable localSelectors.	Since localSelectors is lazily initialized, this may 	return nil, which means that all selectors are local."	^ localSelectors! !!Class methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 02:04'!(Self) basicLocalSelectors: (Set)aSetOrNil	localSelectors := aSetOrNil! !!Class methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 02:04'!(Dictionary) classPool	"Answer the dictionary of class variables."	classPool == nil		ifTrue: [^Dictionary new]		ifFalse: [^classPool]! !!Class methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 02:05'!(Self) classPoolFrom: (Class)aClass	"share the classPool with aClass."	classPool := aClass classPool! !!Class methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 02:05'!(Self) classPool: (Dictionary)aDictionary	classPool := aDictionary! !!Class methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 02:05'!(Boolean) hasTraitComposition		^ traitComposition notNil and: [ traitComposition notEmpty ]! !!Class methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 02:15'!(Symbol) name	"Answer the name of the receiver."	name == nil		ifTrue: [^(<Symbol>super name)]		ifFalse: [^name]! !!Class methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 02:06'!(TraitComposition) traitComposition	traitComposition ifNil: [traitComposition := TraitComposition new].	^traitComposition! !!Class methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 02:06'!(Self) traitComposition: (TraitComposition)aTraitComposition	traitComposition := aTraitComposition! !!Class methodsFor: 'accessing class hierarchy' stamp: 'EstebanAllende 2/28/2012 02:07'!(Self) addSubclass: (Class)aSubclass 	"Make the argument, aSubclass, be one of the subclasses of the receiver. 	Create an error notification if the argument's superclass is not the receiver."		aSubclass superclass ~~ self 		ifTrue: [^self error: aSubclass name , ' is not my subclass'].	subclasses == nil		ifTrue:	[subclasses := Array with: aSubclass.				^self].	subclasses do:[:cl| cl == aSubclass ifTrue:[^self]]. "Already my subclass"	subclasses := subclasses copyWith: aSubclass.! !!Class methodsFor: 'accessing class hierarchy' stamp: 'EstebanAllende 2/28/2012 02:07'!(Self) removeSubclass: (Class)aSubclass 	"If the argument, aSubclass, is one of the receiver's subclasses, remove it."	subclasses == nil ifFalse:		[subclasses :=  subclasses copyWithout: aSubclass.		subclasses isEmpty ifTrue: [subclasses := nil]].! !!Class methodsFor: 'accessing class hierarchy' stamp: 'EstebanAllende 2/28/2012 02:08'!(Array) subclasses	"Answer a Set containing the receiver's subclasses."	^subclasses == nil		ifTrue: [#()]		ifFalse: [subclasses copy]! !!Class methodsFor: 'accessing class hierarchy' stamp: 'EstebanAllende 2/28/2012 02:08'!(Self) subclassesDo: (Self → Object)aBlock 	"Evaluate the argument, aBlock, for each of the receiver's immediate subclasses."	subclasses == nil 		ifFalse:[subclasses do: aBlock]! !!Class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 2/28/2012 02:11'!(SharedPool) sharedPoolOfVarNamed: (String)aString	"Returns the SharedPool or nil from which the pool variable named aString is coming from."		 ^ self sharedPools 			detect: [:(Class)each | each usesClassVarNamed: aString ]			ifNone: [						superclass == nil							ifTrue: [nil]							ifFalse: [(<Class>superclass) sharedPoolOfVarNamed: aString]						]					! !!Class methodsFor: 'class name' stamp: 'EstebanAllende 2/28/2012 02:15'!(Self) rename: (String)aString 	"The new name of the receiver is the argument, aString."	| (Symbol)oldName (Symbol)newName |	(newName := aString asSymbol) = (oldName := self name)		ifTrue: [^ self].	(self environment includesKey: newName)		ifTrue: [^ self error: newName , ' already exists'].	name := newName.	self environment renameClass: self from: oldName.	(Undeclared includesKey: newName)		ifTrue: [self inform: 'There are references to, ' , aString printString , 'from Undeclared. Check them after this change.'].	! !!Class methodsFor: 'class variables' stamp: 'EstebanAllende 2/28/2012 02:16'!(Self) addClassVarNamed: (String)aString 	"Add the argument, aString, as a class variable of the receiver.	Signal an error if the first character of aString is not capitalized,	or if it is already a variable named in the class."	| (Symbol)symbol (Self)oldState |	oldState := self copy.	aString first canBeGlobalVarInitial		ifFalse: [^self error: aString, ' class variable name should be capitalized; proceed to include anyway.'].	symbol := aString asSymbol.	self withAllSubclasses do: 		[:(ClassDescription)subclass | 		(subclass bindingOf: symbol) ifNotNil:[			^ self error: aString 				, ' is already used as a variable name in class ' 				, subclass name]].	classPool == nil ifTrue: [classPool := Dictionary new].	(classPool includesKey: symbol) ifFalse: 		["Pick up any refs in Undeclared"		classPool declare: symbol from: Undeclared.		SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: oldState to: self]! !!Class methodsFor: 'class variables' stamp: 'EstebanAllende 2/28/2012 02:17'!(Set) allClassVarNames	"Answer a Set of the names of the receiver's class variables, including those	defined in the superclasses of the receiver."	| (Set)aSet |	self superclass == nil		ifTrue: 			[^self classVarNames asSet]  "This is the keys so it is a new Set."		ifFalse: 			[aSet := self superclass allClassVarNames.			aSet addAll: self classVarNames.			^aSet]! !!Class methodsFor: 'class variables' stamp: 'EstebanAllende 2/28/2012 02:18'!(Symbol) classVarNamed: (String)aString	"Answer the content of the Class Variable"	^self classPool at: aString asSymbol ifAbsent: [self error: 'no such lass var']! !!Class methodsFor: 'class variables' stamp: 'EstebanAllende 2/28/2012 02:19'!(Self) classVarNamed: (String)aString put: (ProtoObject)anObject	"Store anObject in the class variable."		| (Symbol)symbol |	symbol := aString asSymbol.	(self classPool includesKey: symbol) ifFalse:  [^self error: 'no such lass var'].	self classPool at: symbol put: anObject.! !!Class methodsFor: 'class variables' stamp: 'EstebanAllende 2/28/2012 02:19'!(Array) classVarNames	"Answer a collection of the names of the class variables defined in the receiver."	^self classPool keys asArray sort! !!Class methodsFor: 'class variables' stamp: 'EstebanAllende 2/28/2012 02:19'!(Self) ensureClassPool	classPool ifNil: [classPool := Dictionary new].! !!Class methodsFor: 'class variables' stamp: 'EstebanAllende 2/28/2012 02:19'!(Boolean) hasClassVarNamed: (String)aString	"Return whether the receiver has a class variables (shared variables among its class and subclasses) named: aString"		^ self classVarNames includes: aString! !!Class methodsFor: 'class variables' stamp: 'EstebanAllende 2/28/2012 02:21'!(Self) removeClassVarNamed: (String)aString 	"Remove the class variable whose name is the argument, aString, from 	the names defined in the receiver, a class. Create an error notification if 	aString is not a class variable or if it is still being used in the code of 	the class."	| (Symbol)aSymbol |	aSymbol := aString asSymbol.	(classPool includesKey: aSymbol)		ifFalse: [^self error: aString, ' is not a class variable'].	self withAllSubclasses do:[:(ClassDescription)subclass |		(Array with: subclass with: subclass class) do:[:(ClassDescription)classOrMeta |			(classOrMeta whichSelectorsReferTo: (classPool associationAt: aSymbol))				isEmpty ifFalse: [					InMidstOfFileinNotification signal ifTrue: [						self crTrace: self name, ' (' , aString , ' is Undeclared) '.						^Undeclared declare: aSymbol from: classPool].					(self confirm: (aString,' is still used in code of class ', classOrMeta name,						'.\Is it okay to move it to Undeclared?') withCRs)						ifTrue: [^Undeclared declare: aSymbol from: classPool]						ifFalse: [^self]]]].	classPool removeKey: aSymbol.	classPool isEmpty ifTrue: [classPool := nil].! !!Class methodsFor: 'class variables' stamp: 'EstebanAllende 2/28/2012 02:21'!(Boolean) usesClassVarNamed: (String)aString	"Return whether the receiver or its superclasses have a class variable named: aString"		^ self allClassVarNames includes: aString! !!Class methodsFor: 'compiling' stamp: 'EstebanAllende 2/28/2012 02:22'!(Association) binding       "Answer a binding for the receiver, sharing if possible"      | (Association)binding |	binding := self environment associationAt: name ifAbsent: [nil -> self].       ^binding value == self ifTrue: [binding] ifFalse: [nil -> self]! !!Class methodsFor: 'compiling' stamp: 'EstebanAllende 2/28/2012 02:22'!(Association) bindingOf: (String)varName	"Answer the binding of some variable resolved in the scope of the receiver, or nil	if variable with such name is not defined"	"The lookup recurses up to superclasses looking inside their class and shared pools,	but not the environment, since two classes, even if they have ancestry relationship,	could use different environments.	That's why we doing an environment lookup only as a last step of symbol lookup 	and taking only the environment of receiver only, not any of it's superclass(es) "		| (Symbol)aSymbol|	aSymbol := varName asSymbol.	^ (self innerBindingOf: aSymbol) ifNil: [		 self environment bindingOf: aSymbol	]! !!Class methodsFor: 'compiling' stamp: 'EstebanAllende 2/28/2012 02:32'!(Boolean) canFindWithoutEnvironment: (String)varName	"This method is used for analysis of system structure -- see senders."	"Look up varName, in the context of the receiver. Return true if it can be found without using the declared environment."	"First look in classVar dictionary."	(self classPool bindingOf: varName) ifNotNil:[^true].	"Next look in shared pools."	self sharedPools do:[:(Object)pool | 		(pool bindingOf: varName) ifNotNil:[^true].	].	"Finally look higher up the superclass chain and fail at the end."	superclass == nil		ifTrue: [^ false]		ifFalse: [^ (superclass bindingOf: varName) notNil].! !!Class methodsFor: 'compiling' stamp: 'EstebanAllende 2/28/2012 02:25'!(Self) compileAll	super compileAll.	self class compileAll.! !!Class methodsFor: 'compiling' stamp: 'EstebanAllende 2/28/2012 02:26'!(Self) compileAllFrom: (Behavior)oldClass	"Recompile all the methods in the receiver's method dictionary (not the	subclasses). Also recompile the methods in the metaclass."	super compileAllFrom: oldClass.	self class compileAllFrom: oldClass class! !!Class methodsFor: 'compiling' stamp: 'EstebanAllende 2/28/2012 02:32'!(Association) innerBindingOf: (Symbol)aSymbol	"Answer the binding of some variable resolved in the scope of the receiver, or one of its superclass	but do not look up binding in receiver's environment.	Use #bindingOf: for looking up the variable binding in a full scope, including receiver's environment"		| (Association)binding |	"First look in classVar dictionary."	binding := self classPool bindingOf: aSymbol.	binding ifNotNil: [^binding].	"Next look in shared pools."	self sharedPools do: [:(Object)pool | 		| (Association)aBinding |		aBinding := pool bindingOf: aSymbol.		aBinding ifNotNil: [^aBinding ].	].	superclass ifNotNil: [		^ (<Class>superclass) innerBindingOf: aSymbol.	].		^ nil! !!Class methodsFor: 'compiling' stamp: 'EstebanAllende 2/28/2012 02:35'!(String)possibleVariablesFor: (String)misspelled continuedFrom: (String)oldResults	| (String)results |	results := misspelled correctAgainstDictionary: self classPool continuedFrom: oldResults.	self sharedPools do: [:(Object)pool | 		results := misspelled correctAgainstDictionary: pool continuedFrom: results ].	superclass == nil		ifTrue: 			[ ^ misspelled correctAgainstDictionary: self environment continuedFrom: results ]		ifFalse:			[ ^ (<Class>superclass) possibleVariablesFor: misspelled continuedFrom: results ]! !!Class methodsFor: 'copying' stamp: 'EstebanAllende 2/28/2012 02:36'!(Self) copy 	"Answer a copy of the receiver without a list of subclasses."	| (Self)newClass |	newClass := (<?>self class copy) new		superclass: superclass		methodDict: self methodDict copy		format: format		name: name		organization: self organization copy		instVarNames: instanceVariables copy		classPool: classPool copy		sharedPools: sharedPools copy.	Class instSize+1 to: self class instSize do:		[:(Integer)offset | newClass instVarAt: offset put: (self instVarAt: offset)].	^ newClass! !!Class methodsFor: 'fileIn/Out' stamp: 'EstebanAllende 2/28/2012 02:37'!(Self) fileOut	"Create a file whose name is the name of the receiver with '.st' as the 	extension, and file a description of the receiver onto it."		| (WriteStream)internalStream |	internalStream := (String new: 100) writeStream.	internalStream header; timeStamp.	self hasSharedPools ifTrue: [		self shouldFileOutPools			ifTrue: [self fileOutSharedPoolsOn: internalStream]].	self fileOutOn: internalStream moveSource: false toFile: 0.	internalStream trailer.	FileStream writeSourceCodeFrom: internalStream baseName: self name isSt: true! !!Class methodsFor: 'fileIn/Out' stamp: 'EstebanAllende 2/28/2012 02:38'!(Self) fileOutInitializerOn: (Stream)aStream	^self class fileOutInitializerOn: aStream! !!Class methodsFor: 'fileIn/Out' stamp: 'al 9/3/2004 14:04'!fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex 	"File a description of the receiver on aFileStream. If the boolean argument,	moveSource, is true, then set the trailing bytes to the position of aFileStream and	to fileIndex in order to indicate where to find the source code."	^self fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex initializing: true! !!Class methodsFor: 'fileIn/Out' stamp: 'EstebanAllende 2/28/2012 02:50'!(Self) fileOutOn: (WriteStream)aFileStream moveSource: (Boolean)moveSource toFile: (Integer)fileIndex initializing: (Boolean)aBool	"File a description of the receiver on aFileStream. If the boolean argument,	moveSource, is true, then set the trailing bytes to the position of aFileStream and	to fileIndex in order to indicate where to find the source code."	self crTrace: self name.	super		fileOutOn: aFileStream		moveSource: moveSource		toFile: fileIndex.	self class nonTrivial		ifTrue:			[aFileStream cr; nextPutAll: '"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!!'; cr; cr.			self class				fileOutOn: aFileStream				moveSource: moveSource				toFile: fileIndex				initializing: aBool]! !!Class methodsFor: 'fileIn/Out' stamp: 'EstebanAllende 2/28/2012 02:52'!(Self) fileOutPool: (Dictionary)aPool onFileStream: (WriteStream)aFileStream 	| aPoolName |	(aPool  isKindOf: SharedPool class) ifTrue:[^self notify: 'we do not fileout SharedPool type shared pools for now'].	aPoolName := self environment keyAtIdentityValue: aPool.	self crTrace: aPoolName.	aFileStream nextPutAll: 'Transcript show: ''' , aPoolName , '''; cr!!'; cr.	aFileStream nextPutAll: 'Smalltalk at: #' , aPoolName , ' put: Dictionary new!!'; cr.	aPool keys asSortedCollection do: [ :(String)aKey | | (Object)aValue |		aValue := aPool at: aKey.		aFileStream nextPutAll: aPoolName , ' at: #''' , aKey asString , '''', ' put:  '.		(aValue isKindOf: Number)			ifTrue: [aValue printOn: aFileStream]			ifFalse: [aFileStream nextPutAll: '('.					aValue printOn: aFileStream.					aFileStream nextPutAll: ')'].		aFileStream nextPutAll: '!!'; cr].	aFileStream cr! !!Class methodsFor: 'fileIn/Out' stamp: 'EstebanAllende 2/28/2012 02:53'!(Self) fileOutSharedPoolsOn: (WriteStream)aFileStream	"file out the shared pools of this class after prompting the user about each pool"	| (Collection)poolsToFileOut |	poolsToFileOut := self sharedPools select: 		[:(Dictionary)aPool | (self shouldFileOutPool: (self environment keyAtIdentityValue: aPool))].	poolsToFileOut do: [:(Dictionary)aPool | self fileOutPool: aPool onFileStream: aFileStream].	! !!Class methodsFor: 'fileIn/Out' stamp: 'EstebanAllende 2/28/2012 02:53'!(Boolean) hasSharedPools	"Returns whether the receiver uses shared pools directly (Does not take into account that it may inherit shared pool uses."	^ self sharedPools notEmpty! !!Class methodsFor: 'fileIn/Out' stamp: 'EstebanAllende 2/28/2012 02:53'!(Self) reformatAll 	"Reformat all methods in this class.	Leaves old code accessible to version browsing"	super reformatAll.		"me..."	self class reformatAll	"...and my metaclass"! !!Class methodsFor: 'fileIn/Out' stamp: 'EstebanAllende 2/28/2012 02:53'!(Self) removeFromChanges	"References to the receiver, a class, and its metaclass should no longer be included in the system ChangeSet.	7/18/96 sw: call removeClassAndMetaClassChanges:"	ChangeSet current removeClassAndMetaClassChanges: self! !!Class methodsFor: 'fileIn/Out' stamp: 'EstebanAllende 2/28/2012 02:54'!(Boolean) shouldFileOutPool: (String)aPoolName	"respond with true if the user wants to file out aPoolName"	^self confirm: ('FileOut the sharedPool ', aPoolName, '?')! !!Class methodsFor: 'fileIn/Out' stamp: 'EstebanAllende 2/28/2012 02:54'!(Boolean) shouldFileOutPools	"respond with true if the user wants to file out the shared pools"	^self confirm: 'FileOut selected sharedPools?'! !!Class methodsFor: 'fileIn/Out' stamp: 'EstebanAllende 2/28/2012 02:54'!(Self) withClassVersion: (Integer)aVersion	aVersion = self classVersion ifTrue:[^self].	^self error: 'Invalid class version'! !!Class methodsFor: 'initialize-release' stamp: 'EstebanAllende 2/28/2012 02:56'!(Boolean) declare: (String)varString 	"Declare class variables common to all instances. Answer whether 	recompilation is advisable."	| (Collection)newVars (Boolean)conflicts |	newVars := 		(varString subStrings: ' ')			collect: [:(String)x | x asSymbol].	conflicts := false.	classPool == nil 		ifFalse: [(classPool keys reject: [:(Symbol)x | newVars includes: x]) do: 					[:(Symbol)var | self removeClassVarNamed: var]].	(newVars reject: [:(Symbol)var | self classPool includesKey: var])		do: [:(Symbol)var | "adding"			"check if new vars defined elsewhere"			(self bindingOf: var) notNil				ifTrue: 					[(DuplicatedVariableError new) variable: var;						signal: var , ' is defined elsewhere'.					conflicts := true]].	newVars size > 0		ifTrue: 			[classPool := self classPool.			"in case it was nil"			newVars do: [:(Symbol)var | classPool declare: var from: Undeclared]].	^conflicts! !!Class methodsFor: 'initialize-release' stamp: 'EstebanAllende 2/28/2012 20:46'!(Self) obsolete	"Change the receiver and all of its subclasses to an obsolete class."	self == Object 		ifTrue: [^self error: 'Object is NOT obsolete'].	self setName: ('AnObsolete' , self name) asSymbol.	Object class instSize + 1 to: self class instSize do:		[:(Integer)i | self instVarAt: i put: nil]. "Store nil over class instVars."	self classPool: nil.	self sharedPools: nil.	self class obsolete.	super obsolete.! !!Class methodsFor: 'initialize-release' stamp: 'EstebanAllende 2/28/2012 02:59'!(Self)removeFromSystem	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."	self removeFromSystem: true.! !!Class methodsFor: 'initialize-release' stamp: 'EstebanAllende 2/28/2012 02:59'!(Self) removeFromSystem: (Boolean)logged	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."		"keep the class name and category for triggering the system change message. If we wait to long, then we get obsolete information which is not what we want."	"tell class to deactivate and unload itself-- two separate events in the module system"	self unload.	self superclass ifNotNil:		["If we have no superclass there's nothing to be remembered"		self superclass addObsoleteSubclass: self].	self environment forgetClass: self logged: logged.	self obsolete.! !!Class methodsFor: 'initialize-release' stamp: 'EstebanAllende 2/28/2012 02:59'!(Self) removeFromSystemUnlogged	"Forget the receiver from the Smalltalk global dictionary. Any existing instances will refer to an obsolete version of the receiver.  Do not log the removal either to the current change set nor to the system changes log"	^self removeFromSystem: false! !!Class methodsFor: 'initialize-release' stamp: 'EstebanAllende 2/28/2012 03:01'!(Boolean) sharing: (String)poolString 	"Set up sharedPools. Answer whether recompilation is advisable."	| (OrderedCollection)oldPools |	oldPools := self sharedPools.	sharedPools := OrderedCollection new.	(poolString subStrings: ' ') do: 		[:(String)poolName | 		sharedPools add: (self environment at: poolName asSymbol ifAbsent:[			(self confirm: 'The pool dictionary ', poolName,' does not exist.',						'\Do you want it automatically created?' withCRs)				ifTrue:[self environment at: poolName asSymbol put: Dictionary new]				ifFalse:[^self error: poolName,' does not exist']])].	sharedPools isEmpty ifTrue: [sharedPools := nil].	oldPools do: [:(Dictionary)pool |				| (Boolean)found |				found := self sharedPools anySatisfy: [:p | p == pool].				found ifFalse: [^ true "A pool got deleted"]].	^ false! !!Class methodsFor: 'initialize-release' stamp: 'EstebanAllende 2/28/2012 03:03'!(Self) superclass: (Class)sup methodDict: (MethodDictionary)md format: (Integer)ft name: (Symbol)nm organization: (ClassOrganizer)org instVarNames: (Array)nilOrArray classPool: (Dictionary)pool sharedPools: (OrderedCollection)poolSet 	"Answer an instance of me, a new class, using the arguments of the 	message as the needed information.	Must only be sent to a new instance; else we would need Object flushCache."	superclass := sup.	methodDict := md.	format := ft.	name := nm.	instanceVariables := nilOrArray.	classPool := pool.	sharedPools := poolSet.	self organization: org.! !!Class methodsFor: 'initialize-release' stamp: 'EstebanAllende 2/28/2012 03:04'!(Self) superclass: (Behavior)aClass methodDictionary: (MethodDictionary)mDict format: (Integer)fmt	"Basic initialization of the receiver"	super superclass: aClass methodDictionary: mDict format: fmt.	subclasses := nil. "Important for moving down the subclasses field into Class"! !!Class methodsFor: 'initialize-release' stamp: 'EstebanAllende 2/28/2012 03:04'!(Self) unload	"Sent when a the class is removed.  Does nothing, but may be overridden by (class-side) subclasses."! !!Class methodsFor: 'instance variables' stamp: 'EstebanAllende 2/28/2012 03:06'!(Self) addInstVarNamed: (String)aString	"Add the argument, aString, as one of the receiver's instance variables."	^(ClassBuilder new)		name: self name		inEnvironment: self environment		subclassOf: self superclass		type: self typeOfClass		instanceVariableNames: self instanceVariablesString, ' ', aString		classVariableNames: self classVariablesString		poolDictionaries: self sharedPoolsString		category: self category! !!Class methodsFor: 'instance variables' stamp: 'EstebanAllende 2/28/2012 03:06'!(Self) removeInstVarNamed: (String)aString 	"Remove the argument, aString, as one of the receiver's instance variables."	| newInstVarString |	(self instVarNames includes: aString)		ifFalse: [self error: aString , ' is not one of my instance variables'].	newInstVarString := ''.	(self instVarNames copyWithout: aString) do: 		[:(String)varName | newInstVarString := newInstVarString , ' ' , varName].	^(ClassBuilder new)		name: self name		inEnvironment: self environment		subclassOf: self superclass		type: self typeOfClass		instanceVariableNames: newInstVarString		classVariableNames: self classVariablesString		poolDictionaries: self sharedPoolsString		category: self category! !!Class methodsFor: 'organization' stamp: 'EstebanAllende 2/28/2012 03:07'!(Symbol) category	"Answer the system organization category for the receiver. First check whether the	category name stored in the ivar is still correct and only if this fails look it up	(latter is much more expensive)"	| (Symbol)result |	self basicCategory ifNotNil: [ :(Symbol)symbol |		((self environment organization listAtCategoryNamed: symbol) includes: self name)			ifTrue: [ ^symbol ] ].	self basicCategory: (result := self environment organization categoryOfElement: self name).	^result! !!Class methodsFor: 'organization' stamp: 'EstebanAllende 2/28/2012 03:08'!(Self) category: (String)aString 	"Categorize the receiver under the system category, aString, removing it from 	any previous categorization."	| (Symbol)oldCategory |	oldCategory := self basicCategory.	aString isString		ifTrue: [			self basicCategory: aString asSymbol.			self environment organization classify: self name under: self basicCategory ]		ifFalse: [self errorCategoryName].	SystemChangeNotifier uniqueInstance		class: self recategorizedFrom: oldCategory to: self basicCategory! !!Class methodsFor: 'organization' stamp: 'EstebanAllende 2/28/2012 03:08'!(SystemDictionary) environment	environment == nil ifTrue: [^ super environment].	^ environment! !!Class methodsFor: 'organization' stamp: 'EstebanAllende 2/28/2012 03:08'!(Self) environment: (SystemDictionary)anEnvironment	environment := anEnvironment! !!Class methodsFor: 'pool variables' stamp: 'EstebanAllende 2/28/2012 03:09'!(Self) addSharedPool: (Dictionary)aSharedPool 	"Add the argument, aSharedPool, as one of the receiver's shared pools. 	Create an error if the shared pool is already one of the pools.	This method will work with shared pools that are plain Dictionaries or thenewer SharedPool subclasses"	(self sharedPools includes: aSharedPool)		ifTrue: [^self error: 'This is already in my shared pool list'].	sharedPools == nil		ifTrue: [sharedPools := OrderedCollection with: aSharedPool]		ifFalse: [sharedPools add: aSharedPool]! !!Class methodsFor: 'pool variables' stamp: 'EstebanAllende 2/28/2012 03:09'!(OrderedCollection)allSharedPools	"Answer an ordered collection of the pools the receiver shares, including those defined  in the superclasses of the receiver."	| (OrderedCollection)aSet | 	^self superclass == nil		ifTrue: [self sharedPools copy]		ifFalse: [aSet := self superclass allSharedPools.			aSet addAll: self sharedPools.			aSet]! !!Class methodsFor: 'pool variables' stamp: 'StephaneDucasse 12/24/2011 12:06'!hasPoolVarNamed: aString	self deprecated: 'Renamed to #usesLocalPoolVarNamed:' on: '16 Decembre 2011'  in: 'Pharo1.4'.	^ self usesLocalPoolVarNamed: aString! !!Class methodsFor: 'pool variables' stamp: 'EstebanAllende 2/28/2012 03:12'!(Self) removeSharedPool: (Dictionary)aDictionary 	"Remove the pool dictionary, aDictionary, as one of the receiver's pool 	dictionaries. Create an error notification if the dictionary is not one of 	the pools.	: Note that it removes the wrong one if there are two empty Dictionaries in the list."	| (Set)satisfiedSet (OrderedCollection)workingSet (ClassDescription)aSubclass |	(self sharedPools includes: aDictionary)		ifFalse: [^self error: 'the dictionary is not in my pool'].	"first see if it is declared in a superclass in which case we can remove it."	(self selectSuperclasses: [:(Behavior)class | class sharedPools includes: aDictionary]) isEmpty		ifFalse: [sharedPools remove: aDictionary.				sharedPools isEmpty ifTrue: [sharedPools := nil].				^self]. 	"second get all the subclasses that reference aDictionary through me rather than a 	superclass that is one of my subclasses."	workingSet := self subclasses asOrderedCollection.	satisfiedSet := Set new.	[workingSet isEmpty] whileFalse:		[aSubclass := workingSet removeFirst.		(aSubclass sharedPools includes: aDictionary)			ifFalse: 				[satisfiedSet add: aSubclass.				workingSet addAll: aSubclass subclasses]].	"for each of these, see if they refer to any of the variables in aDictionary because 	if they do, we can not remove the dictionary."	satisfiedSet add: self.	satisfiedSet do: 		[:(ClassDescription)sub | 		aDictionary associationsDo: 			[:(Association)aGlobal | 			(sub whichSelectorsReferTo: aGlobal) isEmpty 				ifFalse: [^self error: aGlobal key 								, ' is still used in code of class '								, sub name]]].	sharedPools remove: aDictionary.	sharedPools isEmpty ifTrue: [sharedPools := nil]! !!Class methodsFor: 'pool variables' stamp: 'EstebanAllende 2/28/2012 03:13'!(OrderedCollection) sharedPools	"Answer an orderedCollection  of the shared pools declared in the receiver."	sharedPools == nil		ifTrue: [^OrderedCollection new]		ifFalse: [^sharedPools]! !!Class methodsFor: 'pool variables' stamp: 'EstebanAllende 2/28/2012 03:13'!(Self) sharedPools: (OrderedCollection)aCollection	sharedPools := aCollection! !!Class methodsFor: 'pool variables' stamp: 'EstebanAllende 2/28/2012 03:19'!(Boolean) usesLocalPoolVarNamed: (String)aString	"Return whether the receiver uses a pool variable named: aString which is defined locally"		self hasSharedPools		ifTrue: [ self sharedPools do: [:(Class)each | (each usesClassVarNamed: aString) 												ifTrue: [ ^true ]]]		ifFalse: [ ^false ].	^false! !!Class methodsFor: 'pool variables' stamp: 'EstebanAllende 2/28/2012 03:21'!(Boolean) usesPoolVarNamed: (String)aString	"Return whether the receiver has a pool variable named: aString, taking into account superclasses too"		self allSharedPools do: [:(Class)each | (each usesClassVarNamed: aString) ifTrue: [^true]].	^false! !!Class methodsFor: 'self evaluating' stamp: 'EstebanAllende 2/28/2012 03:22'!(Boolean) isSelfEvaluating	^self isObsolete not! !!Class methodsFor: 'subclass creation' stamp: 'EstebanAllende 2/28/2012 03:22'!(Self) newSubclass	| (Integer)i (Symbol)className |	i := 1.	[className := (self name , i printString) asSymbol.	 self environment includesKey: className]		whileTrue: [i := i + 1].	^ self subclass: className		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Unclassified'"Point newSubclass new"! !!Class methodsFor: 'subclass creation' stamp: 'EstebanAllende 2/28/2012 03:23'!(Self) subclass: (Symbol)t	^ self subclass: t instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'Unclassified' ! !!Class methodsFor: 'subclass creation' stamp: 'EstebanAllende 2/28/2012 03:29'!(Self) subclass: (Symbol)t instanceVariableNames: (String)ins	^ self subclass: t instanceVariableNames: ins classVariableNames: '' poolDictionaries: '' category: 'Unclassified' ! !!Class methodsFor: 'subclass creation' stamp: 'EstebanAllende 2/28/2012 03:29'!(Self) subclass: (Symbol)t uses: ({asTraitComposition (→TraitComposition)})aTraitComposition 	| (Self)cls |	cls := self				subclass: t				instanceVariableNames: ''				classVariableNames: ''				poolDictionaries: ''				category: 'Unclassified'.	cls setTraitComposition: aTraitComposition asTraitComposition.	^ cls! !!Class methodsFor: 'subclass creation' stamp: 'EstebanAllende 2/28/2012 03:26'!(Self) subclass: (Symbol)t uses: ({asTraitComposition (→TraitComposition)})aTraitCompositionOrArray instanceVariableNames: (String)f classVariableNames: (String)d poolDictionaries: (String)s category: (String)cat 	| (Self)newClass (Self)copyOfOldClass |	copyOfOldClass := self copy.	newClass := self		subclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat.				newClass setTraitComposition: aTraitCompositionOrArray asTraitComposition.	SystemChangeNotifier uniqueInstance		classDefinitionChangedFrom: copyOfOldClass to: newClass.	^newClass! !!Class methodsFor: 'subclass creation' stamp: 'EstebanAllende 2/28/2012 03:40'!(Self) variableByteSubclass: (Symbol)t uses: ({asTraitComposition (→TraitComposition)})aTraitCompositionOrArray instanceVariableNames: (String)f classVariableNames: (String)d poolDictionaries: (String)s category: (String)cat 	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."		| (Self)newClass (Self)copyOfOldClass |	copyOfOldClass := self copy.	newClass := self		variableByteSubclass: t 		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat.		newClass setTraitComposition: aTraitCompositionOrArray asTraitComposition.	SystemChangeNotifier uniqueInstance		classDefinitionChangedFrom: copyOfOldClass to: newClass.	^newClass! !!Class methodsFor: 'subclass creation' stamp: 'EstebanAllende 2/28/2012 03:40'!(Self) variableSubclass: (Symbol)t uses: ({asTraitComposition (→TraitComposition)})aTraitCompositionOrArray instanceVariableNames: (String)f classVariableNames: (String)d poolDictionaries: (String)s category: (String)cat 	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."		| (Self)newClass (Self)copyOfOldClass |	copyOfOldClass := self copy.	newClass := self		variableSubclass: t 		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat.		newClass setTraitComposition: aTraitCompositionOrArray asTraitComposition.	SystemChangeNotifier uniqueInstance		classDefinitionChangedFrom: copyOfOldClass to: newClass.	^newClass	! !!Class methodsFor: 'subclass creation' stamp: 'EstebanAllende 2/28/2012 03:40'!(Self) variableWordSubclass: (Symbol)t uses: ({asTraitComposition (→TraitComposition)})aTraitCompositionOrArray instanceVariableNames: (String)f classVariableNames: (String)d poolDictionaries: (String)s category: (String)cat 	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."		| (Self)newClass (Self)copyOfOldClass |	copyOfOldClass := self copy.	newClass := self		variableWordSubclass: t 		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat.		newClass setTraitComposition: aTraitCompositionOrArray asTraitComposition.	SystemChangeNotifier uniqueInstance		classDefinitionChangedFrom: copyOfOldClass to: newClass.	^newClass	! !!Class methodsFor: 'subclass creation' stamp: 'EstebanAllende 2/28/2012 03:40'!(Self) weakSubclass: (Symbol)t uses: ({asTraitComposition (→TraitComposition)})aTraitCompositionOrArray instanceVariableNames: (String)f classVariableNames: (String)d poolDictionaries: (String)s category: (String)cat 	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."		| (Self)newClass (Self)copyOfOldClass |	copyOfOldClass := self copy.	newClass := self		weakSubclass: t 		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat.		newClass setTraitComposition: aTraitCompositionOrArray asTraitComposition.	SystemChangeNotifier uniqueInstance		classDefinitionChangedFrom: copyOfOldClass to: newClass.	^newClass	! !!Class methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 03:40'!(Boolean) hasMethods	"Answer a Boolean according to whether any methods are defined for the 	receiver (includes whether there are methods defined in the receiver's 	metaclass)."	^super hasMethods or: [self class hasMethods]! !!Class methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 03:41'!(Boolean) isAbstractClass	^ (self allMethods anySatisfy: [:(CompiledMethod)cm | cm sendsSelector: #subclassResponsibility ])		or: [ self class allMethods anySatisfy: [:(CompiledMethod)cm | cm sendsSelector: #subclassResponsibility ] ]! !!Class methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 03:41'!(Boolean) isObsolete	"Return true if the receiver is obsolete."	^(self environment at: name ifAbsent: [nil]) ~~ self! !!Class methodsFor: 'traits' stamp: 'EstebanAllende 2/28/2012 03:42'!(Set) applyChangesOfNewTraitCompositionReplacing: (TraitComposition)oldComposition	"See Trait>>applyChangesOfNewTraitCompositionReplacing:"	| (Set)changedSelectors |	changedSelectors := super applyChangesOfNewTraitCompositionReplacing: oldComposition.	self classSide		noteNewBaseTraitCompositionApplied: self traitComposition.	^ changedSelectors! !!Class methodsFor: 'viewer' stamp: 'EstebanAllende 2/28/2012 03:42'!(Symbol) externalName	"Answer a name by which the receiver can be known."	^ name! !!Class methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 03:42'!(Self) setName: (Symbol)aSymbol	"Private - set the name of the class"	name := aSymbol.! !!Class methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 03:42'!(Integer) spaceUsed	"Object spaceUsed"	^ super spaceUsed + self class spaceUsed! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Class class	uses: TBehaviorCategorization classTrait + TTyped classTrait	instanceVariableNames: ''!!Class class methodsFor: 'fileIn/Out' stamp: 'EstebanAllende 2/28/2012 17:24'!(Array) allSuperclassesFor: (ClassDescription)aClass cache: (Dictionary)cache 		^ cache at: aClass ifAbsentPut: [aClass allSuperclasses asArray]! !!Class class methodsFor: 'fileIn/Out' stamp: 'EstebanAllende 2/28/2012 11:08'!(Boolean) doesNotIncludeInstanceOrSuperclassesFor: (Metaclass)aClass in: (Collection)unprocessedClasses cache: (Dictionary)cache 	| soleInstance |	soleInstance := aClass soleInstance.	^ (unprocessedClasses includes: soleInstance) not and: [				self hasNoSuperclassesOf: soleInstance in: unprocessedClasses cache: cache]! !!Class class methodsFor: 'fileIn/Out' stamp: 'EstebanAllende 2/28/2012 11:08'!(Self) fileOutPool: (String)aString	"file out the global pool named aString"		| (WriteStream)internalStream |	internalStream := (String new: 1000) writeStream.	self new fileOutPool: (self environment at: aString asSymbol) onFileStream: internalStream.	FileStream writeSourceCodeFrom: internalStream baseName: aString isSt: true.! !!Class class methodsFor: 'fileIn/Out' stamp: 'EstebanAllende 2/28/2012 11:09'!(Boolean) hasNoDependenciesForMetaclass: (Metaclass)aClass in: (Collection)unprocessedClasses cache: (Dictionary)cache 	| (ClassDescription)soleInstance |	soleInstance := aClass soleInstance.	^ (unprocessedClasses includes: soleInstance) not and: [				self hasNoSuperclassesOf: soleInstance in: unprocessedClasses cache: cache]! !!Class class methodsFor: 'fileIn/Out' stamp: 'EstebanAllende 2/28/2012 11:16'!(Boolean) hasNoSuperclassesOf: (ClassDescription)aClass in: (Collection)unprocessedClasses cache: (Dictionary)cache 	^ (unprocessedClasses includesAnyOf: (self allSuperclassesFor: aClass cache: cache)) not	! !!Class class methodsFor: 'fileIn/Out' stamp: 'EstebanAllende 2/28/2012 11:10'!(OrderedCollection) superclassOrder: classes	"Arrange the classes in the collection, classes, in superclass order so the 	classes can be properly filed in. Do it in sets instead of ordered collections."	| (OrderedCollection)all (Set)unprocessedClasses (Dictionary)cache |	unprocessedClasses := classes asSet. 	cache := Dictionary new.	all := OrderedCollection new: unprocessedClasses size.	unprocessedClasses size timesRepeat: [ |(Class)nextClass|		nextClass := unprocessedClasses detect: [:(Metaclass)aClass | self hasNoDependenciesFor: aClass in: unprocessedClasses cache: cache].		all add: nextClass.		unprocessedClasses remove: nextClass].	^all! !!Class class methodsFor: 'inquiries' stamp: 'EstebanAllende 2/28/2012 11:11'!(OrderedCollection) rootsOfTheWorld	"return all classes that have a nil superclass"		^(Smalltalk globals select: [:each | each isBehavior and: [each superclass isNil]]) asOrderedCollection! !!Class class methodsFor: 'instance creation' stamp: 'EstebanAllende 2/28/2012 11:13'!(String) template: (Object)aSystemCategoryName 	"Answer an expression that can be edited and evaluated in order to define a new class."	^ self templateForSubclassOf: Object name category: aSystemCategoryName ! !!Class class methodsFor: 'instance creation' stamp: 'EstebanAllende 2/28/2012 11:13'!(String) templateForSubclassOf: (Class)priorClassName category: (Object)systemCategoryName 	"Answer an expression that can be edited and evaluated in order to define a new class, given that the class previously looked at was as given"	^priorClassName asString, ' subclass: #NameOfSubclass	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''' , systemCategoryName asString , ''''! !!Class class methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 11:16'!(Boolean) hasNoDependenciesFor: (ClassDescription)aClass in: (Collection)unprocessedClasses cache: (Dictionary)cache 	^ (self hasNoSuperclassesOf: aClass in: unprocessedClasses cache: cache) and: [		aClass isMeta not or: [			self hasNoDependenciesForMetaclass: (<Metaclass>aClass) in: unprocessedClasses cache: cache]] ! !