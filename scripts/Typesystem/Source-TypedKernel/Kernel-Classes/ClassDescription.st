'From Pharo1.4a of ''16 June 2011'' [Latest update: #14301] on 28 February 2012 at 8:42:41 pm'!Behavior subclass: #ClassDescription	uses: TClassAndTraitDescription + TTyped	instanceVariableNames: '(Array)instanceVariables (ClassOrganizer)organization'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Classes'!!ClassDescription commentStamp: '<historical>' prior: 0!I add a number of facilities to basic Behaviors:	Named instance variables	Category organization for methods	The notion of a name of this class (implemented as subclass responsibility)	The maintenance of a ChangeSet, and logging changes on a file	Most of the mechanism for fileOut.	I am an abstract class, in particular, my facilities are intended for inheritance by two subclasses, Class and Metaclass.The slots 'organization' and 'methodDict' should ONLY be accessed by message in order for things to work during ImageSegment>>discoverActiveClasses (q.v.).!!ClassDescription methodsFor: '*System-Support' stamp: 'EstebanAllende 2/28/2012 01:45'!(OrderedCollection) allUnreferencedClassVariables	"Answer a list of the names of all the receiver's unreferenced class vars, including those defined in superclasses"	^ self systemNavigation allUnreferencedClassVariablesOf: self! !!ClassDescription methodsFor: '*typesystem-parser' stamp: 'EstebanAllende 2/28/2012 01:45'!(String) classVariablesString	"Answer a string of my class variable names separated by spaces."	^String streamContents: [ :(WriteStream)stream | 		self classVarNames 			do: [ :(String)each | stream nextPutAll: (self printClassVariable: each) ]			separatedBy: [ stream space ] ]! !!ClassDescription methodsFor: '*typesystem-parser' stamp: 'EstebanAllende 2/28/2012 01:46'!(String) instanceVariablesString	"Answer a string of my instance variable names separated by spaces."		^String streamContents: [ :(WriteStream)stream |		self instVarNames 			do: [ :(String)each | stream nextPutAll: (self printInstanceVariable: each) ]			separatedBy: [ stream space ] ]! !!ClassDescription methodsFor: '*typesystem-parser' stamp: 'EstebanAllende 2/28/2012 01:47'!(String) printClassVariable: (String)varName	|(Type)type|	type :=  OTCSupport bootstrapping 					ifTrue: [nil]					ifFalse: [TypeDictionary uniqueInstance class: self atClassVar: varName asSymbol].	^type ifNil:[varName]		   ifNotNil: [(type isDyn and: [(<DynType>type) implicit]) ifFalse: ['(', (type asString) , ')', varName] ifTrue:[varName]] ! !!ClassDescription methodsFor: '*typesystem-parser' stamp: 'EstebanAllende 2/28/2012 01:48'!(String) printInstanceVariable: (String)varName	|(Type)type|	type :=  OTCSupport bootstrapping 					ifTrue: [nil]					ifFalse: [TypeDictionary uniqueInstance class: self atInstVar: varName asSymbol].	^type ifNil:[varName]		   ifNotNil: [(type isDyn and: [(<DynType>type) implicit]) ifFalse: ['(', (type asString) , ')', varName] ifTrue:[varName]] ! !!ClassDescription methodsFor: '*typesystem-types' stamp: 'EstebanAllende 2/28/2012 01:48'!(NominalType) asType	^NominalType for: self.! !!ClassDescription methodsFor: 'accessing' stamp: 'EstebanAllende 2/27/2012 22:07'!(Integer) classVersion	"Default.  Any class may return a later version to inform readers that use ReferenceStream.  8/17/96 tk"	"This method allows you to distinguish between class versions when the shape of the class 	hasn't changed (when there's no change in the instVar names).	In the conversion methods you usually can tell by the inst var names 	what old version you have. In a few cases, though, the same inst var 	names were kept but their interpretation changed (like in the layoutFrame).	By changing the class version when you keep the same instVars you can 	warn older and newer images that they have to convert."	^ 0! !!ClassDescription methodsFor: 'accessing' stamp: 'EstebanAllende 2/27/2012 22:07'!(Integer) version	"Allows polymorphism with TraitDescription>>version"	^ self classVersion! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'EstebanAllende 2/27/2012 22:11'!(Array) classesThatImplementAllOf: (Set)selectorSet	"Return an array of any classes that implement all the messages in selectorSet."	| (OrderedCollection)found (Set)remaining |	found := OrderedCollection new.	selectorSet do:		[:(Symbol)sel | (self methodDict includesKey: sel) ifTrue: [found add: sel]].	found isEmpty		ifTrue: [^ self subclasses inject: Array new						into: [:(Array)subsThatDo :(ClassDescription)sub |							subsThatDo , (sub classesThatImplementAllOf: selectorSet)]]		ifFalse: [remaining := selectorSet copyWithoutAll: found.				remaining isEmpty ifTrue: [^ Array with: self].				^ self subclasses inject: Array new						into: [:(Array)subsThatDo :(ClassDescription)sub |							subsThatDo , (sub classesThatImplementAllOf: remaining)]]! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'EstebanAllende 2/27/2012 22:12'!(String) commentInventory	"Answer a string with a count of the classes with and without comments 	for all the classes in the package of which this class is a member."	"Morph commentInventory"	^ self environment organization commentInventory: ((<Class>(<?>self)) category copyUpTo: $-), '*'! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'EstebanAllende 2/27/2012 22:15'!(Self) printSubclassesOn: (WriteStream)aStream level: (Integer)level 	"As part of the algorithm for printing a description of the receiver, print the	subclass on the file stream, aStream, indenting level times."	| (SortedCollection)subclassNames |	aStream crtab: level.	aStream nextPutAll: self name.	aStream space; print: self instVarNames.	self == Class		ifTrue: 			[aStream crtab: level + 1; nextPutAll: '[ ... all the Metaclasses ... ]'.			^self].	subclassNames := self subclasses asSortedCollection:[:(ClassDescription)c1 :(ClassDescription)c2| c1 name <= c2 name].	"Print subclasses in alphabetical order"	subclassNames do:		[:(ClassDescription)subclass | subclass printSubclassesOn: aStream level: level + 1]! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'EstebanAllende 2/27/2012 22:15'!(Array) subclasses	^ Array new! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'EstebanAllende 2/28/2012 20:42'!(Self) subclassesDo: (Self → Object)aBlock	"Evaluate the argument, aBlock, for each of the receiver's immediate subclasses."	self subclasses do: aBlock. ^self! !!ClassDescription methodsFor: 'accessing comment' stamp: 'EstebanAllende 2/27/2012 22:17'!(String) classCommentBlank	| (String)existingComment (WriteStream)stream |	existingComment := self theNonMetaClass organization classComment.	existingComment isEmpty		ifFalse: [^existingComment].	stream := (String new: 100) writeStream.	stream		nextPutAll: 'A';		nextPutAll: (self name first isVowel ifTrue: ['n '] ifFalse: [' ']);		nextPutAll: self name;		nextPutAll: ' is xxxxxxxxx.';		cr; cr;		nextPutAll: 'Instance Variables'.	self instVarNames asSortedCollection do: [:(String)each |		stream			cr; tab; nextPutAll: each;			nextPut: $:;			tab; tab;			nextPutAll: '<Object>'].	stream cr.	self instVarNames asSortedCollection do: [:(String)each |		stream			cr; nextPutAll: each;			cr; tab; nextPutAll: '- xxxxx'; cr].	^stream contents! !!ClassDescription methodsFor: 'accessing comment' stamp: 'EstebanAllende 2/27/2012 22:17'!(String) comment	"Answer the receiver's comment. (If missing, supply a template) "	| (String)aString |	aString := self instanceSide organization classComment.	aString isEmpty ifFalse: [^ aString].	^self classCommentBlank! !!ClassDescription methodsFor: 'accessing comment' stamp: 'EstebanAllende 2/28/2012 01:51'!(Self) comment: (Object)aStringOrText	"Set the receiver's comment to be the argument, aStringOrText."	self instanceSide classComment: aStringOrText.! !!ClassDescription methodsFor: 'accessing comment' stamp: 'EstebanAllende 2/27/2012 22:19'!(Self) comment: (Object)aStringOrText stamp: (String)aStamp	"Set the receiver's comment to be the argument, aStringOrText."	self instanceSide classComment: aStringOrText stamp: aStamp.! !!ClassDescription methodsFor: 'accessing comment' stamp: 'EstebanAllende 2/27/2012 22:19'!(Boolean) hasComment	"return whether this class truly has a comment other than the default"	| (ClassOrganizer)org |	org := self instanceSide organization.	^org classComment isEmptyOrNil not! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 22:25'!(Self) addAndClassifySelector: (Symbol)selector withMethod: (CompiledMethod)compiledMethod inProtocol: (String)category notifying: (Object)requestor	| (CompiledMethod)priorMethodOrNil (Symbol)oldProtocol (Symbol)newProtocol |	priorMethodOrNil := self compiledMethodAt: selector ifAbsent: [nil].	self addSelectorSilently: selector withMethod: compiledMethod.	oldProtocol := self organization categoryOfElement: selector.	SystemChangeNotifier uniqueInstance 		doSilently: [self organization classify: selector under: category].	newProtocol := self organization categoryOfElement: selector.	priorMethodOrNil isNil		ifTrue: [SystemChangeNotifier uniqueInstance methodAdded: compiledMethod selector: selector inProtocol: category class: self requestor: requestor]		ifFalse: [SystemChangeNotifier uniqueInstance methodChangedFrom: priorMethodOrNil to: compiledMethod selector: selector inClass: self oldProtocol: oldProtocol newProtocol: newProtocol requestor: requestor].! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 22:26'!(Self) addSelectorSilently: (Symbol)selector withMethod: (CompiledMethod)compiledMethod	super addSelectorSilently: selector withMethod: compiledMethod.	self instanceSide noteAddedSelector: selector meta: self isMeta.! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 22:27'!(Self) addSelector: (Symbol)selector withMethod: (CompiledMethod)compiledMethod notifying: (Object)requestor	| (CompiledMethod)priorMethodOrNil |	priorMethodOrNil := self compiledMethodAt: selector ifAbsent: [nil].	self addSelectorSilently: selector withMethod: compiledMethod.	priorMethodOrNil isNil		ifTrue: [SystemChangeNotifier uniqueInstance methodAdded: compiledMethod selector: selector inClass: self requestor: requestor]		ifFalse: [SystemChangeNotifier uniqueInstance methodChangedFrom: priorMethodOrNil to: compiledMethod selector: selector inClass: self requestor: requestor].! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 22:28'!(Array) allMethodCategoriesIntegratedThrough: (ClassDescription)mostGenericClass	"Answer a list of all the method categories of the receiver and all its superclasses, up through mostGenericClass"	| (OrderedCollection)aColl |	aColl := OrderedCollection new.	self withAllSuperclasses do:		[:(ClassDescription)aClass |			(aClass includesBehavior: mostGenericClass)				ifTrue:	[aColl addAll: aClass organization categories]].	aColl remove: 'no messages' asSymbol ifAbsent: [].	^ (aColl asSet asSortedCollection: [:a :b | a asLowercase < b asLowercase]) asArray"ColorTileMorph allMethodCategoriesIntegratedThrough: TileMorph"! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 22:29'!(Array) allMethodsInCategory: (String)aName 	"Answer a list of all the methods of the receiver and all its 	superclasses that are in the category named aName"		| (OrderedCollection)aColl |	aColl := OrderedCollection new.	self withAllSuperclasses do: [:(ClassDescription)aClass | 		aColl addAll: (aName = ClassOrganizer allCategory						ifTrue: [aClass organization allMethodSelectors]						ifFalse: [aClass organization listAtCategoryNamed: aName])].	^ aColl asSet asArray sort! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 22:29'!(Array) methodsInCategory: (String)aName 	"Answer a list of the methods of the receiver that are in category named aName"		| (Set)aColl |	aColl := Set withAll: (aName = ClassOrganizer allCategory			ifTrue: [self organization allMethodSelectors]			ifFalse: [self organization listAtCategoryNamed: aName]).	^ aColl asArray sort! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 22:30'!(Self) noteAddedSelector: (Symbol)aSelector meta: (Boolean)isMeta	"A hook allowing some classes to react to adding of certain selectors"! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 22:30'!(Self) removeCategory: (String)aString 	"Remove each of the messages categorized under aString in the method 	dictionary of the receiver. Then remove the category aString."	| (Symbol)categoryName |	categoryName := aString asSymbol.	(self organization listAtCategoryNamed: categoryName) do:		[:(Symbol)sel | self removeSelector: sel].	self organization removeCategory: categoryName! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 22:31'!(Self) removeSelector: (Symbol)selector 	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."		| (CompiledMethod)priorMethod (Symbol)priorProtocol | 	priorMethod := self compiledMethodAt: selector ifAbsent: [^ nil].	priorProtocol := self whichCategoryIncludesSelector: selector.	super removeSelector: selector.	SystemChangeNotifier uniqueInstance 		doSilently: [self updateOrganizationSelector: selector oldCategory: priorProtocol newCategory: nil].	SystemChangeNotifier uniqueInstance 			methodRemoved: priorMethod selector: selector inProtocol: priorProtocol class: self.! !!ClassDescription methodsFor: 'accessing parallel hierarchy' stamp: 'EstebanAllende 2/27/2012 22:31'!(Metaclass) classSide	^self theMetaClass! !!ClassDescription methodsFor: 'accessing parallel hierarchy' stamp: 'EstebanAllende 2/27/2012 22:31'!(Class) instanceSide	^ self theNonMetaClass! !!ClassDescription methodsFor: 'accessing parallel hierarchy' stamp: 'EstebanAllende 2/27/2012 22:31'!(Boolean) isClassSide	^self == self classSide! !!ClassDescription methodsFor: 'accessing parallel hierarchy' stamp: 'EstebanAllende 2/27/2012 22:32'!(Boolean) isInstanceSide	^self isClassSide not! !!ClassDescription methodsFor: 'accessing parallel hierarchy' stamp: 'EstebanAllende 2/27/2012 22:32'!(Boolean) isMeta	^self isClassSide! !!ClassDescription methodsFor: 'accessing parallel hierarchy' stamp: 'EstebanAllende 2/27/2012 22:34'!(Metaclass) theMetaClass	"Sent to a class or metaclass, always return the metaclass"	^(<Metaclass>(<?>self class))! !!ClassDescription methodsFor: 'accessing parallel hierarchy' stamp: 'EstebanAllende 2/27/2012 22:34'!(Class) theNonMetaClass	"Sent to a class or metaclass, always return the class"	^(<Class>(<?>self))! !!ClassDescription methodsFor: 'authors' stamp: 'EstebanAllende 2/27/2012 22:36'!(Self) addAuthorsTo: (Collection)result	"private method that  to store the result in the argument."		self methodsDo: [:(CompiledMethod)each | result add: each author ]! !!ClassDescription methodsFor: 'authors' stamp: 'EstebanAllende 2/27/2012 22:36'!(Bag) authors	"Returns a bag representing the author frequency based on the latest version of the methods of the receiver."	"self new authorsgather: Date"	| (Bag)result |	result := Bag new. 	self addAuthorsTo: result.	self class addAuthorsTo: result.	^ result! !!ClassDescription methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 22:36'!(Boolean) acceptsLoggingOfCompilation	"Answer whether the receiver's method submisions and class defintions should be logged to the changes file and to the current change set.  The metaclass follows the rule of the class itself.  6/18/96 sw"	"weird name is so that it will come lexically before #compile, so that a clean build can make it through.  7/7/96 sw"	^ true! !!ClassDescription methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 22:40'!(Symbol) compile: (String)code classified: (String)heading 	"Compile the argument, code, as source code in the context of the 	receiver and install the result in the receiver's method dictionary under 	the classification indicated by the second argument, heading. nil is to be 	notified if an error occurs. The argument code is either a string or an 	object that converts to a string or a PositionableStream on an object that 	converts to a string."	^self		compile: code		classified: heading		notifying: nil! !!ClassDescription methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 22:39'!(Symbol) compile: (String)text classified: (String)category notifying: (Object)requestor	| (String)stamp |	stamp := self acceptsLoggingOfCompilation ifTrue: [Author changeStamp] ifFalse: [nil].	^ self compile: text classified: category		withStamp: stamp notifying: requestor! !!ClassDescription methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 22:39'!(Symbol) compile: (String)text classified: (String)category withStamp: (String)changeStamp notifying: (Object)requestor	^ self compile: text classified: category withStamp: changeStamp notifying: requestor logSource: self acceptsLoggingOfCompilation! !!ClassDescription methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 22:38'!(Symbol)compile: (String)text classified: (String)categorywithStamp: (String)changeStamp notifying: (Object)requestor logSource: (Boolean)logSource       | (CompiledMethodWithNode)methodAndNode |       methodAndNode := self compile: text asString classified: categorynotifying: requestor                       trailer: self defaultMethodTrailer ifFail: [^nil].       logSource ifTrue: [               " replace 'text' with 'methodAndNode node sourceText' "               self logMethodSource: methodAndNode node sourceTextforMethodWithNode: methodAndNode                       inCategory: category withStamp: changeStamp notifying: requestor.       ].       self addAndClassifySelector: methodAndNode selector withMethod: methodAndNode               method inProtocol: category notifying: requestor.       self instanceSide noteCompilationOf: methodAndNode selector meta:self isClassSide.       ^ methodAndNode selector! !!ClassDescription methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 22:40'!(Symbol) compile: (String)code notifying: (Object)requestor 	"Refer to the comment in Behavior|compile:notifying:." 	^self compile: code		 classified: ClassOrganizer default		 notifying: requestor! !!ClassDescription methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 22:41'!(Symbol) compileSilently: (String)code	"Compile the code and classify the resulting method in the given category, leaving no trail in the system log, nor in any change set, nor in the 'recent submissions' list. This should only be used when you know for sure that the compilation will succeed."	^ self compileSilently: code classified: '' notifying: nil.! !!ClassDescription methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 22:41'!(Symbol) compileSilently: (String)code classified: (String)category	"Compile the code and classify the resulting method in the given category, leaving no trail in the system log, nor in any change set, nor in the 'recent submissions' list. This should only be used when you know for sure that the compilation will succeed."	^ self compileSilently: code classified: category notifying: nil.! !!ClassDescription methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 22:41'!(Symbol) compileSilently: (String)code classified: (String)category notifying: (Object)requestor	"Compile the code and classify the resulting method in the given category, leaving no trail in the system log, nor in any change set, nor in the 'recent submissions' list. This should only be used when you know for sure that the compilation will succeed."	^ SystemChangeNotifier uniqueInstance 		doSilently: [self compile: code classified: category withStamp: nil notifying: requestor logSource: false].! !!ClassDescription methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 22:42'!(Self) doneCompiling	"A ClassBuilder has finished the compilation of the receiver.	This message is a notification for a class that needs to do some	cleanup / reinitialization after it has been recompiled."! !!ClassDescription methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 22:45'!(Self) instVarNamesAndOffsetsDo: (String Integer → Object)aBinaryBlock	"This is part of the interface between the compiler and a class's instance or field names.	 The class should enumerate aBinaryBlock with the instance variable name strings and	 their integer offsets.  The order is important. Names evaluated later will override the	 same names occurring earlier."	| (Integer)superInstSize |	(superInstSize := superclass notNil ifTrue: [superclass instSize] ifFalse: [0]) > 0 ifTrue:		[superclass instVarNamesAndOffsetsDo: aBinaryBlock].	1 to: self instSize - superInstSize do:		[:(Integer)i| aBinaryBlock value: (instanceVariables at: i) value: i + superInstSize]! !!ClassDescription methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 22:48'!(Self) moveInstVarNamed: (String)instVarName to: (ClassDescription)anotherClass after: (String)prevInstVarName	"Move the given instance variable to another class."	self == anotherClass ifFalse:[		self notify:'Warning:' asText allBold,' moving ', instVarName printString,' from ', self name,' to ', anotherClass name,' will not be recorded in the change set correctly.Proceed to do it anyways.'].	(ClassBuilder new)		moveInstVarNamed: instVarName 		from: self 		to: anotherClass 		after: prevInstVarName.	^self		! !!ClassDescription methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 22:48'!(Self) noteCompilationOf: (Symbol)aSelector meta: (Boolean)isMeta	"A hook allowing some classes to react to recompilation of certain selectors"! !!ClassDescription methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 22:49'!(Self) reformatAll	"Reformat all methods in this class.	Leaves old code accessible to version browsing"	self selectorsDo: [:(Symbol)sel | self reformatMethodAt: sel]! !!ClassDescription methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 22:53'!(Self) reformatMethodAt: (Symbol)selector	| (String)newCodeString (CompiledMethod)method |	newCodeString := (<Compiler class>self prettyPrinterClass) 				format: (self sourceCodeAt: selector)				in: self				notifying: nil.	method := self compiledMethodAt: selector.	method 		putSource: newCodeString		fromParseNode: nil		class: self		category: (self organization categoryOfElement: selector)		inFile: 2		priorMethod: method! !!ClassDescription methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 22:53'!(Boolean) wantsChangeSetLogging	"Answer whether code submitted for the receiver should be remembered by the changeSet mechanism.  7/12/96 sw"	^ true! !!ClassDescription methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 22:53'!(Boolean) wantsRecompilationProgressReported	"Answer whether the receiver would like progress of its recompilation reported interactively to the user."	^ true! !!ClassDescription methodsFor: 'copying' stamp: 'EstebanAllende 2/27/2012 22:58'!(Self)copy: (Symbol)sel from: (ClassDescription)class 	"Install the method associated with the first argument, sel, a message 	selector, found in the method dictionary of the second argument, class, 	as one of the receiver's methods. Classify the message under -As yet not 	classified-."	self copy: sel		from: class		classified: nil! !!ClassDescription methodsFor: 'copying' stamp: 'EstebanAllende 2/27/2012 22:57'!(Self) copy: (Symbol)sel from: (ClassDescription)class classified: (String)cat 	"Install the method associated with the first arugment, sel, a message 	selector, found in the method dictionary of the second argument, class, 	as one of the receiver's methods. Classify the message under the third 	argument, cat."	| (Text)code (String)category |	"Useful when modifying an existing class"	code := class sourceMethodAt: sel.	code == nil		ifFalse: 			[cat == nil				ifTrue: [category := class organization categoryOfElement: sel]				ifFalse: [category := cat].			(self includesLocalSelector: sel)				ifTrue: [code asString = (self sourceMethodAt: sel) asString 							ifFalse: [self error: self name 										, ' ' 										, sel 										, ' will be redefined if you proceed.']].			self compile: code asString classified: category]! !!ClassDescription methodsFor: 'copying' stamp: 'EstebanAllende 2/27/2012 22:59'!(Self) copyAll: (Collection)selArray from: (ClassDescription)class 	"Install all the methods found in the method dictionary of the second 	argument, class, as the receiver's methods. Classify the messages under 	-As yet not classified-."	self copyAll: selArray		from: class		classified: nil! !!ClassDescription methodsFor: 'copying' stamp: 'EstebanAllende 2/27/2012 22:59'!(Self) copyAll: (Collection)selArray from: (ClassDescription)class classified: (String)cat 	"Install all the methods found in the method dictionary of the second 	argument, class, as the receiver's methods. Classify the messages under 	the third argument, cat."	selArray do: [:(Symbol)s |		(class includesLocalSelector: s) ifTrue: [			self copy: s				from: class				classified: cat ] ]! !!ClassDescription methodsFor: 'copying' stamp: 'EstebanAllende 2/27/2012 23:01'!(Self) copyAllCategoriesFrom: (ClassDescription) aClass 	"Specify that the categories of messages for the receiver include all of 	those found in the class, aClass. Install each of the messages found in 	these categories into the method dictionary of the receiver, classified 	under the appropriate categories."	aClass organization categories do: [:(String)cat | self copyCategory: cat from: aClass]! !!ClassDescription methodsFor: 'copying' stamp: 'EstebanAllende 2/27/2012 23:00'!(Self) copyCategory: (String)cat from: (ClassDescription)class 	"Specify that one of the categories of messages for the receiver is cat, as 	found in the class, class. Copy each message found in this category."	self copyCategory: cat		from: class		classified: cat! !!ClassDescription methodsFor: 'copying' stamp: 'EstebanAllende 2/27/2012 23:00'!(Self) copyCategory: (String)cat from: (ClassDescription)aClass classified: (String)newCat 	"Specify that one of the categories of messages for the receiver is the 	third argument, newCat. Copy each message found in the category cat in 	class aClass into this new category."	self copyAll: (aClass organization listAtCategoryNamed: cat)		from: aClass		classified: newCat! !!ClassDescription methodsFor: 'copying' stamp: 'EstebanAllende 2/27/2012 23:01'!(Self) copyMethodDictionaryFrom: (ClassDescription)donorClass	"Copy the method dictionary of the donor class over to the receiver"	self methodDict: donorClass copyOfMethodDictionary.	self organization: donorClass organization deepCopy.! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'EstebanAllende 2/27/2012 23:08'!(Self) classComment: (Object)aString stamp: (String)aStamp	"Store the comment, aString or Text or RemoteString, associated with the class we are organizing.  Empty string gets stored only if had a non-empty one before."	| (Integer)ptr (String)header (FileStream)file (RemoteString)oldCommentRemoteStr (Object)oldComment (String)oldStamp |	oldComment := self organization classComment.	oldStamp := self organization commentStamp.	(aString isKindOf: RemoteString) ifTrue:		[SystemChangeNotifier uniqueInstance class: self oldComment: oldComment newComment: (<RemoteString>aString) string oldStamp: oldStamp newStamp: aStamp.		^ self organization classComment: aString stamp: aStamp].	oldCommentRemoteStr := self organization commentRemoteStr.	(aString size = 0) & (oldCommentRemoteStr isNil) ifTrue: [^ self organization classComment: nil].		"never had a class comment, no need to write empty string out"	ptr := oldCommentRemoteStr ifNil: [0] ifNotNil: [oldCommentRemoteStr sourcePointer].	SourceFiles ifNotNil: [(file := SourceFiles at: 2) ifNotNil:		[file setToEnd; cr; nextPut: $!!.	"directly"		"Should be saying (file command: 'H3') for HTML, but ignoring it here"		header := String streamContents: [:(Stream)strm | strm nextPutAll: self name;			nextPutAll: ' commentStamp: '.			aStamp storeOn: strm.			strm nextPutAll: ' prior: '; nextPutAll: ptr printString].		file nextChunkPut: header]].	self organization classComment: (RemoteString newString: aString onFileNumber: 2) stamp: aStamp.	SystemChangeNotifier uniqueInstance class: self oldComment: oldComment newComment: aString oldStamp: oldStamp newStamp: aStamp! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'EstebanAllende 2/27/2012 23:17'!(Self) fileOutCategory: (Symbol)aSymbol on: (WriteStream)aFileStream moveSource: (Boolean)moveSource toFile: (Integer)fileIndex 	"File a description of the receiver's category, aString, onto aFileStream. If 	moveSource, is true, then set the method source pointer to the new file position.	Note when this method is called with moveSource=true, it is condensing the	.sources file, and should only write one preamble per method category."	| (Collection)selectors |	aFileStream cr.	selectors := self selectorsToFileOutCategory: aSymbol.	"Overridden to preserve author stamps in sources file regardless"	selectors do: [:(Symbol)sel |		self printMethodChunk: sel 			withPreamble: true			on: aFileStream 			moveSource: moveSource 			toFile: fileIndex].	^ self! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'EstebanAllende 2/27/2012 23:11'!(Self) moveChangesTo: (FileStream)newFile 	"Used in the process of condensing changes, this message requests that 	the source code of all methods of the receiver that have been changed 	should be moved to newFile."	| (Collection)changes |	changes := self selectors select: [:(Symbol)sel | (self compiledMethodAt: sel) fileIndex > 1 ].	self		fileOutChangedMessages: changes		on: newFile		moveSource: true		toFile: 2! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'EstebanAllende 2/27/2012 23:11'!(Collection) selectorsToFileOutCategory: (Symbol)aSymbol	^ ((aSymbol asString = ClassOrganizer allCategory)				ifTrue: [ self organization allMethodSelectors ]				ifFalse: [ self organization listAtCategoryNamed: aSymbol ]) select: [:(Symbol)sel |					self includesLocalSelector: sel ]! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/28/2012 01:50'!(Self) classComment: (Object)aString	"Store the comment, aString or Text or RemoteString, associated with the class we are orgainzing.  Empty string gets stored only if had a non-empty one before."	^ self classComment: aString stamp: '<historical>'! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:13'!(ClassCommentReader) commentStamp: (String)changeStamp	self organization commentStamp: changeStamp.	^ self commentStamp: changeStamp prior: 0! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:13'!(ClassCommentReader) commentStamp: (String)changeStamp prior: (Integer)indexAndOffset	"Prior source link ignored when filing in."	^ ClassCommentReader new setClass: self				category: #Comment				changeStamp: changeStamp! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:15'!(String) definition	"Answer a String that defines the receiver."	| (WriteStream)aStream |	aStream := (String new: 800) writeStream.	superclass == nil		ifTrue: [aStream nextPutAll: 'ProtoObject']		ifFalse: [aStream nextPutAll: superclass name].	aStream nextPutAll: self kindOfSubclass;			store: self name.	(self hasTraitComposition and: [self traitComposition notEmpty]) ifTrue: [		aStream cr; tab; nextPutAll: 'uses: ';			nextPutAll: self traitCompositionString].	aStream cr; tab; nextPutAll: 'instanceVariableNames: ';			store: self instanceVariablesString.	aStream cr; tab; nextPutAll: 'classVariableNames: ';			store: self classVariablesString.	aStream cr; tab; nextPutAll: 'poolDictionaries: ';			store: self sharedPoolsString.	aStream cr; tab; nextPutAll: 'category: ';			store: (<Class>(<?>self)) category asString.	superclass ifNil: [ 		aStream nextPutAll: '.'; cr.		aStream nextPutAll: self name.		aStream space; nextPutAll: 'superclass: nil'. ].	^ aStream contents! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:17'!(Self) fileOutCategory: (Symbol)catName 	| (WriteStream)internalStream |	internalStream := (String new: 1000) writeStream.	internalStream header; timeStamp.	self fileOutCategory: catName on: internalStream moveSource: false toFile: 0.	internalStream trailer.	FileStream writeSourceCodeFrom: internalStream baseName: (self name , '-' , catName) isSt: true.! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:19'!(Self) fileOutChangedMessages: (Collection)aSet on: (WriteStream)aFileStream 	"File a description of the messages of the receiver that have been 	changed (i.e., are entered into the argument, aSet) onto aFileStream."	self fileOutChangedMessages: aSet		on: aFileStream		moveSource: false		toFile: 0! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:19'!(Self) fileOutChangedMessages: (Collection)aSet on: (WriteStream)aFileStream moveSource: (Boolean)moveSource toFile: (Integer)fileIndex 	"File a description of the messages of this class that have been 	changed (i.e., are entered into the argument, aSet) onto aFileStream.  If 	moveSource, is true, then set the method source pointer to the new file position.	Note when this method is called with moveSource=true, it is condensing the	.changes file, and should only write a preamble for every method."	| (ClassOrganizer)org |	(org := self organization) categories do: 		[:(Symbol)cat | | sels | 		sels := (org listAtCategoryNamed: cat) select: [:(Symbol)sel | aSet includes: sel].		sels do:[:(Symbol)sel |  self printMethodChunk: sel withPreamble: true on: aFileStream						moveSource: moveSource toFile: fileIndex]]! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:20'!(Self) fileOutChangedMessagesHistorically: (Collection)aSet on: (WriteStream)aFileStream moveSource: (Boolean)moveSource toFile: (Integer)fileIndex 	"File all historical description of the messages of this class that have been 	changed (i.e., are entered into the argument, aSet) onto aFileStream.  If 	moveSource, is true, then set the method source pointer to the new file position.	Note when this method is called with moveSource=true, it is condensing the	.changes file, and should only write a preamble for every method."	| (ClassOrganizer)org |	(org := self organization) categories do: 		[:(Symbol)cat | | sels | 		sels := (org listAtCategoryNamed: cat) select: [:(Symbol)sel | aSet includes: sel].		sels do:			[:(Symbol)sel |  self printMethodChunkHistorically: sel on: aFileStream							moveSource: moveSource toFile: fileIndex]]! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:21'!(Self) fileOutMethod: (Symbol)selector	"Write source code of a single method on a file.  Make up a name for the file."		| (WriteStream)internalStream |	(selector == #Comment) ifTrue: [^ self inform: 'Sorry, cannot file out class comment in isolation.'].	(self includesSelector: selector) ifFalse: [^ self error: 'Selector ', selector asString, ' not found'].	internalStream := (String new: 1000) writeStream.	internalStream header; timeStamp.	self printMethodChunk: selector withPreamble: true		on: internalStream moveSource: false toFile: 0.	FileStream writeSourceCodeFrom: internalStream baseName: (self name , '-' , (selector copyReplaceAll: ':' with: '')) isSt: true.! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:21'!(Self) fileOutOn: (WriteStream)aFileStream 	"File a description of the receiver on aFileStream."	self fileOutOn: aFileStream		moveSource: false		toFile: 0! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:22'!(Self) fileOutOn: (WriteStream)aFileStream moveSource: (Boolean)moveSource toFile: (Integer)fileIndex	"File a description of the receiver on aFileStream. If the boolean 	argument, moveSource, is true, then set the trailing bytes to the position 	of aFileStream and to fileIndex in order to indicate where to find the 	source code."	aFileStream nextChunkPut: self definition.	self organization		putCommentOnFile: aFileStream		numbered: fileIndex		moveSource: moveSource		forClass: self.	self organization categories do: 		[:(Symbol)heading |		self fileOutCategory: heading			on: aFileStream			moveSource: moveSource			toFile: fileIndex]! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:22'!(Self) fileOutOrganizationOn: (WriteStream)aFileStream	"File a description of the receiver's organization on aFileStream."	aFileStream cr; nextPut: $!!.	aFileStream nextChunkPut: self name, ' reorganize'; cr.	aFileStream nextChunkPut: self organization printString; cr! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:24'!(Array) localMethods	"returns the methods of classes including the ones of the traits that the class uses" 	 	^ self methods select: [:(CompiledMethod)each | self includesLocalSelector: each selector].! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:24'!(Array)methods	"returns the methods of classes including the ones of the traits that the class uses" 	 	^ self methodDict values  ! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:25'!(ClassCategoryReader) methodsFor: (String)categoryName 	"Answer a ClassCategoryReader for compiling the messages in the category, categoryName, of the receiver."	^ ClassCategoryReader new setClass: self category: categoryName asSymbol	"(False methodsFor: 'logical operations') inspect"! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:26'!(ClassCategoryReader) methodsFor: (String)aString priorSource: (Integer)sourcePosition inFile: (Integer)fileIndex	"Prior source pointer ignored when filing in."	^ self methodsFor: aString! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:27'!(ClassCategoryReader) methodsFor: (String)categoryName stamp: (String)changeStamp 	^ self methodsFor: categoryName stamp: (Author fixStamp: changeStamp) prior: 0! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:26'!(ClassCategoryReader) methodsFor: (String)categoryName stamp: (String)changeStamp prior: (Integer)indexAndOffset	"Prior source link ignored when filing in."	^ ClassCategoryReader new setClass: self				category: categoryName asSymbol				changeStamp: changeStamp"Most importantly, return the new ClassCategoryReader, so a fileIn will let it seize control.  So method will be placed in the proper category.  See the transfer of control where ReadWriteStream fileIn calls scanFrom:"! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:28'!(Self) moveChangesWithVersionsTo: (WriteStream)newFile 	"Used in the process of condensing changes, this message requests that 	the source code of all methods of the receiver that have been changed 	should be moved to newFile."	| (Collection)changes |	changes := self selectors select: [:(Symbol)sel | (self methodDict at: sel) fileIndex > 1].	self fileOutChangedMessagesHistorically: changes		on: newFile		moveSource: true		toFile: 2! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:32'!(Self) printCategoryChunk: (String)categoryName on: (WriteStream)aFileStream	^ self printCategoryChunk: categoryName withStamp: '' on: aFileStream! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:31'!(Self) printCategoryChunk: (String)category on: (WriteStream)aFileStream priorMethod: (CompiledMethod)priorMethod	^ self printCategoryChunk: category on: aFileStream		withStamp: Author changeStamp priorMethod: priorMethod! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:29'!(Self) printCategoryChunk: (String)category on: (WriteStream)aFileStream withStamp: (String)changeStamp priorMethod: (CompiledMethod)priorMethod 	"Print a method category preamble.  This must have a category name.	It may have an author/date stamp, and it may have a prior source link.	If it has a prior source link, it MUST have a stamp, even if it is empty.""The current design is that changeStamps and prior source links are preserved in the changes file.  All fileOuts include changeStamps.  Condensing sources, however, eliminates all stamps (and links, natch)."	aFileStream cr; nextPut: $!!.	aFileStream nextChunkPut: (String streamContents:		[:(WriteStream)strm |		strm nextPutAll: self name; nextPutAll: ' methodsFor: '; print: category asString.		(changeStamp ~~ nil and:			[changeStamp size > 0 or: [priorMethod ~~ nil]]) ifTrue:			[strm nextPutAll: ' stamp: '; print: changeStamp].		priorMethod ~~ nil ifTrue:			[strm nextPutAll: ' prior: '; print: priorMethod sourcePointer]]).	! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:31'!(Self) printCategoryChunk: (String)categoryName withStamp: (String)changeStamp on: (WriteStream) aFileStream	^ self printCategoryChunk: categoryName on: aFileStream withStamp: changeStamp		priorMethod: nil! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:35'!(WriteStream) printMethodChunk: (Symbol)selector withPreamble: (Boolean)doPreamble on: (WriteStream)outStream		moveSource: (Boolean)moveSource toFile: (Integer)fileIndex	"Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method."	| (String)preamble (CompiledMethod)method (Integer)oldPos (Integer)newPos (WriteStream)sourceFile (Integer)endPos |	doPreamble 		ifTrue: [preamble := self name , ' methodsFor: ' ,					(self organization categoryOfElement: selector) asString printString]		ifFalse: [preamble := ''].	method := self methodDict at: selector ifAbsent:		[outStream nextPutAll: selector; cr.		outStream tab; nextPutAll: '** ERROR!!  THIS SCRIPT IS MISSING ** ' translated; cr; cr.		outStream nextPutAll: '  '.		^ outStream].	((method fileIndex = 0		or: [(SourceFiles at: method fileIndex) == nil])		or: [(oldPos := method filePosition) = 0])		ifTrue:		["The source code is not accessible.  We must decompile..."		preamble size > 0 ifTrue: [outStream cr; nextPut: $!!; nextChunkPut: preamble; cr].		outStream nextChunkPut: method decompileString]		ifFalse:		[sourceFile := SourceFiles at: method fileIndex.		preamble size > 0			ifTrue:    "Copy the preamble"				[outStream copyPreamble: preamble from: sourceFile at: oldPos]			ifFalse:				[sourceFile position: oldPos].		"Copy the method chunk"		newPos := outStream position.		outStream copyMethodChunkFrom: sourceFile.		sourceFile skipSeparators.      "The following chunk may have ]style["		sourceFile peek == $] ifTrue: [			outStream cr; copyMethodChunkFrom: sourceFile].		moveSource ifTrue:    "Set the new method source pointer"			[endPos := outStream position.			method checkOKToAdd: endPos - newPos at: newPos.			method setSourcePosition: newPos inFile: fileIndex]].	preamble size > 0 ifTrue: [outStream nextChunkPut: ' '].	^ outStream cr! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:39'!(WriteStream) printMethodChunkHistorically: (Symbol)selector on: (WriteStream)outStream moveSource: (Boolean)moveSource toFile: (Integer)fileIndex	"Copy all source codes historically for the method associated with selector onto the 	fileStream.  If moveSource true, then also set the source code pointer of the method."	| (String)preamble (CompiledMethod)method (WriteStream)sourceFile (Integer)endPos (Symbol)category (OrderedCollection)changeList (Integer)newPos |	category := self organization categoryOfElement: selector.	preamble := self name , ' methodsFor: ', category asString printString.	method := self methodDict at: selector.	((method fileIndex = 0	or: [(SourceFiles at: method fileIndex) == nil])	or: [method filePosition = 0])	ifTrue: [		outStream cr; nextPut: $!!; nextChunkPut: preamble; cr.		outStream nextChunkPut: method decompileString.		outStream nextChunkPut: ' '; cr]	ifFalse: [		changeList := ChangeSet 			scanVersionsOf: method 			class: self 			meta: self isMeta			category: category 			selector: selector.		newPos := nil.		sourceFile := SourceFiles at: method fileIndex.		changeList reverseDo: [ :(ChangeRecord)chgRec | | (Array)prior |			chgRec fileIndex = fileIndex ifTrue: [				outStream copyPreamble: preamble from: sourceFile at: chgRec position.				(prior := chgRec prior) ifNotNil: [					outStream position: outStream position - 2.					outStream nextPutAll: ' prior: ', (						prior first = method fileIndex ifFalse: [prior third] ifTrue: [							SourceFiles 								sourcePointerFromFileIndex: method fileIndex 								andPosition: newPos]) printString.					outStream nextPut: $!!; cr].				"Copy the method chunk"				newPos := outStream position.				outStream copyMethodChunkFrom: sourceFile at: chgRec position.				sourceFile skipSeparators.      "The following chunk may have ]style["				sourceFile peek == $] ifTrue: [					outStream cr; copyMethodChunkFrom: sourceFile].				outStream nextChunkPut: ' '; cr]].		moveSource ifTrue: [			endPos := outStream position.			method checkOKToAdd: endPos - newPos at: newPos.			method setSourcePosition: newPos inFile: fileIndex]].	^ outStream! !!ClassDescription methodsFor: 'filein/out' stamp: 'EstebanAllende 2/27/2012 23:40'!(Self) putClassCommentToCondensedChangesFile: (WriteStream)aFileStream	"Called when condensing changes.  If the receiver has a class comment, and if that class comment does not reside in the .sources file, then write it to the given filestream, with the resulting RemoteString being reachable from the source file #2.  Note that any existing backpointer into the .sources file is lost by this process -- a situation that maybe should be fixed someday."	| (String)header (String)aStamp (RemoteString)aCommentRemoteStr |	self isMeta ifTrue: [^ self].  "bulletproofing only"	((aCommentRemoteStr := self organization commentRemoteStr) isNil or:		[aCommentRemoteStr sourceFileNumber = 1]) ifTrue: [^ self].	aFileStream cr; nextPut: $!!.	header := String streamContents: [:(Stream)strm | strm nextPutAll: self name;		nextPutAll: ' commentStamp: '.		(aStamp := self organization commentStamp ifNil: ['<historical>']) storeOn: strm.		strm nextPutAll: ' prior: 0'].	aFileStream nextChunkPut: header.	aFileStream cr.	self organization classComment: (RemoteString newString: self organization classComment onFileNumber: 2 toFile: aFileStream) stamp: aStamp! !!ClassDescription methodsFor: 'initialize-release' stamp: 'EstebanAllende 2/27/2012 23:42'!(Self) obsolete	"Make the receiver obsolete."	(<{removeSubclass: (Behavior→Object)}>(<?>superclass)) removeSubclass: self.	self organization: nil.	super obsolete.! !!ClassDescription methodsFor: 'initialize-release' stamp: 'EstebanAllende 2/27/2012 23:42'!(Self) superclass: (Behavior)aClass methodDictionary: (MethodDictionary)mDict format: (Integer)fmt	"Basic initialization of the receiver"	super superclass: aClass methodDictionary: mDict format: fmt.	instanceVariables := nil.	self organization: nil.! !!ClassDescription methodsFor: 'initialize-release' stamp: 'EstebanAllende 2/27/2012 23:47'!(Array) updateInstances: (Array)oldInstances from: (ClassDescription)oldClass isMeta: (Boolean)isMeta	"Recreate any existing instances of the argument, oldClass, as instances of the receiver, which is a newly changed class. Permute variables as necessary. Return the array of old instances (none of which should be pointed to legally by anyone but the array)."	"If there are any contexts having an old instance as receiver it might crash the system because the layout has changed, and the method only knows about the old layout."	| (Array)map (Boolean)variable (Integer)instSize (Array)newInstances |	oldInstances isEmpty ifTrue:[^#()]. "no instances to convert"	isMeta ifTrue: [		oldInstances size = 1 ifFalse:[^self error:'Metaclasses can only have one instance'].		(<Metaclass>(<?>self)) soleInstance class == self ifTrue:[			^self error:'Metaclasses can only have one instance']].	map := self instVarMappingFrom: oldClass.	variable := self isVariable.	instSize := self instSize.	newInstances := Array new: oldInstances size.	1 to: oldInstances size do:[:(Integer)i|		newInstances at: i put: (			self newInstanceFrom: (oldInstances at: i) variable: variable size: instSize map: map)].	"Now perform a bulk mutation of old instances into new ones"	oldInstances elementsExchangeIdentityWith: newInstances.	^newInstances "which are now old"! !!ClassDescription methodsFor: 'initialize-release' stamp: 'EstebanAllende 2/27/2012 23:50'!(Array) updateInstancesFrom: (ClassDescription)oldClass	"Recreate any existing instances of the argument, oldClass, as instances of 	the receiver, which is a newly changed class. Permute variables as 	necessary. Return the array of old instances (none of which should be	pointed to legally by anyone but the array)."	"ar 7/15/1999: The updating below is possibly dangerous. If there are any	contexts having an old instance as receiver it might crash the system if	the new receiver in which the context is executed has a different layout.	See bottom below for a simple example:"	| (Array)oldInstances |	oldInstances := oldClass allInstances asArray.	oldInstances := self updateInstances: oldInstances from: oldClass isMeta: self isMeta.	^oldInstances"	| crashingBlock class |	class := Object subclass: #CrashTestDummy		instanceVariableNames: 'instVar'		classVariableNames: ''		poolDictionaries: ''		category: 'Crash-Test'.	class compile:'instVar: value instVar := value'.	class compile:'crashingBlock ^[instVar]'.	crashingBlock := (class new) instVar: 42; crashingBlock.	Object subclass: #CrashTestDummy		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Crash-Test'.	crashingBlock.	crashingBlock value.	"! !!ClassDescription methodsFor: 'instance variables' stamp: 'EstebanAllende 2/27/2012 23:50'!(Self) addInstVarNamed: (String)aString 	"Add the argument, aString, as one of the receiver's instance variables."	self subclassResponsibility! !!ClassDescription methodsFor: 'instance variables' stamp: 'EstebanAllende 2/27/2012 23:51'!(Set) allInstVarNamesEverywhere	"Answer the set of inst var names used by the receiver, all superclasses, and all subclasses"	| (OrderedCollection)aList |	aList := OrderedCollection new.	(self allSuperclasses , self withAllSubclasses asOrderedCollection) do:		[:(ClassDescription)cls | aList addAll: cls instVarNames].	^ aList asSet	"BorderedMorph allInstVarNamesEverywhere"! !!ClassDescription methodsFor: 'instance variables' stamp: 'EstebanAllende 2/27/2012 23:52'!(Boolean) checkForInstVarsOK: (String)instVarString	"Return true if instVarString does no include any names used in a subclass"	| (Collection)instVarArray |	instVarArray := instVarString subStrings: ' '.	self allSubclasses do:		[:(ClassDescription)cl | cl instVarNames do:			[:(String)n | (instVarArray includes: n)				ifTrue: [self error: n , ' is already used in ' , cl name.						^ false]]].	^ true! !!ClassDescription methodsFor: 'instance variables' stamp: 'EstebanAllende 2/27/2012 23:54'!(ClassDescription) classThatDefinesClassVariable: (String)classVarName	"Answer the class that defines the given class variable"	((<{classPool (→Dictionary)}>(<?>self)) classPool includesKey: classVarName asSymbol) ifTrue: [^ self]. 	^self superclass ifNotNil: [(<ClassDescription>self superclass) classThatDefinesClassVariable: classVarName]! !!ClassDescription methodsFor: 'instance variables' stamp: 'EstebanAllende 2/27/2012 23:57'!(ClassDescription) classThatDefinesInstanceVariable: (String)instVarName	(self instVarNames notNil and: [self instVarNames includes: instVarName asString]) ifTrue: [^ self]. 	^self superclass ifNotNil: [(<ClassDescription>self superclass) classThatDefinesInstanceVariable: instVarName]! !!ClassDescription methodsFor: 'instance variables' stamp: 'EstebanAllende 2/28/2012 01:12'!(Self instance) forceNewFrom: (Array)anArray    "Create a new instance of the class and fill    its instance variables up with the array."    | (Self instance)object (Integer)max |    object := self new.    max := self instSize.    anArray doWithIndex: [:(Object)each :(Integer)index |        index > max ifFalse:            [object instVarAt: index put: each]].    ^ object! !!ClassDescription methodsFor: 'instance variables' stamp: 'EstebanAllende 2/28/2012 01:12'!(Boolean) hasInstVarNamed: (String)aString	"Return true whether the receiver defines an instance variable named aString."		^ self instVarNames includes: aString! !!ClassDescription methodsFor: 'instance variables' stamp: 'EstebanAllende 2/28/2012 01:13'!(Integer) instVarIndexFor: (String)instVarName	"Answer the index of the named instance variable."	| (Integer)index |	index := instanceVariables == nil 		ifTrue: [0]		ifFalse: [instanceVariables indexOf: instVarName].	index = 0 ifTrue: 		[^superclass == nil 			ifTrue: [0]			ifFalse: [(<ClassDescription>superclass) instVarIndexFor: instVarName]].	^superclass == nil 			ifTrue: [index]		ifFalse: [index + superclass instSize]! !!ClassDescription methodsFor: 'instance variables' stamp: 'EstebanAllende 2/28/2012 01:15'!(Integer) instVarIndexFor: (String)instVarName ifAbsent: (→Integer)aBlock	"Answer the index of the named instance variable."	| index |	index := instanceVariables == nil 				ifTrue: [0]				ifFalse: [instanceVariables indexOf: instVarName ifAbsent: [0]].	index = 0 ifTrue: 		[^superclass == nil 			ifTrue: [aBlock value]			ifFalse: [(<ClassDescription>superclass) instVarIndexFor: instVarName ifAbsent: aBlock]].	^superclass == nil 			ifTrue: [index]		ifFalse: [index + superclass instSize]! !!ClassDescription methodsFor: 'instance variables' stamp: 'EstebanAllende 2/28/2012 01:16'!(String) instVarNameForIndex: (Integer)index	"Answer the named instance variable with index index or nil if none."	| (Integer)superInstSize |	index > self instSize ifTrue: [^nil].	superInstSize := superclass isNil ifTrue: [0] ifFalse: [superclass instSize].	index > superInstSize ifTrue:		[^instanceVariables at: index - superInstSize].	superclass isNil ifTrue: [^nil].	^(<ClassDescription>superclass) instVarNameForIndex: index	"(Object allSubclasses select:		[:cls| cls instSize > cls superclass instSize and: [cls subclasses isEmpty and: [cls superclass instSize > 0]]]) collect:			[:cls| (1 to: cls instSize) collect: [:i| cls instVarNameForIndex: i]]"! !!ClassDescription methodsFor: 'instance variables' stamp: 'EstebanAllende 2/28/2012 01:16'!(Array) instVarNames	"Answer an Array of the receiver's instance variable names."	instanceVariables == nil		ifTrue: [^#()]		ifFalse: [^instanceVariables]! !!ClassDescription methodsFor: 'instance variables' stamp: 'EstebanAllende 2/28/2012 01:17'!(Self) removeInstVarNamed: (String)aString 	"Remove the argument, aString, as one of the receiver's instance 	variables. Create an error notification if the argument is not found."	self subclassResponsibility! !!ClassDescription methodsFor: 'instance variables' stamp: 'EstebanAllende 2/28/2012 01:18'!(Self) renameInstVar: (String)oldName to: (String)newName	(self confirm: 'WARNING: Renaming of instance variablesis subject to substitution ambiguities.Do you still wish to attempt it?') ifFalse: [self halt].	"...In other words, this does a dumb text search-and-replace,	which might improperly alter, eg, a literal string.  As long as	the oldName is unique, everything should work jes' fine. - di"	^ self renameSilentlyInstVar: oldName to: newName! !!ClassDescription methodsFor: 'instance variables' stamp: 'EstebanAllende 2/28/2012 01:19'!(Self) renameSilentlyInstVar: (String)old to: (String)new	| (Integer)i (String)oldName (String)newName |	oldName := old asString.	newName := new asString.	(i := self instVarNames indexOf: oldName) = 0 ifTrue:		[self error: oldName , ' is not defined in ', self name].	self allSuperclasses , self withAllSubclasses asOrderedCollection do:		[:(ClassDescription)cls | (cls instVarNames includes: newName) ifTrue:			[self error: newName , ' is already used in ', cls name]].	self instVarNames replaceFrom: i to: i with: (Array with: newName).	self replaceSilently: oldName to: newName.	"replace in text body of all methods"! !!ClassDescription methodsFor: 'instance variables' stamp: 'EstebanAllende 2/28/2012 01:21'!(Self) replaceSilently: (String)old to: (String)new	"text-replace any part of a method.  Used for class and pool variables.  Don't touch the header.  Not guaranteed to work if name appears in odd circumstances"	| (String)oldName (String)newName |	oldName := old asString.	newName := new asString.	self withAllSubclasses do:		[:(ClassDescription)cls |		| sels |		sels := cls selectors copyWithoutAll: #(DoIt DoItIn:).		sels do:			[:(Symbol)sel |			| (String)oldCode (String)newCode (Parser)parser (String)header (String)body |			oldCode := cls sourceCodeAt: sel.			"Don't make changes in the method header"			(parser := (<Parser>cls parserClass new)) parseSelector: oldCode.			header := oldCode copyFrom: 1 to: (parser endOfLastToken min: oldCode size).			body := header size > oldCode size					ifTrue: ['']					ifFalse: [oldCode copyFrom: header size+1 to: oldCode size].			newCode := header , (body copyReplaceTokens: oldName with: newName).			newCode ~= oldCode ifTrue:				[cls compile: newCode					classified: (cls organization categoryOfElement: sel)					notifying: nil]].		cls isMeta ifFalse:			[| (String)oldCode (String)newCode |			oldCode := cls comment.			newCode := oldCode copyReplaceTokens: oldName with: newName.			newCode ~= oldCode ifTrue:				[cls comment: newCode]]]! !!ClassDescription methodsFor: 'organization' stamp: 'EstebanAllende 2/28/2012 01:22'!(Collection) methodReferencesInCategory: (String)aCategoryName	^(self organization listAtCategoryNamed: aCategoryName)		collect: [:(Symbol)ea | RGMethodDefinition 						realClass: (self isMeta ifTrue:[ self theMetaClass ] ifFalse:[ self theNonMetaClass ])						selector: ea]! !!ClassDescription methodsFor: 'organization' stamp: 'EstebanAllende 2/28/2012 01:25'!(ClassOrganizer) organization	"Answer the instance of ClassOrganizer that represents the organization 	of the messages of the receiver."	organization ifNil:		[self organization: (ClassOrganizer defaultList: self selectors asArray sort)].	(organization isMemberOf: Array) ifTrue:		["self recoverFromMDFaultWithTrace" self flag: #DEAD].		"Making sure that subject is set correctly. It should not be necessary."	organization ifNotNil: [organization setSubject: self].	^ organization! !!ClassDescription methodsFor: 'organization' stamp: 'EstebanAllende 2/28/2012 01:26'!(Self) organization: (ClassOrganizer)aClassOrg	"Install an instance of ClassOrganizer that represents the organization of the messages of the receiver."	aClassOrg ifNotNil: [aClassOrg setSubject: self].	organization := aClassOrg! !!ClassDescription methodsFor: 'organization' stamp: 'EstebanAllende 2/28/2012 01:26'!(ClassOrganizer) reorganize	"During fileIn, !!Rectangle reorganize!! allows Rectangle to seize control and treat the next chunk as its organization.  See the transfer of control where ReadWriteStream fileIn calls scanFrom:"	^self organization! !!ClassDescription methodsFor: 'organization' stamp: 'EstebanAllende 2/28/2012 01:26'!(Symbol) whichCategoryIncludesSelector: (Symbol)aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	(self includesSelector: aSelector)		ifTrue: [^ self organization categoryOfElement: aSelector]		ifFalse: [^nil]! !!ClassDescription methodsFor: 'organization' stamp: 'EstebanAllende 2/28/2012 01:27'!(Self) zapOrganization	"Remove the organization of this class by message categories.	This is typically done to save space in small systems.  Classes and methods	created or filed in subsequently will, nonetheless, be organized"	self organization: nil.	self isClassSide ifFalse: [self classSide zapOrganization]! !!ClassDescription methodsFor: 'organization updating' stamp: 'EstebanAllende 2/28/2012 01:29'!(Set) applyChangesOfNewTraitCompositionReplacing: (TraitComposition)oldComposition	| (Set)changedSelectors |	changedSelectors := super applyChangesOfNewTraitCompositionReplacing: oldComposition.	self noteRecategorizedSelectors: changedSelectors oldComposition: oldComposition.	^ changedSelectors.! !!ClassDescription methodsFor: 'organization updating' stamp: 'EstebanAllende 2/28/2012 01:30'!(Self) noteRecategorizedSelectors: (Collection)aCollection oldComposition: (TraitComposition)aTraitComposition		aCollection do: [:(Symbol)each | | (Symbol)oldCategory (Symbol)newCategory | 		oldCategory := self organization categoryOfElement: each.		newCategory := (self traitComposition methodDescriptionForSelector: each) effectiveMethodCategory.		self noteRecategorizedSelector: each from: oldCategory to: newCategory]! !!ClassDescription methodsFor: 'organization updating' stamp: 'EstebanAllende 2/28/2012 01:31'!(Self) noteRecategorizedSelector: (Symbol)aSymbol from: (Symbol)oldCategoryOrNil to: (Symbol)newCategoryOrNil	| (Set)changedCategories |	changedCategories := self updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil.	changedCategories do: [:(Symbol)each |		(self organization isEmptyCategoryNamed: each) ifTrue: [self organization removeCategory: each]]! !!ClassDescription methodsFor: 'organization updating' stamp: 'EstebanAllende 2/28/2012 01:34'!(Self) notifyOfRecategorizedSelector: (Symbol)element from: (Symbol)oldCategory to: (Symbol)newCategory	SystemChangeNotifier uniqueInstance selector: element recategorizedFrom: oldCategory to: newCategory inClass: self! !!ClassDescription methodsFor: 'organization updating' stamp: 'EstebanAllende 2/28/2012 01:33'!(Set) updateOrganizationSelector: (Symbol)aSymbol oldCategory: (Symbol)oldCategoryOrNil newCategory: (Symbol)newCategoryOrNil	| (IdentitySet)changedCategories (TraitComposition)composition |	changedCategories := IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:(TraitMethodDescription)each | | (Symbol)currentCategory (Symbol)effectiveCategory (Symbol)sel |		sel := each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory := self organization categoryOfElement: sel.			effectiveCategory := each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!ClassDescription methodsFor: 'pool variable' stamp: 'EstebanAllende 2/28/2012 01:35'!(OrderedCollection) allSharedPools	"Answer an ordered collection  of the shared pools the receiver shares, including those defined  in the superclasses of the receiver."		^ OrderedCollection new! !!ClassDescription methodsFor: 'pool variable' stamp: 'StephaneDucasse 12/24/2011 12:07'!hasPoolVarNamed: aString	self deprecated: 'Renamed to #usesLocalPoolVarNamed:' on: '16 Decembre 2011'  in: 'Pharo1.4'.	^ self usesLocalPoolVarNamed: aString! !!ClassDescription methodsFor: 'pool variable' stamp: 'EstebanAllende 2/28/2012 01:35'!(Boolean) hasSharedPools	"Only a class may have shared pools"	^ false! !!ClassDescription methodsFor: 'pool variable' stamp: 'EstebanAllende 2/28/2012 02:10'!(SharedPool) sharedPoolOfVarNamed: aString	"Only classes may have shared pools"		^ nil! !!ClassDescription methodsFor: 'pool variable' stamp: 'EstebanAllende 2/28/2012 01:35'!(Boolean) usesLocalPoolVarNamed: (String)aString	^ false! !!ClassDescription methodsFor: 'pool variable' stamp: 'EstebanAllende 2/28/2012 01:36'!(Boolean) usesPoolVarNamed: (String)aString	"Only classes may use a pool variable named: aString"		^ false! !!ClassDescription methodsFor: 'printing' stamp: 'EstebanAllende 2/28/2012 01:36'!(Self) printOn: (Stream)aStream 	aStream nextPutAll: self name! !!ClassDescription methodsFor: 'printing' stamp: 'EstebanAllende 2/28/2012 01:36'!(Self) printWithClosureAnalysisOn: (Stream)aStream 	aStream nextPutAll: self name! !!ClassDescription methodsFor: 'printing' stamp: 'EstebanAllende 2/28/2012 01:37'!(String) sharedPoolsString	"Answer a string of my shared pool names separated by spaces."	^String streamContents: [ :(WriteStream)stream |		self sharedPools 			do: [ :(Symbol)each |				stream nextPutAll: (self environment 					keyAtIdentityValue: each 					ifAbsent: [ 'private' ]) ]			separatedBy: [ stream space ] ]! !!ClassDescription methodsFor: 'printing' stamp: 'EstebanAllende 2/28/2012 01:38'!(Self) storeOn: (Stream)aStream	"Classes and Metaclasses have global names."	aStream nextPutAll: self name! !!ClassDescription methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 01:38'!(Boolean) isAbstractClass	^self subclassResponsibility! !!ClassDescription methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 01:39'!(UndefinedObject) errorCategoryName	self error: 'Category name must be a String'.	^nil	! !!ClassDescription methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 01:39'!(Array) instVarMappingFrom: (ClassDescription)oldClass	"Return the mapping from instVars of oldClass to new class that is used for converting old instances of oldClass."	| (Array)oldInstVarNames |	oldInstVarNames := oldClass allInstVarNames.	^self allInstVarNames 			collect: [:(String)instVarName | oldInstVarNames indexOf: instVarName].! !!ClassDescription methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 01:40'!(Integer) linesOfCode 	"An approximate measure of lines of code.	Includes comments, but excludes blank lines."	| (Integer)lines |	lines := self localMethods inject: 0 into: [:(Integer)sum :(CompiledMethod)each | sum + each linesOfCode]. 	^ self isMeta 		ifTrue: [lines]		ifFalse: [lines + self class linesOfCode]! !!ClassDescription methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 01:41'!(Self) logMethodSource: (Text)aText forMethodWithNode: (CompiledMethodWithNode)aCompiledMethodWithNode inCategory: (String)category withStamp: (String)changeStamp notifying: (Object)requestor 	aCompiledMethodWithNode method		putSource: aText		fromParseNode: aCompiledMethodWithNode node		class: self		category: category		withStamp: changeStamp		inFile: 2		priorMethod: (self				compiledMethodAt: aCompiledMethodWithNode selector				ifAbsent: []) ! !!ClassDescription methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 01:43'!(Self instance) newInstanceFrom: (Self instance)oldInstance variable: (Boolean)variable size: (Integer)instSize map: (Array)map	"Create a new instance of the receiver based on the given old instance.	The supplied map contains a mapping of the old instVar names into	the receiver's instVars"	| (Self instance)new |	variable		ifTrue: [new := self basicNew: oldInstance basicSize]		ifFalse: [new := self basicNew].	1 to: instSize do: 		[:(Integer)offset |  (map at: offset) > 0 ifTrue:			[new instVarAt: offset					put: (oldInstance instVarAt: (map at: offset))]].	variable 		ifTrue: [1 to: oldInstance basicSize do: 					[:(Integer)offset |					new basicAt: offset put: (oldInstance basicAt: offset)]].	^new! !!ClassDescription methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 01:43'!(Integer) numberOfMethods	"count all methods that are local (not comming from a trait)"	| (Integer)num |	num := self localMethods size.	^ self isMeta  		ifTrue: [ num ]		ifFalse: [ num + self class numberOfMethods ] ! !!ClassDescription methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 01:44'!(Self) setInstVarNames: (Collection)instVarArray	"Private - for class initialization only"	| (Integer)required |	required := self instSize.	superclass notNil ifTrue:[required := required - superclass instSize].	instVarArray size = required		ifFalse:[^self error: required printString, ' instvar names are required'].	instVarArray isEmpty		ifTrue:[instanceVariables := nil]		ifFalse:[instanceVariables := instVarArray asArray].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClassDescription class	uses: TClassAndTraitDescription classTrait + TTyped classTrait	instanceVariableNames: ''!