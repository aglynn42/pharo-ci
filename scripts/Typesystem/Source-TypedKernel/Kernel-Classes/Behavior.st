'From Pharo1.4 of 18 April 2012 [Latest update: #14438] on 14 August 2012 at 5:49:15 pm'!Object subclass: #Behavior	uses: TPureBehavior + TTyped	instanceVariableNames: '(Behavior)superclass (MethodDictionary)methodDict (Integer)format'	classVariableNames: '(WeakKeyToCollectionDictionary)ObsoleteSubclasses'	poolDictionaries: ''	category: 'Kernel-Classes'!!Behavior commentStamp: 'al 12/8/2005 20:44' prior: 0!My instances describe the behavior of other objects. I provide the minimum state necessary for compiling methods, and creating and running instances. Most objects are created as instances of the more fully supported subclass, Class, but I am a good starting point for providing instance-specific behavior (as in Metaclass).!!Behavior methodsFor: '*Ring-Core-Kernel' stamp: 'EstebanAllende 2/27/2012 21:27'!(CompiledMethod) methodNamed: (Symbol)aSelector	^ self methodDict at: aSelector! !!Behavior methodsFor: '*Ring-Core-Kernel' stamp: 'EstebanAllende 2/27/2012 21:27'!(Array) methods		^ self methodDict values! !!Behavior methodsFor: '*Ring-Core-Kernel' stamp: 'EstebanAllende 2/27/2012 21:29'!(Collection)methodsInProtocol: (String)aString	^  ((<ClassDescription>(<?>self)) organization listAtCategoryNamed: aString) collect: [:(Symbol)each | (self methodDict at: each) ]! !!Behavior methodsFor: '*Ring-Core-Kernel' stamp: 'EstebanAllende 2/27/2012 21:29'!(Collection)protocols		^ (<ClassDescription>(<?>self)) organization categories copy! !!Behavior methodsFor: '*System-Support' stamp: 'EstebanAllende 2/27/2012 21:30'!(SortedCollection) allCallsOn	"Answer a SortedCollection of all the methods that refer to me by name or as part of an association in a global dict."		^ (self allCallsOnIn: self systemNavigation)! !!Behavior methodsFor: '*System-Support' stamp: 'EstebanAllende 2/27/2012 21:30'!(SortedCollection) allCallsOn: (Symbol)aSymbol	"Answer a SortedCollection of all the methods that call on aSymbol."	^ self  systemNavigation allCallsOn: aSymbol from: self .	! !!Behavior methodsFor: '*System-Support' stamp: 'EstebanAllende 2/27/2012 21:32'!(SortedCollection) allCallsOnIn: (SystemNavigation)aSystemNavigation	"Answer a SortedCollection of all the methods that refer to me by name or as part of an association in a global dict."	^ (aSystemNavigation 		allReferencesTo: (self environment associationAt: (<ClassDescription>(<?>self)) theNonMetaClass name)), 		(aSystemNavigation allCallsOn: (<ClassDescription>(<?>self)) theNonMetaClass name)	! !!Behavior methodsFor: '*System-Support' stamp: 'EstebanAllende 2/27/2012 21:32'!(Array) allUnsentMessages	"Answer an array of all the messages defined by the receiver that are not sent anywhere in the system."	^ SystemNavigation default allUnsentMessagesIn: self selectors! !!Behavior methodsFor: '*System-Support' stamp: 'EstebanAllende 2/27/2012 21:32'!(Set) referencedClasses	"Return the set of classes that are directly referenced by my methods"	| (Set)answer |	answer := Set new.	self methods do: [ :(CompiledMethod)cm |		answer addAll: 			( cm literals select: [ :(Object)l | l isKindOf: Association ] thenCollect: #value ) ].			^ answer! !!Behavior methodsFor: '*Tools-Inspector' stamp: 'EstebanAllende 2/27/2012 21:33'!(Self) inspectAllInstances 	"Inpsect all instances of the receiver.  1/26/96 sw"	| (Array)all (Integer)allSize (String)prefix |	all := self allInstances.	(allSize := all size) isZero ifTrue: [^ self inform: 'There are no instances of ', self name].	prefix := allSize = 1		ifTrue: 	['The lone instance']		ifFalse:	['The ', allSize printString, ' instances'].		all asArray inspectWithLabel: (prefix, ' of ', self name)! !!Behavior methodsFor: '*Tools-Inspector' stamp: 'EstebanAllende 2/27/2012 21:35'!(Self) inspectSubInstances 	"Inspect all instances of the receiver and all its subclasses.  CAUTION - don't do this for something as generic as Object!!  1/26/96 sw"	| (OrderedCollection)all (Integer)allSize (String)prefix |	all := self allSubInstances.	(allSize := all size) isZero ifTrue: [^ self inform: 'There are no instances of ', self name, 'or any of its subclasses'].	prefix := allSize = 1		ifTrue: 	['The lone instance']		ifFalse:	['The ', allSize printString, ' instances'].		all asArray inspectWithLabel: (prefix, ' of ', self name, ' & its subclasses')! !!Behavior methodsFor: '*ast-core' stamp: 'EstebanAllende 2/27/2012 21:35'!(RBMethodNode) parseTreeFor: (Symbol)aSymbol		^ RBParser parseMethod: (self sourceCodeAt: aSymbol) onError: [ :(String)msg :(Integer)pos | ^ nil ]! !!Behavior methodsFor: '*compiler-extensions-accesing methods' stamp: 'EstebanAllende 2/27/2012 21:37'!(Array) formalParametersAt: (Symbol)aSelector	"Return the names of the arguments used in this method."	| (String)source (RBMethodNode)node|	source := self sourceCodeAt: aSelector ifAbsent: [^ #()].	"for now"	node := (MethodParseRequest new source: source) sendTo: self.	^node arguments ifNil: [#()] ifNotNil: [node arguments collect: [:(RBVariableNode)each| each name]]! !!Behavior methodsFor: '*compiler-extensions-accesing methods' stamp: 'EstebanAllende 2/27/2012 21:38'!(String) methodHeaderFor: (Symbol)selector 	"Answer the string corresponding to the method header for the given selector"	| (String)sourceString (RBMethodNode)methodNode|	sourceString := self ultimateSourceCodeAt: selector ifAbsent: [self standardMethodHeaderFor: selector].	methodNode := (MethodParseRequest new source: sourceString) sendTo: self.	^sourceString asString copyFrom: 1 to: ((methodNode arguments size >0) ifTrue:[methodNode arguments last stop] ifFalse:[methodNode selectorParts first stop])."	(parser := self parserClass new) parseSelector: sourceString.	^ sourceString asString copyFrom: 1 to: (parser endOfLastToken min: sourceString size)"	"Behavior methodHeaderFor: #methodHeaderFor: "! !!Behavior methodsFor: '*compiler-extensions-compiling' stamp: 'EstebanAllende 2/27/2012 21:40'!(CompiledMethodWithNode) compile: (String)code classified: (String)category notifying: (Object)requestor trailer: (CompiledMethodTrailer)bytes ifFail: (→Object)failBlock	"Compile code without logging the source in the changes file"	|(MethodCompileRequest)request|	request := MethodCompileRequest new.	request source: code.	request category: category.	request requestor: requestor.	request trailer: bytes.	request failBlock: failBlock.	^request sendTo: self. 	! !!Behavior methodsFor: '*compiler-extensions-compiling' stamp: 'EstebanAllende 2/27/2012 21:40'!(Class) oldCompilerClass	"Answer a compiler class appropriate for source methods of this class."	^self compilerContext compiler bcCompilerClass! !!Behavior methodsFor: '*compiler-extensions-compiling' stamp: 'EstebanAllende 8/14/2012 17:47'!(Self) recompile: (Symbol)selector from: (Behavior)oldClass	"Compile the method associated with selector in the receiver's method dictionary."	"ar 7/10/1999: Use oldClass compiledMethodAt: not self compiledMethodAt:"	| ({selector (->Symbol)})methodNode (MethodCompileRequest)request (CompiledMethodWithNode)pair (CompilerContext)ctx|	request := MethodCompileRequest new.	request source: (oldClass sourceCodeAt: selector).	request failBlock: [^ self]. "Assume OK after proceed from SyntaxError"	request trailer: (oldClass compiledMethodAt: selector) trailer.	request target: self.	ctx := CompilerFrontend compilerContextForClass: oldClass.	pair := ctx compiler methodCompiler compileWithRequest: request usingCompilerContext: ctx.	methodNode := pair node. 	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	self basicAddSelector: selector withMethod: pair method.! !!Behavior methodsFor: '*compiler-extensions-compiling' stamp: 'EstebanAllende 2/27/2012 21:44'!(Self) recompileNonResidentMethod: (CompiledMethod)method atSelector: (Symbol)selector from: (Behavior)oldClass	"Recompile the method supplied in the context of this class."	|(RBMethodNode)methodNode (MethodCompileRequest)request (CompiledMethodWithNode)pair|	methodNode := nil.	request := MethodCompileRequest new.	request source: (method getSourceFor: selector in: oldClass).	request failBlock: ["We're in deep doo-doo if this fails (syntax error).				Presumably the user will correct something and proceed,				thus installing the result in this methodDict.  We must				retrieve that new method, and restore the original (or remove)				and then return the method we retrieved."				^ self error: 'see comment'].	request trailer: method trailer.	pair := request sendTo: self.	methodNode := pair node    	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	^pair method.! !!Behavior methodsFor: '*compiler-extensions-deprecated' stamp: 'EstebanAllende 2/20/2012 22:49'!subclassDefinerClass	"Answer an evaluator class appropriate for evaluating definitions of new 	subclasses of this class."	self deprecated: 'Use new evaluate request' on: 'December 23th, 2011' in: 'NCAPI'.	^Compiler! !!Behavior methodsFor: '*compiler-frontend' stamp: 'EstebanAllende 2/27/2012 21:44'!(CompilerContext) compilerContext	<original> "Unless you want a frozen system, don't delete or change this pragma"	^ CompilerFrontend compilerContextForClass: self! !!Behavior methodsFor: '*opalcompiler-core' stamp: 'EstebanAllende 2/27/2012 21:45'!(Boolean) needsLongForm	^false! !!Behavior methodsFor: '*opalcompiler-core' stamp: 'EstebanAllende 2/27/2012 21:45'!(OCClassScope) parseScope	^ OCClassScope for: self! !!Behavior methodsFor: '*typesystem-core' stamp: 'EstebanAllende 7/19/2012 12:09'!enhancedEqual: aBehavior	^self == aBehavior	! !!Behavior methodsFor: '*typesystem-core' stamp: 'EstebanAllende 7/19/2012 13:32'!instanceSpecies	^{self}! !!Behavior methodsFor: '*typesystem-core' stamp: 'EstebanAllende 7/19/2012 12:17'!tInheritsFrom: aClass 	"Answer whether the argument, aClass, is on the receiver's superclass 	chain."	| aSuperclass |	(self inheritsFrom: aClass) ifTrue: [^true].	aSuperclass := superclass.	[aSuperclass == nil]		whileFalse: 			[(aSuperclass enhancedEqual: aClass) ifTrue: [^true].			aSuperclass := aSuperclass superclass].	^false! !!Behavior methodsFor: 'accessing' stamp: 'EstebanAllende 2/27/2012 01:05'!(Integer) classDepth	superclass ifNil: [^ 1].	^ superclass classDepth + 1! !!Behavior methodsFor: 'accessing' stamp: 'EstebanAllende 7/8/2012 12:43'!(Compiler class) compilerClass	"Answer a compiler class appropriate for source methods of this class."	^self compilerContext compiler bcCompilerClass! !!Behavior methodsFor: 'accessing' stamp: 'EstebanAllende 2/26/2012 14:43'!(Class) decompilerClass	"Answer a decompiler class appropriate for compiled methods of this class."	^ self compilerContext compiler bcDecompilerClass! !!Behavior methodsFor: 'accessing' stamp: 'EstebanAllende 2/26/2012 14:43'!(SystemDictionary) environment	"Return the environment in which the receiver is visible"		^Smalltalk globals! !!Behavior methodsFor: 'accessing' stamp: 'EstebanAllende 2/26/2012 14:44'!(Class) evaluatorClass	"Answer an evaluator class appropriate for evaluating expressions in the 	context of this class."	"self deprecated: 'Use new evaluate request' on: 'Dicember 23th, 2011' in: 'NCAPI'."	^self compilerContext compiler bcEvaluatorClass! !!Behavior methodsFor: 'accessing' stamp: 'EstebanAllende 2/26/2012 14:44'!(Integer) format	"Answer an Integer that encodes the kinds and numbers of variables of 	instances of the receiver."	^format! !!Behavior methodsFor: 'accessing' stamp: 'EstebanAllende 2/26/2012 14:45'!(MethodDictionary) methodDict	methodDict == nil ifTrue: [self manageMDFault].	^ methodDict! !!Behavior methodsFor: 'accessing' stamp: 'EstebanAllende 2/26/2012 14:45'!(String) name	"Answer a String that is the name of the receiver."	^'a subclass of ', superclass name! !!Behavior methodsFor: 'accessing' stamp: 'EstebanAllende 2/26/2012 14:45'!(Integer) numberOfInstanceVariables	^ self instVarNames size! !!Behavior methodsFor: 'accessing' stamp: 'EstebanAllende 2/26/2012 14:45'!(Class) parserClass	"Answer a parser class to use for parsing method headers."	^self compilerContext compiler bcParserClass! !!Behavior methodsFor: 'accessing' stamp: 'EstebanAllende 2/26/2012 14:45'!(String) sourceCodeTemplate	"Answer an expression to be edited and evaluated in order to define 	methods in this class or trait."	^'message selector and argument names	"comment stating purpose of message"	| temporary variable names |	statements'! !!Behavior methodsFor: 'accessing' stamp: 'EstebanAllende 2/26/2012 14:46'!(Symbol) typeOfClass	"Answer a symbol uniquely describing the type of the receiver"	self instSpec = CompiledMethod instSpec ifTrue:[^#compiledMethod]. "Very special!!"	self isBytes ifTrue:[^#bytes].	(self isWords and:[self isPointers not]) ifTrue:[^#words].	self isWeak ifTrue:[^#weak].	self isVariable ifTrue:[^#variable].	^#normal.! !!Behavior methodsFor: 'accessing class hierarchy' stamp: 'EstebanAllende 2/26/2012 14:47'!(OrderedCollection) allSubclasses	"Answer an orderedCollection of the receiver's and the receiver's descendent's subclasses. "	| (OrderedCollection)scan (Integer)scanTop |	scan := OrderedCollection withAll: self subclasses.	scanTop := 1.	[scanTop > scan size]		whileFalse: [scan addAll: (scan at: scanTop) subclasses.			scanTop := scanTop + 1].	^ scan! !!Behavior methodsFor: 'accessing class hierarchy' stamp: 'EstebanAllende 2/27/2012 18:02'!(Self) allSubclassesWithLevelDo: (Self Integer → Object)classAndLevelBlock startingLevel: (Integer)level 	"Walk the tree of subclasses, giving the class and its level"	| (SortedCollection)subclassNames |	classAndLevelBlock value: self value: level.	self == Class ifTrue:  [^ self].  "Don't visit all the metaclasses"	"Visit subclasses in alphabetical order"	subclassNames := SortedCollection new.	self subclassesDo: [:(Self)subC | subclassNames add: subC name].	subclassNames do:		[:(String)name | (self environment at: name)			allSubclassesWithLevelDo: classAndLevelBlock			startingLevel: level+1]! !!Behavior methodsFor: 'accessing class hierarchy' stamp: 'EstebanAllende 2/26/2012 14:58'!(OrderedCollection) allSuperclasses	"Answer an OrderedCollection of the receiver's and the receiver's  	ancestor's superclasses. The first element is the receiver's immediate  	superclass, followed by its superclass; the last element is Object."	| (OrderedCollection)temp |	^ superclass == nil		ifTrue: [ OrderedCollection new]		ifFalse: [temp := superclass allSuperclasses.			temp addFirst: superclass.			temp]! !!Behavior methodsFor: 'accessing class hierarchy' stamp: 'EstebanAllende 2/26/2012 15:01'!(OrderedCollection) allSuperclassesIncluding: (Behavior)aClass	"Answer an OrderedCollection of the receiver's and the receiver's  	ancestor's superclasses up to aClass included. The first element is the receiver's immediate  	superclass up to aClass included."	| (OrderedCollection)temp |	^ superclass == aClass		ifTrue: [ OrderedCollection with: aClass]		ifFalse: [temp := superclass allSuperclassesIncluding: aClass.			temp addFirst: superclass.			temp]! !!Behavior methodsFor: 'accessing class hierarchy' stamp: 'EstebanAllende 2/26/2012 15:01'!(Array) subclasses	"slow implementation since Behavior does not keep trace of subclasses"		^ self class allInstances  select: [:each | each superclass = self ]! !!Behavior methodsFor: 'accessing class hierarchy' stamp: 'EstebanAllende 2/26/2012 16:53'!(Behavior) superclass	"Answer the receiver's superclass, a Class."	^superclass! !!Behavior methodsFor: 'accessing class hierarchy' stamp: 'EstebanAllende 2/26/2012 16:54'!(Self) superclass: (Behavior)aClass 	"Change the receiver's superclass to be aClass."	"Note: Do not use 'aClass isKindOf: Behavior' here		in case we recompile from Behavior itself."	(aClass == nil or: [aClass isBehavior])		ifTrue: [superclass := aClass.				Object flushCache]		ifFalse: [self error: 'superclass must be a class-describing object']! !!Behavior methodsFor: 'accessing class hierarchy' stamp: 'EstebanAllende 2/26/2012 16:55'!(OrderedCollection) withAllSubclasses	"Answer a Set of the receiver, the receiver's descendent's, and the  	receiver's descendent's subclasses."	^ self allSubclasses add: self;		 yourself! !!Behavior methodsFor: 'accessing class hierarchy' stamp: 'EstebanAllende 2/26/2012 16:55'!(OrderedCollection)withAllSuperclasses	"Answer an OrderedCollection of the receiver and the receiver's 	superclasses. The first element is the receiver, 	followed by its superclass; the last element is Object."	| (OrderedCollection)temp |	temp := self allSuperclasses.	temp addFirst: self.	^ temp! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'EstebanAllende 2/26/2012 16:57'!(Set) allClassVarNames	"Answer a Set of the names of the receiver's and the receiver's ancestor's 	class variables."	^superclass allClassVarNames! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'EstebanAllende 2/26/2012 17:01'!(Array) allInstVarNames	"Answer an Array of the names of the receiver's instance variables. The 	Array ordering is the order in which the variables are stored and 	accessed by the interpreter."	| (Array) vars |	superclass == nil		ifTrue: [vars := self instVarNames copy]	"Guarantee a copy is answered."		ifFalse: [vars := superclass allInstVarNames , self instVarNames].	^vars! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'EstebanAllende 2/26/2012 17:36'!(Array) allInstances	"Answer a collection of all current instances of the receiver."	| (OrderedCollection)all (Self instance)inst (Self instance)next |	all := OrderedCollection new.	inst := self someInstance.	[inst == nil]		whileFalse: [		next := inst nextInstance.		inst == all ifFalse: [all add: inst].		inst := next].	^ all asArray! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'EstebanAllende 2/26/2012 17:24'!(OrderedCollection)allSharedPools	"Answer an ordered collection of the shared pools that the receiver and the receiver's ancestors share."	^superclass allSharedPools! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'EstebanAllende 2/26/2012 17:37'!(OrderedCollection) allSubInstances 	"Answer a list of all current instances of the receiver and all of its subclasses."	| (OrderedCollection)aCollection |	aCollection := OrderedCollection new.	self allSubInstancesDo:		[:(Behavior)x | x == aCollection ifFalse: [aCollection add: x]].	^ aCollection! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'EstebanAllende 2/26/2012 17:38'!(Boolean) allowsSubInstVars	"Classes that allow instances to change classes among its subclasses will want to override this and return false, so inst vars are not accidentally added to its subclasses."	^ true! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'EstebanAllende 2/26/2012 17:39'!(Array) classVarNames	"Answer a collection of the receiver's class variable names."	^#()! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'EstebanAllende 2/26/2012 17:40'!(Boolean) includesSharedPoolNamed: (String)aSharedPoolString 	"Answer whether the receiver uses the shared pool named aSharedPoolString"		^ (self sharedPools anySatisfy: [:each | each name = aSharedPoolString])! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'EstebanAllende 2/26/2012 17:42'!(Array) instVarNames	"Answer an Array of the instance variable names. Behaviors must make 	up fake local instance variable names because Behaviors have instance 	variables for the purpose of compiling methods, but these are not named 	instance variables."	| (Integer)mySize (Integer)superSize |	mySize := self instSize.	superSize := 		superclass == nil			ifTrue: [0]			ifFalse: [superclass instSize].	mySize = superSize ifTrue: [^#()].		^(superSize + 1 to: mySize) collect: [:(Integer)i | 'inst' , i printString]! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'EstebanAllende 2/26/2012 17:43'!(Integer) instanceCount	"Answer the number of instances of the receiver that are currently in 	use."	| (Integer)count |	count := 0.	self allInstancesDo: [:(Behavior)x | count := count + 1].	^count! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'EstebanAllende 2/26/2012 17:44'!(OrderedCollection) sharedPools	"Answer an ordered collection of  the shared pools that the receiver shares"	^ OrderedCollection new! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'EstebanAllende 2/26/2012 17:35'!(Self instance)someInstance	"Primitive. Answer the first instance in the enumeration of all instances 	of the receiver. Fails if there are none. Essential. See Object 	documentation whatIsAPrimitive."	<primitive: 77>	^nil! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'EstebanAllende 2/26/2012 17:45'!(Set) subclassInstVarNames	"Answer a Set of the names of the receiver's subclasses' instance 	variables."	| (Set)vars |	vars := Set new.	self allSubclasses do: [:(Behavior)aSubclass | vars addAll: aSubclass instVarNames].	^vars! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/26/2012 17:46'!(CompiledMethod) >> (Symbol)selector 	"Answer the compiled method associated with the argument, selector (a 	Symbol), a message selector in the receiver's method dictionary. If the 	selector is not in the dictionary, create an error notification."	^self compiledMethodAt: selector! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 00:20'!(Self) addSelector: (Symbol)selector withMethod: (CompiledMethod)compiledMethod 	^ self addSelector: selector withMethod: compiledMethod notifying: nil! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 00:20'!(Self) addSelector: (Symbol)selector withMethod: (CompiledMethod)compiledMethod notifying: (Object)requestor	^ self addSelectorSilently: selector withMethod: compiledMethod! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/26/2012 17:47'!(Self) addSelectorSilently: (Symbol)selector withMethod: (CompiledMethod)compiledMethod	self methodDictAddSelectorSilently: selector withMethod: compiledMethod.	self registerLocalSelector: selector! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 00:21'!(Array) allMethods	"Return the collection of compiled method I and my superclasses are defining"	"asArray is used to not bump into a bug when comparing compiled methods."		^ self allSelectors asArray collect: [ :(Symbol)s | self lookupSelector: s ]! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 00:22'!(IdentitySet) allSelectors	"Answer all selectors understood by instances of the receiver"	^ self allSelectorsBelow: nil! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 00:23'!(IdentitySet) allSelectorsAbove	^ self allSelectorsAboveUntil: ProtoObject 	! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 00:23'!(IdentitySet) allSelectorsAboveUntil: (Behavior)aRootClass	| (IdentitySet)coll |	coll := IdentitySet new.	(self allSuperclassesIncluding: aRootClass) 		do: [:(Behavior)aClass | 				aClass selectorsDo: [ :(Symbol)sel | coll add: sel ]].	^ coll	! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 18:03'!(IdentitySet) allSelectorsBelow: (Behavior)topClass 	| (IdentitySet)coll |	coll := IdentitySet new.	self withAllSuperclassesDo: 			[:(Behavior)aClass | 			aClass = topClass				ifTrue: [^ coll ]				ifFalse: [aClass selectorsDo: [ :(Symbol)sel | coll add: sel ]]].	^ coll	! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'StephaneDucasse 2/23/2012 12:40'!allSelectorsWithout: behaviors      "Returns all the selectors of the receiver and its superclasses, except the ones define in behaviors"	| selectors |	selectors := IdentitySet new.	self withAllSuperclassesDo: [:class | (behaviors includes: class)											ifFalse: [selectors addAll: class selectors.]].	^ selectors asOrderedCollection ! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 00:27'!(Set) basicLocalSelectors	"Direct accessor for the instance variable localSelectors.	Because of hardcoded ivar indexes of Behavior and Class in the VM, Class and	Metaclass declare the needed ivar and override this method as an accessor. 	By returning nil instead of declaring this method as a subclass responsibility,	Behavior can be instantiated for creating anonymous classes."		^nil! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 00:27'!(Self) basicLocalSelectors: (Set)aSetOrNil	self subclassResponsibility ! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 00:40'!(ChangeSet) changeRecordsAt: (Symbol)selector	"Return a list of ChangeRecords for all versions of the method at selector. Source code can be retrieved by sending string to any one.  Return nil if the method is absent."	"(Pen changeRecordsAt: #go:) collect: [:cRec | cRec string]"	^ChangeSet 		scanVersionsOf: (self compiledMethodAt: selector ifAbsent: [^ nil])		class: self meta: self isMeta		category: (self whichCategoryIncludesSelector: selector)		selector: selector.! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 00:43'!(?) classAndMethodFor: (Symbol) aSymbol do: (Behavior CompiledMethod → Object)binaryBlock ifAbsent: (→ Object)absentBlock	"Looks up the selector aSymbol in the class chain. If it is found, binaryBlock is evaluated	with the class that defines the selector and the associated method. Otherwise	absentBlock is evaluated."		self withAllSuperclassesDo: [:(Behavior)class | | (CompiledMethod)method |		method := class compiledMethodAt: aSymbol ifAbsent: [nil].		method ifNotNil: [^ binaryBlock value: class value: method].	].	^ absentBlock value.! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 01:02'!(OrderedCollection) commentsAt:  (Symbol)selector	"Answer a string representing the first comment in the method associated with selector.  Return an empty string if the relevant source file is not available, or if the method's source code does not contain a comment.  Not smart enough to bypass quotes in string constants, but does map doubled quote into a single quote."	^self commentsIn:  (self sourceCodeAt: selector) asString.	"Behavior commentsAt: #commentsAt:"! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 00:49'!(OrderedCollection) commentsIn: (String)sourceString		| (Integer)commentStart (Integer)nextQuotePos (OrderedCollection) someComments (Integer)aPos |	('*"*' match: sourceString) ifFalse: [^OrderedCollection new].	someComments:= OrderedCollection new.	sourceString size = 0 ifTrue: [^ someComments].	aPos:=1.	nextQuotePos:= 0.	[commentStart := sourceString findString: '"' startingAt: aPos.	nextQuotePos:= self nextQuotePosIn: sourceString startingFrom: commentStart.	(commentStart ~= 0 and: [nextQuotePos >commentStart])] whileTrue: [		commentStart ~= nextQuotePos ifTrue: [			someComments add: ((sourceString copyFrom: commentStart + 1 to: nextQuotePos - 1) copyReplaceAll: '""' with: '"').].	aPos := nextQuotePos+1].	^someComments! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 00:51'!(CompiledMethod) compiledMethodAt: (Symbol)selector 	"Answer the compiled method associated with the argument, selector (a 	Symbol), a message selector in the receiver's method dictionary. If the 	selector is not in the dictionary, create an error notification."	^ self methodDict at: selector! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 00:51'!(CompiledMethod) compiledMethodAt: (Symbol)selector ifAbsent: (→CompiledMethod)aBlock	"Answer the compiled method associated with the argument, selector (a Symbol), a message selector in the receiver's method dictionary. If the selector is not in the dictionary, return the value of aBlock"	^ self methodDict at: selector ifAbsent: [aBlock value]! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 00:52'!(Self) compress	"Compact the method dictionary of the receiver."	self methodDict rehash! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 01:01'!(Self) deregisterLocalSelector: (Symbol)aSymbol	self basicLocalSelectors notNil ifTrue: [		self basicLocalSelectors remove: aSymbol ifAbsent: []]! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 01:02'!(String) firstCommentAt:  (Symbol)selector	"Answer a string representing the first comment in the method associated with selector.  Return an empty string if the relevant source file is not available, or if the method's source code does not contain a comment.  Not smart enough to bypass quotes in string constants, but does map doubled quote into a single quote."	|(OrderedCollection)someComments|	someComments := self commentsAt: selector.	^someComments isEmpty ifTrue: [''] ifFalse: [someComments first]"Behavior firstCommentAt: #firstCommentAt:"! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 01:07'!(String) firstPrecodeCommentFor: (Symbol)selector 	"If there is a comment in the source code at the given selector that preceeds the body of the method, return it here, else return nil"	"Behavior firstPrecodeCommentFor: #firstPrecodeCommentFor:"	| (Parser)parser (String)source (MethodNode)tree |	(#(#Comment #Definition #Hierarchy ) includes: selector) ifTrue: 		[ "Not really a selector"		^ nil ].	source := self 		sourceCodeAt: selector asSymbol		ifAbsent: [ ^ nil ].	parser := (<Parser>self parserClass new).	tree := parser 		parse: source readStream		class: self		noPattern: false		context: nil		notifying: nil		ifFail: [ ^ nil ].	^ (tree comment ifNil: [ ^ nil ]) first! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 01:09'!(OrderedCollection) "popeye" formalHeaderPartsFor: "olive oil" (Symbol) aSelector	"RELAX!!  The warning you may have just seen about possibly having a bad source file does not apply here, because this method *intends* to have its source code start with a comment.	This method returns a collection giving the parts in the formal declaration for aSelector.  This parse is in support of schemes in which adjutant properties of a method can be declared via special comments secreted in the formal header	The result will have     	3 elements for a simple, argumentless selector.		5 elements for a single-argument selector		9 elements for a two-argument selector		13 elements for a three-argument, selector		etc...	The syntactic elements are:		1		comment preceding initial selector fragment		2		first selector fragment		3		comment following first selector fragment  (nil if selector has no arguments)        ----------------------  (ends here for, e.g., #copy)		4		first formal argument		5		comment following first formal argument (nil if selector has only one argument)        ----------------------  (ends here for, e.g., #copyFrom:)		6		second keyword		7		comment following second keyword		8		second formal argument		9		comment following second formal argument (nil if selector has only two arguments)         ----------------------  (ends here for, e.g., #copyFrom:to:)	Any nil element signifies an absent comment.	NOTE: The comment following the final formal argument is *not* successfully retrieved by this method in its current form, though it can be obtained, if needed, by other means (e.g. calling #firstPrecodeCommentFor:).  Thus, the *final* element in the structure returned by this method is always going to be nil."	^ Scanner new scanMessageParts: (self methodHeaderFor: aSelector)"	Behavior class formalHeaderPartsFor: #formalHeaderPartsFor:"	! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 01:09'!(CompiledMethod) lookupSelector: (Symbol)selector	"Look up the given selector in my methodDictionary.	Return the corresponding method if found.	Otherwise chase the superclass chain and try again.	Return nil if no method is found."	| (Behavior)lookupClass |	lookupClass := self.	[lookupClass == nil]		whileFalse: 			[(lookupClass includesSelector: selector)				ifTrue: [^ lookupClass compiledMethodAt: selector].			lookupClass := lookupClass superclass].	^ nil! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 01:10'!(Self) methodDict: (MethodDictionary)aDictionary	methodDict := aDictionary! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 01:10'!(MethodDictionary) methodDictionary	"Convenience"	^self methodDict! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 01:10'!(Self) methodDictionary: (MethodDictionary)aDictionary	self methodDict: aDictionary! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 01:12'!(Self) methodsDo: (CompiledMethod → Object)aBlock	"Evaluate aBlock for all the compiled methods in my method dictionary."	self methodDict valuesDo: aBlock.	^self! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 01:13'!(Integer) nextQuotePosIn: (String)sourceString startingFrom: (Integer)commentStart	| (Integer)pos (Integer)nextQuotePos |	pos := commentStart + 1.	[((nextQuotePos := sourceString findString: '"' startingAt: pos) == (sourceString findString: '""' startingAt: pos)) and: [nextQuotePos ~= 0]]		whileTrue:			[pos := nextQuotePos + 2].	^nextQuotePos! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 01:14'!(String) precodeCommentOrInheritedCommentFor: (Symbol)selector 	"Answer a string representing the first comment in the method associated 	with selector, considering however only comments that occur before the 	beginning of the actual code. If the version recorded in the receiver is 	uncommented, look up the inheritance chain. Return nil if none found."		| (Behavior)aSuper (String)aComment |	^ (aComment := self firstPrecodeCommentFor: selector) isEmptyOrNil		ifTrue: [(self == Behavior					or: [superclass == nil							or: [(aSuper := superclass whichClassIncludesSelector: selector) == nil]])				ifFalse: [aSuper precodeCommentOrInheritedCommentFor: selector]]		ifFalse: [aComment]! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 01:15'!(Self) registerLocalSelector: (Symbol)aSymbol	self basicLocalSelectors notNil ifTrue: [		self basicLocalSelectors add: aSymbol]! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 01:20'!(Self) removeSelector: (Symbol)aSelector 	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method.		If the method to remove will be replaced by a method from my trait composition,	the current method does not have to be removed because we mark it as non-local.	If it is not identical to the actual method from the trait it will be replaced automatically	by #noteChangedSelectors:.		This is useful to avoid bootstrapping problems when moving methods to a trait	(e.g., from TPureBehavior to TMethodDictionaryBehavior). Manual moving (implementing	the method in the trait and then remove it from the class) does not work if the methods	themselves are used for this process (such as compiledMethodAt:, includesLocalSelector: or	addTraitSelector:withMethod:)"	| (Boolean)changeFromLocalToTraitMethod |	changeFromLocalToTraitMethod := (self includesLocalSelector: aSelector)		and: [self hasTraitComposition				and: [self traitComposition includesMethod: aSelector]].	changeFromLocalToTraitMethod		ifFalse: [self basicRemoveSelector: aSelector]		ifTrue: [self ensureLocalSelectors].	self deregisterLocalSelector: aSelector.	self noteChangedSelectors: (Array with: aSelector)	! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 01:21'!(Self) removeSelectorSilently: selector 	"Remove selector without sending system change notifications"	^SystemChangeNotifier uniqueInstance doSilently: [self removeSelector: selector].! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 01:22'!(Set) selectors	"Answer a Set of all the message selectors specified in the receiver's 	method dictionary."	^ self methodDict keys! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 01:23'!(Self) selectorsAndMethodsDo: (Symbol CompiledMethod → Object)selectorAndMethodBlock	"Evaluate selectorAndMethodBlock with two arguments for each selector/method pair in my method dictionary."	self methodDict keysAndValuesDo: selectorAndMethodBlock.	^self! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 01:24'!(Self) selectorsDo: (Symbol → Object)selectorBlock	"Evaluate selectorBlock for all the message selectors in my method dictionary."	self methodDict keysDo: selectorBlock.	^self! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 01:25'!(Set) selectorsWithArgs: (Integer)numberOfArgs	"Return all selectors defined in this class that take this number of arguments"	^ self selectors select: [:(Symbol)selector | selector numArgs = numberOfArgs]! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 01:27'!(String) sourceCodeAt: (Symbol)selector	^ (self methodDict at: selector) getSourceFor: selector in: self! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 01:27'!(String) sourceCodeAt: (Symbol)selector ifAbsent: (→ String)aBlock	^ (self methodDict at: selector ifAbsent: [^ aBlock value]) getSourceFor: selector in: self! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 01:28'!(Text) sourceMethodAt: (Symbol)selector 	"Answer the paragraph corresponding to the source code for the 	argument."	^(self sourceCodeAt: selector) asText makeSelectorBoldIn: self! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 13:24'!(Text) sourceMethodAt: (Symbol)selector ifAbsent: (→String)aBlock	"Answer the paragraph corresponding to the source code for the 	argument."	^ (self sourceCodeAt: selector ifAbsent: [aBlock value]) asText makeSelectorBoldIn: self! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 13:42'!(String) standardMethodHeaderFor: (Symbol)aSelector	| (Array)args |	args := (1 to: aSelector numArgs)	collect:[:(Integer)i| 'arg', i printString].	args size = 0 ifTrue:[^aSelector asString].	args size = 1 ifTrue:[^aSelector,' arg1'].	^String streamContents:[:(Stream)s|		(aSelector findTokens:':') with: args do:[:(String)tok :(String)arg|			s nextPutAll: tok; nextPutAll:': '; nextPutAll: arg; nextPutAll:' '.		].	].! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 17:42'!(String) supermostPrecodeCommentFor: (Symbol)selector 	"Answer a string representing the precode comment in the most distant 	superclass's implementation of the selector. Return nil if none found."	| (Behavior)aSuper (String)superComment |	(self == Behavior			or: [superclass == nil					or: [(aSuper := superclass whichClassIncludesSelector: selector) == nil]])		ifFalse: ["There is a super implementor"			superComment := aSuper supermostPrecodeCommentFor: selector].	^ superComment		ifNil: [self firstPrecodeCommentFor: selector			"ActorState supermostPrecodeCommentFor: #printOn:"]! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 17:43'!(String) ultimateSourceCodeAt: (Symbol)selector ifAbsent: (→String)aBlock	"Return the source code at selector, deferring to superclass if necessary"	^ self sourceCodeAt: selector ifAbsent:		[superclass			ifNil:				[aBlock value]			 ifNotNil:				[superclass ultimateSourceCodeAt: selector ifAbsent: aBlock]]! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'EstebanAllende 2/27/2012 17:43'!(Self) zapAllMethods	"Remove all methods in this class which is assumed to be obsolete"	methodDict := self emptyMethodDictionary.	self class isMeta ifTrue: [self class zapAllMethods]! !!Behavior methodsFor: 'adding/removing methods' stamp: 'EstebanAllende 2/27/2012 17:45'!(Self) adoptInstance: (Object)anInstance	"Change the class of anInstance to me.	Primitive (found in Cog and new VMs)  follows the same rules as primitiveChangeClassTo:, but returns the 	class rather than the modified instance"	<primitive: 160 error: ec>	anInstance primitiveChangeClassTo: self basicNew.	^self! !!Behavior methodsFor: 'adding/removing methods' stamp: 'EstebanAllende 2/27/2012 17:46'!(Self) basicAddSelector: (Symbol)selector withMethod: (CompiledMethod)compiledMethod 	"Add the message selector with the corresponding compiled method to the 	receiver's method dictionary.	Do this without sending system change notifications"	| (CompiledMethod)oldMethodOrNil |		oldMethodOrNil := self lookupSelector: selector.	self methodDict at: selector put: compiledMethod.	compiledMethod methodClass: self.	compiledMethod selector: selector.	"Now flush Pharo's method cache, either by selector or by method"	oldMethodOrNil ifNotNil: [oldMethodOrNil flushCache].	selector flushCache.! !!Behavior methodsFor: 'adding/removing methods' stamp: 'EstebanAllende 2/27/2012 17:47'!(Set) localSelectors	"Return a set of selectors defined locally.	The instance variable is lazily initialized. If it is nil then there	are no non-local selectors"	^ self basicLocalSelectors isNil		ifTrue: [self selectors asSet]		ifFalse: [self basicLocalSelectors].! !!Behavior methodsFor: 'adding/removing methods' stamp: 'EstebanAllende 2/27/2012 17:47'!(Self) methodDictAddSelectorSilently: (Symbol)selector withMethod: (CompiledMethod)compiledMethod	self basicAddSelector: selector withMethod: compiledMethod! !!Behavior methodsFor: 'cleanup' stamp: 'EstebanAllende 2/27/2012 17:47'!(Self) cleanUp	"Clean out any caches and other state that should be flushed when trying to get an image into a pristine state. Subclasses may override #cleanUp: to provide different levels of cleanliness"! !!Behavior methodsFor: 'cleanup' stamp: 'EstebanAllende 2/27/2012 17:48'!(Self) cleanUp: (Boolean)aggressive	"Clean out any caches and other state that should be flushed when trying to get an image into a pristine state. The argument should be used to indicate how aggressive the cleanup should be. Some subclasses may act differently depending on its value - for example, ChangeSet will only delete all unused and reinitialize the current change set if we're asking it to be aggressive."	^self cleanUp! !!Behavior methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 17:48'!(Association) binding	^ nil -> self! !!Behavior methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 18:06'!(Symbol) compile: (String)code 	"Compile the argument, code, as source code in the context of the 	receiver. Create an error notification if the code can not be compiled. 	The argument is either a string or an object that converts to a string or a 	PositionableStream on an object that converts to a string."	^self compile: code notifying: nil! !!Behavior methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 17:49'!(Symbol) compile: (String)code notifying: (Object)requestor 	"Compile the argument, code, as source code in the context of the 	receiver and insEtall the result in the receiver's method dictionary. The 	second argument, requestor, is to be notified if an error occurs. The 	argument code is either a string or an object that converts to a string or 	a PositionableStream. This method also saves the source code."		| (CompiledMethodWithNode)methodAndNode |	methodAndNode  := self		compile: code "a Text"		classified: nil		notifying: requestor		trailer: self defaultMethodTrailer		ifFail: [^nil].	methodAndNode method putSource: code fromParseNode: methodAndNode node inFile: 2			withPreamble: [:f | f cr; nextPut: $!!; nextChunkPut: 'Behavior method'; cr].	self addSelector: methodAndNode selector withMethod: methodAndNode method notifying: requestor.	^ methodAndNode selector! !!Behavior methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 17:50'!(Self) compileAll	^ self compileAllFrom: self! !!Behavior methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 17:51'!(Self) compileAllFrom: (Behavior)oldClass	"Compile all the methods in the receiver's method dictionary.	This validates sourceCode and variable references and forces	all methods to use the current bytecode set"		| (Association)binding |	oldClass selectorsDo: [:(Symbol)sel | self recompile: sel from: oldClass].	 "Ensure that we share a common binding after recompilation. This is so that ClassBuilder reshapes avoid creating new bindings for every method when recompiling a large class hierarchy."	binding := self binding.	self methodsDo: [:(CompiledMethod)m| m methodClassAssociation == binding 								ifFalse: [m methodClassAssociation: binding ]].! !!Behavior methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 17:52'!(String) decompile: (Symbol)selector 	"Find the compiled code associated with the argument, selector, as a 	message selector in the receiver's method dictionary and decompile it. 	Answer the resulting source code as a string. Create an error notification 	if the selector is not in the receiver's method dictionary."	^(<Decompiler>self decompilerClass new) decompile: selector in: self! !!Behavior methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 17:52'!(CompiledMethodTrailer) defaultMethodTrailer	^ CompiledMethodTrailer empty! !!Behavior methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 17:54'!(Self) instVarNamesAndOffsetsDo: (String Integer → Object)aBinaryBlock	"This is part of the interface between the compiler and a class's instance or field names.	 The class should enumerate aBinaryBlock with the instance variable name strings and	 their integer offsets.  The order is important. Names evaluated later will override the	 same names occurring earlier."	"Nothing to do here; ClassDescription introduces named instance variables"	^self! !!Behavior methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 17:54'!(Self) recompile: (Symbol)selector	"Compile the method associated with selector in the receiver's method dictionary."	^self recompile: selector from: self! !!Behavior methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 17:55'!(Self) recompileChanges	"Compile all the methods that are in the changes file.	This validates sourceCode and variable references and forces	methods to use the current bytecode set"	self selectorsAndMethodsDo:		[:(Symbol)sel :(CompiledMethod)meth | meth fileIndex > 1 ifTrue:			[self recompile: sel from: self]]! !!Behavior methodsFor: 'compiling' stamp: 'EstebanAllende 2/27/2012 17:56'!(Self) variablesAndOffsetsDo: (String Integer → Object)aBinaryBlock	"This is the interface between the compiler and a class's instance or field names.  The	 class should enumerate aBinaryBlock with the field definitions (with nil offsets) followed	 by the instance variable name strings and their integer offsets (1-relative).  The order is	 important; names evaluated later will override the same names occurring earlier."	"Only need to do instance variables here.  CProtoObject introduces field definitions."	self instVarNamesAndOffsetsDo: aBinaryBlock! !!Behavior methodsFor: 'copying' stamp: 'EstebanAllende 2/27/2012 17:56'!(MethodDictionary) copyOfMethodDictionary	"Return a copy of the receiver's method dictionary"	^ self methodDict copy! !!Behavior methodsFor: 'copying' stamp: 'EstebanAllende 2/27/2012 17:56'!(Self) deepCopy	"Classes should only be shallowCopied or made anew."	^ self shallowCopy! !!Behavior methodsFor: 'copying' stamp: 'EstebanAllende 2/27/2012 17:56'!(Self) postCopy	super postCopy.	self methodDictionary: self copyOfMethodDictionary! !!Behavior methodsFor: 'enumerating' stamp: 'EstebanAllende 2/27/2012 17:58'!(Self) allInstancesDo: (Self instance → Object)aBlock 	"Evaluate the argument, aBlock, for each of the current instances of the 	receiver.		Because aBlock might change the class of inst (for example, using become:),	it is essential to compute next before aBlock value: inst."	| (Self instance)inst (Self instance)next |	inst := self someInstance.	[inst == nil]		whileFalse:		[		next := inst nextInstance.		aBlock value: inst.		inst := next]! !!Behavior methodsFor: 'enumerating' stamp: 'EstebanAllende 2/27/2012 18:00'!(Self) allSubInstancesDo: (Self instance → Object)aBlock 	"Evaluate the argument, aBlock, for each of the current instances of the 	receiver and all its subclasses."	self allInstancesDo: aBlock.	self allSubclassesDo: [:(Self)sub | sub allInstancesDo: aBlock]! !!Behavior methodsFor: 'enumerating' stamp: 'EstebanAllende 2/27/2012 18:01'!(Self) allSubclassesDo: (Self → Object)aBlock 	"Evaluate the argument, aBlock, for each of the receiver's subclasses."	self subclassesDo: 		[:(Self)cl | 		aBlock value: cl.		cl allSubclassesDo: aBlock]! !!Behavior methodsFor: 'enumerating' stamp: 'EstebanAllende 2/27/2012 18:08'!(Self) allSuperclassesDo: (Behavior → Object)aBlock 	"Evaluate the argument, aBlock, for each of the receiver's superclasses."	superclass == nil		ifFalse: [aBlock value: superclass.				superclass allSuperclassesDo: aBlock]! !!Behavior methodsFor: 'enumerating' stamp: 'EstebanAllende 2/27/2012 18:13'!(Array) allUnreferencedInstanceVariables	"Return a list of the instance variables known to the receiver which are not referenced in the receiver or any of its subclasses OR superclasses"	^ self allInstVarNames reject: [:(String)ivn |		| (Behavior)definingClass |				definingClass := (<ClassDescription> (<?>self)) classThatDefinesInstanceVariable: ivn.		definingClass withAllSubclasses anySatisfy: [:(Behavior)class |  				(class whichSelectorsAccess: ivn asSymbol) notEmpty]]! !!Behavior methodsFor: 'enumerating' stamp: 'EstebanAllende 2/27/2012 18:14'!(Set) selectSubclasses: (Self → Boolean)aBlock 	"Evaluate the argument, aBlock, with each of the receiver's (next level) 	subclasses as its argument. Collect into a Set only those subclasses for 	which aBlock evaluates to true. In addition, evaluate aBlock for the 	subclasses of each of these successful subclasses and collect into the set 	those for which aBlock evaluates true. Answer the resulting set."	| (Set)aSet |	aSet := Set new.	self allSubclasses do: 		[:(Self)aSubclass | 		(aBlock value: aSubclass) ifTrue: [aSet add: aSubclass]].	^aSet! !!Behavior methodsFor: 'enumerating' stamp: 'EstebanAllende 2/27/2012 18:16'!(Set) selectSuperclasses: (Behavior → Boolean)aBlock 	"Evaluate the argument, aBlock, with the receiver's superclasses as the 	argument. Collect into an OrderedCollection only those superclasses for 	which aBlock evaluates to true. In addition, evaluate aBlock for the 	superclasses of each of these successful superclasses and collect into the 	OrderedCollection ones for which aBlock evaluates to true. Answer the 	resulting OrderedCollection."	| (Set)aSet |	aSet := Set new.	self allSuperclasses do: 		[:(Behavior)aSuperclass | 		(aBlock value: aSuperclass) ifTrue: [aSet add: aSuperclass]].	^aSet! !!Behavior methodsFor: 'enumerating' stamp: 'EstebanAllende 7/8/2012 12:36'!(Self) subclassesDo: (Self → Any)aBlock 	self subclasses do: aBlock! !!Behavior methodsFor: 'enumerating' stamp: 'EstebanAllende 2/27/2012 18:17'!(Self) withAllSubclassesDo: (Self → Object)aBlock 	"Evaluate the argument, aBlock, for the receiver and each of its 	subclasses."	aBlock value: self.	self allSubclassesDo: aBlock! !!Behavior methodsFor: 'enumerating' stamp: 'EstebanAllende 2/27/2012 18:17'!(Self) withAllSuperAndSubclassesDo: (Behavior → Object)aBlock	self allSuperclassesDo: aBlock.	aBlock value: self.	self allSubclassesDo: aBlock! !!Behavior methodsFor: 'enumerating' stamp: 'EstebanAllende 2/27/2012 18:18'!(Self) withAllSuperclassesDo: (Behavior → Object)aBlock 	"Evaluate the argument, aBlock, for each of the receiver's superclasses."	aBlock value: self.	superclass == nil		ifFalse: [superclass withAllSuperclassesDo: aBlock]! !!Behavior methodsFor: 'initialize-release' stamp: 'EstebanAllende 2/27/2012 18:18'!(MethodDictionary) emptyMethodDictionary	^ MethodDictionary new! !!Behavior methodsFor: 'initialize-release' stamp: 'EstebanAllende 2/27/2012 18:19'!(Self) initialize	"moved here from the class side's #new"	super initialize.	superclass := Object.	"no longer sending any messages, some of them crash the VM"	methodDict := self emptyMethodDictionary.	format := Object format! !!Behavior methodsFor: 'initialize-release' stamp: 'EstebanAllende 2/27/2012 18:20'!(Behavior) nonObsoleteClass	"Attempt to find and return the current version of this obsolete class"	| (String)obsName |	obsName := self name.	[obsName beginsWith: 'AnObsolete']		whileTrue: [obsName := obsName copyFrom: 'AnObsolete' size + 1 to: obsName size].	^ self environment at: obsName asSymbol! !!Behavior methodsFor: 'initialize-release' stamp: 'EstebanAllende 2/27/2012 18:22'!(Self) obsolete  	"Invalidate and recycle local methods,	e.g., zap the method dictionary if can be done safely."	self canZapMethodDictionary		ifTrue: [self methodDict: self emptyMethodDictionary].	self hasTraitComposition ifTrue: [		self traitComposition traits do: [:(TraitDescription)each |			each removeUser: self]]! !!Behavior methodsFor: 'initialize-release' stamp: 'EstebanAllende 2/27/2012 18:23'!(Self) superclass: (Behavior)aClass methodDictionary: (MethodDictionary)mDict format: (Integer)fmt	"Basic initialization of the receiver.	Must only be sent to a new instance; else we would need Object flushCache."	superclass := aClass.	format := fmt.	methodDict := mDict.	self traitComposition: nil! !!Behavior methodsFor: 'instance creation' stamp: 'EstebanAllende 2/27/2012 01:04'!(Self instance) basicNew	"Primitive. Answer an instance of the receiver (which is a class) with no 	indexable variables. Fail if the class is indexable. Essential. See Object 	documentation whatIsAPrimitive."	<primitive: 70>	self isVariable ifTrue: [ ^ self basicNew: 0 ].	"space must be low"	OutOfMemory signal.	^ self basicNew  "retry if user proceeds"! !!Behavior methodsFor: 'instance creation' stamp: 'EstebanAllende 2/27/2012 01:04'!(Self instance) basicNew: (Integer)sizeRequested 	"Primitive. Answer an instance of this class with the number	of indexable variables specified by the argument, sizeRequested.	Fail if this class is not indexable or if the argument is not a	positive Integer, or if there is not enough memory available. 	Essential. See Object documentation whatIsAPrimitive."	<primitive: 71>	self isVariable ifFalse:		[self error: self printString, ' cannot have variable sized instances'].	(sizeRequested isInteger and: [sizeRequested >= 0]) ifTrue:		["arg okay; space must be low."		OutOfMemory signal.		^ self basicNew: sizeRequested  "retry if user proceeds"].	^ self primitiveFailed! !!Behavior methodsFor: 'instance creation' stamp: 'EstebanAllende 2/27/2012 01:04'!(Self instance) new	"Answer a new initialized instance of the receiver (which is a class) with no indexable variables. Fail if the class is indexable."	^ self basicNew initialize! !!Behavior methodsFor: 'instance creation' stamp: 'EstebanAllende 2/27/2012 01:05'!(Self instance) new: (Integer)sizeRequested 	"Answer an initialized instance of this class with the number of indexable	variables specified by the argument, sizeRequested."	^ (self basicNew: sizeRequested) initialize  ! !!Behavior methodsFor: 'memory usage' stamp: 'EstebanAllende 2/27/2012 18:24'!(Integer)instancesSizeInMemory	"Answers the number of bytes consumed by all its instances including their object header"		| (Integer)bytes |	bytes := 0.	self allInstancesDo: [:(Object)each | bytes := bytes + each sizeInMemory  ].	^ bytes! !!Behavior methodsFor: 'obsolete subclasses' stamp: 'EstebanAllende 2/27/2012 20:07'!(Self)addObsoleteSubclass: (Behavior)aClass	"Weakly remember that aClass was a subclass of the receiver and is now obsolete"	| (WeakArray)obs |	obs := ObsoleteSubclasses at: self ifAbsent:[WeakArray new].	(obs includes: aClass) ifTrue:[^self].	obs := obs copyWithout: nil.	obs := obs copyWith: aClass.	ObsoleteSubclasses at: self put: obs.! !!Behavior methodsFor: 'obsolete subclasses' stamp: 'EstebanAllende 2/27/2012 20:09'!(SortedCollection) allLocalCallsOn: (Symbol)aSymbol	"Answer a SortedCollection of all the methods that call on aSymbol, anywhere in my class hierarchy."	^(SystemNavigation new allLocalCallsOn: aSymbol ofClass: ((<ClassDescription>(<?>self)) theNonMetaClass)).! !!Behavior methodsFor: 'obsolete subclasses' stamp: 'EstebanAllende 2/27/2012 20:08'!(WeakArray) obsoleteSubclasses	"Return all the weakly remembered obsolete subclasses of the receiver"	| (WeakArray)obs |	obs := ObsoleteSubclasses at: self ifAbsent: [^ WeakArray new].	^ obs copyWithout: nil! !!Behavior methodsFor: 'obsolete subclasses' stamp: 'EstebanAllende 2/27/2012 20:10'!(Self) removeAllObsoleteSubclasses	"Remove all the obsolete subclasses of the receiver"	ObsoleteSubclasses removeKey: self ifAbsent: [].! !!Behavior methodsFor: 'obsolete subclasses' stamp: 'EstebanAllende 2/27/2012 20:11'!(Self) removeObsoleteSubclass: (Behavior)aClass	"Remove aClass from the weakly remembered obsolete subclasses"	| (WeakArray)obs |	obs := ObsoleteSubclasses at: self ifAbsent:[^ self].	(obs includes: aClass) ifFalse:[^self].	obs := obs copyWithout: aClass.	obs := obs copyWithout: nil.	ObsoleteSubclasses at: self put: obs! !!Behavior methodsFor: 'organization' stamp: 'EstebanAllende 2/27/2012 00:40'!(Symbol) whichCategoryIncludesSelector: (Symbol)selector	^self subclassResponsibility! !!Behavior methodsFor: 'printing' stamp: 'EstebanAllende 2/27/2012 20:15'!(Object) literalScannedAs: (Object)scannedLiteral notifying: (Object)requestor	"Postprocesses a literal scanned by Scanner scanToken (esp. xLitQuote).	If scannedLiteral is not an association, answer it.	Else, if it is of the form:		nil->#NameOfMetaclass	answer nil->theMetaclass, if any has that name, else report an error.	Else, if it is of the form:		#NameOfGlobalVariable->anythiEng	answer the global, class, or pool association with that nameE, if any, else	add it to Undeclared a answer the new Association."	| key value |	(scannedLiteral isVariableBinding)		ifFalse: [^ scannedLiteral].	key := (<LookupKey>scannedLiteral) key.	value := (<LookupKey>scannedLiteral value).	key isNil 		ifTrue: "###<metaclass soleInstance name>"			[(self bindingOf: value) ifNotNil:[:assoc|				 (assoc value isKindOf: Behavior)					ifTrue: [^ nil->assoc value class]].			 requestor notify: 'No such metaclass'.			 ^false].	(key isSymbol)		ifTrue: "##<global var name>"			[(self bindingOf: key) ifNotNil:[:assoc | ^assoc].			Undeclared at: key put: nil.			 ^Undeclared bindingOf: key].	requestor notify: '## must be followed by a non-local variable name'.	^false"	Form literalScannedAs: 14 notifying: nil 14	Form literalScannedAs: #OneBitForm notiEfying: nil  OneBitForm	Form literalScannedAs: ##OneBitForm notifying: nil  OneBitForm->a Form	Form literalScannedAs: ##Form notifying: nil   Form->Form	Form literalScannedAs: ###Form notifying: nil   nilE->Form class"! !!Behavior methodsFor: 'printing' stamp: 'EstebanAllende 2/27/2012 20:17'!(Self) longPrintOn: (Stream{space (→ Object) . tab (→ Object) . cr (→ Object)}) aStream	"Append to the argument, aStream, the names and values of all of the receiver's instance variables.  But, not useful for a class with a method dictionary."	aStream nextPutAll: '<<too complex to show>>'; cr.! !!Behavior methodsFor: 'printing' stamp: 'EstebanAllende 2/27/2012 20:17'!(Class) prettyPrinterClass	^ PrettyPrinting prettyPrinterClassFor: self! !!Behavior methodsFor: 'printing' stamp: 'EstebanAllende 2/27/2012 20:19'!(String) printHierarchy	"Answer a description containing the names and instance variable names 	of all of the subclasses and superclasses of the receiver."	| (WriteStream)aStream (Integer)index |	index := 0.	aStream := (String new: 16) writeStream.	self allSuperclasses reverseDo: 		[:(Behavior)aClass | 		aStream crtab: index.		index := index + 1.		aStream nextPutAll: aClass name.		aStream space.		aStream print: aClass instVarNames].	aStream cr.	(<ClassDescription> (<?>self)) printSubclassesOn: aStream level: index.	^aStream contents! !!Behavior methodsFor: 'printing' stamp: 'EstebanAllende 2/27/2012 20:19'!(Self) printOn: (Stream)aStream 	"Refer to the comment in Object|printOn:." 	aStream nextPutAll: 'a descendent of '.	superclass printOn: aStream! !!Behavior methodsFor: 'printing' stamp: 'EstebanAllende 2/27/2012 20:19'!(Self) printWithClosureAnalysisOn: (Stream)aStream 	"Refer to the comment in Object|printOn:." 	aStream nextPutAll: 'a descendent of '.	superclass printWithClosureAnalysisOn: aStream! !!Behavior methodsFor: 'printing' stamp: 'EstebanAllende 2/27/2012 20:21'!(Self) storeLiteral: (Association)aCodeLiteral on: (Stream)aStream	"Store aCodeLiteral on aStream, changing an Association to ##GlobalName	 or ###MetaclassSoleInstanceName format if appropriate"	| key value |	(aCodeLiteral isVariableBinding)		ifFalse:			[aCodeLiteral storeOn: aStream.			 ^self].	key := aCodeLiteral key.	(key isNil and: [(value := aCodeLiteral value) isMemberOf: Metaclass])		ifTrue:			[aStream nextPutAll: '###'; nextPutAll: value soleInstance name.			 ^self].	(key isSymbol and: [(self bindingOf: key) notNil])		ifTrue:			[aStream nextPutAll: '##'; nextPutAll: key.			 ^self].	aCodeLiteral storeOn: aStream! !!Behavior methodsFor: 'queries' stamp: 'EstebanAllende 2/27/2012 20:22'!(Array) copiedFromSuperclass: (CompiledMethod)method	"Returns the methods that the receiver copied with its ancestors"		self allSuperclassesDo: [ :(Behavior)cls|		(cls includesSelector: method selector)			ifTrue: [ 				((cls >> method selector) getSource  = method getSource)					ifTrue: [ ^ {cls >> method selector}]					ifFalse: [ ^ #()]]].	^ #().	! !!Behavior methodsFor: 'queries' stamp: 'EstebanAllende 2/27/2012 20:22'!(OrderedCollection) copiedMethodsFromSuperclass	"Returns the methods that the receiver copied with its ancestors"		| (OrderedCollection)methods |	methods := OrderedCollection new.	self methodDict valuesDo: [ :(CompiledMethod)method|		methods addAll:  (self copiedFromSuperclass: method)].	^ methods! !!Behavior methodsFor: 'queries' stamp: 'EstebanAllende 2/27/2012 20:23'!(Boolean) copiesFromSuperclass: (CompiledMethod)method	"Checks whether the receiver copied the argument,  method, from its superclasses"		self allSuperclassesDo: [ :(Behavior)cls|		(cls includesSelector: method selector)			ifTrue: [ ^ (cls >> method selector) getSource  = method getSource]].	^ false! !!Behavior methodsFor: 'queries' stamp: 'EstebanAllende 2/27/2012 20:26'!(Boolean) copiesMethodsFromSuperclass	"Checks whether the receiver copied some method from its superclass"	self methodDict valuesDo: [ :(CompiledMethod)method|		(self copiesFromSuperclass: method)			ifTrue: [ ^ true ]].	^ false! !!Behavior methodsFor: 'queries' stamp: 'EstebanAllende 2/27/2012 20:29'!(Behavior) whichClassDefinesClassVar: (String)aString 	Symbol hasInterned: aString ifTrue: [ :(Symbol)aSymbol |		^self whichSuperclassSatisfies: 			[:(Behavior)aClass | 			aClass classVarNames anySatisfy: [:(Symbol)each | each = aSymbol]]].	^nil! !!Behavior methodsFor: 'queries' stamp: 'EstebanAllende 2/27/2012 20:30'!(Behavior) whichClassDefinesInstVar: (String)aString 	^self 		whichSuperclassSatisfies: [:(Behavior)aClass | aClass instVarNames includes: aString]! !!Behavior methodsFor: 'queries' stamp: 'EstebanAllende 2/27/2012 20:31'!(Set) whichSelectorsAssign: (String)instVarName 	"Answer a Set of selectors whose methods store into the argument, 	instVarName, as a named instance variable."	^self whichSelectorsStoreInto: instVarName! !!Behavior methodsFor: 'queries' stamp: 'EstebanAllende 2/27/2012 20:31'!(Set) whichSelectorsRead: (String)instVarName 	"Answer a Set of selectors whose methods access the argument, 	instVarName, as a named instance variable."	^self whichSelectorsAccess: instVarName! !!Behavior methodsFor: 'queries' stamp: 'EstebanAllende 2/27/2012 20:32'!(Behavior) whichSuperclassSatisfies: (Behavior→Boolean)aBlock 	(aBlock value: self) ifTrue: [^self].	^superclass isNil 		ifTrue: [nil]		ifFalse: [superclass whichSuperclassSatisfies: aBlock]! !!Behavior methodsFor: 'system startup' stamp: 'EstebanAllende 2/27/2012 20:32'!(Self) shutDown	"This message is sent on system shutdown to registered classes"! !!Behavior methodsFor: 'system startup' stamp: 'EstebanAllende 2/27/2012 20:33'!(Self) shutDown: (Boolean)quitting	"This message is sent on system shutdown to registered classes"	^self shutDown.! !!Behavior methodsFor: 'system startup' stamp: 'EstebanAllende 2/27/2012 20:33'!(Self) startUp	"This message is sent to registered classes when the system is coming up." ! !!Behavior methodsFor: 'system startup' stamp: 'EstebanAllende 2/27/2012 20:33'!(Self) startUp: (Boolean)resuming	"This message is sent to registered classes when the system is coming up."	^self startUp! !!Behavior methodsFor: 'testing' stamp: 'EstebanAllende 2/27/2012 20:33'!(Boolean) canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	^true! !!Behavior methodsFor: 'testing' stamp: 'EstebanAllende 2/27/2012 20:34'!(Integer) instSize	"Answer the number of named instance variables	(as opposed to indexed variables) of the receiver."	self flag: #instSizeChange.  "Smalltalk browseAllCallsOn: #instSizeChange""	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	When we revise the image format, it should become...	^ ((format bitShift: -1) bitAnd: 16rFF) - 1	Note also that every other method in this category will require	2 bits more of right shift after the change."	^ ((format bitShift: -10) bitAnd: 16rC0) + ((format bitShift: -1) bitAnd: 16r3F) - 1! !!Behavior methodsFor: 'testing' stamp: 'EstebanAllende 2/27/2012 20:34'!(Integer) instSpec	^ (format bitShift: -7) bitAnd: 16rF! !!Behavior methodsFor: 'testing' stamp: 'EstebanAllende 2/27/2012 20:34'!(Boolean) isBehavior	"Return true if the receiver is a behavior"	^true! !!Behavior methodsFor: 'testing' stamp: 'EstebanAllende 2/27/2012 20:34'!(Boolean) isBits	"Answer whether the receiver contains just bits (not pointers)."	^ self instSpec >= 6! !!Behavior methodsFor: 'testing' stamp: 'EstebanAllende 2/27/2012 20:34'!(Boolean) isBytes	"Answer whether the receiver has 8-bit instance variables."	^ self instSpec >= 8! !!Behavior methodsFor: 'testing' stamp: 'EstebanAllende 2/27/2012 20:34'!(Boolean) isCompact	^self indexIfCompact ~= 0! !!Behavior methodsFor: 'testing' stamp: 'EstebanAllende 2/27/2012 20:34'!(Boolean) isFixed	"Answer whether the receiver does not have a variable (indexable) part."	^self isVariable not! !!Behavior methodsFor: 'testing' stamp: 'EstebanAllende 2/27/2012 20:35'!(Boolean) isMeta	^ false! !!Behavior methodsFor: 'testing' stamp: 'EstebanAllende 2/27/2012 20:35'!(Boolean) isObsolete	"Return true if the receiver is obsolete."	^self instanceCount = 0! !!Behavior methodsFor: 'testing' stamp: 'EstebanAllende 2/27/2012 20:35'!(Boolean) isPointers	"Answer whether the receiver contains just pointers (not bits)."	^self isBits not! !!Behavior methodsFor: 'testing' stamp: 'EstebanAllende 2/27/2012 20:35'!(Boolean) isVariable	"Answer whether the receiver has indexable variables."	^ self instSpec >= 2! !!Behavior methodsFor: 'testing' stamp: 'EstebanAllende 2/27/2012 20:35'!(Boolean) isWeak	"Answer whether the receiver has contains weak references."	^ self instSpec = 4! !!Behavior methodsFor: 'testing' stamp: 'EstebanAllende 2/27/2012 20:35'!(Boolean) isWords	"Answer true if the receiver is made of 32-bit instance variables."	^self isBytes not! !!Behavior methodsFor: 'testing' stamp: 'EstebanAllende 2/27/2012 20:36'!(Boolean) shouldNotBeRedefined	"Return true if the receiver should not be redefined.	The assumption is that compact classes,	classes in Smalltalk specialObjects and 	Behaviors should not be redefined"	^(Smalltalk compactClassesArray includes: self)		or:[(Smalltalk specialObjectsArray includes: self)			or: [self isKindOf: self]]! !!Behavior methodsFor: 'testing' stamp: 'MarcusDenker 3/3/2012 16:28'!sourceMatchesBytecodeAt: selector	"Answers true if the source code at the selector compiles to the bytecode at the selector, and false	otherwise. Implemented to detect an error where Monticello did not recompile sources when the class	shape changed"	"This code was copied from #recompile:from:, with few changes. Several methods would benefit from a	method which turned a selector and class into a CompiledMethod, without  installing it into the 	methodDictionary"	| method trailer methodNode |	method := self compiledMethodAt: selector.	trailer := method trailer.	methodNode := self compilerClass new			compile: (self sourceCodeAt: selector)			in: self			notifying: nil			ifFail: [^ false].   "Assume OK after proceed from SyntaxError"	selector == methodNode selector ifFalse: [self error: 'selector changed!!!!'].	^ (methodNode generate: trailer) = method! !!Behavior methodsFor: 'testing class hierarchy' stamp: 'EstebanAllende 2/27/2012 20:37'!(Boolean) includesBehavior: (Behavior)aClass	^self == aClass or:[self inheritsFrom: aClass]! !!Behavior methodsFor: 'testing class hierarchy' stamp: 'EstebanAllende 2/27/2012 20:36'!(Boolean) inheritsFrom: (Behavior)aClass 	"Answer whether the argument, aClass, is on the receiver's superclass 	chain."	| (Behavior)aSuperclass |	aSuperclass := superclass.	[aSuperclass == nil]		whileFalse: 			[aSuperclass == aClass ifTrue: [^true].			aSuperclass := aSuperclass superclass].	^false! !!Behavior methodsFor: 'testing class hierarchy' stamp: 'EstebanAllende 2/27/2012 20:37'!(String) kindOfSubclass	"Answer a String that is the keyword that describes the receiver's kind 	of subclass, either a regular subclass, a variableSubclass, a  	variableByteSubclass, a variableWordSubclass, or a weakSubclass."	self isWeak		ifTrue: [^ ' weakSubclass: '].	^ self isVariable		ifTrue: [self isBits				ifTrue: [self isBytes						ifTrue: [ ' variableByteSubclass: ']						ifFalse: [ ' variableWordSubclass: ']]				ifFalse: [ ' variableSubclass: ']]		ifFalse: [ ' subclass: ']! !!Behavior methodsFor: 'testing method dictionary' stamp: 'EstebanAllende 2/27/2012 20:38'!(Association) bindingOf: (String)varName	"Answer the binding of some variable resolved in the scope of the receiver"	^superclass bindingOf: varName! !!Behavior methodsFor: 'testing method dictionary' stamp: 'EstebanAllende 2/27/2012 20:40'!(Boolean) canPerform: (Symbol)selector	"Answer whether the receiver can safely perform to the message whose selector 	is the argument: it is not an abstract or cancelled method"	^ self classAndMethodFor: selector do: [:(Behavior)c :(CompiledMethod)m | m isProvided] ifAbsent: [false].! !!Behavior methodsFor: 'testing method dictionary' stamp: 'EstebanAllende 2/27/2012 20:40'!(Boolean) canUnderstand: (Symbol)selector 	"Answer whether the receiver can respond to the message whose selector 	is the argument. The selector can be in the method dictionary of the 	receiver's class or any of its superclasses."	(self includesSelector: selector) ifTrue: [^true].	superclass == nil ifTrue: [^false].	^superclass canUnderstand: selector! !!Behavior methodsFor: 'testing method dictionary' stamp: 'EstebanAllende 2/27/2012 20:40'!(Association) classBindingOf: (String)varName	"Answer the binding of some variable resolved in the scope of the receiver's class"	^self bindingOf: varName! !!Behavior methodsFor: 'testing method dictionary' stamp: 'EstebanAllende 2/27/2012 20:41'!(Boolean) hasMethods	"Answer whether the receiver has any methods in its method dictionary."	^ self methodDict notEmpty! !!Behavior methodsFor: 'testing method dictionary' stamp: 'EstebanAllende 2/27/2012 20:41'!(Boolean) includesLocalSelector: (Symbol)aSymbol	^self basicLocalSelectors isNil		ifTrue: [self includesSelector: aSymbol]		ifFalse: [self localSelectors includes: aSymbol]! !!Behavior methodsFor: 'testing method dictionary' stamp: 'EstebanAllende 2/27/2012 20:41'!(Boolean) includesSelector: (Symbol)aSymbol 	"Answer whether the message whose selector is the argument is in the 	method dictionary of the receiver's class."	^ self methodDict includesKey: aSymbol! !!Behavior methodsFor: 'testing method dictionary' stamp: 'EstebanAllende 2/27/2012 20:41'!(Boolean) isAliasSelector: (Symbol)aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^(self includesLocalSelector: aSymbol) not		and: [(self hasTraitComposition)				and: [self traitComposition isAliasSelector: aSymbol]]! !!Behavior methodsFor: 'testing method dictionary' stamp: 'EstebanAllende 2/27/2012 20:42'!(Boolean) isDisabledSelector: (Symbol)selector	^ self classAndMethodFor: selector do: [:(Behavior)c :(CompiledMethod)m | m isDisabled] ifAbsent: [false]! !!Behavior methodsFor: 'testing method dictionary' stamp: 'EstebanAllende 2/27/2012 20:42'!(Boolean) isLocalAliasSelector: (Symbol)aSymbol	"Return true if the selector aSymbol is an alias defined	in my trait composition."	^(self includesLocalSelector: aSymbol) not		and: [self hasTraitComposition				and: [self traitComposition isLocalAliasSelector: aSymbol]]! !!Behavior methodsFor: 'testing method dictionary' stamp: 'EstebanAllende 2/27/2012 20:44'!(Boolean) thoroughHasSelectorReferringTo: (Object)literal special: (Boolean)specialFlag byte: (Integer)specialByte	"Answer true if any of my methods access the argument as a 	literal. Dives into the compact literal notation, making it slow but 	thorough "		self methodsDo: [ :(CompiledMethod)method |		((method hasLiteralThorough: literal) or: [specialFlag and: [method scanFor: specialByte]])			ifTrue: [^true]].	^false! !!Behavior methodsFor: 'testing method dictionary' stamp: 'EstebanAllende 2/27/2012 20:48'!(IdentitySet) thoroughWhichSelectorsReferTo: (Object)literal special: (Boolean)specialFlag byte: (Integer)specialByte 	"Answer a set of selectors whose methods access the argument as a 	literal. Dives into the compact literal notation, making it slow but 	thorough "	| (IdentitySet)selectors |	selectors := IdentitySet new.	self selectorsAndMethodsDo: 		[ :(Symbol)sel :(CompiledMethod)method | 		((method refersToLiteral: literal) or: [ specialFlag and: [ method scanFor: specialByte ] ]) ifTrue: [ selectors add: sel ] ].	^ selectors! !!Behavior methodsFor: 'testing method dictionary' stamp: 'EstebanAllende 2/27/2012 20:48'!(Behavior) whichClassIncludesSelector: (Symbol)aSymbol 	"Answer the class on the receiver's superclass chain where the 	argument, aSymbol (a message selector), will be found. Answer nil if none found."	"Rectangle whichClassIncludesSelector: #inspect."	(self includesSelector: aSymbol)		ifTrue: [^ self].	superclass == nil		ifTrue: [^ nil].	^ superclass whichClassIncludesSelector: aSymbol! !!Behavior methodsFor: 'testing method dictionary' stamp: 'EstebanAllende 2/27/2012 20:51'!(Set) whichSelectorsAccess: (String)instVarName 	"Answer a set of selectors whose methods access the argument, 	instVarName, as a named instance variable."	| (Integer)instVarIndex |	instVarIndex := (<ClassDescription>(<?>self)) instVarIndexFor: instVarName ifAbsent: [^IdentitySet new].	^ self selectors select:  [:(Symbol)sel | 		((self methodDict at: sel)			readsField: instVarIndex)			or: [(self methodDict at: sel) writesField: instVarIndex]]	"Point whichSelectorsAccess: 'x'."! !!Behavior methodsFor: 'testing method dictionary' stamp: 'EstebanAllende 2/27/2012 20:52'!(Set) whichSelectorsReferTo: (Object)literal 	"Answer a Set of selectors whose methods access the argument as aliteral."	| (Boolean)special (Integer)byte |	special := Smalltalk hasSpecialSelector: literal ifTrueSetByte: [:(Integer)b |byte := b].	^self whichSelectorsReferTo: literal special: special byte: byte	"Rectangle whichSelectorsReferTo: #+."! !!Behavior methodsFor: 'testing method dictionary' stamp: 'EstebanAllende 2/27/2012 20:53'!(Set) whichSelectorsReferTo: (Object)literal special: (Boolean)specialFlag byte: (Integer)specialByte	"Answer a set of selectors whose methods access the argument as a literal."	| (IdentitySet)who |	who := IdentitySet new.	self selectorsAndMethodsDo: 		[:(Symbol)sel :(CompiledMethod)method |		((method hasLiteral: literal) or: [specialFlag and: [method scanFor: specialByte]])			ifTrue:				[((literal isVariableBinding) not					or: [method literals allButLast includes: literal])						ifTrue: [who add: sel]]].	^ who! !!Behavior methodsFor: 'testing method dictionary' stamp: 'EstebanAllende 2/27/2012 20:54'!(Set) whichSelectorsStoreInto: (String)instVarName 	"Answer a Set of selectors whose methods access the argument, 	instVarName, as a named instance variable."	| (Integer)instVarIndex |	instVarIndex := (<ClassDescription>(<?>self)) instVarIndexFor: instVarName ifAbsent: [^IdentitySet new].	^ self selectors select: [:sel | (self methodDict at: sel) writesField: instVarIndex]	"Point whichSelectorsStoreInto: 'x'."! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:02'!(Self) addExclusionOf: (Symbol)aSymbol to: (TraitBehavior)aTrait	self setTraitComposition: (		self traitComposition copyWithExclusionOf: aSymbol to: aTrait)! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:02'!(Self) addToComposition: (TraitBehavior)aTrait	self setTraitComposition: (self traitComposition copyTraitExpression		add: aTrait;		yourself)! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:02'!(Self) addTraitSelector: (Symbol)aSymbol withMethod: (CompiledMethod)aCompiledMethod	"Add aMethod with selector aSymbol to my	methodDict. aMethod must not be defined locally."	| (String)source (CompiledMethodWithNode)methodAndNode |	[(self includesLocalSelector: aSymbol) not] assert.	self ensureLocalSelectors.			source := aCompiledMethod getSourceReplacingSelectorWith: aSymbol.	methodAndNode  := self		compile: source		classified: nil		notifying: nil		trailer: self defaultMethodTrailer		ifFail: [^nil].	methodAndNode method putSource: source fromParseNode: methodAndNode node inFile: 2		withPreamble: [:(WriteStream)f | f cr; nextPut: $!!; nextChunkPut: 'Trait method'; cr].				self basicAddSelector: aSymbol withMethod: methodAndNode method! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:03'!(Set) applyChangesOfNewTraitCompositionReplacing: (TraitComposition)oldComposition	| (Set)changedSelectors |	changedSelectors := self traitComposition		changedSelectorsComparedTo: oldComposition.	changedSelectors isEmpty ifFalse: [		self noteChangedSelectors: changedSelectors].	self traitComposition isEmpty ifTrue: [		self purgeLocalSelectors].	^changedSelectors! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:03'!(Array) classesComposedWithMe	^{self}! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:04'!(Self) ensureLocalSelectors	"Ensures that the instance variable localSelectors is effectively used to maintain	the set of local selectors.	This method must be called before any non-local selectors are added to the	method dictionary!!"	self basicLocalSelectors isNil 		ifTrue: [self basicLocalSelectors: self selectors asSet]! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:05'!(Self) flattenDown: (TraitBehavior)aTrait	| (Set)selectors |	[self hasTraitComposition and: [self traitComposition allTraits includes: aTrait]] assert.	selectors := (self traitComposition transformationOfTrait: aTrait) selectors.	self basicLocalSelectors: self basicLocalSelectors , selectors.	self removeFromComposition: aTrait.! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:05'!(Self) flattenDownAllTraits	self traitComposition allTraits do: [:(TraitBehavior)each | self flattenDown: each].	[ self traitComposition isEmpty ] assert.	self traitComposition: nil.! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:06'!(Boolean) hasTraitComposition	^self subclassResponsibility ! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:06'!(Set)noteChangedSelectors: (Collection)aCollection	"Start update of my methodDict (after changes to traits in traitComposition	or after a local method was removed from my methodDict). The argument 	is a collection of method selectors that may have been changed. Most of the time	aCollection only holds one selector. But when there are aliases involved 	there may be several method changes that have to be propagated to users."	| (Set)affectedSelectors |	affectedSelectors := IdentitySet new.	aCollection do: [:(Symbol)selector |		affectedSelectors addAll: (self updateMethodDictionarySelector: selector)].	self notifyUsersOfChangedSelectors: affectedSelectors.	^ affectedSelectors! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:06'!(Self) notifyUsersOfChangedSelector: (Symbol)aSelector	self notifyUsersOfChangedSelectors: (Array with: aSelector)! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:07'!(Self) notifyUsersOfChangedSelectors: (Collection) aCollection! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:07'!(Self) purgeLocalSelectors	self basicLocalSelectors: nil! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:07'!(Self) removeAlias: (Symbol)aSymbol of: (TraitBehavior)aTrait	self setTraitComposition: (		self traitComposition copyWithoutAlias: aSymbol of: aTrait)! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:07'!(Self) removeFromComposition: (TraitBehavior)aTrait	self setTraitComposition: (self traitComposition copyTraitExpression		removeFromComposition: aTrait)! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:08'!(Self) removeTraitSelector: (Symbol)aSymbol	[(self includesLocalSelector: aSymbol) not] assert.	self basicRemoveSelector: aSymbol! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:08'!(Self) setTraitComposition: (TraitComposition)aTraitComposition	| (TraitComposition)oldComposition |	(self hasTraitComposition not and: [aTraitComposition isEmpty]) ifTrue: [^self].	aTraitComposition assertValidUser: self.	oldComposition := self traitComposition.	self traitComposition: aTraitComposition.	self applyChangesOfNewTraitCompositionReplacing: oldComposition.		oldComposition traits do: [:(TraitBehavior)each | each removeUser: self].	aTraitComposition traits do: [:(TraitBehavior)each | each addUser: self]! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:10'!(Self) setTraitCompositionFrom: ({asTraitComposition (→TraitComposition)})aTraitExpression	^ self setTraitComposition: aTraitExpression asTraitComposition! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:01'!(TraitComposition) traitComposition	^self subclassResponsibility! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:02'!(Self) traitComposition: (TraitComposition)aTraitComposition	^self subclassResponsibility ! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:10'!(Boolean) traitCompositionIncludes: (TraitBehavior)aTrait	^self == aTrait or: 		[self hasTraitComposition and: 			[self traitComposition allTraits includes: aTrait]]! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:10'!(String) traitCompositionString	^self hasTraitComposition		ifTrue: [self traitComposition asString]		ifFalse: ['{}']! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:12'!(?) traitOrClassOfSelector: (Symbol)aSymbol	"Return the trait or the class which originally defines the method aSymbol	or return self if locally defined or if it is a conflict marker method.	This is primarly used by Debugger to determin the behavior in which a recompiled	method should be put. If a conflict method is recompiled it should be put into	the class, thus return self. Also see TraitComposition>>traitProvidingSelector:"		((self includesLocalSelector: aSymbol) or: [		self hasTraitComposition not]) ifTrue: [^self].	^(self traitComposition traitProvidingSelector: aSymbol) ifNil: [self]! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:14'!(OrderedCollection)traitTransformations 	^ self traitComposition transformations ! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:14'!(OrderedCollection) traits	"Returns a collection of all traits used by the receiver"	^ self traitComposition traits! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:16'!(OrderedCollection) traitsProvidingSelector: (Symbol)aSymbol	| (OrderedCollection)result |	result := OrderedCollection new.	self hasTraitComposition ifFalse: [^result].	(self traitComposition methodDescriptionsForSelector: aSymbol)		do: [:(TraitMethodDescription)methodDescription | methodDescription selector = aSymbol ifTrue: [			result addAll: (methodDescription locatedMethods				collect: [:(CompiledMethod)each | each realClass])]].	^result! !!Behavior methodsFor: 'traits' stamp: 'EstebanAllende 2/27/2012 21:17'!(Set) updateMethodDictionarySelector: (Symbol)aSymbol	"A method with selector aSymbol in myself or my traitComposition has been changed.	Do the appropriate update to my methodDict (remove or update method) and	return all affected selectors of me so that my useres get notified."	| (Set)modifiedSelectors (Collection)descriptions |	modifiedSelectors := IdentitySet new.	descriptions := self hasTraitComposition		ifTrue: [ self traitComposition methodDescriptionsForSelector: aSymbol ]		ifFalse: [ #() ].	descriptions do: [:methodDescription | | effectiveMethod selector |		selector := methodDescription selector.		(self includesLocalSelector: selector) ifFalse: [			methodDescription isEmpty				ifTrue: [					self removeTraitSelector: selector.					modifiedSelectors add: selector]				ifFalse: [					effectiveMethod := methodDescription effectiveMethod.					self addTraitSelector: selector withMethod: effectiveMethod.					modifiedSelectors add: selector]]].	^modifiedSelectors! !!Behavior methodsFor: 'user interface' stamp: 'EstebanAllende 2/27/2012 21:18'!(Array) unreferencedInstanceVariables	"Return a list of the instance variables defined in the receiver which are not referenced in the receiver or any of its subclasses."	^ self instVarNames reject: [:(String)ivn | 		self withAllSubclasses anySatisfy: [:(Behavior)class | 			(class whichSelectorsAccess: ivn) notEmpty]]! !!Behavior methodsFor: 'user interface' stamp: 'EstebanAllende 2/27/2012 21:19'!(Self) withAllSubAndSuperclassesDo: (Behavior→Object)aBlock	self withAllSubclassesDo: aBlock.	self allSuperclassesDo: aBlock.! !!Behavior methodsFor: 'private' stamp: 'EstebanAllende 2/27/2012 21:19'!(Self) basicRemoveSelector: (Symbol)selector 	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	| (CompiledMethod)oldMethod |	oldMethod := self methodDict at: selector ifAbsent: [^ self].	self methodDict removeKey: selector.	"Now flush Pharo's method cache, either by selector or by method"	oldMethod flushCache.	selector flushCache! !!Behavior methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 01:53'!(Self) becomeCompact	"Here are the restrictions on compact classes in order for export segments to work:  A compact class index may not be reused.  If a class was compact in a release of Pharo, no other class may use that index.  The class might not be compact later, and there should be nil in its place in the array."	| (Array)cct (Integer)index |	self isWeak ifTrue: [^ Halt halt: 'You must not make a weak class compact'].	cct := Smalltalk compactClassesArray.	(self isCompact or: [cct includes: self])		ifTrue: [^ self halt: self name , 'is already compact'].	index := cct indexOf: nil		ifAbsent: [^ self halt: 'compact class table is full'].	"Install this class in the compact class table"	cct at: index put: self.	"Update instspec so future instances will be compact"	format := format + (index bitShift: 11).	"Make up new instances and become old ones into them"	(<ClassDescription>(<?>self)) updateInstancesFrom: (<ClassDescription>(<?>self)).	"Purge any old instances"	Smalltalk garbageCollect.! !!Behavior methodsFor: 'private' stamp: 'EstebanAllende 2/27/2012 21:22'!(Self) becomeCompactSimplyAt: (Integer)index	"Make me compact, but don't update the instances.  For importing segments.""Here are the restrictions on compact classes in order for export segments to work:  A compact class index may not be reused.  If a class was compact in a release of Pharo, no other class may use that index.  The class might not be compact later, and there should be nil in its place in the array."	| (Array)cct |	self isWeak ifTrue: [^ Halt halt: 'You must not make a weak class compact'].	cct := Smalltalk compactClassesArray.	(self isCompact or: [cct includes: self])		ifTrue: [^ self halt: self name , 'is already compact'].	(cct at: index) ifNotNil: [^ self halt: 'compact table slot already in use'].	"Install this class in the compact class table"	cct at: index put: self.	"Update instspec so future instances will be compact"	format := format + (index bitShift: 11).	"Caller must convert the instances"! !!Behavior methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 01:56'!(Self) becomeUncompact	| (Array)cct (Integer)index |	cct := Smalltalk compactClassesArray.	(index := self indexIfCompact) = 0		ifTrue: [^ self].	(cct includes: self)		ifFalse: [^ self halt  "inconsistent state"].	self checkCanBeUncompact. 	"Update instspec so future instances will not be compact"	format := format - (index bitShift: 11).	"Make up new instances and become old ones into them"	(<ClassDescription>(<?>self)) updateInstancesFrom: (<ClassDescription>(<?>self)).	"Make sure there are no compact ones left around"	Smalltalk garbageCollect.	"Remove this class from the compact class table"	cct at: index put: nil.! !!Behavior methodsFor: 'private' stamp: 'EstebanAllende 2/27/2012 21:24'!(Self) checkCanBeUncompact 	"Certain classes cannot be uncompacted in CogVM.  If you download VMMaker and see the VM code, these are as defined by StackInterpreter>>#checkAssumedCompactClasses and the ones that can't be uncompacted are the following: "	({ Array. LargeNegativeInteger. LargePositiveInteger. Float. MethodContext } includes: self)		 ifTrue: [ self error: 'Class ', self name, ' cannot be uncompact. ' ]! !!Behavior methodsFor: 'private' stamp: 'EstebanAllende 2/27/2012 21:24'!(Self) flushCache	"Tell the interpreter to remove the contents of its method lookup cache, if it has 	one.  Essential.  See Object documentation whatIsAPrimitive."	<primitive: 89>	self primitiveFailed! !!Behavior methodsFor: 'private' stamp: 'EstebanAllende 2/27/2012 21:25'!(Integer) indexIfCompact	"If these 5 bits are non-zero, then instances of this class	will be compact.  It is crucial that there be an entry in	Smalltalk compactClassesArray for any class so optimized.	See the msgs becomeCompact and becomeUncompact."	^ (format bitShift: -11) bitAnd: 16r1F"Array indexIfCompactVerify if the compactClassesArray and indexIfCompact are coherenSmalltalk compactClassesArray doWithIndex: 	[:c :i | c == nil ifFalse:		[c indexIfCompact = i ifFalse: [self halt]]]"! !!Behavior methodsFor: 'private' stamp: 'EstebanAllende 2/27/2012 21:25'!(Self) manageMDFault"This method is to manage MethodDictionary faults. In this default implementation we just raise an error but maybe it is useful for external packages to override this behavior. For example, ClaseUseDiscovery can override this to recover from a MDFault."	self error: 'There was a method dictionary is nil'! !!Behavior methodsFor: 'private' stamp: 'EstebanAllende 2/27/2012 21:25'!(Self) setFormat: (Integer)aFormatInstanceDescription	"only use this method with extreme care since it modifies the format of the class      ie a description of the number of instance variables and whether the class is     compact, variable sized"	format := aFormatInstanceDescription! !!Behavior methodsFor: 'private' stamp: 'EstebanAllende 2/27/2012 21:26'!(Integer) spaceUsed	"Answer a rough estimate of number of bytes used by this class and its metaclass. Does not include space used by class variables."	| (Integer)space |	space := 0.	self methodsDo: [:(CompiledMethod)method  |		space := space + 16.  "dict and org'n space"		space := space + (method size + 6 "hdr + avg pad").		method literalsDo: [:(Object)lit |			(lit isMemberOf: Array) ifTrue: [space := space + ((lit size + 1) * 4)].			(lit isMemberOf: Float) ifTrue: [space := space + 12].			(lit isMemberOf: ByteString) ifTrue: [space := space + (lit size + 6)].			(lit isMemberOf: LargeNegativeInteger) ifTrue: [space := space + ((lit size + 1) * 4)].			(lit isMemberOf: LargePositiveInteger) ifTrue: [space := space + ((lit size + 1) * 4)]]].		^ space! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Behavior class	uses: TPureBehavior classTrait + TTyped classTrait	instanceVariableNames: ''!!Behavior class methodsFor: 'class initialization' stamp: 'EstebanAllende 2/27/2012 21:47'!(Self) flushObsoleteSubclasses	"Behavior flushObsoleteSubclasses"	ObsoleteSubclasses finalizeValues.! !!Behavior class methodsFor: 'class initialization' stamp: 'EstebanAllende 2/27/2012 21:47'!(Self) initialize	"Behavior initialize"	"Never called for real"	true ifTrue: [^self]. "We ensure that is never called for real"	ObsoleteSubclasses		ifNil: [self initializeObsoleteSubclasses]		ifNotNil: [| (WeakKeyToCollectionDictionary)newDict | 			newDict := WeakKeyToCollectionDictionary newFrom: ObsoleteSubclasses.			newDict rehash.			ObsoleteSubclasses := newDict]! !!Behavior class methodsFor: 'class initialization' stamp: 'EstebanAllende 2/27/2012 21:47'!(Self) initializeObsoleteSubclasses	ObsoleteSubclasses := WeakKeyToCollectionDictionary new.! !!Behavior class methodsFor: 'cleanup' stamp: 'EstebanAllende 2/27/2012 21:48'!(Self) cleanUp	"Flush the obsolete subclasses."	self flushObsoleteSubclasses! !!Behavior class methodsFor: 'testing' stamp: 'EstebanAllende 2/27/2012 21:48'!(Boolean) canZapMethodDictionary	"Return false since zapping the method dictionary of Behavior class or its subclasses will cause the system to fail."	^false! !Behavior initialize!