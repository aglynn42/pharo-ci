'From Pharo1.4a of ''16 June 2011'' [Latest update: #14301] on 25 February 2012 at 11:57 pm'!Integer variableByteSubclass: #LargePositiveInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Numbers'!!LargePositiveInteger commentStamp: '<historical>' prior: 0!I represent positive integers of more than 30 bits (ie, >= 1073741824).  These values are beyond the range of SmallInteger, and are encoded here as an array of 8-bit digits.  Care must be taken, when new values are computed, that any result that COULD BE a SmallInteger IS a SmallInteger (see normalize).Note that the bit manipulation primitives, bitAnd:, bitShift:, etc., = and ~= run without failure (and therefore fast) if the value fits in 32 bits.  This is a great help to the simulator.!!LargePositiveInteger methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/25/2012 21:56'!(?) * (Number)anInteger 	"Primitive. Multiply the receiver by the argument and answer with an	Integer result. Fail if either the argument or the result is not a	SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive. "	<primitive: 29>	^super * anInteger! !!LargePositiveInteger methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/25/2012 21:56'!(?) + (Number)anInteger 	"Primitive. Add the receiver to the argument and answer with an	Integer result. Fail if either the argument or the result is not a	SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive."	<primitive: 21>	^super + anInteger! !!LargePositiveInteger methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/25/2012 21:57'!(?) - (Number)anInteger 	"Primitive. Subtract the argument from the receiver and answer with an	Integer result. Fail if either the argument or the result is not a	SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive."	<primitive: 22>	^super - anInteger! !!LargePositiveInteger methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/25/2012 21:57'!(?) / (Number)anInteger 	"Primitive. Divide the receiver by the argument and answer with the	result if the division is exact. Fail if the result is not a whole integer.	Fail if the argument is 0. Fail if either the argument or the result is not	a SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive. "	<primitive: 30>	^super / anInteger! !!LargePositiveInteger methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/25/2012 21:57'!(?) // (Number)anInteger 	"Primitive. Divide the receiver by the argument and return the result.	Round the result down towards negative infinity to make it a whole	integer. Fail if the argument is 0. Fail if either the argument or the	result is not a SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824).	Optional. See Object documentation whatIsAPrimitive. "	<primitive: 32>	^super // anInteger! !!LargePositiveInteger methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/25/2012 21:58'!(?) \\ (Number)anInteger 	"Primitive. Take the receiver modulo the argument. The result is the	remainder rounded towards negative infinity, of the receiver divided	by the argument. Fail if the argument is 0. Fail if either the argument	or the result is not a SmallInteger or a LargePositiveInteger less than	2-to-the-30th (1073741824). Optional. See Object documentation whatIsAPrimitive."	<primitive: 31>	^super \\ anInteger! !!LargePositiveInteger methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/25/2012 21:58'!(Integer)\\\ (Integer)anInteger 	"a faster modulo method for use in DSA. Be careful if you try to use this elsewhere"	^(self digitDiv: anInteger neg: false) second! !!LargePositiveInteger methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/25/2012 22:37'!(Self) abs! !!LargePositiveInteger methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/25/2012 22:43'!(?) negated 	^ (self copyto: (LargeNegativeInteger new: self digitLength))		normalize  "Need to normalize to catch SmallInteger minVal"! !!LargePositiveInteger methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/25/2012 22:45'!(Integer)quo: (Number)anInteger 	"Primitive. Divide the receiver by the argument and return the result.	Round the result down towards zero to make it a whole integer. Fail if	the argument is 0. Fail if either the argument or the result is not a	SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824). Optional. See	Object documentation whatIsAPrimitive."	<primitive: 33>	^super quo: anInteger! !!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'EstebanAllende 2/25/2012 22:50'!(Integer) bitAt: (Integer)anInteger	"Optimize super algorithm to avoid long bit operations.	Instead work on digits which are known to be SmallInteger and fast.	Note that this algorithm does not work for negative integers."		| (Integer)digitIndex (Integer)bitIndex |	digitIndex := anInteger - 1 // 8 + 1.	digitIndex > self digitLength ifTrue: [^0].	bitIndex := anInteger - 1 \\ 8 + 1.	^(self digitAt: digitIndex) bitAt: bitIndex! !!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'EstebanAllende 2/25/2012 22:51'!(Integer) hashMultiply	"Truncate to 28 bits and try again"	^(<SmallInteger>(self bitAnd: 16rFFFFFFF)) hashMultiply! !!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'EstebanAllende 2/25/2012 22:51'!(Integer) highBit	"Answer the index of the high order bit of the receiver, or zero if the  	receiver is zero. Raise an error if the receiver is negative, since  	negative integers are defined to have an infinite number of leading 1's 	in 2's-complement arithmetic. Use >>highBitOfMagnitude if you want to  	get the highest bit of the magnitude."	^ self highBitOfMagnitude! !!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'EstebanAllende 2/25/2012 22:52'!(Integer) highBitOfMagnitude	"Answer the index of the high order bit of the magnitude of the  	receiver, or zero if the receiver is zero.  	This method is used for LargeNegativeIntegers as well,  	since LargeIntegers are sign/magnitude."	| (Integer)realLength (SmallInteger)lastDigit |	realLength := self digitLength.	[(lastDigit := self digitAt: realLength) = 0]		whileTrue: [(realLength := realLength - 1) = 0 ifTrue: [^ 0]].	^ lastDigit highBitOfPositiveReceiver + (8 * (realLength - 1))! !!LargePositiveInteger methodsFor: 'comparing' stamp: 'EstebanAllende 2/25/2012 22:53'!(Boolean) < (Magnitude)anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is less than the argument. Otherwise answer false. Fail if the	argument is not a SmallInteger or a LargePositiveInteger less than 2-to-the-30th (1073741824).	Optional. See Object documentation whatIsAPrimitive."	<primitive: 23>	^super < anInteger! !!LargePositiveInteger methodsFor: 'comparing' stamp: 'EstebanAllende 2/25/2012 22:53'!(Boolean) <= (Magnitude)anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is less than or equal to the argument. Otherwise answer false.	Fail if the argument is not a SmallInteger or a LargePositiveInteger less	than 2-to-the-30th (1073741824). Optional. See Object documentation whatIsAPrimitive."	<primitive: 25>	^super <= anInteger! !!LargePositiveInteger methodsFor: 'comparing' stamp: 'EstebanAllende 2/25/2012 22:53'!(Boolean) > (Magnitude)anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is greater than the argument. Otherwise answer false. Fail if	the argument is not a SmallInteger or a LargePositiveInteger less than	2-to-the-30th (1073741824). Optional. See Object documentation whatIsAPrimitive."	<primitive: 24>	^super > anInteger! !!LargePositiveInteger methodsFor: 'comparing' stamp: 'EstebanAllende 2/25/2012 22:54'!(Boolean) >= (Magnitude)anInteger 	"Primitive. Compare the receiver with the argument and answer true if	the receiver is greater than or equal to the argument. Otherwise answer	false. Fail if the argument is not a SmallInteger or a LargePositiveInteger	less than 2-to-the-30th (1073741824). Optional. See Object documentation whatIsAPrimitive."	<primitive: 26>	^super >= anInteger! !!LargePositiveInteger methodsFor: 'comparing' stamp: 'EstebanAllende 2/25/2012 22:54'!(Integer) hash	^ByteArray		hashBytes: self		startingWith: self species hash! !!LargePositiveInteger methodsFor: 'converting' stamp: 'EstebanAllende 2/25/2012 22:55'!(SmallInteger) as31BitSmallInt	"This is only for 31 bit numbers.  Keep my 31 bits the same, but put them in a small int.  The small int will be negative since my 31st bit is 1.  We know my 31st bit is 1 because otherwise I would already be a positive small int."	self highBit = 31 ifFalse: [self error: 'more than 31 bits can not fit in a SmallInteger'].	^ (<SmallInteger>self - 16r80000000)! !!LargePositiveInteger methodsFor: 'converting' stamp: 'EstebanAllende 2/25/2012 23:10'!(Float) asFloat	"Answer a Float that best approximates the value of the receiver.	This algorithm is optimized to process only the significant digits of a LargeInteger.	And it does honour IEEE 754 round to nearest even mode in case of excess precision (see details below)."		"How numbers are rounded in IEEE 754 default rounding mode:	A shift is applied so that the highest 53 bits are placed before the floating point to form a mantissa.	The trailing bits form the fraction part placed after the floating point.	This fractional number must be rounded to the nearest integer.	If fraction part is 2r0.1, exactly between two consecutive integers, there is a tie.	The nearest even integer is chosen in this case.	Examples (First 52bits of mantissa are omitted for brevity):	2r0.00001 is rounded downward to 2r0	2r1.00001 is rounded downward to 2r1	2r0.1 is a tie and rounded to 2r0 (nearest even)	2r1.1 is a tie and rounded to 2r10 (nearest even)	2r0.10001 is rounded upward to 2r1	2r1.10001 is rounded upward to 2r10	Thus, if the next bit after floating point is 0, the mantissa is left unchanged.	If next bit after floating point is 1, an odd mantissa is always rounded upper.	An even mantissa is rounded upper only if the fraction part is not a tie."		"Algorihm details:	Floating point hardware will correctly handle the rounding by itself with a single inexact operation if mantissa has one excess bit of precision.	Except in the last case when extra bits are present after an even mantissa, we must round upper by ourselves.	Note 1: the inexact flag in floating point hardware must not be trusted because it won't take into account the bits we truncated by ourselves.	Note 2: the floating point hardware is presumed configured in default rounding mode."		| (Integer)mantissa (Integer)shift (Float)sum (Integer)excess |	"Check how many bits excess the maximum precision of a Float mantissa."	excess := self highBitOfMagnitude - Float precision.	excess > 1		ifTrue:			["Remove the excess bits but one."			mantissa := self bitShift: 1 - excess.			shift := excess - 1.			"Handle the case of extra bits truncated after an even mantissa."			((mantissa bitAnd: 2r11) = 2r01 and: [self anyBitOfMagnitudeFrom: 1 to: shift])				ifTrue: [mantissa := mantissa + 1]]		ifFalse:			[mantissa := self.			shift := 0].	"Now that mantissa has at most 1 excess bit of precision, let floating point operations perform the final rounding."	sum := 0.0.	1 to: mantissa digitLength do:		[:(Integer)byteIndex | 		sum := sum + ((mantissa digitAt: byteIndex) asFloat timesTwoPower: shift).		shift := shift + 8].	^sum! !!LargePositiveInteger methodsFor: 'converting' stamp: 'EstebanAllende 2/25/2012 23:11'!(Integer) normalize	"Check for leading zeroes and return shortened copy if so"	| (Integer)sLen (Integer)val (Integer)len (Integer)oldLen |	<primitive: 'primNormalizePositive' module:'LargeIntegers'>	"First establish len = significant length"	len := oldLen := self digitLength.	[len = 0 ifTrue: [^0].	(self digitAt: len) = 0]		whileTrue: [len := len - 1].	"Now check if in SmallInteger range"	sLen := SmallInteger maxVal digitLength.	(len <= sLen		and: [(self digitAt: sLen) <= (SmallInteger maxVal digitAt: sLen)])		ifTrue: ["If so, return its SmallInt value"				val := 0.				len to: 1 by: -1 do:					[:(Integer)i | val := (val *256) + (self digitAt: i)].				^ val].	"Return self, or a shortened copy"	len < oldLen		ifTrue: [^ self growto: len]		ifFalse: [^ self]! !!LargePositiveInteger methodsFor: 'converting' stamp: 'EstebanAllende 2/25/2012 23:12'!(Integer) withAtLeastNDigits: (Integer)desiredLength	| (Integer)new |	self size >= desiredLength ifTrue: [^self].	new := self class new: desiredLength.	new		replaceFrom: 1 		to: self size 		with: self 		startingAt: 1.	^new! !!LargePositiveInteger methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/25/2012 23:14'!(Float) ln	"This function is defined because super ln might overflow."	| (Float) res (Integer)h |	res := super ln.	res isFinite ifTrue: [^res].	h := self highBit.	^2 ln * h + (self / (1 << h)) asFloat ln! !!LargePositiveInteger methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/25/2012 23:15'!(Float) log	"This function is defined because super log might overflow."	| (Float)res (Integer)h |	res := super log.	res isFinite ifTrue: [^res].	h := self highBit.	^2 log * h + (self / (1 << h)) asFloat log! !!LargePositiveInteger methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/25/2012 23:17'!(Boolean) mightBeASquare	"In base 16, a square number can end only with 0,1,4 or 9 and	- in case 0, only 0,1,4,9 can precede it,	- in case 4, only even numbers can precede it.	See http://en.wikipedia.org/wiki/Square_number	So, in hex, the last byte must be one of:		00		10		40		90		x1		e4		x9	where x is any hex digit and e is any even digit	Also, the receiver must be an aven power of two."	| (SmallInteger)lsb |	lsb := self digitAt: 1.	^(lsb = 0 and: [ self lowBit odd ])	"00 (and even power of 2)"		or: [ lsb = 16r40				"40"		or: [ (lsb bitAnd: 16r7) = 1		"any|1 or any|9"		or: [ (lsb bitAnd: 16r1F) = 4		"even|4"		or: [ (lsb bitAnd: 16r7F) = 16 ]]]]	"10 or 90"! !!LargePositiveInteger methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/25/2012 23:19'!(Number) sqrt 	"If we know for sure no exact solution exists, then just answer the cheap float approximation without wasting time."	| (Float)selfAsFloat |	self mightBeASquare		ifFalse:			[selfAsFloat := self asFloat.			selfAsFloat isFinite ifTrue: [^self asFloat sqrt ]].	"If some exact solution might exist, or self asFloat isInfinite, call potentially expensive super"	^super sqrt! !!LargePositiveInteger methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/25/2012 23:19'!(Integer)sqrtFloor	"Return the integer part of the square root of self"	| (Integer)powerOfTwo |	(powerOfTwo := self lowBit - 1 // 2) > 1		ifFalse: [^super sqrtFloor].	^(self bitShift: -2 * powerOfTwo) sqrtFloor bitShift: powerOfTwo! !!LargePositiveInteger methodsFor: 'printing' stamp: 'EstebanAllende 2/25/2012 23:26'!(Self) printOn: (Stream)aStream base: (Integer)b	"Append a representation of this number in base b on aStream.	In order to reduce cost of LargePositiveInteger ops, split the number in approximately two equal parts in number of digits."		| (Integer)halfDigits (Integer)halfPower (Integer)head (Integer)tail (Integer)nDigitsUnderestimate |	"Don't engage any arithmetic if not normalized"	(self digitLength = 0 or: [(self digitAt: self digitLength) = 0]) ifTrue: [self normalize printOn: aStream base: b.^self].		nDigitsUnderestimate := b = 10		ifTrue: [((self highBit - 1) * 1233 >> 12) + 1. "This is because (2 log)/(10 log)*4096 is slightly greater than 1233"]		ifFalse: [self highBit quo: b highBit].			"splitting digits with a whole power of two is more efficient"	halfDigits := 1 bitShift: nDigitsUnderestimate highBit - 2.		halfDigits <= 1		ifTrue: ["Hmmm, this could happen only in case of a huge base b... Let lower level fail"			^self printOn: aStream base: b nDigits: (self numberOfDigitsInBase: b)].		"Separate in two halves, head and tail"	halfPower := (<Integer>b raisedToInteger: halfDigits).	head := self quo: halfPower.	tail := self - (head * halfPower).		"print head"	head printOn: aStream base: b.		"print tail without the overhead to count the digits"	tail printOn: aStream base: b nDigits: halfDigits! !!LargePositiveInteger methodsFor: 'printing' stamp: 'EstebanAllende 2/25/2012 23:38'!(Self) printOn: (Stream)aStream base: (Integer)b nDigits: (Integer)n	"Append a representation of this number in base b on aStream using n digits.	In order to reduce cost of LargePositiveInteger ops, split the number of digts approximatily in two	Should be invoked with: 0 <= self < (b raisedToInteger: n)"		| (Integer)halfPower (Integer)half (Integer)head (Integer)tail |	n <= 1 ifTrue: [		n <= 0 ifTrue: [^self error: 'Number of digits n should be > 0'].				"Note: this is to stop an infinite loop if one ever attempts to print with a huge base		This can happen because choice was to not hardcode any limit for base b		We let Character>>#digitValue: fail"		^aStream nextPut: (Character digitValue: self)].	halfPower := n bitShift: -1.	half := (<Integer>b raisedToInteger: halfPower).	head := self quo: half.	tail := self - (head * half).	head printOn: aStream base: b nDigits: n - halfPower.	tail printOn: aStream base: b nDigits: halfPower! !!LargePositiveInteger methodsFor: 'system primitives' stamp: 'EstebanAllende 2/25/2012 23:38'!(SmallInteger) digitAt: (Integer)index 	"Primitive. Answer the value of an indexable field in the receiver.   LargePositiveInteger uses bytes of base two number, and each is a 'digit' base 256.  Fail if the argument (the index) is not an Integer or is out of bounds. Essential.  See Object documentation whatIsAPrimitive."	<primitive: 60>	self digitLength < index		ifTrue: [^0]		ifFalse: [^super at: index]! !!LargePositiveInteger methodsFor: 'system primitives' stamp: 'EstebanAllende 2/25/2012 23:41'!(Integer)digitAt: (Integer)index put: (Integer)value 	"Primitive. Store the second argument (value) in the indexable field of 	the receiver indicated by index. Fail if the value is negative or is larger 	than 255. Fail if the index is not an Integer or is out of bounds. Answer 	the value that was stored. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 61>	^super at: index put: value! !!LargePositiveInteger methodsFor: 'system primitives' stamp: 'EstebanAllende 2/25/2012 23:41'!(Integer)digitLength	"Primitive. Answer the number of indexable fields in the receiver. This 	value is the same as the largest legal subscript. Essential. See Object 	documentation whatIsAPrimitive."	<primitive: 62>	^self primitiveFailed! !!LargePositiveInteger methodsFor: 'system primitives' stamp: 'EstebanAllende 2/25/2012 23:53'!(Self) replaceFrom: (Integer)start to: (Integer)stop with: (Integer)replacement startingAt: (Integer)repStart 	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."	<primitive: 105>	^ (<Self>super replaceFrom: start to: stop with: replacement startingAt: repStart)! !!LargePositiveInteger methodsFor: 'testing' stamp: 'EstebanAllende 2/25/2012 23:54'!(Boolean) isLarge	^true! !!LargePositiveInteger methodsFor: 'testing' stamp: 'EstebanAllende 2/25/2012 23:54'!(Boolean) negative	"Answer whether the receiver is mathematically negative."	^ false! !!LargePositiveInteger methodsFor: 'testing' stamp: 'EstebanAllende 2/25/2012 23:55'!(Boolean) positive	"Answer whether the receiver is positive or equal to 0. (ST-80 protocol).	See also strictlyPositive"	^ true! !!LargePositiveInteger methodsFor: 'testing' stamp: 'EstebanAllende 2/25/2012 23:55'!(Integer) sign	"Optimization. Answer 1 since receiver is greater than 0."	^ 1! !!LargePositiveInteger methodsFor: 'testing' stamp: 'EstebanAllende 2/25/2012 23:55'!(Boolean) strictlyPositive	"Answer whether the receiver is mathematically positive."	^ true! !