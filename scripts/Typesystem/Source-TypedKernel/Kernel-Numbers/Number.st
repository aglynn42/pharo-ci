'From Pharo1.4 of 18 April 2012 [Latest update: #14438] on 17 October 2012 at 1:31:16 pm'!Magnitude subclass: #Number	uses: TTyped	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Numbers'!!Number commentStamp: 'StephaneDucasse 11/1/2010 07:50' prior: 0!Class Number holds the most general methods for dealing with numbers. Subclasses Float, Fraction, and Integer, and their subclasses, provide concrete representations of a numeric quantity.All of Number's subclasses participate in a simple type coercion mechanism that supports mixed-mode arithmetic and comparisons.  It works as follows:  If	self<typeA> op: arg<typeB>fails because of incompatible types, then it is retried in the following guise:	(arg adaptTypeA: self) op: arg adaptToTypeA.This gives the arg of typeB an opportunity to resolve the incompatibility, knowing exactly what two types are involved.  If self is more general, then arg will be converted, and viceVersa.  This mechanism is extensible to any new number classes that one might wish to add to Squeak.  The only requirement is that every subclass of Number must support a pair of conversion methods specific to each of the other subclasses of Number.Implementation notes----------------------------------The implementation of #degreeCos and #degreeSin is such that results are exact for any multiple of 90.Care is also taken to evaluate the sine between -90° and 90°, this will avoid #degreesToRadians and i386 FPU sine fonction to accumulate round off errors due to approximate representation of pi.We can thus evaluate 240 degreeCos with at most 1 ulp error. It's not perfect, but better than previous implementation.For cosine, we know that:	cosd(x)=cosd(abs(x))	cosd(x)=sind(90-x)thus the trick is to evaluate:	cosd(x)=sind(90-abs(x)) after appropriate modulo in [-180,180[This way, we are sure to evaluate the sine between -90° and 90°The #degreesToRadians and #sin are used rather than #degreeSin to avoid cycles.For sine, it would be necessary to evaluate eithersind(x) if abs(x) <=90or sind(180-x) if abs(x) >= 90A possible implementation would be:	| x |	x := 90 + self \\ 360 - 90.	x >= 180 ifTrue: [x := 180 - x].	^x degreesToRadians sinWe prefer evaluating cosd(90-x) thus providing a branch free implementation.!!Number methodsFor: '*Graphics-Primitives' stamp: 'EstebanAllende 2/24/2012 23:18'!(Point)@ (Number)y 	"Primitive. Answer a Point whose x value is the receiver and whose y 	value is the argument. Optional. No Lookup. See Object documentation 	whatIsAPrimitive."	<primitive: 18>	^Point x: self y: y! !!Number methodsFor: '*Tools-Inspector' stamp: 'EstebanAllende 2/24/2012 23:19'!(String) defaultLabelForInspector	"Answer the default label to be used for an Inspector window on the receiver."	^ super defaultLabelForInspector, ': ', self printString! !!Number methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/24/2012 01:19'!(Number) * (Number)aNumber 	"Answer the result of multiplying the receiver by aNumber."	^self subclassResponsibility! !!Number methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/24/2012 01:19'!(Number) + (Number)aNumber 	"Answer the sum of the receiver and aNumber."	^self subclassResponsibility! !!Number methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/24/2012 01:20'!(Number) - (Number)aNumber 	"Answer the difference between the receiver and aNumber."	^self subclassResponsibility! !!Number methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/24/2012 01:20'!(Number) / (Number)aNumber 	"Answer the result of dividing the receiver by aNumber."	^self subclassResponsibility! !!Number methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/24/2012 01:25'!(Integer) // (Number)aNumber 	"Integer quotient defined by division with truncation toward negative 	infinity. 9//4 = 2, -9//4 = -3. -0.9//0.4 = -3. \\ answers the remainder 	from this division."	^(self / aNumber) floor! !!Number methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/24/2012 01:21'!(Number) \\ (Number)aNumber 	"modulo. Remainder defined in terms of //. Answer a Number with the 	same sign as aNumber. e.g. 9\\4 = 1, -9\\4 = 3, 9\\-4 = -3, 0.9\\0.4 = 0.1."	^self - (self // aNumber * aNumber)! !!Number methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/24/2012 01:24'!(Self) abs	"Answer a Number that is the absolute value (positive magnitude) of the 	receiver."	self < 0		ifTrue: [^self negated]		ifFalse: [^self]! !!Number methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/24/2012 01:23'!(Number) arg	"Answer the argument of the receiver (see Complex | arg)."		self isZero ifTrue: [self error: 'Zero (0 + 0 i) does not have an argument.'].	0 < self		ifTrue: [^ 0]		ifFalse: [^ Float pi]! !!Number methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/24/2012 01:26'!(Self) negated	"Answer a Number that is the negation of the receiver."	^0 - self! !!Number methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/24/2012 01:25'!(Integer) quo: (Number)aNumber 	"Integer quotient defined by division with truncation toward zero. -9 quo: 	4 = -2, -0.9 quo: 0.4 = -2. rem: answers the remainder from this division."	^(self / aNumber) truncated! !!Number methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/24/2012 01:26'!(Number) reciprocal	"Returns the reciprocal of self.	In case self is 0 the / signals ZeroDivide"		^1 / self! !!Number methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/24/2012 01:26'!(Number) rem: (Number)aNumber 	"Remainder defined in terms of quo:. Answer a Number with the same 	sign as self. e.g. 9 rem: 4 = 1, -9 rem: 4 = -1. 0.9 rem: 0.4 = 0.1."	^self - ((self quo: aNumber) * aNumber)! !!Number methodsFor: 'comparing' stamp: 'EstebanAllende 2/24/2012 21:32'!(Boolean) closeTo: (Object)num	"are these two numbers close?"		num isFloat ifTrue: [^ num closeTo: self asFloat].	^[self = num] ifError: [false]! !!Number methodsFor: 'comparing' stamp: 'EstebanAllende 10/17/2012 13:26'!(Self|a) max: (a <: Number)aNumber	<ignoreParent: true>	"Answer the receiver or the argument, whichever has the greater 	magnitude."	self > aNumber		ifTrue: [^self]		ifFalse: [^aNumber]! !!Number methodsFor: 'comparing' stamp: 'EstebanAllende 10/17/2012 13:26'!(Self|a) min: (a <: Number)aNumber	<ignoreParent: true>	"Answer the receiver or the argument, whichever has the lesser 	magnitude."	self < aNumber		ifTrue: [^self]		ifFalse: [^aNumber]! !!Number methodsFor: 'comparing' stamp: 'EstebanAllende 7/18/2012 20:35'!(Number) min: (Number)aMin max: (Number)aMax 	<ignoreParent: true>	^ (self min: aMin) max: aMax! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 20:55'!(Collection) adaptToCollection: (Collection)rcvr andSend: (Symbol)selector	"If I am involved in arithmetic with a Collection, return a Collection of	the results of each element combined with me in that expression."	^ rcvr collect: [:element | element perform: selector with: self]! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 20:58'!(Boolean) adaptToFloat: (Float)rcvr andCompare: (Symbol)selector 	"If I am involved in comparison with a Float, convert rcvr to a	Fraction. This way, no bit is lost and comparison is exact."		rcvr isFinite		ifFalse: [			selector == #= ifTrue: [^false].			selector == #~= ifTrue: [^true].			rcvr isNaN ifTrue: [^ false].			(selector = #< or: [selector = #'<='])				ifTrue: [^ rcvr positive not].			(selector = #> or: [selector = #'>='])				ifTrue: [^ rcvr positive].			^self error: 'unknow comparison selector'].	^ rcvr asTrueFraction perform: selector with: self! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:32'!(?) adaptToFloat: (Float) rcvr andSend: (Symbol)selector 	"If I am involved in arithmetic with a Float, convert me to a Float."	^ rcvr perform: selector with: self asFloat! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:24'!(?) adaptToFraction: (Fraction)rcvr andSend: (Symbol)selector	"If I am involved in arithmetic with a Fraction, convert us and evaluate exprBlock."	^ self subclassResponsibility! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:25'!(?) adaptToInteger: (Integer)rcvr andSend: (Symbol)selector	"If I am involved in arithmetic with a Integer, convert us and evaluate exprBlock."	^ self subclassResponsibility! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:26'!(?) adaptToPoint: (Point)rcvr andSend: (Symbol)selector	"If I am involved in arithmetic with a Point, convert me to a Point."	^ rcvr perform: selector with: self@self! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:27'!(?) adaptToString: (String)rcvr andSend: (Symbol)selector	"If I am involved in arithmetic with a String, convert it to a Number."	^ rcvr asNumber perform: selector with: self! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 7/18/2012 20:41'!asB3DVector3	self flag: #DEAD	"^self@self@self"! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:29'!(Duration) asDuration  	^ Duration nanoSeconds: self asInteger ! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:31'!(Float) asFloat		^ self subclassResponsibility! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:32'!(Float) asFloatD	"Answer a d precision floating-point number approximating the receiver."	#Numeric.	"add 200/01/19 For ANSI <number> protocol."	^ self asFloat! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:33'!(Float) asFloatE	"Answer a floating-point number approximating the receiver."	#Numeric.	"add 200/01/19 For ANSI <number> protocol."	^ self asFloat! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:33'!(Float) asFloatQ	"Answer a floating-point number approximating the receiver."	#Numeric.	"add 200/01/19 For ANSI <number> protocol."	^ self asFloat! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:33'!(Integer) asInteger	"Answer an Integer nearest the receiver toward zero."	^self truncated! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:33'!(Number) asNumber	^ self! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:33'!(Point) asPoint	"Answer a Point with the receiver as both coordinates; often used to 	supply the same value in two dimensions, as with symmetrical gridding 	or scaling."	^self @ self! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:34'!(ScaledDecimal) asScaledDecimal	"Answer a scaled decimal number approximating the receiver."	#Numeric.	^ self asScaledDecimal: 8! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:34'!(ScaledDecimal) asScaledDecimal: (Integer)scale 	"Answer the receiver converted to a ScaledDecimal."		^ ScaledDecimal newFromNumber: self scale: scale! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:41'!(Number) asSmallAngleDegrees	"Return the receiver normalized to lie within the range (-180, 180)"	| (Number)pos |	pos := self \\ 360.	pos > 180 ifTrue: [pos := pos - 360].	^ pos"#(-500 -300 -150 -5 0 5 150 300 500 1200) collect: [:n | n asSmallAngleDegrees]"! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:41'!(Number) asSmallPositiveDegrees	"Return the receiver normalized to lie within the range (0, 360)"	^self \\ 360! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:42'!(Duration) day  	^ self sign days! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:42'!(Duration) days  	^ Duration days: self! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:42'!(Float) degreesToRadians	"The receiver is assumed to represent degrees. Answer the conversion to 	radians."	^self asFloat degreesToRadians! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:43'!(Duration) hour  	^ self sign hours ! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:43'!(Duration) hours  	^ Duration hours: self! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:43'!(Duration) milliSecond  	^ self sign milliSeconds ! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:43'!(Duration) milliSeconds  	^ Duration milliSeconds: self ! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:43'!(Duration) minute  	^ self sign minutes ! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:44'!(Duration) minutes  	^ Duration minutes: self! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:44'!(Duration) nanoSecond  	^ self sign nanoSeconds ! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:45'!(Duration) nanoSeconds  	^ Duration nanoSeconds: self.! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:45'!(Float) radiansToDegrees	"The receiver is assumed to represent radians. Answer the conversion to 	degrees."	^self asFloat radiansToDegrees! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:45'!(Duration)second  	^ self sign seconds ! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:46'!(Duration) seconds  	^ Duration seconds: self! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:48'!(Duration) week  	^ self sign weeks ! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:48'!(Duration)weeks  	^ Duration weeks: self! !!Number methodsFor: 'converting' stamp: 'EstebanAllende 2/24/2012 21:49'!(Self) withNegativeSign	"Answer a number with same magnitude than receiver and negative sign."	^self abs negated! !!Number methodsFor: 'intervals' stamp: 'EstebanAllende 2/24/2012 21:50'!(Interval) to: (Number)stop	"Answer an Interval from the receiver up to the argument, stop, 	incrementing by 1."	^Interval from: self to: stop by: 1! !!Number methodsFor: 'intervals' stamp: 'EstebanAllende 2/24/2012 21:51'!(Interval) to: (Number)stop by: (Number)step	"Answer an Interval from the receiver up to the argument, stop, 	incrementing by step."	^Interval from: self to: stop by: step! !!Number methodsFor: 'intervals' stamp: 'EstebanAllende 10/17/2012 13:29'!(Nil) to: (Number)stop by: (Number)step do: (?→Any) aBlock 	"Normally compiled in-line, and therefore not overridable.	Evaluate aBlock for each element of the interval (self to: stop by: step)."	| (Number)nextValue |	nextValue := self.	step = 0 ifTrue: [self error: 'step must be non-zero'].	step < 0		ifTrue: [[stop <= nextValue]				whileTrue: 					[aBlock value: nextValue.					nextValue := nextValue + step]]		ifFalse: [[stop >= nextValue]				whileTrue: 					[aBlock value: nextValue.					nextValue := nextValue + step]].		^nil.! !!Number methodsFor: 'intervals' stamp: 'EstebanAllende 10/17/2012 13:29'!(Nil) to: (Number)stop do: (?→Any)aBlock 	"Normally compiled in-line, and therefore not overridable.	Evaluate aBlock for each element of the interval (self to: stop by: 1)."	| (Number)nextValue |	nextValue := self.	[nextValue <= stop]		whileTrue: 			[aBlock value: nextValue.			nextValue := nextValue + 1].	^nil! !!Number methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/24/2012 22:34'!(Float) arcCos 	"The receiver is the cosine of an angle. Answer the angle measured in 	radians."	^self asFloat arcCos! !!Number methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/24/2012 22:34'!(Float) arcSin	"The receiver is the sine of an angle. Answer the angle measured in 	radians."	^self asFloat arcSin! !!Number methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/24/2012 22:34'!(Float) arcTan	"The receiver is the tangent of an angle. Answer the angle measured in 	radians."	^self asFloat arcTan! !!Number methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/24/2012 22:35'!(Float) arcTan: (Number)denominator	"The receiver is the tangent of an angle. Answer the angle measured in 	radians."	^(self asFloat) arcTan: denominator.! !!Number methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/24/2012 22:36'!(Number) copySignTo: (Number)aNumber	"Return a number with same magnitude as aNumber and same sign as self."	^ self positive		ifTrue: [aNumber abs]		ifFalse: [aNumber withNegativeSign].! !!Number methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/24/2012 22:36'!(Float) cos	"The receiver represents an angle measured in radians. Answer its cosine."	^self asFloat cos! !!Number methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/24/2012 22:36'!(Float) degreeCos	"Answer the cosine of the receiver taken as an angle in degrees."		^ (90 - (180 + self \\ 360 - 180) abs) degreesToRadians sin! !!Number methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/24/2012 22:37'!(Float) degreeSin	"Answer the sine of the receiver taken as an angle in degrees."		^(90 - self) degreeCos! !!Number methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/24/2012 22:37'!(Float) exp	"Answer the exponential of the receiver as a floating point number."	^self asFloat exp! !!Number methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/24/2012 22:37'!(Integer) floorLog: (Integer)radix	"Answer the floor of the log base radix of the receiver."	^ self asFloat floorLog: radix! !!Number methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/24/2012 22:38'!(Number) interpolateTo: (Number)aNumber at: (Number)param	^self + (aNumber - self * param)! !!Number methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/24/2012 22:38'!(Float) ln	"Answer the natural log of the receiver."	^self asFloat ln! !!Number methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/24/2012 22:38'!(Float) log	"Answer the base-10 log of the receiver."	^self asFloat log! !!Number methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/24/2012 22:38'!(Float) log: (Number)aNumber 	"Answer the log base aNumber of the receiver."	^self ln / aNumber ln! !!Number methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/24/2012 22:38'!(Number) nthRoot: (Integer)aPositiveInteger	"Answer the nth root of the receiver."	self subclassResponsibility! !!Number methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/24/2012 22:46'!(Number) raisedTo: (Number)aNumber 	"Answer the receiver raised to aNumber."	aNumber isInteger ifTrue: [		"Do the special case of integer power"		^ self raisedToInteger: (<Integer>aNumber)].	aNumber isFraction ifTrue: [		"Special case for fraction power"		^ (self nthRoot: (<Fraction>aNumber) denominator) raisedToInteger: (<Fraction>aNumber) numerator ].	self < 0 ifTrue: [		^ ArithmeticError signal: 'Negative numbers can''t be raised to float powers.' ].	0 = aNumber ifTrue: [^ self class one].	"Special case of exponent=0"	1 = aNumber ifTrue: [^ self].	"Special case of exponent=1"	0 = self ifTrue: [				"Special case of self = 0"		aNumber < 0			ifTrue: [^ (ZeroDivide dividend: self) signal]			ifFalse: [^ self]].	^ (aNumber * self ln) exp		"Otherwise use logarithms"! !!Number methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/24/2012 22:48'!(Number) raisedToInteger: (Integer)anInteger	"The 0 raisedToInteger: 0 is an special case. In some contexts must be 1 and in others must	be handled as an indeterminate form.	I take the first context because that's the way that was previously handled.	Maybe further discussion is required on this topic."		|(Integer)bitProbe (Number)result|	anInteger negative ifTrue: [^(self raisedToInteger: anInteger negated) reciprocal].	bitProbe := 1 bitShift: anInteger highBit - 1. 	result := self class one.  	[		(anInteger bitAnd: bitProbe) = 0 ifFalse: [result := result * self].       bitProbe := bitProbe bitShift: -1.		bitProbe > 0 ]	whileTrue: [result := result * result].		^result! !!Number methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/24/2012 22:48'!(Integer)sign	"Answer 1 if the receiver is greater than 0, -1 if less than 0, else 0."	self > 0 ifTrue: [^1].	self < 0 ifTrue: [^-1].	^0! !!Number methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/24/2012 22:49'!(Number) sign: (Number)aNumber 	"Return a Number with the same sign as aNumber"  	^ aNumber copySignTo: self.! !!Number methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/24/2012 22:49'!(Float) sin	"The receiver represents an angle measured in radians. Answer its sine."	^self asFloat sin! !!Number methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/24/2012 22:50'!(Number) sqrt	"Answer the square root of the receiver."	^self subclassResponsibility! !!Number methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/24/2012 22:50'!(Number) squared	"Answer the receiver multipled by itself."	^self * self! !!Number methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/24/2012 22:51'!(Float) tan	"The receiver represents an angle measured in radians. Answer its 	tangent."	^self asFloat tan! !!Number methodsFor: 'printing' stamp: 'EstebanAllende 2/24/2012 22:52'!(String) isOrAreStringWith: (String)aNoun	|(String)result |	result := self = 1		ifTrue:			[' is one ']		ifFalse:			[self = 0				ifTrue:					[' are no ']				ifFalse:					[' are ', self printString, ' ']].	result := result, aNoun.	self = 1 ifFalse: [result := result, 's'].	^ result"#(0 1 2 98.6) do:	[:num | Transcript cr; show: 'There', (num isOrAreStringWith: 'way'), ' to skin a cat']"! !!Number methodsFor: 'printing' stamp: 'EstebanAllende 2/24/2012 22:53'!(Self) printOn: (Stream)aStream	self printOn: aStream base: 10! !!Number methodsFor: 'printing' stamp: 'EstebanAllende 2/24/2012 22:53'!(Self) printOn: (Stream)aStream base: (Integer)base	"This method should print a representation of the number for the given base,	excluding the base prefix (and the letter r for radix)"		^self subclassResponsibility! !!Number methodsFor: 'printing' stamp: 'EstebanAllende 2/25/2012 20:16'!(Self) printOn: (Stream) aStream showingDecimalPlaces: (Integer)placesDesired	"Print a representation of the receiver on aStream in decimal notation with prescribed number of places after decimal separator."	| (Number)rounder (Number)rounded (Integer)roundedFractionPart |	placesDesired <= 0 ifTrue: [self rounded printOn: aStream.^self].	rounder := 10 raisedToInteger: placesDesired.	rounded := self roundTo: rounder reciprocal.	rounded negative ifTrue: [aStream nextPut: $-].	rounded := rounded abs.	rounded integerPart truncated printOn: aStream.	aStream nextPut: $..	roundedFractionPart := (rounded fractionPart * rounder) truncated.	roundedFractionPart printOn: aStream base: 10 length: placesDesired padded: true! !!Number methodsFor: 'printing' stamp: 'EstebanAllende 2/24/2012 22:57'!(String) printShowingDecimalPlaces: (Integer)placesDesired	"Print the receiver showing precisely the given number of places desired.  If placesDesired is positive, a decimal point and that many digits after the decimal point will always be shown.  If placesDesired is zero, a whole number will be shown, without a decimal point."	^String new: placesDesired + 10 streamContents: [:aStream |		self printOn: aStream showingDecimalPlaces: placesDesired]"23 printShowingDecimalPlaces: 223.5698 printShowingDecimalPlaces: 2-234.567 printShowingDecimalPlaces: 523.4567 printShowingDecimalPlaces: 023.5567 printShowingDecimalPlaces: 0-23.4567 printShowingDecimalPlaces: 0-23.5567 printShowingDecimalPlaces: 0100000000 printShowingDecimalPlaces: 10.98 printShowingDecimalPlaces: 5-0.98 printShowingDecimalPlaces: 22.567 printShowingDecimalPlaces: 2-2.567 printShowingDecimalPlaces: 20 printShowingDecimalPlaces: 2"! !!Number methodsFor: 'printing' stamp: 'EstebanAllende 2/24/2012 22:57'!(String) printString	^self printStringBase: 10! !!Number methodsFor: 'printing' stamp: 'EstebanAllende 2/24/2012 22:57'!(String) printStringBase: (Integer)base	^ String streamContents:		[:strm | self printOn: strm base: base]! !!Number methodsFor: 'printing' stamp: 'EstebanAllende 2/24/2012 22:58'!(Self) storeOn: (Stream)aStream 	self printOn: aStream! !!Number methodsFor: 'printing' stamp: 'EstebanAllende 2/24/2012 22:58'!(Self) storeOn: (Stream)aStream base: (Integer)base	"This method should print a representation of the number for the given base,	including the base prefix (with letter r for radix)"		^self subclassResponsibility! !!Number methodsFor: 'printing' stamp: 'EstebanAllende 2/24/2012 22:58'!(String) storeStringBase: (Integer)base	^ String streamContents: [:strm | self storeOn: strm base: base]! !!Number methodsFor: 'printing' stamp: 'EstebanAllende 2/24/2012 22:58'!(String) stringForReadout	^ self rounded printString! !!Number methodsFor: 'testing' stamp: 'EstebanAllende 2/24/2012 22:59'!(Boolean) even	"Answer whether the receiver is an even number."	^self \\ 2 = 0! !!Number methodsFor: 'testing' stamp: 'EstebanAllende 2/24/2012 22:59'!(Boolean) isDivisibleBy: (Number)aNumber	aNumber = 0 ifTrue: [^ false].	aNumber isInteger ifFalse: [^ false].	^ (self \\ aNumber) = 0! !!Number methodsFor: 'testing' stamp: 'EstebanAllende 2/24/2012 22:59'!(Boolean) isInfinite	^ false! !!Number methodsFor: 'testing' stamp: 'EstebanAllende 2/24/2012 23:00'!(Boolean) isNaN	^ false! !!Number methodsFor: 'testing' stamp: 'EstebanAllende 2/24/2012 23:00'!(Boolean) isNumber	^ true! !!Number methodsFor: 'testing' stamp: 'EstebanAllende 2/24/2012 23:00'!(Boolean) isZero	^self = 0! !!Number methodsFor: 'testing' stamp: 'EstebanAllende 2/24/2012 23:00'!(Boolean)negative	"Answer whether the receiver is mathematically negative."	^ self < 0! !!Number methodsFor: 'testing' stamp: 'EstebanAllende 2/24/2012 23:00'!(Boolean) odd	"Answer whether the receiver is an odd number."	^self even == false! !!Number methodsFor: 'testing' stamp: 'EstebanAllende 2/24/2012 23:00'!(Boolean) positive	"Answer whether the receiver is positive or equal to 0. (ST-80 protocol).	See also strictlyPositive"	^ self >= 0! !!Number methodsFor: 'testing' stamp: 'EstebanAllende 2/24/2012 23:01'!(Boolean) strictlyPositive	"Answer whether the receiver is mathematically positive."	^ self > 0! !!Number methodsFor: 'truncation and round off' stamp: 'EstebanAllende 2/24/2012 23:01'!(Integer)ceiling       "Answer the integer nearest the receiver toward  infinity."       |(Integer) truncation |       truncation := self truncated.       self <= 0 ifTrue: [ ^ truncation ].       ^ self = truncation               ifTrue: [ truncation ]               ifFalse: [ truncation + 1 ]! !!Number methodsFor: 'truncation and round off' stamp: 'EstebanAllende 2/24/2012 23:04'!(Number) detentBy: (Number)detent atMultiplesOf: (Number) grid snap: (Boolean)snap	"Map all values that are within detent/2 of any multiple of grid to that multiple.  Otherwise, if snap is true, return self, meaning that the values in the dead zone will never be returned.  If snap is false, then expand the range between dead zones so that it covers the range between multiples of the grid, and scale the value by that factor."	|(Number)r1 (Number)r2 |	r1 := self roundTo: grid.  "Nearest multiple of grid"	(self roundTo: detent) = r1 ifTrue: [^ r1].  "Snap to that multiple..."	snap ifTrue: [^ self].  "...or return self"	r2 := self < r1  "Nearest end of dead zone"		ifTrue: [r1 - (detent asFloat/2)]		ifFalse: [r1 + (detent asFloat/2)].	"Scale values between dead zones to fill range between multiples"	^ r1 + ((self - r2) * grid asFloat / (grid - detent))"	(170 to: 190 by: 2) collect: [:a | a detentBy: 10 atMultiplesOf: 90 snap: true] 	(170 to: 190 by: 2) collect: [:a | a detentBy: 10 atMultiplesOf: 90 snap: false]	(3.9 to: 4.1 by: 0.02) collect: [:a | a detentBy: 0.1 atMultiplesOf: 1.0 snap: true] 	(-3.9 to: -4.1 by: -0.02) collect: [:a | a detentBy: 0.1 atMultiplesOf: 1.0 snap: false]"! !!Number methodsFor: 'truncation and round off' stamp: 'EstebanAllende 2/24/2012 23:04'!(Integer) floor	"Answer the integer nearest the receiver toward negative infinity."	|(Integer)truncation |	truncation := self truncated.	self >= 0 ifTrue: [^truncation].	self = truncation		ifTrue: [^truncation]		ifFalse: [^truncation - 1]! !!Number methodsFor: 'truncation and round off' stamp: 'EstebanAllende 2/24/2012 23:18'!(Number) fractionPart	"Added for ANSI compatibility"	^self - self integerPart! !!Number methodsFor: 'truncation and round off' stamp: 'EstebanAllende 2/24/2012 23:18'!(Integer) integerPart	"Added for ANSI compatibility"	^self truncated! !!Number methodsFor: 'truncation and round off' stamp: 'EstebanAllende 2/24/2012 23:17'!(Number) reduce    "If self is close to an integer, return that integer"    ^ self! !!Number methodsFor: 'truncation and round off' stamp: 'EstebanAllende 2/24/2012 23:17'!(Number) roundDownTo: (Number)aNumber	"Answer the next multiple of aNumber toward negative infinity that is nearest the receiver. 	Examples:               3.1479 roundDownTo: 0.01 -> 3.14               3.1479 roundDownTo: 0.1 -> 3.1               1923 roundDownTo: 10 -> 1920               3.1479 roundDownTo: 0.005 -> 3.145               -3.1479 roundDownTo: 0.01 -> -3.15"		^(self / aNumber) floor * aNumber! !!Number methodsFor: 'truncation and round off' stamp: 'EstebanAllende 2/24/2012 23:16'!(Number) roundTo: (Number)quantum 	"Answer the nearest number that is a multiple of quantum."	^(self / quantum) rounded * quantum! !!Number methodsFor: 'truncation and round off' stamp: 'EstebanAllende 2/24/2012 23:16'!(Number) roundUpTo: (Number)aNumber 	"Answer the next multiple of aNumber toward infinity that is nearest the receiver.	Examples:               3.1479 roundUpTo: 0.01 -> 3.15               3.1479 roundUpTo: 0.1 -> 3.2               1923 roundUpTo: 10 -> 1930               3.1479 roundUpTo: 0.005 -> 3.15               -3.1479 roundUpTo: 0.01 -> -3.14"	^(self / aNumber) ceiling * aNumber! !!Number methodsFor: 'truncation and round off' stamp: 'EstebanAllende 2/24/2012 23:13'!(Integer)rounded	"Answer the integer nearest the receiver."	^(self + (self sign / 2)) truncated! !!Number methodsFor: 'truncation and round off' stamp: 'EstebanAllende 2/24/2012 23:05'!(Number) truncateTo: (Number)aNumber 	"Answer the next multiple of aNumber toward zero that is nearest the receiver.	Examples:               3.1479 truncateTo: 0.01 -> 3.14               3.1479 truncateTo: 0.1 -> 3.1               1923 truncateTo: 10 -> 1920               3.1479 truncateTo: 0.005 -> 3.145               -3.1479 truncateTo: 0.01 -> -3.14"	^(self quo: aNumber) * aNumber! !!Number methodsFor: 'truncation and round off' stamp: 'EstebanAllende 2/24/2012 23:05'!(Integer) truncated	"Answer an integer nearest the receiver toward zero."	^self quo: 1! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Number class	uses: TTyped classTrait	instanceVariableNames: ''!!Number class methodsFor: '*System-Settings-Browser' stamp: 'alain.plantec 3/18/2009 15:09'!settingInputWidgetForNode: aSettingNode	^ aSettingNode inputWidgetForNumber! !!Number class methodsFor: 'constants' stamp: 'EstebanAllende 2/24/2012 23:19'!(Integer) one	^1! !!Number class methodsFor: 'deprecated' stamp: 'dtl 7/3/2006 17:41'!readExponent: baseValue base: base from: aStream	"Complete creation of a number, reading exponent from aStream. Answer the	number, or nil if parsing fails.	<number>(e|d|q)<exponent>>"	| sign exp value |	('edq' includes: aStream next) ifFalse: [^ nil].	sign := ((aStream peek) == $-)		ifTrue: [aStream next. -1]		ifFalse: [1].	(aStream atEnd or: [(aStream peek digitValue between: 0 and: 9) not])		ifTrue: [^ nil]. "Avoid throwing an error"	exp := (Integer readFrom: aStream base: 10) * sign.	value := baseValue * (base raisedTo: exp).	^ value! !!Number class methodsFor: 'deprecated' stamp: 'dtl 7/4/2006 08:32'!readRemainderOf: integerPart from: aStream base: base withSign: sign 	"Read optional fractional part and exponent or decimal scale, and return the final result"	"Changed 200/01/19 For ANSI Numeric Literals support."	"Number readFrom: '3r-22.2'"	| value fractionDigits fracpos fractionPart fraction pos v foundDecimal |	#Numeric.	value := integerPart.	fractionDigits := 0.	foundDecimal := false.	(aStream peekFor: $.)		ifTrue: ["<integer>.<fraction>"			foundDecimal := true.			(aStream atEnd not					and: [aStream peek digitValue between: 0 and: base - 1])				ifTrue: [fracpos := aStream position.					fractionPart := Integer readFrom: aStream base: base.					fraction := fractionPart asFloat								/ (base raisedTo: aStream position - fracpos).					fractionDigits := aStream position - fracpos.					value := value asFloat + fraction]].	pos := aStream position.	(v := self readScaledDecimal: integerPart			fractionPart: fractionPart			digits: fractionDigits			base: base			sign: sign			from: aStream)		ifNil: [aStream position: pos]		ifNotNil: [^ v "<number>s<scale>>"].	pos := aStream position.	(v := self readExponent: value base: base from: aStream)		ifNil: [aStream position: pos.			(foundDecimal and: [fractionDigits = 0])				ifTrue: ["oops - just <integer>."							aStream skip: -1.							"un-gobble the period"							^ value * sign]]		ifNotNil: [value := v "<number>(e|d|q)<exponent>>"].	(value isFloat			and: [value = 0.0					and: [sign = -1]])		ifTrue: [^ Float negativeZero]		ifFalse: [^ value * sign]! !!Number class methodsFor: 'deprecated' stamp: 'nice 5/16/2009 22:11'!readScaledDecimal: integerPart fractionPart: fractionPart digits: fractionDigits base: base sign: sign from: aStream 	"Complete creation of a ScaledDecimal, reading scale from aStream. Answer	a ScaledDecimal, or nil if parsing fails.	<number>s[<scale>]"	| scale decimalMultiplier decimalFraction |	aStream atEnd ifTrue: [^ nil].	(aStream next == $s) ifFalse: [^ nil].	"<number>s<scale>"	(aStream atEnd not and: [aStream peek digitValue between: 0 and: 9])		ifTrue: [scale := Integer readFrom: aStream]		ifFalse: [^ nil].	scale isNil		ifTrue: ["<number>s"			fractionDigits = 0				ifTrue: ["<integer>s"					scale := 0]				ifFalse: ["<integer>.<fraction>s"					scale := fractionDigits]].	fractionPart isNil		ifTrue: [^integerPart * sign asScaledDecimal: scale]		ifFalse: [decimalMultiplier := base raisedTo: fractionDigits.			decimalFraction := integerPart * decimalMultiplier + fractionPart * sign / decimalMultiplier.			^decimalFraction asScaledDecimal: scale]! !!Number class methodsFor: 'instance creation' stamp: 'nice 10/22/2009 18:46'!readFrom: stringOrStream 	"Answer a number as described on aStream.  The number may	be any accepted Smalltalk literal Number format.	It can include a leading radix specification, as in 16rFADE.	It can as well be NaN, Infinity or -Infinity for conveniency.	If stringOrStream does not start with a valid number description, fail."		^(SqNumberParser on: stringOrStream) nextNumber! !!Number class methodsFor: 'instance creation' stamp: 'GuillermoPolito 8/24/2010 18:50'!readFrom: stringOrStream base: base	"Answer a number as described on aStream in the given number base.	If stringOrStream does not start with a valid number description, answer 0 for backward compatibility. This is not clever and should better be changed."	^(SqNumberParser on: stringOrStream) nextNumberBase: base! !!Number class methodsFor: 'instance creation' stamp: 'nice 3/15/2008 00:42'!readFrom: stringOrStream ifFail: aBlock	"Answer a number as described on aStream.  The number may	be any accepted Smalltalk literal Number format.	It can include a leading radix specification, as in 16rFADE.	It can as well be NaN, Infinity or -Infinity for conveniency.	If input does not represent a valid number, then execute fail block	and leave the stream positioned before offending character"		^(SqNumberParser on: stringOrStream) failBlock: aBlock; nextNumber! !!Number class methodsFor: 'instance creation' stamp: 'NikoSchwarz 10/23/2009 13:18'!squeezeNumberOutOfString: stringOrStream	"Try and find a number in this string. First, look if the string 	starts with a number. Then, see if it ends with a number. Then,	remove a character from the front and see if the remaining 	string makes a number. Repeat the process until no characters	are left or the number has been found. As soon as a number is	found, it is returned. Otherwise, the method fails."	^ SqNumberParser squeezeNumberOutOfString: stringOrStream! !!Number class methodsFor: 'instance creation' stamp: 'NikoSchwarz 10/23/2009 13:19'!squeezeNumberOutOfString: stringOrStream ifFail: aBlock	"Try and find a number in this string. First, look if the string 	starts with a number. Then, see if it ends with a number. Then,	remove a character from the front and see if the remaining 	string makes a number. Repeat the process until no characters	are left or the number has been found. As soon as a number is	found, it is returned. Otherwise, the method fails."	^ SqNumberParser squeezeNumberOutOfString: stringOrStream onError: aBlock! !