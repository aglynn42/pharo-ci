'From Pharo1.4a of ''16 June 2011'' [Latest update: #14301] on 26 February 2012 at 12:42:26 am'!LargePositiveInteger variableByteSubclass: #LargeNegativeInteger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Numbers'!!LargeNegativeInteger commentStamp: '<historical>' prior: 0!Just like LargePositiveInteger, but represents a negative number.!!LargeNegativeInteger methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/26/2012 00:10'!(?) abs	^ self negated! !!LargeNegativeInteger methodsFor: 'arithmetic' stamp: 'EstebanAllende 2/26/2012 00:10'!(?) negated	^ self copyto: (LargePositiveInteger new: self digitLength)! !!LargeNegativeInteger methodsFor: 'bit manipulation' stamp: 'EstebanAllende 2/26/2012 00:17'!(Integer) bitAt: (Integer)anInteger	"super would not work because we have to pretend we are in two-complement.	this has to be tricky..."		| (Integer)digitIndex (Integer)bitIndex (Integer)i |	digitIndex := anInteger - 1 // 8 + 1.	digitIndex > self digitLength ifTrue: [^1].	bitIndex := anInteger - 1 \\ 8 + 1.	i := 1.	[i = digitIndex		ifTrue:			["evaluate two complement (bitInvert + 1) on the digit :			(if digitIndex > 1, we must still add 1 due to the carry).			but x bitInvert is -1-x, bitInvert+1 is just x negated..."			^(self digitAt: digitIndex) negated bitAt: bitIndex].	(self digitAt: i) = 0]		whileTrue: [			"two complement (bitInvert + 1) raises a carry:			0 bitInvert -> 2r11111111.  2r11111111 + 1 -> 0 with carry...			Thus we must inquire one digit forward"			i := i + 1].		"We escaped the while loop, because there is no more carry.	Do a simple bitInvert without a carry"	^1 - ((self digitAt: digitIndex) bitAt: bitIndex)! !!LargeNegativeInteger methodsFor: 'bit manipulation' stamp: 'EstebanAllende 2/26/2012 00:21'!(Integer)highBit	"Answer the index of the high order bit of the receiver, or zero if the  	receiver is zero. Raise an error if the receiver is negative, since  	negative integers are defined to have an infinite number of leading 1's 	in 2's-complement arithmetic. Use >>highBitOfMagnitude if you want to  	get the highest bit of the magnitude."	^ self shouldNotImplement! !!LargeNegativeInteger methodsFor: 'converting' stamp: 'EstebanAllende 2/26/2012 00:22'!(Float) asFloat	^self negated asFloat negated! !!LargeNegativeInteger methodsFor: 'converting' stamp: 'EstebanAllende 2/26/2012 00:26'!(Integer)normalize	"Check for leading zeroes and return shortened copy if so"	| (Integer)sLen (Integer)val (Integer)len (Integer)oldLen (Integer)minVal |	<primitive: 'primNormalizeNegative' module:'LargeIntegers'>	"First establish len = significant length"	len := oldLen := self digitLength.	[len = 0 ifTrue: [^0].	(self digitAt: len) = 0]		whileTrue: [len := len - 1].	"Now check if in SmallInteger range"	sLen := 4  "SmallInteger minVal digitLength".	len <= sLen ifTrue:		[minVal := SmallInteger minVal.		(len < sLen			or: [(self digitAt: sLen) < minVal lastDigit])			ifTrue: ["If high digit less, then can be small"					val := 0.					len to: 1 by: -1 do:						[:(Integer)i | val := (val *256) - (self digitAt: i)].					^ val].		1 to: sLen do:  "If all digits same, then = minVal"			[:i | (self digitAt: i) = (minVal digitAt: i)					ifFalse: ["Not so; return self shortened"							len < oldLen								ifTrue: [^ self growto: len]								ifFalse: [^ self]]].		^ minVal].	"Return self, or a shortened copy"	len < oldLen		ifTrue: [^ self growto: len]		ifFalse: [^ self]! !!LargeNegativeInteger methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/26/2012 00:27'!(UndefinedObject) ln	DomainError signal: 'ln is only defined for x > 0' from: 0.	^nil.! !!LargeNegativeInteger methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/26/2012 00:28'!(UndefinedObject) log	DomainError signal: 'log is only defined for x > 0' from: 0.	^nil.! !!LargeNegativeInteger methodsFor: 'mathematical functions' stamp: 'EstebanAllende 2/26/2012 00:29'!(UndefinedObject) sqrt	"Answer the square root of the receiver."	DomainError signal: 'sqrt undefined for number less than zero.'.	^nil.! !!LargeNegativeInteger methodsFor: 'printing' stamp: 'EstebanAllende 2/26/2012 00:37'!(Self) printOn: (Stream)aStream base: (Integer)b	"Append a representation of this number in base b on aStream."		aStream nextPut: $-.	self abs printOn: aStream base: b! !!LargeNegativeInteger methodsFor: 'testing' stamp: 'EstebanAllende 2/26/2012 00:37'!(Boolean) negative	"Answer whether the receiver is mathematically negative."	^ true! !!LargeNegativeInteger methodsFor: 'testing' stamp: 'EstebanAllende 2/26/2012 00:37'!(Boolean) positive	"Answer whether the receiver is positive or equal to 0. (ST-80 protocol).	See also strictlyPositive"	^ false! !!LargeNegativeInteger methodsFor: 'testing' stamp: 'EstebanAllende 2/26/2012 00:37'!(Integer) sign	"Optimization. Answer -1 since receiver is less than 0."	^ -1! !!LargeNegativeInteger methodsFor: 'testing' stamp: 'EstebanAllende 2/26/2012 00:39'!(Boolean) strictlyPositive	"Answer whether the receiver is mathematically positive."	^ false! !