'From Pharo1.4 of 18 April 2012 [Latest update: #14438] on 17 October 2012 at 11:57:11 am'!Object subclass: #TUndefinedObject	uses: TTyped	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Objects'!!TUndefinedObject methodsFor: '*Compiler-Kernel' stamp: 'EstebanAllende 7/2/2012 17:58'!parserClass	^ self class evaluatorClass parserClass! !!TUndefinedObject methodsFor: '*compiler-extensions-deprecated' stamp: 'EstebanAllende 7/2/2012 17:58'!subclassDefinerClass	"For disjunct class hierarchies -- how should subclasses of nil be evaluated"	self deprecated: 'Use new evaluate request' on: 'December 23th, 2011' in: 'NCAPI'.	^self class evaluatorClass! !!TUndefinedObject methodsFor: '*compiler-frontend' stamp: 'EstebanAllende 7/2/2012 17:58'!compilerContext	<original> "For consistency"	^CompilerFrontend compilerContextForClass: nil.! !!TUndefinedObject methodsFor: '*compiler-frontend' stamp: 'EstebanAllende 7/2/2012 17:58'!printAsIfCompiledOn: aStream	"Warning: HACK"	^self printOn: aStream! !!TUndefinedObject methodsFor: '*opalcompiler-core' stamp: 'EstebanAllende 7/2/2012 17:58'!parseScope	^ OCGlobalScope new! !!TUndefinedObject methodsFor: '*petitparser-converting' stamp: 'EstebanAllende 7/2/2012 17:58'!asParser	"Answer a parser that succeeds and does not consume anything."		^ PPEpsilonParser new! !!TUndefinedObject methodsFor: '*prettypetit-converting' stamp: 'EstebanAllende 7/2/2012 17:58'!asDocument	^ PPEmptyDocument new! !!TUndefinedObject methodsFor: 'bottom context' stamp: 'EstebanAllende 7/2/2012 18:23'!(Boolean) canHandleSignal: (Exception)exception	"When no more handler (on:do:) context left in sender chain this gets called"	^ false! !!TUndefinedObject methodsFor: 'bottom context' stamp: 'EstebanAllende 7/2/2012 18:24'!(?) handleSignal: (Exception)exception	"When no more handler (on:do:) context left in sender chain this gets called.  Return from signal with default action."	^ exception resumeUnchecked: exception defaultAction! !!TUndefinedObject methodsFor: 'class hierarchy' stamp: 'EstebanAllende 7/2/2012 18:23'!(Self) addSubclass: (Class)aClass	"Ignored -- necessary to support disjoint class hierarchies"! !!TUndefinedObject methodsFor: 'class hierarchy' stamp: 'EstebanAllende 7/2/2012 18:30'!(Self) allSuperclassesDo: (Behavior → Any)aBlock	self shouldBeImplemented! !!TUndefinedObject methodsFor: 'class hierarchy' stamp: 'EstebanAllende 7/2/2012 18:31'!(SystemDictionary) environment	"Necessary to support disjoint class hierarchies."	^self class environment! !!TUndefinedObject methodsFor: 'class hierarchy' stamp: 'EstebanAllende 7/2/2012 18:33'!(Object) literalScannedAs: (Object)scannedLiteral notifying: (Object)requestor 	^ scannedLiteral! !!TUndefinedObject methodsFor: 'class hierarchy' stamp: 'EstebanAllende 7/2/2012 18:33'!(Self) removeObsoleteSubclass: (Class)aClass	"Ignored -- necessary to support disjoint class hierarchies"! !!TUndefinedObject methodsFor: 'class hierarchy' stamp: 'EstebanAllende 7/2/2012 18:33'!(Self) removeSubclass: (Class)aClass	"Ignored -- necessary to support disjoint class hierarchies"! !!TUndefinedObject methodsFor: 'class hierarchy' stamp: 'EstebanAllende 7/2/2012 18:35'!(ProtoObject class) subclass: (Symbol)nameOfClass  	instanceVariableNames: (String)instVarNames	classVariableNames: (String)classVarNames	poolDictionaries: (String)poolDictnames	category: (String)category	"Calling this method is now considered an accident.  If you really want to create a class with a nil superclass, then create the class and then set the superclass using #superclass:"	self traceCr: ('Attempt to create ', nameOfClass, ' as a subclass of nil.  Possibly a class is being loaded before its superclass.').	^ProtoObject		subclass: nameOfClass		instanceVariableNames: instVarNames		classVariableNames: classVarNames		poolDictionaries: poolDictnames		category: category! !!TUndefinedObject methodsFor: 'class hierarchy' stamp: 'EstebanAllende 7/2/2012 18:41'!(Array<Class>) subclasses	"Return all the subclasses of nil"	| (WriteStream)classList |	classList := Array new writeStream.	self subclassesDo:[:(Class)class| classList nextPut: class].	^classList contents! !!TUndefinedObject methodsFor: 'class hierarchy' stamp: 'EstebanAllende 7/2/2012 18:41'!(Self) subclassesDo: (Class → Any)aBlock	"Evaluate aBlock with all subclasses of nil.  Others are not direct subclasses of Class."	Class subclassesDo: [:(Behavior)cl | 			cl isMeta ifTrue: [aBlock value: (<Metaclass>cl) soleInstance]].! !!TUndefinedObject methodsFor: 'class hierarchy' stamp: 'EstebanAllende 7/2/2012 18:41'!(Symbol) typeOfClass	"Necessary to support disjoint class hierarchies."	^#normal! !!TUndefinedObject methodsFor: 'copying' stamp: 'EstebanAllende 7/2/2012 18:42'!(Self) deepCopy	"Only one instance of UndefinedObject should ever be made, so answer 	with self."! !!TUndefinedObject methodsFor: 'copying' stamp: 'EstebanAllende 7/2/2012 18:42'!(Self) shallowCopy	"Only one instance of UndefinedObject should ever be made, so answer 	with self."! !!TUndefinedObject methodsFor: 'copying' stamp: 'EstebanAllende 7/2/2012 18:42'!(Self) veryDeepCopyWith: (DeepCopier)deepCopier	"Return self.  I can't be copied.  Do not record me."! !!TUndefinedObject methodsFor: 'dependents access' stamp: 'EstebanAllende 10/17/2012 11:55'!(a) addDependent: (a <: Object)ignored 	"Refer to the comment in Object|dependents."	^self error: 'Nil should not have dependents'! !!TUndefinedObject methodsFor: 'dependents access' stamp: 'EstebanAllende 7/2/2012 18:42'!(Self) release	"Nil release is a no-op"! !!TUndefinedObject methodsFor: 'dependents access' stamp: 'EstebanAllende 7/2/2012 18:42'!(Self) suspend	"Kills off processes that didn't terminate properly"	"Display reverse; reverse."  "<-- So we can catch the suspend bug"	Processor terminateActive! !!TUndefinedObject methodsFor: 'printing' stamp: 'EstebanAllende 7/2/2012 18:43'!(Self) printOn: (Stream)aStream 	"Refer to the comment in Object|printOn:." 	aStream nextPutAll: 'nil'! !!TUndefinedObject methodsFor: 'printing' stamp: 'EstebanAllende 7/2/2012 18:43'!(Self) storeOn: (Stream)aStream 	"Refer to the comment in Object|storeOn:." 	aStream nextPutAll: 'nil'! !!TUndefinedObject methodsFor: 'sets support' stamp: 'EstebanAllende 7/2/2012 18:44'!(SetElement) asSetElement	"Since nil is a singleton, we need only a single wrapper instance to represent it in set,	created in advance"	^ SetElement withNil! !!TUndefinedObject methodsFor: 'testing' stamp: 'EstebanAllende 7/2/2012 18:44'!(Self) haltIfNil	self halt! !!TUndefinedObject methodsFor: 'testing' stamp: 'EstebanAllende 10/17/2012 11:55'!(a) ifNil: (→ a)aBlock	"A convenient test, in conjunction with Object ifNil:"	^ aBlock value! !!TUndefinedObject methodsFor: 'testing' stamp: 'EstebanAllende 10/17/2012 11:56'!(a) ifNil: (→a)nilBlock ifNotNil: (→Any|Self→Any)ifNotNilBlock	"Evaluate the block for nil because I'm == nil"	^ nilBlock value! !!TUndefinedObject methodsFor: 'testing' stamp: 'EstebanAllende 10/17/2012 11:56'!(a) ifNil: (→a)nilBlock ifNotNilDo: (Self → Any)ifNotNilBlock	"Evaluate the block for nil because I'm == nil"	^ nilBlock value! !!TUndefinedObject methodsFor: 'testing' stamp: 'EstebanAllende 7/3/2012 00:03'!(Nil) ifNotNil: (→Any|Self→Any)aBlock	"A convenient test, in conjunction with Object ifNotNil:"	^ self! !!TUndefinedObject methodsFor: 'testing' stamp: 'EstebanAllende 10/17/2012 11:56'!(a) ifNotNil: (→Any|Self→Any)ifNotNilBlock ifNil: (→a)nilBlock 	"If I got here, I am nil, so evaluate the block nilBlock"	^ nilBlock value! !!TUndefinedObject methodsFor: 'testing' stamp: 'EstebanAllende 7/2/2012 19:23'!(Nil) ifNotNilDo: (Self→Any)aBlock	"Override to do nothing."	^ self! !!TUndefinedObject methodsFor: 'testing' stamp: 'EstebanAllende 10/17/2012 11:56'!(a) ifNotNilDo: (Self→Any)ifNotNilBlock ifNil: (→a)nilBlock 	"If I got here, I am nil, so evaluate the block nilBlock"	^ nilBlock value! !!TUndefinedObject methodsFor: 'testing' stamp: 'EstebanAllende 7/2/2012 19:24'!(Boolean) isEmptyOrNil	"Answer whether the receiver contains any elements, or is nil.  Useful in numerous situations where one wishes the same reaction to an empty collection or to nil"	^ true! !!TUndefinedObject methodsFor: 'testing' stamp: 'EstebanAllende 7/2/2012 19:24'!(Boolean) isLiteral	^ true! !!TUndefinedObject methodsFor: 'testing' stamp: 'EstebanAllende 7/2/2012 19:24'!(Boolean) isNil 	"Refer to the comment in Object|isNil."	^true! !!TUndefinedObject methodsFor: 'testing' stamp: 'EstebanAllende 7/2/2012 19:24'!(Boolean) notNil 	"Refer to the comment in Object|notNil."	^false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TUndefinedObject class	uses: TTyped classTrait	instanceVariableNames: ''!!TUndefinedObject class methodsFor: 'accessing' stamp: 'EstebanAllende 7/2/2012 19:31'!(Array<Nil>) allInstances	"It is well known there is a single instance"		^Array with: nil! !!TUndefinedObject class methodsFor: 'accessing' stamp: 'EstebanAllende 7/2/2012 19:31'!(Self) allInstancesDo: (Nil → Any)aBlock	"It is well known there is a single instance"		aBlock value: nil! !!TUndefinedObject class methodsFor: 'instance creation' stamp: 'EstebanAllende 7/2/2012 19:32'!(Self instance) new	self error: 'You may not create any more undefined objects--use nil'! !