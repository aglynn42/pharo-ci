'From Pharo1.4a of ''16 June 2011'' [Latest update: #14301] on 21 February 2012 at 10:49:01 pm'!Object subclass: #TUndefinedObject	uses: TTyped	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Objects'!!TUndefinedObject methodsFor: '*Compiler-Kernel' stamp: 'EstebanAllende 2/21/2012 22:19'!(Class) parserClass	^ self class evaluatorClass parserClass! !!TUndefinedObject methodsFor: '*compiler-extensions-deprecated' stamp: 'EstebanAllende 2/21/2012 22:19'!(Class) subclassDefinerClass	"For disjunct class hierarchies -- how should subclasses of nil be evaluated"	self deprecated: 'Use new evaluate request' on: 'December 23th, 2011' in: 'NCAPI'.	^self class evaluatorClass! !!TUndefinedObject methodsFor: '*compiler-frontend' stamp: 'EstebanAllende 2/21/2012 22:19'!(CompilerContext) compilerContext	<original> "For consistency"	^CompilerFrontend compilerContextForClass: nil.! !!TUndefinedObject methodsFor: '*compiler-frontend' stamp: 'EstebanAllende 2/21/2012 22:22'!(Self) printAsIfCompiledOn: (Stream)aStream	"Warning: HACK"	^self printOn: aStream! !!TUndefinedObject methodsFor: '*opalcompiler-core' stamp: 'EstebanAllende 2/21/2012 22:20'!(OCGlobalScope) parseScope	^ OCGlobalScope new! !!TUndefinedObject methodsFor: '*petitparser-converting' stamp: 'EstebanAllende 2/21/2012 22:20'!(PPEpsilonParser) asParser	"Answer a parser that succeeds and does not consume anything."		^ PPEpsilonParser new! !!TUndefinedObject methodsFor: '*prettypetit-converting' stamp: 'EstebanAllende 2/21/2012 22:23'!(PPEmptyDocument) asDocument	^ PPEmptyDocument new! !!TUndefinedObject methodsFor: 'bottom context' stamp: 'EstebanAllende 2/21/2012 22:25'!(Boolean) canHandleSignal: (Exception)exception	"When no more handler (on:do:) context left in sender chain this gets called"	^ false! !!TUndefinedObject methodsFor: 'bottom context' stamp: 'EstebanAllende 2/21/2012 22:25'!(?) handleSignal: (Exception) exception	"When no more handler (on:do:) context left in sender chain this gets called.  Return from signal with default action."	^ exception resumeUnchecked: exception defaultAction! !!TUndefinedObject methodsFor: 'class hierarchy' stamp: 'EstebanAllende 2/21/2012 22:26'!(Self) addSubclass: (Class) aClass	"Ignored -- necessary to support disjoint class hierarchies"! !!TUndefinedObject methodsFor: 'class hierarchy' stamp: 'EstebanAllende 2/21/2012 22:28'!(Self) allSuperclassesDo: (Behavior → Object) aBlockContext 	self shouldBeImplemented! !!TUndefinedObject methodsFor: 'class hierarchy' stamp: 'EstebanAllende 2/21/2012 22:30'!(SystemDictionary) environment	"Necessary to support disjoint class hierarchies."	^self class environment! !!TUndefinedObject methodsFor: 'class hierarchy' stamp: 'EstebanAllende 2/21/2012 22:32'!(Symbol) literalScannedAs: (Symbol)scannedLiteral notifying: (Object)requestor 	^ scannedLiteral! !!TUndefinedObject methodsFor: 'class hierarchy' stamp: 'EstebanAllende 2/21/2012 22:32'!(Self) removeObsoleteSubclass: (Class)aClass	"Ignored -- necessary to support disjoint class hierarchies"! !!TUndefinedObject methodsFor: 'class hierarchy' stamp: 'EstebanAllende 2/21/2012 22:33'!(Self) removeSubclass: (Class) aClass	"Ignored -- necessary to support disjoint class hierarchies"! !!TUndefinedObject methodsFor: 'class hierarchy' stamp: 'EstebanAllende 2/21/2012 22:34'!(Class) subclass: (Symbol)nameOfClass  	instanceVariableNames: (String)instVarNames	classVariableNames: (String) classVarNames	poolDictionaries: (String) poolDictnames	category: (String) category	"Calling this method is now considered an accident.  If you really want to create a class with a nil superclass, then create the class and then set the superclass using #superclass:"	self traceCr: ('Attempt to create ', nameOfClass, ' as a subclass of nil.  Possibly a class is being loaded before its superclass.').	^ProtoObject		subclass: nameOfClass		instanceVariableNames: instVarNames		classVariableNames: classVarNames		poolDictionaries: poolDictnames		category: category! !!TUndefinedObject methodsFor: 'class hierarchy' stamp: 'EstebanAllende 2/21/2012 22:34'!(Array) subclasses	"Return all the subclasses of nil"	| classList |	classList := Array new writeStream.	self subclassesDo:[:class| classList nextPut: class].	^classList contents! !!TUndefinedObject methodsFor: 'class hierarchy' stamp: 'EstebanAllende 2/21/2012 22:38'!(?) subclassesDo: (Class → ?) aBlock	"Evaluate aBlock with all subclasses of nil.  Others are not direct subclasses of Class."	^ Class subclassesDo: [:(ClassDescription)cl | 			cl isMeta ifTrue: [aBlock value: (<Metaclass>cl) soleInstance]].! !!TUndefinedObject methodsFor: 'class hierarchy' stamp: 'EstebanAllende 2/21/2012 22:38'!(Symbol) typeOfClass	"Necessary to support disjoint class hierarchies."	^#normal! !!TUndefinedObject methodsFor: 'copying' stamp: 'EstebanAllende 2/21/2012 22:38'!(Self) deepCopy	"Only one instance of UndefinedObject should ever be made, so answer 	with self."! !!TUndefinedObject methodsFor: 'copying' stamp: 'EstebanAllende 2/21/2012 22:38'!(Self) shallowCopy	"Only one instance of UndefinedObject should ever be made, so answer 	with self."! !!TUndefinedObject methodsFor: 'copying' stamp: 'EstebanAllende 2/21/2012 22:39'!(Self) veryDeepCopyWith: (DeepCopier) deepCopier	"Return self.  I can't be copied.  Do not record me."! !!TUndefinedObject methodsFor: 'dependents access' stamp: 'EstebanAllende 2/21/2012 22:18'!(Self) addDependent: (Object)ignored 	"Refer to the comment in Object|dependents."	self error: 'Nil should not have dependents'! !!TUndefinedObject methodsFor: 'dependents access' stamp: 'EstebanAllende 2/21/2012 22:18'!(Self) release	"Nil release is a no-op"! !!TUndefinedObject methodsFor: 'dependents access' stamp: 'EstebanAllende 2/21/2012 22:19'!(Self) suspend	"Kills off processes that didn't terminate properly"	"Display reverse; reverse."  "<-- So we can catch the suspend bug"	Processor terminateActive! !!TUndefinedObject methodsFor: 'printing' stamp: 'EstebanAllende 2/21/2012 22:39'!(Self) printOn: (Stream) aStream 	"Refer to the comment in Object|printOn:." 	aStream nextPutAll: 'nil'! !!TUndefinedObject methodsFor: 'printing' stamp: 'EstebanAllende 2/21/2012 22:39'!(Self) storeOn: (Stream)aStream 	"Refer to the comment in Object|storeOn:." 	aStream nextPutAll: 'nil'! !!TUndefinedObject methodsFor: 'sets support' stamp: 'EstebanAllende 2/21/2012 22:40'!(SetElement) asSetElement	"Since nil is a singleton, we need only a single wrapper instance to represent it in set,	created in advance"	^ SetElement withNil! !!TUndefinedObject methodsFor: 'testing' stamp: 'EstebanAllende 2/21/2012 22:40'!(Self) haltIfNil	self halt! !!TUndefinedObject methodsFor: 'testing' stamp: 'EstebanAllende 2/21/2012 22:40'!(?) ifNil: (→?)aBlock	"A convenient test, in conjunction with Object ifNil:"	^ aBlock value! !!TUndefinedObject methodsFor: 'testing' stamp: 'EstebanAllende 2/21/2012 22:43'!(?) ifNil: (→?)nilBlock ifNotNil: (BlockClosure)ifNotNilBlock	"Evaluate the block for nil because I'm == nil"	^ nilBlock value! !!TUndefinedObject methodsFor: 'testing' stamp: 'EstebanAllende 2/21/2012 22:44'!(?) ifNil: (→?)nilBlock ifNotNilDo: (BlockClosure)ifNotNilBlock	"Evaluate the block for nil because I'm == nil"	^ nilBlock value! !!TUndefinedObject methodsFor: 'testing' stamp: 'EstebanAllende 2/21/2012 22:45'!(Nil) ifNotNil: (BlockClosure)aBlock	"A convenient test, in conjunction with Object ifNotNil:"	^ self! !!TUndefinedObject methodsFor: 'testing' stamp: 'EstebanAllende 2/21/2012 22:46'!(?) ifNotNil: (BlockClosure)ifNotNilBlock ifNil: (→?)nilBlock 	"If I got here, I am nil, so evaluate the block nilBlock"	^ nilBlock value! !!TUndefinedObject methodsFor: 'testing' stamp: 'EstebanAllende 2/21/2012 22:46'!(Nil) ifNotNilDo: (BlockClosure)aBlock	"Override to do nothing."	^ self! !!TUndefinedObject methodsFor: 'testing' stamp: 'EstebanAllende 2/21/2012 22:47'!(?)ifNotNilDo: (BlockClosure)ifNotNilBlock ifNil: (→?)nilBlock 	"If I got here, I am nil, so evaluate the block nilBlock"	^ nilBlock value! !!TUndefinedObject methodsFor: 'testing' stamp: 'EstebanAllende 2/21/2012 22:47'!(Boolean)isEmptyOrNil	"Answer whether the receiver contains any elements, or is nil.  Useful in numerous situations where one wishes the same reaction to an empty collection or to nil"	^ true! !!TUndefinedObject methodsFor: 'testing' stamp: 'EstebanAllende 2/21/2012 22:47'!(Boolean)isLiteral	^ true! !!TUndefinedObject methodsFor: 'testing' stamp: 'EstebanAllende 2/21/2012 22:47'!(Boolean) isNil	"Refer to the comment in Object|isNil."	^true! !!TUndefinedObject methodsFor: 'testing' stamp: 'EstebanAllende 2/21/2012 22:47'!(Boolean) notNil 	"Refer to the comment in Object|notNil."	^false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TUndefinedObject class	uses: TTyped classTrait	instanceVariableNames: ''!!TUndefinedObject class methodsFor: 'accessing' stamp: 'EstebanAllende 2/21/2012 22:04'!allInstances	"It is well known there is a single instance"		^Array with: nil! !!TUndefinedObject class methodsFor: 'accessing' stamp: 'EstebanAllende 2/21/2012 22:04'!allInstancesDo: aBlock	"It is well known there is a single instance"		aBlock value: nil! !!TUndefinedObject class methodsFor: 'instance creation' stamp: 'EstebanAllende 2/21/2012 22:04'!new	self error: 'You may not create any more undefined objects--use nil'! !