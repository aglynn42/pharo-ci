'From Pharo1.4a of ''16 June 2011'' [Latest update: #14301] on 28 February 2012 at 8:33:27 pm'!ProtoObject subclass: #Object	instanceVariableNames: ''	classVariableNames: 'DependentsFields'	poolDictionaries: ''	category: 'Kernel-Objects'!!Object commentStamp: 'StephaneDucasse 1/3/2010 20:41' prior: 0!Object is the root class for almost all of the other classes in the class hierarchy. The exceptions are ProtoObject (the superclass of Object) and its subclasses.Class Object provides default behavior common to all normal objects, such as access, copying, comparison, error handling, message sending, and reflection. Also utility messages that all objects should respond to are defined here.Object has no instance variables, nor should any be added. This is due to several classes of objects that inherit from Object that have special implementations (SmallInteger and UndefinedObject for example) or the VM knows about and depends on the structure and layout of certain standard classes.Class Variables:	DependentsFields		an IdentityDictionary		Provides a virtual 'dependents' field so that any object may have one		or more dependent views, synchronized by the changed:/update: protocol.		Note that class Model has a real slot for its dependents, and overrides		the associated protocol with more efficient implementations.	EventsFields			an IdentityDictionary that maps each object to its dependents.		Registers a message send (consisting of a selector and a receiver object)		which should be performed when anEventSymbol is triggered by the receiver.		Part of a new event notification framework which could eventually replace		the existing changed/update mechanism.  It is intended to be compatible		with Dolphin Smalltalk and VSE as much as possible.Because Object is the root of the inheritance tree, methods are often defined in Object to give all objects special behaviors needed by certain subsystems or applications, or to respond to certain general test messages such as isMorph.About at: index accepting float and not only integers This behavior is also free in the sense that the failure code is only invoked when theprimitive fails and so adds nothing to the cost of successful accesses,which are the high dynamic frequency operation.  It will also show up underprofiling if one is concerned about efficiency, and so isn't a hidden cost.It is also in keeping with Smalltalk's mixed mode/arbitrary precisionimplicit coercion number system that one *can* use fractions or floats asindices.  Stripping out coercions like this will make the system more brittle.  So please do *not* remove this "hack".  I think it's a feature and a useful  one.Can you give me an example that demonstrates the usefulness of thisfeature?| a r |a := Array new: 10 withAll: 0.r := Random new.100 timesRepeat: [| v | v := r next * 10 + 1. a at: v put: (a at: v) + 1].ai.e. I didn't have to provide an explicit rounding step.  That's useful.  But in general anywhere where an index is derived by some calculation not having to provide the rounding step could be useful/helpful/more concise.  e.g. (n roundTo: 0.1) * 10 vs ((n roundTo: 0.1) * 10) asInteger.Some thought went into the original choice.  It is not a hack but there by intent.  The integers are simply a subset of the reals and forcing the programmer to use them is favouring the machine above the programmer.But I think you should justify getting rid of it rather than my having to justify keeping it.  Getting rid of it risks breaking code.  If it is there but does not harm then why get rid of it?best Eliot Miranda !!Object methodsFor: '*Graphics-Display Objects' stamp: 'EstebanAllende 2/21/2012 01:16'!(Self) printDirectlyToDisplay	"For debugging: write the receiver's printString directly to the display at (0, 100); senders of this are detected by the check-for-slips mechanism."	self asString displayAt: 0@100"StringMorph someInstance printDirectlyToDisplay"! !!Object methodsFor: '*Kernel-Exceptions-debugging' stamp: 'EstebanAllende 12/15/2011 19:32'!(Self) halt	"This is the typical message to use for inserting breakpoints during 	debugging. It behaves like halt:, but does not call on halt: in order to 	avoid putting this message on the stack. Halt is especially useful when 	the breakpoint message is an arbitrary one."	Halt now.! !!Object methodsFor: '*Kernel-Exceptions-debugging' stamp: 'EstebanAllende 12/15/2011 19:33'!(Self) haltIf: (Boolean)condition	Halt if: condition.! !!Object methodsFor: '*Kernel-Exceptions-debugging' stamp: 'EstebanAllende 12/15/2011 19:33'!(Self) haltIfShiftPressed	Halt ifShiftPressed.! !!Object methodsFor: '*Kernel-Exceptions-debugging' stamp: 'EstebanAllende 12/15/2011 19:33'!(Self) haltOnCount: (Integer)anInteger 	Halt onCount: anInteger.! !!Object methodsFor: '*Kernel-Exceptions-debugging' stamp: 'EstebanAllende 12/15/2011 19:34'!(Self) haltOnce	Halt once.! !!Object methodsFor: '*Morphic' stamp: 'EstebanAllende 2/21/2012 01:16'!(MenuMorph) addModelYellowButtonMenuItemsTo: (MenuMorph)aCustomMenu forMorph: (Morph)aMorph hand: (HandMorph)aHandMorph 	"The receiver serves as the model for aMorph; a menu is being constructed for the morph, and here the receiver is able to add its own items"	Morph cmdGesturesEnabled ifTrue: [ "build mode"		aCustomMenu add: 'inspect model' translated target: self action: #inspect.	].	^aCustomMenu! !!Object methodsFor: '*Morphic' stamp: 'EstebanAllende 12/15/2011 19:36'!(Morph) asDraggableMorph	^(StringMorph contents: self asString)		color: Color white;		yourself! !!Object methodsFor: '*Morphic' stamp: 'EstebanAllende 12/15/2011 19:37'!(Morph) asMorph	"Open a morph, as best one can, on the receiver"	^ self asStringMorph	"234 asMorph.(MenuIcons tinyMenuIcon) asMorph.'fred' asMorph."! !!Object methodsFor: '*Morphic' stamp: 'EstebanAllende 12/15/2011 19:37'!(StringMorph) asStringMorph	"Open a StringMorph, as best one can, on the receiver"	^ self asStringOrText asStringMorph! !!Object methodsFor: '*Morphic' stamp: 'EstebanAllende 12/15/2011 19:37'!(TextMorph) asTextMorph	"Open a TextMorph, as best one can, on the receiver"	^ TextMorph new contentsAsIs: self asStringOrText! !!Object methodsFor: '*Morphic' stamp: 'EstebanAllende 2/21/2012 01:17'!(MorphicEvent) currentEvent	"Answer the current Morphic event.  This method never returns nil."	^ActiveEvent ifNil:[self currentHand lastEvent]! !!Object methodsFor: '*Morphic' stamp: 'EstebanAllende 12/15/2011 19:38'!(HandMorph) currentHand	"Return a usable HandMorph -- the one associated with the object's current environment.  This method will always return a hand, even if it has to conjure one up as a last resort.  If a particular hand is actually handling events at the moment (such as a remote hand or a ghost hand), it will be returned."	^ActiveHand ifNil: [ self currentWorld primaryHand ]! !!Object methodsFor: '*Morphic' stamp: 'EstebanAllende 12/15/2011 19:39'!(Morph) currentWorld	"Answer a morphic world that is the current UI focus."	^UIManager default currentWorld! !!Object methodsFor: '*Morphic' stamp: 'BenjaminVanRyseghem 10/7/2011 21:36'!dragPassengersFor: item inMorph: dragSource 	^ { item }! !!Object methodsFor: '*Morphic' stamp: 'EstebanAllende 12/15/2011 19:40'!(String) externalName	"Answer an external name by which the receiver is known. Generic	implementation here is a transitional backstop. probably"	^ [(self asString copyWithout: Character cr)		truncateTo: 27]		ifError: [ ^ self class name printString] ! !!Object methodsFor: '*Morphic' stamp: 'EstebanAllende 12/15/2011 19:41'!(Boolean) hasModelYellowButtonMenuItems	^Morph cmdGesturesEnabled! !!Object methodsFor: '*Morphic' stamp: 'EstebanAllende 2/21/2012 21:05'!(?) iconOrThumbnailOfSize: (?) aNumberOrPoint 	"Answer an appropiate form to represent the receiver"	^ nil! !!Object methodsFor: '*Morphic' stamp: 'EstebanAllende 12/15/2011 19:41'!(Morph) openAsMorph	"Open a morph, as best one can, on the receiver"	^ self asMorph openInHand"234 openAsMorph.(MenuIcons tinyMenuIcon) openAsMorph.'fred' openAsMorph."! !!Object methodsFor: '*Polymorph-EventEnhancements' stamp: 'gvc 10/25/2006 18:18'!when: anEventSelectorsend: aMessageSelectorto: anObjectexclusive: aValueHolder 	self		when: anEventSelector		evaluate: ((ExclusiveWeakMessageSend					receiver: anObject					selector: aMessageSelector)						basicExecuting: aValueHolder)! !!Object methodsFor: '*Polymorph-EventEnhancements' stamp: 'gvc 10/25/2006 18:17'!when: anEventSelectorsend: aMessageSelectorto: anObjectwith: anArgexclusive: aValueHolder     self        when: anEventSelector        evaluate: ((ExclusiveWeakMessageSend 		receiver: anObject		selector: aMessageSelector		arguments: (Array with: anArg))			basicExecuting: aValueHolder)! !!Object methodsFor: '*Polymorph-EventEnhancements' stamp: 'gvc 10/25/2006 18:17'!when: anEventSelectorsend: aMessageSelectorto: anObjectwithArguments: anArgArrayexclusive: aValueHolder     self        when: anEventSelector        evaluate: ((ExclusiveWeakMessageSend		receiver: anObject		selector: aMessageSelector		arguments: anArgArray)			basicExecuting: aValueHolder)! !!Object methodsFor: '*Polymorph-EventEnhancements' stamp: 'gvc 10/24/2006 11:50'!when: anEventSelectorsendOnce: aMessageSelectorto: anObject     self        when: anEventSelector        evaluate: (NonReentrantWeakMessageSend            receiver: anObject            selector: aMessageSelector)! !!Object methodsFor: '*Polymorph-EventEnhancements' stamp: 'gvc 10/24/2006 11:49'!when: anEventSelectorsendOnce: aMessageSelectorto: anObjectwith: anArg     self        when: anEventSelector        evaluate: (NonReentrantWeakMessageSend            receiver: anObject            selector: aMessageSelector		arguments: (Array with: anArg))! !!Object methodsFor: '*Polymorph-EventEnhancements' stamp: 'gvc 10/24/2006 11:49'!when: anEventSelectorsendOnce: aMessageSelectorto: anObjectwithArguments: anArgArray     self        when: anEventSelector        evaluate: (NonReentrantWeakMessageSend            receiver: anObject            selector: aMessageSelector		arguments: anArgArray)! !!Object methodsFor: '*Polymorph-Widgets' stamp: 'EstebanAllende 2/21/2012 21:17'!(Boolean) okToClose	"Sent to models when a window closing.	Allows this check to be independent of okToChange."		^true! !!Object methodsFor: '*Polymorph-Widgets' stamp: 'EstebanAllende 2/21/2012 21:25'!(Form) taskbarIcon	^ self class taskbarIcon! !!Object methodsFor: '*Polymorph-Widgets' stamp: 'EstebanAllende 2/21/2012 21:25'!(String) taskbarLabel	"Answer the label string for the receiver in a task bar	or nil for the default."	^self class taskbarLabel! !!Object methodsFor: '*Ring-Core-Kernel' stamp: 'EstebanAllende 2/21/2012 21:11'!(Boolean) isRingObject	^false! !!Object methodsFor: '*System-Object Storage' stamp: 'EstebanAllende 2/21/2012 20:42'!(Object) comeFullyUpOnReload: (Stream) smartRefStream	"Normally this read-in object is exactly what we want to store. 7/26/96 tk"	^ self! !!Object methodsFor: '*System-Object Storage' stamp: 'EstebanAllende 2/21/2012 21:06'!(Integer) indexIfCompact	^0		"helps avoid a #respondsTo: in publishing"! !!Object methodsFor: '*System-Object Storage' stamp: 'EstebanAllende 2/21/2012 21:15'!(Object) objectForDataStream: (Stream)refStrm    "Return an object to store on an external data stream."    ^ self! !!Object methodsFor: '*System-Object Storage' stamp: 'EstebanAllende 2/21/2012 21:16'!(Self) readDataFrom: (DataStream) aDataStream size: (Integer) varsOnDisk	"Fill in the fields of self based on the contents of aDataStream.  Return self.	 Read in the instance-variables written by Object>>storeDataOn:.	 NOTE: This method must send beginReference: before reading any objects from aDataStream that might reference it.	 Allow aDataStream to have fewer inst vars.  See SmartRefStream."	| cntInstVars cntIndexedVars |	cntInstVars := self class instSize.	self class isVariable		ifTrue: [cntIndexedVars := varsOnDisk - cntInstVars.				cntIndexedVars < 0 ifTrue: [					self error: 'Class has changed too much.  Define a convertxxx method']]		ifFalse: [cntIndexedVars := 0.				cntInstVars := varsOnDisk]. 	"OK if fewer than now"	aDataStream beginReference: self.	1 to: cntInstVars do:		[:(Integer) i | self instVarAt: i put: aDataStream next].	1 to: cntIndexedVars do:		[:(Integer)i | self basicAt: i put: aDataStream next].	"Total number read MUST be equal to varsOnDisk!!"	^ self	"If we ever return something other than self, fix calls 			on (super readDataFrom: aDataStream size: anInteger)"! !!Object methodsFor: '*System-Object Storage' stamp: 'EstebanAllende 2/21/2012 21:17'!(Self) storeDataOn: (DataStream) aDataStream	"Store myself on a DataStream.  Answer self.  This is a low-level DataStream/ReferenceStream method. See also objectToStoreOnDataStream.  NOTE: This method must send 'aDataStream beginInstance:size:' and then (nextPut:/nextPutWeak:) its subobjects.  readDataFrom:size: reads back what we write here."	| cntInstVars cntIndexedVars |	cntInstVars := self class instSize.	cntIndexedVars := self basicSize.	aDataStream		beginInstance: self class		size: cntInstVars + cntIndexedVars.	1 to: cntInstVars do:		[:(Integer)i | aDataStream nextPut: (self instVarAt: i)].	"Write fields of a variable length object.  When writing to a dummy 		stream, don't bother to write the bytes"	((aDataStream byteStream class == DummyStream) and: [self class isBits]) ifFalse: [		1 to: cntIndexedVars do:			[:(Integer)i | aDataStream nextPut: (self basicAt: i)]].! !!Object methodsFor: '*System-Settings-Browser' stamp: 'EstebanAllende 2/21/2012 21:21'!(SettingDeclaration) settingFixedDomainValueNodeFrom: (MultipleSettingDeclaration)aSettingNode 	^ aSettingNode fixedDomainValueNodeForObject: self! !!Object methodsFor: '*System-Settings-Browser' stamp: 'EstebanAllende 2/21/2012 21:22'!(Self) settingStoreOn: (WriteStream) aStream	^ self storeOn: aStream! !!Object methodsFor: '*System-Support' stamp: 'EstebanAllende 2/21/2012 21:23'!(SystemNavigation) systemNavigation	^ SystemNavigation default! !!Object methodsFor: '*Tools-Base' stamp: 'EstebanAllende 2/21/2012 20:48'!(Color) defaultBackgroundColor	"Answer the color to be used as the base window color for a window whose model is an object of the receiver's class"		"I don't want to do a self theme  because otherwise I will need to implement it on Object"	^  UITheme current  windowColorFor: self! !!Object methodsFor: '*Tools-Base' stamp: 'sw 1/18/2001 13:43'!showDiffs	"Answer whether the receiver, serving as the model of a text-bearing entity, is 'showing differences' -- if it is, the editor may wish to show special feedback"	^ false! !!Object methodsFor: '*Tools-Base' stamp: 'EstebanAllende 2/21/2012 21:31'!(Self) updateListsAndCodeIn: (SystemWindow) aWindow	self canDiscardEdits ifFalse: [^ self].	aWindow updatablePanes do: [:aPane | aPane verifyContents]! !!Object methodsFor: '*Tools-Browser' stamp: 'EstebanAllende 2/21/2012 20:39'!(Self) browse	self systemNavigation browseClass: self class! !!Object methodsFor: '*Tools-Browser' stamp: 'EstebanAllende 2/21/2012 20:39'!(Self) browseHierarchy	self systemNavigation browseHierarchy: self class! !!Object methodsFor: '*Tools-Explorer' stamp: 'EstebanAllende 2/21/2012 20:30'!(String) asExplorerString	^ self printString! !!Object methodsFor: '*Tools-Explorer' stamp: 'EstebanAllende 2/21/2012 21:03'!(Boolean) customizeExplorerContents	^ false.! !!Object methodsFor: '*Tools-Explorer' stamp: 'EstebanAllende 2/21/2012 21:00'!(ObjectExplorer) explore	^Smalltalk tools explore: self! !!Object methodsFor: '*Tools-Explorer' stamp: 'EstebanAllende 2/21/2012 21:03'!(Boolean) hasContentsInExplorer	^self basicSize > 0 or: [self class allInstVarNames notEmpty]! !!Object methodsFor: '*Tools-Finder' stamp: 'EstebanAllende 2/21/2012 20:41'!(Boolean) closeTo: (Object)anObject	"Do not use this Method!! It is a workaround for MethodFinder"	^[self = anObject] ifError: [false]! !!Object methodsFor: '*Tools-Finder' stamp: 'pmm 3/13/2010 11:33'!copyTwoLevel	"one more level than a shallowCopy"	"do not use this method we will deprecated soon"	| newObject class index |	class := self class.	newObject := self shallowCopy.	newObject == self ifTrue: [^ self].	class isVariable		ifTrue: 			[index := self basicSize.			[index > 0]				whileTrue: 					[newObject basicAt: index put: (self basicAt: index) shallowCopy.					index := index - 1]].	index := class instSize.	[index > 0]		whileTrue: 			[newObject instVarAt: index put: (self instVarAt: index) shallowCopy.			index := index - 1].	^newObject! !!Object methodsFor: '*Tools-Inspector' stamp: 'EstebanAllende 2/21/2012 20:37'!(Inspector) basicInspect	"Create and schedule an Inspector in which the user can examine the 	receiver's variables. This method should not be overriden."	^Smalltalk tools basicInspect: self! !!Object methodsFor: '*Tools-Inspector' stamp: 'EstebanAllende 2/21/2012 20:48'!(String) defaultLabelForInspector	"Answer the default label to be used for an Inspector window on the receiver."	^ self class name! !!Object methodsFor: '*Tools-Inspector' stamp: 'EstebanAllende 2/21/2012 20:50'!(Self) doExpiredInspectCount	self clearHaltOnce.	self removeHaltCount.	self inspect! !!Object methodsFor: '*Tools-Inspector' stamp: 'EstebanAllende 2/21/2012 21:07'!(Self) inspect	"Create and schedule an Inspector in which the user can examine the receiver's variables."	Smalltalk tools inspect: self! !!Object methodsFor: '*Tools-Inspector' stamp: 'EstebanAllende 2/21/2012 21:07'!(Self) inspectOnCount: (Integer)int 	self haltOnceEnabled		ifTrue: [self hasHaltCount				ifTrue: [self decrementAndCheckHaltCount						ifTrue: [self doExpiredInspectCount]]				ifFalse: [int = 1						ifTrue: [self doExpiredInspectCount]						ifFalse: [self setHaltCountTo: int - 1]]]! !!Object methodsFor: '*Tools-Inspector' stamp: 'EstebanAllende 2/21/2012 21:08'!(Self) inspectOnce	"Inspect unless we have already done it once."	self haltOnceEnabled		ifTrue: [self clearHaltOnce.				^ self inspect]! !!Object methodsFor: '*Tools-Inspector' stamp: 'EstebanAllende 2/21/2012 21:08'!(Self) inspectUntilCount: (Integer) int 	self haltOnceEnabled		ifTrue: [self hasHaltCount				ifTrue: [self decrementAndCheckHaltCount						ifTrue: [self doExpiredInspectCount]						ifFalse: [self inspect]]				ifFalse: [int = 1						ifTrue: [self doExpiredInspectCount]						ifFalse: [self setHaltCountTo: int - 1]]]! !!Object methodsFor: '*Tools-Inspector' stamp: 'EstebanAllende 2/21/2012 21:09'!(Object) inspectWithLabel: (String) aLabel	"Create and schedule an Inspector in which the user can examine the receiver's variables."	^Smalltalk tools inspect: self label: aLabel! !!Object methodsFor: '*Tools-Inspector' stamp: 'EstebanAllende 2/21/2012 21:09'!(Class) inspectorClass	"Answer the class of the inspector to be used on the receiver.  Called by inspect; 	use basicInspect to get a normal (less useful) type of inspector."	^ Smalltalk tools inspector! !!Object methodsFor: '*UIManager' stamp: 'EstebanAllende 2/21/2012 20:43'!(Boolean) confirm: (String) queryString	"Put up a yes/no menu with caption queryString. Answer true if the 	response is yes, false if no. This is a modal question--the user must 	respond yes or no."	"nil confirm: 'Are you hungry?'"	^ UIManager default confirm: queryString! !!Object methodsFor: '*UIManager' stamp: 'EstebanAllende 2/21/2012 20:44'!(Self) inform: (String)aString	"Display a message for the user to read and then dismiss. 6/9/96 sw"	aString isEmptyOrNil ifFalse: [UIManager default inform: aString]! !!Object methodsFor: '*UIManager' stamp: 'EstebanAllende 2/21/2012 20:44'!(Self) primitiveError: (String)aString 	"This method is called when the error handling results in a recursion in 	calling on error: or halt or halt:."	UIManager default onPrimitiveError: aString.! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:35'!checkHaltCountExpired	self deprecated: 'Was used internally by Object>>halt:onCount: See its deprecation warning' on: '8/29/2011' in: '1.4'.! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:56'!clearHaltOnce	"Turn on image-wide Halt once"	self deprecated: 'Use "Halt disableHaltOnce". This method bloats Object and wrongly suggests haltOnce may be per-object' on: '8/29/2011' in: '1.4'.	Halt disableHaltOnce.! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:36'!decrementAndCheckHaltCount	self deprecated: 'Was used internally by Object>>halt:onCount: See its deprecation warning' on: '8/29/2011' in: '1.4'.! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:36'!decrementHaltCount	self deprecated: 'Was used internally by Object>>halt:onCount: See its deprecation warning' on: '8/29/2011' in: '1.4'.! !!Object methodsFor: '*deprecated14' stamp: 'StephaneDucasse 10/8/2011 12:48'!deprecated: anExplanationString	^ self deprecated: anExplanationString on: '8 October 2011'  in: 'Pharo1.4'! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:36'!doExpiredHaltCount	self deprecated: 'Was used internally by Object>>halt:onCount: See its deprecation warning' on: '8/29/2011' in: '1.4'.! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:35'!doExpiredHaltCount: aString	self deprecated: 'Was used internally by Object>>halt:onCount: See its deprecation warning' on: '8/29/2011' in: '1.4'.! !!Object methodsFor: '*deprecated14' stamp: 'StephaneDucasse 10/20/2011 15:43'!halt: aString 		self deprecated: 'Use #halt. Since you end up in a debugger, aString provides little information' on: '8/29/2011' in: '1.4'.	Halt now: aString! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:57'!halt: aString onCount: anInteger 	"Deprecated: see below	Halt on the anInteger-th time through, showing message aString"			| currentCount |	currentCount := Halt isCounting 		ifTrue: [ Halt callsUntilHaltOnCount ]		ifFalse: [				self deprecated: 'Use #haltOnCount:. Since you end up in a debugger, aString provides little information' on: '8/29/2011' in: '1.4'.				anInteger ].	Halt callsUntilHaltOnCount: currentCount - 1.	Halt callsUntilHaltOnCount = 0 ifTrue: [ Halt now ].! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:36'!haltCount	self deprecated: 'Was used internally by Object>>halt:onCount: See its deprecation warning' on: '8/29/2011' in: '1.4'.! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:57'!haltOnce: aString 	"Halt unless we have already done it once."	self deprecated: 'Use #haltOnce:. Since you end up in a debugger, aString provides little information' on: '8/29/2011' in: '1.4'.	Halt isHaltOnceEnabled		ifTrue: [ Halt disableHaltOnce.				^ Halt signal: aString ]! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:57'!haltOnceEnabled	"is haltOnce enabled globally"	self deprecated: 'Use "Halt isHaltOnceEnabled".  This method bloats Object and wrongly suggests haltOnce may be per-object' on: '8/29/2011' in: '1.4'.	^ Halt isHaltOnceEnabled.! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 15:51'!hasHaltCount	self deprecated: 'Now private to Halt' on: '8/29/2011' in: '1.4'.	^ Halt isCounting.! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 15:51'!removeHaltCount	self deprecated: 'Now private to Halt' on: '8/29/2011' in: '1.4'.	^ Halt stopCounting.! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:55'!setHaltCountTo: int	self deprecated: 'Was used internally by Object>>halt:onCount: See its deprecation warning' on: '8/29/2011' in: '1.4'.! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:58'!setHaltOnce	"Turn on the halt once flag."	self deprecated: 'Use "Halt enableHaltOnce".  This method bloats Object and wrongly suggests haltOnce may be per-object' on: '8/29/2011' in: '1.4'.	Halt enableHaltOnce.! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:34'!toggleHaltOnce	self deprecated: 'See Halt for new API' on: '8/29/2011' in: '1.4'.	Halt isHaltOnceEnabled		ifTrue: [Halt disableHaltOnce]		ifFalse: [Halt enableHaltOnce]! !!Object methodsFor: '*petitparser-core-converting' stamp: 'EstebanAllende 2/21/2012 20:31'!(PPParser) asParser	"Answer a parser accepting the receving object."	^ PPPredicateObjectParser expect: self! !!Object methodsFor: '*petitparser-core-testing' stamp: 'EstebanAllende 2/21/2012 21:10'!(Boolean) isPetitFailure	^ false! !!Object methodsFor: '*petitparser-core-testing' stamp: 'EstebanAllende 2/21/2012 21:11'!(Boolean) isPetitParser	^ false! !!Object methodsFor: '*prettypetit-converting' stamp: 'EstebanAllende 2/24/2012 00:42'!(PPDocument) asDocument	^ PPTextDocument string: self printString! !!Object methodsFor: '*system-object storage' stamp: 'EstebanAllende 2/21/2012 20:45'!(Object) convertToCurrentVersion: (Dictionary) varDict refStream: (Stream) smartRefStrm	"subclasses should implement if they wish to convert old instances to modern ones"	"this method should not be removed since SmartRefStream use it"! !!Object methodsFor: '*typesystem-core' stamp: 'EstebanAllende 12/16/2011 18:38'!(Boolean) isType	^false! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 2/24/2012 00:18'!(?) at: (Number) index 	"Primitive. Assumes receiver is indexable. Answer the value of an 	indexable element in the receiver. Fail if the argument index is not an 	Integer or is out of bounds. Essential. See Object documentation 	whatIsAPrimitive. Read the class comment for a discussion about that the fact	that the index can be a float."	<primitive: 60>	index isInteger ifTrue:		[self class isVariable			ifTrue: [^self errorSubscriptBounds: (<Integer>index)]			ifFalse: [^self errorNotIndexable]].	index isNumber		ifTrue: [^self at: index asInteger]		ifFalse: [^self errorNonIntegerIndex]! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 2/21/2012 00:44'!(?) at: (Number) index modify: (? → ?)aBlock	"Replace the element of the collection with itself transformed by the block"	^ self at: index put: (aBlock value: (self at: index))! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 2/24/2012 00:19'!(?) at: (Number)index put: (Object)value 	"Primitive. Assumes receiver is indexable. Store the argument value in 	the indexable element of the receiver indicated by index. Fail if the 	index is not an Integer or is out of bounds. Or fail if the value is not of 	the right type for this kind of collection. Answer the value that was 	stored. Essential. See Object documentation whatIsAPrimitive."	<primitive: 61>	index isInteger ifTrue:		[self class isVariable			ifTrue: [(index >= 1 and: [index <= self size])					ifTrue: [^self errorImproperStore]					ifFalse: [^self errorSubscriptBounds: (<Integer>index)]]			ifFalse: [^self errorNotIndexable]].	index isNumber		ifTrue: [^self at: index asInteger put: value]		ifFalse: [^self errorNonIntegerIndex]! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 2/24/2012 00:19'!(?) basicAt: (Number)index 	"Primitive. Assumes receiver is indexable. Answer the value of an 	indexable element in the receiver. Fail if the argument index is not an 	Integer or is out of bounds. Essential. Do not override in a subclass. See 	Object documentation whatIsAPrimitive."	<primitive: 60>	index isInteger ifTrue: [self errorSubscriptBounds: (<Integer>index)].	index isNumber		ifTrue: [^self basicAt: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 2/24/2012 00:21'!(?) basicAt: (Number)index put: (Object)value 	"Primitive. Assumes receiver is indexable. Store the second argument 	value in the indexable element of the receiver indicated by index. Fail 	if the index is not an Integer or is out of bounds. Or fail if the value is 	not of the right type for this kind of collection. Answer the value that 	was stored. Essential. Do not override in a subclass. See Object 	documentation whatIsAPrimitive."	<primitive: 61>	index isInteger		ifTrue: [(index >= 1 and: [index <= self size])					ifTrue: [self errorImproperStore]					ifFalse: [self errorSubscriptBounds: (<Integer>index)]].	index isNumber		ifTrue: [^self basicAt: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 12/15/2011 19:47'!(Integer)basicSize	"Primitive. Answer the number of indexable variables in the receiver. 	This value is the same as the largest legal subscript. Essential. Do not 	override in any subclass. See Object documentation whatIsAPrimitive."	<primitive: 62>	"The number of indexable fields of fixed-length objects is 0"	^0	! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 2/21/2012 20:35'!(Object) enclosedSetElement	"The receiver is included into a set as an element. 	Since some objects require wrappers (see SetElement) to be able to be included into a Set,	a set sends this message to its element to make sure it getting real object,	instead of its wrapper.	Only SetElement instance or its subclasses allowed to answer something different than receiver itself"	! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 2/21/2012 00:46'!(?)ifNil: (→ ?)nilBlock ifNotNilDo: (Self → ?)aBlock 	"Evaluate aBlock with the receiver as its argument."	^ aBlock value: self! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 2/21/2012 00:46'!(?)ifNotNilDo: (Self → ?)aBlock	"Evaluate the given block with the receiver as its argument."	^ aBlock value: self! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 2/21/2012 00:46'!(?) ifNotNilDo: (Self → ?)aBlock ifNil: (→ ?)nilBlock	"Evaluate aBlock with the receiver as its argument."	^ aBlock value: self! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 2/21/2012 00:46'!(?) in: (Self → ?)aBlock	"Evaluate the given block with the receiver as its argument."	^ aBlock value: self! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 20:33'!(?) readFromString: (String) aString 	"Create an object based on the contents of aString."	^ (<{readFrom: (ReadStream→ ?)}>(<?>self)) readFrom: aString readStream! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 12/16/2011 12:44'!(Integer) size	"Primitive. Answer the number of indexable variables in the receiver. 	This value is the same as the largest legal subscript. Essential. See Object 	documentation whatIsAPrimitive."	<primitive: 62>	self class isVariable ifFalse: [self errorNotIndexable].	^ 0! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 12/16/2011 12:44'!(Self) yourself	"Answer self."	^self! !!Object methodsFor: 'associating' stamp: 'EstebanAllende 12/15/2011 18:01'!(Association) -> (Object)anObject	"Answer an Association between self and anObject"	^Association basicNew key: self value: anObject! !!Object methodsFor: 'binding' stamp: 'EstebanAllende 12/16/2011 12:46'!(Association) bindingOf: (String)aString	^nil! !!Object methodsFor: 'breakpoint' stamp: 'EstebanAllende 12/16/2011 12:46'!(Self) break	"This is a simple message to use for inserting breakpoints during debugging.	The debugger is opened by sending a signal. This gives a chance to restore	invariants related to multiple processes."	BreakPoint signal.	"nil break."! !!Object methodsFor: 'casing' stamp: 'EstebanAllende 12/16/2011 14:32'!(?) caseOf: (Collection) aBlockAssociationCollection	"The elements of aBlockAssociationCollection are associations between blocks.	 Answer the evaluated value of the first association in aBlockAssociationCollection	 whose evaluated key equals the receiver.  If no match is found, report an error."	^ self caseOf: aBlockAssociationCollection otherwise: [self caseError]"| z | z := {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z""| z | z := {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z""The following are compiled in-line:""#b caseOf: {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}""#b caseOf: {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}"! !!Object methodsFor: 'casing' stamp: 'EstebanAllende 2/21/2012 00:47'!(?) caseOf: (Collection) aBlockAssociationCollection otherwise: (→ ?) aBlock	"The elements of aBlockAssociationCollection are associations between blocks.	 Answer the evaluated value of the first association in aBlockAssociationCollection	 whose evaluated key equals the receiver.  If no match is found, answer the result	 of evaluating aBlock."	aBlockAssociationCollection associationsDo:		[:(Association) assoc | (assoc key value = self) ifTrue: [^assoc value value]].	^ aBlock value"| z | z := {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]""| z | z := {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]""The following are compiled in-line:""#b caseOf: {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]""#b caseOf: {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]"! !!Object methodsFor: 'class membership' stamp: 'EstebanAllende 12/16/2011 14:34'!(Self class) class	"Primitive. Answer the object which is the receiver's class. Essential. See 	Object documentation whatIsAPrimitive."	<primitive: 111>	^self primitiveFailed! !!Object methodsFor: 'class membership' stamp: 'EstebanAllende 12/16/2011 14:35'!(Boolean) isKindOf: (Behavior) aClass 	"Answer whether the class, aClass, is a superclass or class of the receiver."	self class == aClass		ifTrue: [^true]		ifFalse: [^self class inheritsFrom: aClass]! !!Object methodsFor: 'class membership' stamp: 'EstebanAllende 12/16/2011 14:35'!(Boolean) isMemberOf: (Behavior) aClass 	"Answer whether the receiver is an instance of the class, aClass."	^self class == aClass! !!Object methodsFor: 'class membership' stamp: 'EstebanAllende 12/16/2011 14:36'!(Boolean) respondsTo: (Symbol) aSymbol 	"Answer whether the method dictionary of the receiver's class contains 	aSymbol as a message selector."	^self class canUnderstand: aSymbol! !!Object methodsFor: 'class membership' stamp: 'EstebanAllende 12/16/2011 14:36'!(Self class) xxxClass	"For subclasses of nil, such as ObjectOut"	^ self class! !!Object methodsFor: 'comparing' stamp: 'EstebanAllende 12/16/2011 14:42'!(Integer) hash	"Answer a SmallInteger whose value is related to the receiver's identity.	May be overridden, and should be overridden in any classes that define = "	^ self identityHash ! !!Object methodsFor: 'comparing' stamp: 'EstebanAllende 12/16/2011 14:37'!(String) identityHashPrintString	"'fred' identityHashPrintString"	^ '(', self identityHash printString, ')'! !!Object methodsFor: 'comparing' stamp: 'EstebanAllende 12/16/2011 14:42'!(Boolean) literalEqual: (Object)other	^ self class == other class and: [self = other]! !!Object methodsFor: 'comparing' stamp: 'EstebanAllende 12/15/2011 18:01'!(Boolean)= (Object)anObject 	"Answer whether the receiver and the argument represent the same 	object. If = is redefined in any subclass, consider also redefining the 	message hash."	^self == anObject ! !!Object methodsFor: 'comparing' stamp: 'EstebanAllende 12/16/2011 14:43'!(Boolean) ~= (Object)anObject 	"Answer whether the receiver and the argument do not represent the 	same object."	^self = anObject == false! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 12/15/2011 18:31'!(Boolean) adaptToFloat: (Float) rcvr andCompare: (Symbol)selector 	"If I am involved in comparison with a Float.	Default behaviour is to process comparison as any other selectors."	^ self adaptToFloat: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 12/15/2011 18:47'!(?) adaptToFloat: (Float)rcvr andSend: (Symbol)selector	"If no method has been provided for adapting an object to a Float,	then it may be adequate to simply adapt it to a number."	^ self adaptToNumber: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 12/15/2011 18:48'!(Boolean) adaptToFraction: (Fraction)rcvr andCompare: (Symbol)selector 	"If I am involved in comparison with a Fraction.	Default behaviour is to process comparison as any other selectors."	^ self adaptToFraction: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 12/15/2011 18:48'!(?) adaptToFraction: (Fraction)rcvr andSend: (Symbol)selector	"If no method has been provided for adapting an object to a Fraction,	then it may be adequate to simply adapt it to a number."	^ self adaptToNumber: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 12/15/2011 18:48'!(Boolean) adaptToInteger: (Integer)rcvr andCompare: (Symbol)selector 	"If I am involved in comparison with an Integer.	Default behaviour is to process comparison as any other selectors."	^ self adaptToInteger: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 12/15/2011 18:49'!(?) adaptToInteger: (Integer)rcvr andSend: (Symbol)selector	"If no method has been provided for adapting an object to a Integer,	then it may be adequate to simply adapt it to a number."	^ self adaptToNumber: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 12/15/2011 18:47'!(?) adaptToNumber: (Number)rcvr andSend: (Symbol)selector	^self error: 'This object does not understand the selector #adaptToNumber:andSend:'! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 12/15/2011 18:49'!(WeakActionSequence) asActionSequence	^WeakActionSequence with: self! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 12/15/2011 18:49'!(WeakActionSequenceTrappingErrors) asActionSequenceTrappingErrors	^WeakActionSequenceTrappingErrors with: self! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 12/15/2011 18:55'!(Link) asLink	"Answer a string that represents the receiver."	^ ValueLink value: self! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 12/15/2011 18:50'!(OrderedCollection) asOrderedCollection	"Answer an OrderedCollection with the receiver as its only element."	^ OrderedCollection with: self! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 2/21/2012 20:32'!(Object) asSetElement	"Answer an object, which can be put into a Set as element , wrapped	by one of SetElement instance, if necessary. 	Default implementation is to answer self"! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 12/15/2011 18:51'!(String) asString	"Answer a string that represents the receiver."	^ self printString ! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 12/15/2011 18:55'!(ArrayedCollection) asStringOrText	"Answer a string that represents the receiver."	^ self printString ! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 12/15/2011 19:23'!(Object) as: (Object class)aSimilarClass	"Create an object of class aSimilarClass that has similar contents to the receiver."	^ aSimilarClass newFrom: self! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 2/21/2012 20:42'!(Object) complexContents	^self! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 12/15/2011 19:26'!(Boolean) mustBeBoolean	"Catches attempts to test truth of non-Booleans.  This message is sent from the VM.  The sending context is rewound to just before the jump causing this exception."	^ self mustBeBooleanIn: thisContext sender! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 12/15/2011 19:27'!(Boolean) mustBeBooleanIn: (ContextPart)context	"context is the where the non-boolean error occurred. Rewind context to before jump then raise error."	| (Object) proceedValue |	context skipBackBeforeJump.	proceedValue := NonBooleanReceiver new		object: self;		signal: 'proceed for truth.'.	^ proceedValue ~~ false! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 12/16/2011 14:44'!(?) withoutListWrapper	^self! !!Object methodsFor: 'copying' stamp: 'EstebanAllende 12/16/2011 14:44'!(Self) copy	"Answer another instance just like the receiver. Subclasses typically override postCopy; they typically do not override shallowCopy. Copy is a template method in the sense of Design Patterns. So do not override it. Override postCopy instead. Pay attention that normally you should call postCopy of your superclass too."	^self shallowCopy postCopy! !!Object methodsFor: 'copying' stamp: 'EstebanAllende 12/16/2011 14:55'!(Self) copyFrom: (Object) anotherObject	"Copy to myself all instance variables I have in common with anotherObject.  This is dangerous because it ignores an object's control over its own inst vars.  "	|(Array)mine (Array)his |	<primitive: 168>	mine := self class allInstVarNames.	his := anotherObject class allInstVarNames.	1 to: (mine size min: his size) do: [:(Integer)ind |		(mine at: ind) = (his at: ind) ifTrue: [			self instVarAt: ind put: (anotherObject instVarAt: ind)]].	self class isVariable & anotherObject class isVariable ifTrue: [		1 to: (self basicSize min: anotherObject basicSize) do: [:(Integer)ind |			self basicAt: ind put: (anotherObject basicAt: ind)]].! !!Object methodsFor: 'copying' stamp: 'EstebanAllende 12/16/2011 14:57'!(Self) copySameFrom: (Object) otherObject	"Copy to myself all instance variables named the same in otherObject.	This ignores otherObject's control over its own inst vars."	|(Array)myInstVars (Array)otherInstVars |	myInstVars := self class allInstVarNames.	otherInstVars := otherObject class allInstVarNames.	myInstVars doWithIndex: [:(String)each :(Integer)index | | (Integer)match |		(match := otherInstVars indexOf: each) > 0 ifTrue:			[self instVarAt: index put: (otherObject instVarAt: match)]].	1 to: (self basicSize min: otherObject basicSize) do: [:(Integer)i |		self basicAt: i put: (otherObject basicAt: i)].! !!Object methodsFor: 'copying' stamp: 'EstebanAllende 12/16/2011 14:59'!(Self) deepCopy	"Answer a copy of the receiver with its own copy of each instance variable. deepCopy does a deep copy. It should never be overridden and only be used if you want to get these very specific semantics.It doesn't handle cycles, #veryDeepCopy does. In the future we will make it handle cycles and deprecate veryDeepCopy"	| (Self)newObject (Self class)class (Integer)index |	class := self class.	(class == Object) ifTrue: [^self].	class isVariable		ifTrue: 			[index := self basicSize.			newObject := class basicNew: index.			[index > 0]				whileTrue: 					[newObject basicAt: index put: (self basicAt: index) deepCopy.					index := index - 1]]		ifFalse: [newObject := class basicNew].	index := class instSize.	[index > 0]		whileTrue: 			[newObject instVarAt: index put: (self instVarAt: index) deepCopy.			index := index - 1].	^newObject! !!Object methodsFor: 'copying' stamp: 'EstebanAllende 12/16/2011 15:01'!(Self) postCopy	"I'm a hook method in the sense of Design Patterns TemplateHook/Methods. I'm called by copy. self is a shallow copy, subclasses should copy fields as necessary to complete the full copy"	^ self ! !!Object methodsFor: 'copying' stamp: 'EstebanAllende 12/16/2011 15:02'!(Self) shallowCopy	"Answer a copy of the receiver which shares the receiver's instance variables. It should never be overridden. I'm invoked from the copy template method. Subclasses that need to specialize the copy should specialize the postCopy hook method."		|(Self class)class (Self)newObject (Integer)index |	<primitive: 148>	class := self class.	class isVariable		ifTrue: 			[index := self basicSize.			newObject := class basicNew: index.			[index > 0]				whileTrue: 					[newObject basicAt: index put: (self basicAt: index).					index := index - 1]]		ifFalse: [newObject := class basicNew].	index := class instSize.	[index > 0]		whileTrue: 			[newObject instVarAt: index put: (self instVarAt: index).			index := index - 1].	^ newObject! !!Object methodsFor: 'copying' stamp: 'EstebanAllende 12/16/2011 15:03'!(Self) veryDeepCopy	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  All references to the object in the copy of the tree will point to the new copy."	| (DeepCopier)copier (Self)new |	copier := DeepCopier new initialize: 4096 "self initialDeepCopierSize".	new := self veryDeepCopyWith: copier.	copier references associationsDo: [:(Association)assoc | 		assoc value veryDeepFixupWith: copier].	copier fixDependents.	^ new! !!Object methodsFor: 'copying' stamp: 'EstebanAllende 2/27/2012 21:55'!(Self) veryDeepCopyWith: (DeepCopier)deepCopier	"Copy me and the entire tree of objects I point to.  An object in the tree twice is copied once, and both references point to him.  deepCopier holds a dictionary of objects we have seen.  Some classes refuse to be copied.  Some classes are picky about which fields get deep copied."	|(Self class)class (Integer)index (Object)sub (Association)subAss (Self)new (Behavior)sup (Boolean)has (Array)mine (CompiledMethod)cm |	deepCopier references at: self ifPresent: [:(Self)newer | ^ newer]. 	"already did him"	class := self class.	class isMeta ifTrue: [^ self].		"a class"	new := self shallowCopy.	deepCopier references at: self put: new.	"remember"	(class isVariable and: [class isPointers]) ifTrue: 		[index := self basicSize.		[index > 0] whileTrue: 			[sub := self basicAt: index.			(subAss := deepCopier references associationAt: sub ifAbsent: [nil])				ifNil: [new basicAt: index put: (sub veryDeepCopyWith: deepCopier)]				ifNotNil: [new basicAt: index put: subAss value].			index := index - 1]].	"Ask each superclass if it wants to share (weak copy) any inst vars"	new veryDeepInner: deepCopier.		"does super a lot"	"other superclasses want all inst vars deep copied"	sup := class.  index := class instSize.	[cm := sup compiledMethodAt: #veryDeepInner: ifAbsent: [nil].	has := cm ifNil: [ false ] ifNotNil: [ true ].	mine := sup instVarNames.	has ifTrue: [index := index - mine size]	"skip inst vars"		ifFalse: [1 to: mine size do: [:xx |				sub := self instVarAt: index.				(subAss := deepCopier references associationAt: sub ifAbsent: [nil])						"use association, not value, so nil is an exceptional value"					ifNil: [new instVarAt: index put: 								(sub veryDeepCopyWith: deepCopier)]					ifNotNil: [new instVarAt: index put: subAss value].				index := index - 1]].	(sup := sup superclass) == nil] whileFalse.	new rehash.	"force Sets and Dictionaries to rehash"	^ new! !!Object methodsFor: 'copying' stamp: 'EstebanAllende 12/16/2011 15:26'!(Self) veryDeepFixupWith: (DeepCopier)deepCopier	"I have no fields and no superclass.  Catch the super call."		"avoid to use me we will deprecate it in the future"! !!Object methodsFor: 'copying' stamp: 'EstebanAllende 12/16/2011 15:27'!(Self) veryDeepInner: (DeepCopier)deepCopier	"No special treatment for inst vars of my superclasses.  Override when some need to be weakly copied.  Object>>veryDeepCopyWith: will veryDeepCopy any inst var whose class does not actually define veryDeepInner:"	"avoid to use me we will deprecate it in the future"! !!Object methodsFor: 'dependents access' stamp: 'EstebanAllende 12/16/2011 15:27'!(?) addDependent: (Object)anObject	"Make the given object one of the receiver's dependents."	|(Collection)dependents |	dependents := self dependents.	(dependents includes: anObject) ifFalse:		[self myDependents: (dependents copyWithDependent: anObject)].	^ anObject! !!Object methodsFor: 'dependents access' stamp: 'EstebanAllende 12/16/2011 15:28'!(Self) breakDependents	"Remove all of the receiver's dependents."	self myDependents: nil! !!Object methodsFor: 'dependents access' stamp: 'EstebanAllende 12/16/2011 15:28'!(Boolean) canDiscardEdits	"Answer true if none of the views on this model has unaccepted edits that matter."	self dependents		do: [:(Object)each | each canDiscardEdits ifFalse: [^ false]]		without: self.	^ true! !!Object methodsFor: 'dependents access' stamp: 'EstebanAllende 12/16/2011 15:29'!(Collection) dependents	"Answer a collection of objects that are 'dependent' on the receiver;	 that is, all objects that should be notified if the receiver changes."	^ self myDependents ifNil: [#()]! !!Object methodsFor: 'dependents access' stamp: 'EstebanAllende 12/16/2011 15:29'!(Boolean) hasUnacceptedEdits	"Answer true if any of the views on this object has unaccepted edits."	self dependents		do: [:(Object)each | each hasUnacceptedEdits ifTrue: [^ true]]		without: self.	^ false! !!Object methodsFor: 'dependents access' stamp: 'EstebanAllende 12/16/2011 15:30'!(Collection) myDependents	<access: #private>	"Private. Answer a list of all the receiver's dependents."	^ DependentsFields at: self ifAbsent: []! !!Object methodsFor: 'dependents access' stamp: 'EstebanAllende 12/16/2011 15:31'!(Self) myDependents: (Collection)aCollectionOrNil	<access: #private>	"Private. Set (or remove) the receiver's dependents list."	aCollectionOrNil		ifNil: [DependentsFields removeKey: self ifAbsent: []]		ifNotNil: [DependentsFields at: self put: aCollectionOrNil]! !!Object methodsFor: 'dependents access' stamp: 'EstebanAllende 12/16/2011 15:31'!(Self) release	"Remove references to objects that may refer to the receiver. This message 	should be overridden by subclasses with any cycles, in which case the 	subclass should also include the expression super release."	self releaseActionMap! !!Object methodsFor: 'dependents access' stamp: 'EstebanAllende 12/16/2011 15:32'!(?)removeDependent: (Object)anObject	"Remove the given object as one of the receiver's dependents."	| dependents |	dependents := self dependents reject: [:(Object)each | each == anObject].	self myDependents: (dependents isEmpty ifFalse: [dependents]).	^ anObject! !!Object methodsFor: 'drag and drop' stamp: 'EstebanAllende 2/21/2012 01:19'!(Boolean) acceptDroppingMorph: (TransferMorph)transferMorph event: (MorphicEvent)evt inMorph: (Morph)dstListMorph 		^false.! !!Object methodsFor: 'drag and drop' stamp: 'EstebanAllende 12/16/2011 15:33'!(?)dragPassengerFor: (?)item inMorph: (Morph) dragSource 	^item! !!Object methodsFor: 'drag and drop' stamp: 'EstebanAllende 12/16/2011 15:34'!(Symbol) dragTransferType	^nil! !!Object methodsFor: 'drag and drop' stamp: 'EstebanAllende 12/16/2011 15:34'!(Symbol) dragTransferTypeForMorph: (Morph)dragSource 	^nil! !!Object methodsFor: 'drag and drop' stamp: 'EstebanAllende 2/21/2012 01:21'!(Boolean) wantsDroppedMorph: (Morph) aMorph event: (MorphicEvent)anEvent inMorph: (Morph) destinationLM 	^false ! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 2/21/2012 20:32'!(Self) assert: (→ Boolean)aBlock	"Throw an assertion error if aBlock does not evaluates to true."		aBlock value ifFalse: [AssertionFailure signal: 'Assertion failed']! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 2/21/2012 20:32'!(Self) assert: (→ Boolean)aBlock descriptionBlock: (→ Object)descriptionBlock	"Throw an assertion error if aBlock does not evaluate to true."		aBlock value ifFalse: [AssertionFailure signal: descriptionBlock value asString ]! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 2/21/2012 20:33'!(Self) assert: (→Boolean)aBlock description: (String)aString	"Throw an assertion error if aBlock does not evaluates to true."		aBlock value ifFalse: [AssertionFailure signal: aString ]! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 12/16/2011 15:52'!(?) caseError	"Report an error from an in-line or explicit case statement."	^self error: 'Case not found (', self printString, '), and no otherwise clause'! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 2/21/2012 00:44'!(Boolean) confirm: (String)aString orCancel: (→Boolean)cancelBlock	"Put up a yes/no/cancel menu with caption aString. Answer true if  	the response is yes, false if no. If cancel is chosen, evaluate  	cancelBlock. This is a modal question--the user must respond yes or no."	^ UIManager default confirm: aString orCancel: cancelBlock! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 12/16/2011 15:40'!(Self) deprecated: (String)anExplanationString on: (String)date in: (String)version	"Warn that the sending method has been deprecated"		(Deprecation		method: thisContext sender method		explanation: anExplanationString		on: date		in: version) signal! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 2/21/2012 20:51'!(?) doesNotUnderstand: (Message)aMessage 	 "Handle the fact that there was an attempt to send the given message to the receiver but the receiver does not understand this message (typically sent from the machine when a message is sent to the receiver and no method is defined for that selector)."	"Testing: (3 activeProcess)"	"fixed suggested by Eliot miranda to make sure 		[Object new blah + 1] 		on: MessageNotUnderstood 		do: [:e | e resume: 1] does not loop indefinitively"			|(MessageNotUnderstood)exception (?)resumeValue |	(exception := MessageNotUnderstood new)		message: aMessage;		receiver: self.	resumeValue := exception signal.	^exception reachedDefaultHandler		ifTrue: [aMessage sentTo: self]		ifFalse: [resumeValue]! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 12/16/2011 15:49'!(Self) dpsTrace: (Object)reportObject  	Transcript myDependents isNil ifTrue: [^self].	self dpsTrace: reportObject levels: 1 withContext: thisContext		" nil dpsTrace: 'sludder'. "! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 12/16/2011 15:49'!(Self) dpsTrace: (Object)reportObject levels: (Integer)anInt	self dpsTrace: reportObject levels: anInt withContext: thisContext"(1 to: 3) do: [:int | nil dpsTrace: int levels: 5.]"! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 12/16/2011 16:01'!(Self) dpsTrace: (Object)reportObject levels: (Integer)anInt withContext: (ContextPart)currentContext	|(String)reportString (ContextPart)context (Boolean)displayCount |	self flag: #WTF.	reportString := (reportObject respondsTo: #asString)  "useless test"		ifTrue: [ reportObject asString ]		ifFalse: [ reportObject printString ].	(Smalltalk globals at: #Decompiler ifAbsent: [ nil ])		ifNil: [ 			Transcript				cr;				show: reportString ]		ifNotNil: [ 			context := currentContext.			displayCount := anInt > 1.			1 to: anInt do: [ :(Integer)count | 				Transcript cr.				displayCount					ifTrue: [ Transcript show: count printString , ': ' ].				reportString notNil					ifTrue: [ 						Transcript show: context home class name , '/' , context sender selector , ' (' , reportString , ')'.						context := context sender.						reportString := nil ]					ifFalse: [ 						(context notNil and: [ (context := context sender) notNil ])							ifTrue: [ Transcript show: context receiver class name , '/' , context selector ] ] ]	"Transcript cr" ]! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 12/16/2011 15:52'!(?)error	"Throw a generic Error exception."	^self error: 'Error!!'.! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 12/16/2011 15:52'!(?) error: (String)aString 	"Throw a generic Error exception."	^Error new signal: aString! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 12/16/2011 16:00'!(UndefinedObject) explicitRequirement	self error: 'Explicitly required method'.	^nil! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 12/16/2011 16:00'!(Boolean) handles: (Exception)exception	"This method exists in case a non exception class is the first arg in an on:do: (for instance using a exception class that is not loaded). We prefer this to raising an error during error handling itself. Also, semantically it makes sense that the exception handler is not active if its exception class is not loaded"	^ false! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 12/16/2011 15:58'!(Self) notify: (String) aString 	"Create and schedule a Notifier with the argument as the message in 	order to request confirmation before a process can proceed."	Warning signal: aString! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 12/16/2011 15:58'!(Self) notify: (String) aString at: (Integer) location	"Create and schedule a Notifier with the argument as the message in 	order to request confirmation before a process can proceed. Subclasses can	override this and insert an error message at location within aString."	self notify: aString	"nil notify: 'confirmation message' at: 12"! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 12/16/2011 15:57'!(Self) primitiveFail	"primitiveFail may be invoked by certain methods whose code is translated in C. In such a case primitiveFail and not primitiveFailed	 should be invoked. The reason is that this code is translated to C by VMMaker. #primitiveFail is 	implemented in Interpreter of VMMaker."	^ self primitiveFailed! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 12/16/2011 15:56'!(Nil)primitiveFailed	"Announce that a primitive has failed and there is no appropriate Smalltalk code to run."	^self primitiveFailed: thisContext sender selector! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 12/16/2011 15:57'!(Nil) primitiveFailed: (Symbol)selector	"Announce that a primitive has failed and there is no appropriate Smalltalk code to run."		PrimitiveFailed signalFor: selector.	^nil! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 12/16/2011 15:55'!(UndefinedObject) requirement	self error: 'Implicitly required method'.	^nil.! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 12/16/2011 15:54'!(UndefinedObject) shouldBeImplemented	"Announce that this message should be implemented"	ShouldBeImplemented signalFor: thisContext sender selector.	^nil! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 12/16/2011 15:54'!(UndefinedObject) shouldNotImplement	"Announce that, although the receiver inherits this message, 	it should not implement it."	ShouldNotImplement signalFor: thisContext sender selector.	^nil.! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 12/16/2011 15:52'!(UndefinedObject) subclassResponsibility	"This message sets up a framework for the behavior of the class' subclasses.	Announce that the subclass should have implemented this message."	SubclassResponsibility signalFor: thisContext sender selector.	^nil! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 2/21/2012 21:26'!(Self) traitConflict	self error: 'A class or trait does not properly resolve a conflict between multiple traits it uses.'! !!Object methodsFor: 'evaluating' stamp: 'EstebanAllende 12/16/2011 16:01'!(?) value	^self! !!Object methodsFor: 'evaluating' stamp: 'EstebanAllende 12/16/2011 16:02'!(?) valueWithArguments: (Collection) aSequenceOfArguments	^self! !!Object methodsFor: 'events-accessing' stamp: 'EstebanAllende 2/21/2012 00:30'!(Object)actionForEvent: ({asSymbol (→ Symbol)})anEventSelector    "Answer the action to be evaluated when <anEventSelector> has been triggered."	| ({asMinimalRepresentation (→ Object)})actions |	actions := self actionMap		at: anEventSelector asSymbol		ifAbsent: [nil].	actions ifNil: [^nil].	^ actions asMinimalRepresentation! !!Object methodsFor: 'events-accessing' stamp: 'EstebanAllende 2/21/2012 00:31'!(Object)actionForEvent: ({asSymbol (→ Symbol)})anEventSelectorifAbsent: (→ Object)anExceptionBlock    "Answer the action to be evaluated when <anEventSelector> has been triggered."	| ({asMinimalRepresentation (→ Object)})actions |	actions := self actionMap		at: anEventSelector asSymbol		ifAbsent: [nil].	actions ifNil: [^anExceptionBlock value].	^ actions asMinimalRepresentation! !!Object methodsFor: 'events-accessing' stamp: 'EstebanAllende 12/15/2011 18:20'!(Dictionary) actionMap	^EventManager actionMapFor: self! !!Object methodsFor: 'events-accessing' stamp: 'EstebanAllende 2/21/2012 00:31'!(WeakActionSequence) actionSequenceForEvent: ({asSymbol (→ Symbol)}) anEventSelector    ^(self actionMap        at: anEventSelector asSymbol        ifAbsent: [^WeakActionSequence new])            asActionSequence! !!Object methodsFor: 'events-accessing' stamp: 'EstebanAllende 2/21/2012 00:31'!(Self) actionsDo: (? → Object)aBlock	self actionMap do: aBlock! !!Object methodsFor: 'events-accessing' stamp: 'EstebanAllende 12/16/2011 16:03'!(Dictionary) createActionMap	^IdentityDictionary new! !!Object methodsFor: 'events-accessing' stamp: 'EstebanAllende 2/21/2012 00:31'!(Boolean) hasActionForEvent: ({asSymbol (→Symbol)})anEventSelector    "Answer true if there is an action associated with anEventSelector"    ^(self actionForEvent: anEventSelector) notNil! !!Object methodsFor: 'events-accessing' stamp: 'EstebanAllende 2/21/2012 00:35'!(Boolean) hasActionsWithReceiver: (Object) anObject	^self actionMap keys anySatisfy:		[:({asSymbol (→ Symbol)}) eachEventSelector |			(self actionSequenceForEvent: eachEventSelector)				anySatisfy: [:anAction | anAction receiver == anObject]]! !!Object methodsFor: 'events-accessing' stamp: 'EstebanAllende 2/21/2012 00:53'!(Self) setActionSequence: ({asMinimalRepresentation (→ ?)}) actionSequence          forEvent: ({asSymbol (→ Symbol)})anEventSelector    | (Object)action |    action := actionSequence asMinimalRepresentation.    action == nil        ifTrue:            [self removeActionsForEvent: anEventSelector]        ifFalse:            [self updateableActionMap                at: anEventSelector asSymbol                put: action]! !!Object methodsFor: 'events-accessing' stamp: 'EstebanAllende 12/16/2011 16:11'!(Dictionary) updateableActionMap	^EventManager updateableActionMapFor: self! !!Object methodsFor: 'events-registering' stamp: 'EstebanAllende 2/21/2012 00:37'!(Self) when: ({asSymbol (→ Symbol)})anEventSelector evaluate: ({asMinimalRepresentation (→ ?)})anAction 	|(WeakActionSequence)actions |	actions := self actionSequenceForEvent: anEventSelector.	(actions includes: anAction)		ifTrue: [^ self].	self 		setActionSequence: (actions copyWith: anAction)		forEvent: anEventSelector! !!Object methodsFor: 'events-registering' stamp: 'EstebanAllende 2/21/2012 00:37'!(Self) when: ({asSymbol (→ Symbol)})anEventSelectorsend: (Symbol)aMessageSelectorto: (Object)anObject     self        when: anEventSelector        evaluate: (WeakMessageSend            receiver: anObject            selector: aMessageSelector)! !!Object methodsFor: 'events-registering' stamp: 'EstebanAllende 2/21/2012 00:37'!(Self) when: ({asSymbol (→ Symbol)})anEventSelectorsend: (Symbol)aMessageSelectorto: (Object)anObjectwithArguments: (Array)anArgArray     self        when: anEventSelector        evaluate: (WeakMessageSend            receiver: anObject            selector: aMessageSelector		arguments: anArgArray)! !!Object methodsFor: 'events-registering' stamp: 'EstebanAllende 2/21/2012 00:37'!(Self)when: ({asSymbol (→ Symbol)})anEventSelectorsend: (Symbol)aMessageSelectorto: (Object)anObjectwith: (Array)anArg     self        when: anEventSelector        evaluate: (WeakMessageSend            receiver: anObject            selector: aMessageSelector		arguments: (Array with: anArg))! !!Object methodsFor: 'events-removing' stamp: 'EstebanAllende 12/16/2011 16:18'!(Self) releaseActionMap	EventManager releaseActionMapFor: self! !!Object methodsFor: 'events-removing' stamp: 'EstebanAllende 2/21/2012 00:38'!(Self) removeActionsForEvent: ({asSymbol (→ Symbol)})anEventSelector    | (Dictionary)map |    map := self actionMap.    map removeKey: anEventSelector asSymbol ifAbsent: [].    map isEmpty        ifTrue: [self releaseActionMap]! !!Object methodsFor: 'events-removing' stamp: 'EstebanAllende 2/21/2012 00:38'!(Self)removeActionsSatisfying: (? → Boolean)aBlock	self actionMap keys do:		[:({asSymbol (→ Symbol)})eachEventSelector |			self   				removeActionsSatisfying: aBlock				forEvent: eachEventSelector		]! !!Object methodsFor: 'events-removing' stamp: 'EstebanAllende 2/21/2012 00:38'!(Self)removeActionsSatisfying: (? → Boolean)aOneArgBlock forEvent: ({asSymbol (→ Symbol)})anEventSelector    self        setActionSequence:            ((self actionSequenceForEvent: anEventSelector)                reject: [:(Object)anAction | aOneArgBlock value: anAction])        forEvent: anEventSelector! !!Object methodsFor: 'events-removing' stamp: 'EstebanAllende 2/21/2012 00:39'!(Self) removeActionsWithReceiver: (Object)anObject	self actionMap copy keysDo:		[:({asSymbol (→ Symbol)})eachEventSelector |			self   				removeActionsSatisfying: [:({receiver (→ ?)})anAction | anAction receiver == anObject]				forEvent: eachEventSelector		]! !!Object methodsFor: 'events-removing' stamp: 'EstebanAllende 2/21/2012 00:39'!(Self)removeActionsWithReceiver: (Object)anObjectforEvent: ({asSymbol (→ Symbol)})anEventSelector    self        removeActionsSatisfying:            [:({receiver (→ ?)})anAction |            anAction receiver == anObject]        forEvent: anEventSelector! !!Object methodsFor: 'events-removing' stamp: 'EstebanAllende 2/21/2012 00:39'!(Self) removeAction: (Object)anActionforEvent: ({asSymbol (→ Symbol)})anEventSelector    self        removeActionsSatisfying: [:action | action = anAction]        forEvent: anEventSelector! !!Object methodsFor: 'events-triggering' stamp: 'EstebanAllende 2/21/2012 21:27'!(?) triggerEvent: ({asSymbol (→ Symbol)})anEventSelector	"Evaluate all actions registered for <anEventSelector>. Return the value of the last registered action."    ^(self actionForEvent: anEventSelector) value! !!Object methodsFor: 'events-triggering' stamp: 'EstebanAllende 2/21/2012 00:40'!(?)triggerEvent: ({asSymbol (→ Symbol)})anEventSelectorifNotHandled: (→ ?)anExceptionBlock	"Evaluate all actions registered for <anEventSelector>. Return the value of the last registered action."    ^(self 		actionForEvent: anEventSelector		ifAbsent: [^anExceptionBlock value]) value! !!Object methodsFor: 'events-triggering' stamp: 'EstebanAllende 2/21/2012 00:40'!(?) triggerEvent: ({asSymbol (→ Symbol)})anEventSelectorwithArguments: (Array)anArgumentList    ^(self actionForEvent: anEventSelector)        valueWithArguments: anArgumentList! !!Object methodsFor: 'events-triggering' stamp: 'EstebanAllende 2/21/2012 01:09'!(?)triggerEvent: ({asSymbol (→ Symbol)})anEventSelectorwithArguments: (Array)anArgumentListifNotHandled: (→ ?)anExceptionBlock    ^(self 		actionForEvent: anEventSelector		ifAbsent: [^anExceptionBlock value])        valueWithArguments: anArgumentList! !!Object methodsFor: 'events-triggering' stamp: 'EstebanAllende 2/21/2012 00:40'!(?)triggerEvent: ({asSymbol (→ Symbol)})anEventSelectorwith: (Object)anObject    ^self 		triggerEvent: anEventSelector		withArguments: (Array with: anObject)! !!Object methodsFor: 'events-triggering' stamp: 'EstebanAllende 2/21/2012 00:40'!(?)triggerEvent: ({asSymbol (→ Symbol)})anEventSelectorwith: (Object)anObjectifNotHandled: (→ ?)anExceptionBlock    ^self 		triggerEvent: anEventSelector		withArguments: (Array with: anObject)		ifNotHandled: anExceptionBlock! !!Object methodsFor: 'filter streaming' stamp: 'EstebanAllende 12/16/2011 16:28'!elementSeparator	self flag: #DEAD.	^nil.! !!Object methodsFor: 'filter streaming' stamp: 'EstebanAllende 12/16/2011 16:29'!(Self) putOn:(Stream)aStream	^aStream nextPut:self.! !!Object methodsFor: 'finalization' stamp: 'EstebanAllende 12/15/2011 18:04'!(Self) actAsExecutor	"Prepare the receiver to act as executor for any resources associated with it"	self breakDependents! !!Object methodsFor: 'finalization' stamp: 'EstebanAllende 12/16/2011 16:30'!(Self) executor	"Return an object which can act as executor for finalization of the receiver"	^self shallowCopy actAsExecutor! !!Object methodsFor: 'finalization' stamp: 'EstebanAllende 12/16/2011 16:31'!(WeakRegistry) finalizationRegistry	"Answer the finalization registry associated with the receiver."	^WeakRegistry default! !!Object methodsFor: 'finalization' stamp: 'EstebanAllende 12/16/2011 16:31'!(Self) finalize	"Finalize the resource associated with the receiver. This message should only be sent during the finalization process. There is NO garantuee that the resource associated with the receiver hasn't been free'd before so take care that you don't run into trouble - this all may happen with interrupt priority."! !!Object methodsFor: 'finalization' stamp: 'EstebanAllende 12/16/2011 16:31'!(Boolean) hasMultipleExecutors	"All objects, except ObjectFinalizerCollection instances should answer false to this message"	^ false! !!Object methodsFor: 'finalization' stamp: 'EstebanAllende 2/21/2012 00:54'!(?) retryWithGC: (→ ?)execBlock until: (? → Boolean)testBlock	"Retry execBlock as long as testBlock returns false. Do an incremental GC after the first try, a full GC after the second try."	| blockValue |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!Object methodsFor: 'finalization' stamp: 'EstebanAllende 12/16/2011 16:35'!(Self) toFinalizeSend: (Symbol)aSelector to: (Object)aFinalizer with: (Object)aResourceHandle	"When I am finalized (e.g., garbage collected) close the associated resource handle by sending aSelector to the appropriate finalizer (the guy who knows how to get rid of the resource).	WARNING: Neither the finalizer nor the resource handle are allowed to reference me. If they do, then I will NEVER be garbage collected. Since this cannot be validated here, it is up to the client to make sure this invariant is not broken."	self == aFinalizer ifTrue:[self error: 'I cannot finalize myself'].	self == aResourceHandle ifTrue:[self error: 'I cannot finalize myself'].	^self finalizationRegistry add: self executor:		(ObjectFinalizer new			receiver: aFinalizer			selector: aSelector			argument: aResourceHandle)! !!Object methodsFor: 'flagging' stamp: 'EstebanAllende 12/16/2011 16:36'!(Self) isThisEverCalled	^ self isThisEverCalled: thisContext sender printString! !!Object methodsFor: 'flagging' stamp: 'EstebanAllende 12/16/2011 16:35'!(Self) isThisEverCalled: (Object)msg	"Send this message, with some useful printable argument, from methods or branches of methods which you believe are never reached.  2/5/96 sw"	Halt halt: 'This is indeed called: ', msg printString! !!Object methodsFor: 'flagging' stamp: 'EstebanAllende 12/16/2011 16:36'!(Self) logEntry	Transcript show: 'Entered ', thisContext sender printString; cr.! !!Object methodsFor: 'flagging' stamp: 'EstebanAllende 12/16/2011 16:36'!(Self) logExecution	Transcript show: 'Executing ', thisContext sender printString; cr.! !!Object methodsFor: 'flagging' stamp: 'EstebanAllende 12/16/2011 16:36'!(Self)logExit	Transcript show:  'Exited ', thisContext sender printString; cr.! !!Object methodsFor: 'logging-Deprecated' stamp: 'StephaneDucasse 11/7/2011 22:43'!crLog      self crTrace: self printString! !!Object methodsFor: 'logging-Deprecated' stamp: 'StephaneDucasse 5/27/2011 19:09'!crLog: aString	"Log the argument. Use self log: instead of Transcript cr; show: "		Transcript cr; show: aString.! !!Object methodsFor: 'logging-Deprecated' stamp: 'StephaneDucasse 5/23/2011 22:09'!log: aString	"Log the argument. Use self log: instead of Transcript show: "		Transcript show: aString.! !!Object methodsFor: 'logging-Deprecated' stamp: 'StephaneDucasse 11/5/2011 10:49'!logCr      self logCr: self printString! !!Object methodsFor: 'logging-Deprecated' stamp: 'StephaneDucasse 5/23/2011 22:09'!logCr: aString	"Log the argument. Use self logCr: 'something' instead of Transcript show: 'something'  ; cr "		Transcript show: aString ; cr! !!Object methodsFor: 'logging-Deprecated' stamp: 'StephaneDucasse 5/27/2011 19:07'!logCrTab: aString	"Log the argument. Use self logCr: 'something' instead of Transcript show: 'something'  ; cr ; tab"		Transcript show: aString ; cr ; tab! !!Object methodsFor: 'macpal' stamp: 'EstebanAllende 12/16/2011 16:37'!(Self) contentsChanged	self changed: #contents! !!Object methodsFor: 'macpal' stamp: 'EstebanAllende 12/16/2011 16:38'!(Self) flash	"Do nothing."! !!Object methodsFor: 'macpal' stamp: 'EstebanAllende 12/16/2011 16:40'!(Boolean) refusesToAcceptCode	"Answer whether the receiver is a code-bearing instrument which at the moment refuses to allow its contents to be submitted"	^ false	! !!Object methodsFor: 'memory usage' stamp: 'EstebanAllende 12/16/2011 16:42'!(Integer) sizeInMemory    "Answer the number of bytes consumed by this instance including object header."    |(Integer)contentBytes |	contentBytes := Smalltalk wordSize. "base header"	contentBytes := contentBytes + (self class instSize * Smalltalk wordSize). "instance vars"	self class isVariable ifTrue:[ | (SmallInteger)bytesPerElement | "indexed elements"		bytesPerElement := self class isBytes ifTrue: [1] ifFalse: [4].		contentBytes := contentBytes + (self basicSize * bytesPerElement)	].	contentBytes > 255 ifTrue:	[ contentBytes := contentBytes +  (2 * Smalltalk wordSize) ]						ifFalse:	[ self class indexIfCompact > 0 									ifFalse: [ contentBytes := contentBytes + Smalltalk wordSize]								].	^contentBytes! !!Object methodsFor: 'message handling' stamp: 'EstebanAllende 12/16/2011 16:43'!(?) perform: (Symbol) aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Object methodsFor: 'message handling' stamp: 'EstebanAllende 12/16/2011 16:43'!(?)perform: (Symbol)selector orSendTo: (Object)otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!Object methodsFor: 'message handling' stamp: 'EstebanAllende 12/16/2011 16:46'!(?) perform: (Symbol)selector withArguments: (Array)argArray 	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Fail if the number of arguments expected by the selector 	does not match the size of argArray.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 84>	^ self perform: selector withArguments: argArray inSuperclass: self class! !!Object methodsFor: 'message handling' stamp: 'EstebanAllende 2/21/2012 01:38'!(?) perform: (Symbol)selector withArguments: (Array)argArray inSuperclass: (Behavior)lookupClass	"NOTE:  This is just like perform:withArguments:, except that	the message lookup process begins, not with the receivers's class,	but with the supplied superclass instead.  It will fail if lookupClass	cannot be found among the receiver's superclasses.	Primitive. Essential. See Object documentation whatIsAPrimitive."	<primitive: 100>	(selector isSymbol)		ifFalse: [^ self error: 'selector argument must be a Symbol'].	(selector numArgs = argArray size)		ifFalse: [^ self error: 'incorrect number of arguments'].	(self class == lookupClass or: [self class inheritsFrom: lookupClass])		ifFalse: [^ self error: 'lookupClass is not in my inheritance chain'].	self primitiveFailed! !!Object methodsFor: 'message handling' stamp: 'EstebanAllende 12/16/2011 16:50'!(?) perform: (Symbol)selector withEnoughArguments: (Array)anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| (Integer)numArgs (Array)args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!Object methodsFor: 'message handling' stamp: 'EstebanAllende 12/16/2011 16:51'!(?)perform: (Symbol)aSymbol with: (Object)anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Object methodsFor: 'message handling' stamp: 'EstebanAllende 12/16/2011 16:51'!(?)perform: (Symbol)aSymbol with: (Object)firstObject with: (Object)secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Object methodsFor: 'message handling' stamp: 'EstebanAllende 12/16/2011 16:52'!(?) perform: (Symbol)aSymbol with: (Object)firstObject with: (Object)secondObject with: (Object)thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 83>	^ self perform: aSymbol		withArguments: (Array with: firstObject with: secondObject with: thirdObject)! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 12/16/2011 16:52'!(String)fullPrintString	"Answer a String whose characters are a description of the receiver."	^ String streamContents: [:(Stream)s | self printOn: s]! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 12/16/2011 16:52'!(Boolean) isLiteral	"Answer whether the receiver has a literal text form recognized by the 	compiler."	^false! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 2/21/2012 00:56'!(Self) longPrintOn: (Stream{space (→ Object) . tab (→ Object) . cr (→ Object)})aStream	"Append to the argument, aStream, the names and values of all 	of the receiver's instance variables."	self class allInstVarNames doWithIndex:		[:(String)title :(Integer)index |		aStream nextPutAll: title;		 nextPut: $:;		 space;		 tab;		 print: (self instVarAt: index);		 cr]! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 2/21/2012 00:57'!(Self)longPrintOn: (Stream{space (→ Object) . tab (→ Object) . cr (→ Object)})aStream limitedTo: (Integer)sizeLimit indent: (Integer)indent	"Append to the argument, aStream, the names and values of all of the receiver's instance variables.  Limit is the length limit for each inst var."	self class allInstVarNames doWithIndex:		[:(String)title :(Integer)index |		indent timesRepeat: [aStream tab].		aStream nextPutAll: title;		 nextPut: $:;		 space;		 tab;		 nextPutAll: 			((self instVarAt: index) printStringLimitedTo: (sizeLimit -3 -title size max: 1));		 cr]! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 12/16/2011 17:09'!(String)longPrintString	"Answer a String whose characters are a description of the receiver."		| (String)str |	str := String streamContents: [:(WriteStream)aStream | self longPrintOn: aStream].	"Objects without inst vars should return something"	^ str isEmpty ifTrue: [self printString, String cr] ifFalse: [str]! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 12/16/2011 17:10'!(String)longPrintStringLimitedTo: (Integer)aLimitValue	"Answer a String whose characters are a description of the receiver."		| (String)str |	str := String streamContents: [:(WriteStream)aStream | self longPrintOn: aStream limitedTo: aLimitValue indent: 0].	"Objects without inst vars should return something"	^ str isEmpty ifTrue: [self printString, String cr] ifFalse: [str]! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 12/16/2011 17:13'!(Self) nominallyUnsent: (Symbol)aSelectorSymbol	"From within the body of a method which is not formally sent within the system, but which you intend to have remain in the system (for potential manual invocation, or for documentation, or perhaps because it's sent by commented-out-code that you anticipate uncommenting out someday, send this message, with the selector itself as the argument.This will serve two purposes:	(1)  The method will not be returned by searches for unsent selectors (because it, in a manner of speaking, sends itself).	(2)	You can locate all such methods by browsing senders of #nominallyUnsent:"			self flag: #DEAD.	false ifTrue: [self flag: #nominallyUnsent:]    "So that this method itself will appear to be sent"! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 12/16/2011 17:14'!(Self) printOn: (Stream)aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| (String)title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);		nextPutAll: title! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 12/16/2011 17:14'!(String) printString	"Answer a String whose characters are a description of the receiver. 	If you want to print without a character limit, use fullPrintString."	^ self printStringLimitedTo: 50000! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 12/16/2011 17:15'!(String) printStringLimitedTo: (Integer)limit	"Answer a String whose characters are a description of the receiver.	If you want to print without a character limit, use fullPrintString."	| (String) limitedString |	limitedString := String streamContents: [:s | self printOn: s] limitedTo: limit.	limitedString size < limit ifTrue: [^ limitedString].	^ limitedString , '...etc...'! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 12/16/2011 17:16'!(Self) printWithClosureAnalysisOn: (Stream)aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| (String)title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);		nextPutAll: title! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 12/16/2011 17:19'!(Self) storeOn: (WriteStream)aStream 	"Append to the argument aStream a sequence of characters that is an 	expression whose evaluation creates an object similar to the receiver."	aStream nextPut: $(.	self class isVariable		ifTrue: [aStream nextPutAll: '(', self class name, ' basicNew: ';					store: self basicSize;					nextPutAll: ') ']		ifFalse: [aStream nextPutAll: self class name, ' basicNew'].	1 to: self class instSize do:		[:(Integer)i |		aStream nextPutAll: ' instVarAt: ';			store: i;			nextPutAll: ' put: ';			store: (self instVarAt: i);			nextPut: $;].	1 to: self basicSize do:		[:i |		aStream nextPutAll: ' basicAt: ';			store: i;			nextPutAll: ' put: ';			store: (self basicAt: i);			nextPut: $;].	aStream nextPutAll: ' yourself)'! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 12/16/2011 17:19'!(String)storeString	"Answer a String representation of the receiver from which the receiver 	can be reconstructed."	^ String streamContents: [:(WriteStream)s | self storeOn: s]! !!Object methodsFor: 'self evaluating' stamp: 'EstebanAllende 12/16/2011 17:20'!(Boolean) isSelfEvaluating	^ self isLiteral! !!Object methodsFor: 'splitjoin' stamp: 'EstebanAllende 2/21/2012 00:59'!(?) appendTo: (SequenceableCollection{addLast: (? → ?)})aCollection	"double dispatch for join:"	^ aCollection addLast: self! !!Object methodsFor: 'splitjoin' stamp: 'EstebanAllende 12/16/2011 17:25'!(SequenceableCollection)join: (SequenceableCollection)aSequenceableCollection	^ (Array with: self) join: aSequenceableCollection! !!Object methodsFor: 'splitjoin' stamp: 'EstebanAllende 12/16/2011 17:25'!(Self) joinTo: (Stream)stream	"double dispatch for join:"	^ stream nextPut: self! !!Object methodsFor: 'splitjoin' stamp: 'EstebanAllende 12/16/2011 17:26'!(SequenceableCollection) split: (SequenceableCollection)aSequenceableCollection	^ (Array with: self) split: aSequenceableCollection! !!Object methodsFor: 'system primitives' stamp: 'EstebanAllende 2/21/2012 20:38'!(Self)becomeForward: (Self)otherObject 	"Primitive. All variables in the entire system that used to point	to the receiver now point to the argument.	Fails if either argument is a SmallInteger."	(Array with: self)		elementsForwardIdentityTo:			(Array with: otherObject)! !!Object methodsFor: 'system primitives' stamp: 'EstebanAllende 2/21/2012 20:38'!(Self)becomeForward: (Self)otherObject copyHash: (Boolean)copyHash	"Primitive. All variables in the entire system that used to point to the receiver now point to the argument.	If copyHash is true, the argument's identity hash bits will be set to those of the receiver.	Fails if either argument is a SmallInteger."	(Array with: self)		elementsForwardIdentityTo:			(Array with: otherObject)				copyHash: copyHash! !!Object methodsFor: 'system primitives' stamp: 'EstebanAllende 12/16/2011 17:29'!(String)className	"Answer a string characterizing the receiver's class, for use in list views for example"	^ self class name asString! !!Object methodsFor: 'system primitives' stamp: 'EstebanAllende 12/16/2011 17:29'!(?) instVarAt: (Integer)index 	"Primitive. Answer a fixed variable in an object. The numbering of the 	variables corresponds to the named instance variables. Fail if the index 	is not an Integer or is not the index of a fixed variable. Essential. See 	Object documentation whatIsAPrimitive."	<primitive: 73>	"Access beyond fixed variables."	^self basicAt: index - self class instSize		! !!Object methodsFor: 'system primitives' stamp: 'EstebanAllende 12/16/2011 17:30'!(?) instVarAt: (Integer)anInteger put: (?)anObject 	"Primitive. Store a value into a fixed variable in the receiver. The 	numbering of the variables corresponds to the named instance variables. 	Fail if the index is not an Integer or is not the index of a fixed variable. 	Answer the value stored as the result. Using this message violates the 	principle that each object has sovereign control over the storing of 	values into its instance variables. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 74>	"Access beyond fixed fields"	^self basicAt: anInteger - self class instSize put: anObject! !!Object methodsFor: 'system primitives' stamp: 'EstebanAllende 12/16/2011 18:08'!(?) instVarNamed: (Object)aString	"Return the value of the instance variable in me with that name.  Slow and unclean, but very useful. "	^ self instVarAt: ((<ClassDescription>(<?>self class))						instVarIndexFor: aString asString						ifAbsent: [self error: 'no such inst var'])! !!Object methodsFor: 'system primitives' stamp: 'EstebanAllende 12/16/2011 18:11'!(?) instVarNamed: (Object)aString put: (Object)aValue	"Store into the value of the instance variable in me of that name.  Slow and unclean, but very useful. "	^self		instVarAt: ((<ClassDescription>(<?>self class))						instVarIndexFor: aString asString						ifAbsent: [self error: 'no such inst var'])		put: aValue! !!Object methodsFor: 'system primitives' stamp: 'EstebanAllende 12/16/2011 18:13'!(Object) primitiveChangeClassTo: (Object)anObject	"Primitive. Change the class of the receiver into the class of the argument given that the format of the receiver matches the format of the argument's class. Fail if receiver or argument are SmallIntegers, or the receiver is an instance of a compact class and the argument isn't, or when the argument's class is compact and the receiver isn't, or when the format of the receiver is different from the format of the argument's class, or when the arguments class is fixed and the receiver's size differs from the size that an instance of the argument's class should have.	Note: The primitive will fail in most cases that you think might work. This is mostly because of a) the difference between compact and non-compact classes, and b) because of differences in the format. As an example, '(Array new: 3) primitiveChangeClassTo: Morph basicNew' would fail for three of the reasons mentioned above. Array is compact, Morph is not (failure #1). Array is variable and Morph is fixed (different format - failure #2). Morph is a fixed-field-only object and the array is too short (failure #3).	The facility is really provided for certain, very specific applications (mostly related to classes changing shape) and not for casual use."	<primitive: 115>	self primitiveFailed! !!Object methodsFor: 'system primitives' stamp: 'EstebanAllende 12/16/2011 18:13'!(Object) someObject	"Primitive. Answer the first object in the enumeration of all	 objects."	<primitive: 138>	self primitiveFailed.! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:14'!(Self) haltIfNil! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 2/21/2012 01:01'!(Boolean) hasLiteralSuchThat: (?→Boolean)testBlock	"This is the end of the imbedded structure path so return false."	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:17'!(Boolean) is: (Symbol)aSymbol	"A means for cleanly replacing all isXXX like methods.	Please use judiciously!!	Suggested by Igor Stasenko at	http://lists.squeakfoundation.org/pipermail/squeak-dev/2009-June/136793.html.	all isXXX should be converted following the pattern		ColorForm>>isColorForm 			^ true	Object>>isColorForm 			^ false 	is: aSymbol		^ aSymbol = #ColorForm or: [ super is: aSymbol ]"	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:17'!(Boolean) isArray	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:17'!(Boolean) isBehavior	"Return true if the receiver is a behavior.	Note: Do not override in any class except behavior."	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:17'!(Boolean) isBlock	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:17'!(Boolean) isCharacter	^ false.! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:17'!(Boolean) isClosure	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:17'!(Boolean) isCollection	"Return true if the receiver is some sort of Collection and responds to basic collection messages such as #size and #do:"	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:17'!(Boolean) isColor	"Answer true if receiver is a Color. False by default."	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:18'!(Boolean) isColorForm	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:18'!(Boolean) isCompiledMethod	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:18'!(Boolean) isComplex	"Answer true if receiver is a Complex number. False by default."	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:18'!(Boolean) isContext	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:18'!(Boolean) isDictionary	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:18'!(Boolean) isFloat	"Overridden to return true in Float, natch"	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:18'!(Boolean) isForm	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:18'!(Boolean) isFraction	"Answer true if the receiver is a Fraction."	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:19'!(Boolean) isHeap	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:19'!(Boolean) isInteger	"Overridden to return true in Integer."	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:19'!(Boolean) isInterval	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:19'!(Boolean) isMessageSend	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:19'!(Boolean) isMethodProperties	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:19'!(Boolean) isMorph	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:19'!(Boolean) isMorphicEvent	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:19'!(Boolean) isMorphicModel	"Return true if the receiver is a morphic model"	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:19'!(Boolean) isNumber	"Overridden to return true in Number, natch"	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:20'!(Boolean) isPoint	"Overridden to return true in Point."	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:20'!(Boolean) isPseudoContext	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:20'!(Boolean) isRectangle	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:20'!(Boolean) isStream	"Return true if the receiver responds to the stream protocol"	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:20'!(Boolean) isString	"Overridden to return true in String, natch"	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:20'!(Boolean) isSymbol	^ false ! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:20'!(Boolean) isSystemWindow"answer whatever the receiver is a SystemWindow"	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:21'!(Boolean) isText	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:21'!(Boolean) isTrait	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:21'!(Boolean) isVariableBinding	"Return true if I represent a literal variable binding"	^false	! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:21'!(String) name	"Answer a name for the receiver.  This is used generically in the title of certain inspectors, such as the referred-to inspector, and specificially by various subsystems.  By default, we let the object just print itself out..  "	^ self printString ! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:21'!(Boolean) notNil	"Coerces nil to false and everything else to true."	^true! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:22'!(Boolean) refersToLiteral: (Object)literal 	"Answer true if literal is identical to any literal in this array, even if imbedded in further structures.  This is the end of the imbedded structure path so return false."	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:22'!(Boolean) shouldBePrintedAsLiteral	^self isLiteral! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 2/21/2012 21:23'!(Object) stepAt: (Integer)millisecondClockValue in: (Morph)aWindow	^ self stepIn: aWindow! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 2/21/2012 21:23'!(Object) stepIn: (Morph)aWindow	^ (<{step (→?)}>(<?>self)) step! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:26'!(Integer) stepTime		^ 1000 "milliseconds -- default backstop for objects serving as models of system windows"! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:26'!(Integer) stepTimeIn: (Morph)aSystemWindow		^ 1000 "milliseconds -- default backstop for objects serving as models of system windows"! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:26'!(Boolean) wantsDiffFeedback	"Answer whether the receiver, serving as the model of a text-bearing entity, would like for 'diffs' green pane-border feedback to be shown"	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:27'!(Boolean) wantsSteps	"Overridden by morphic classes whose instances want to be stepped,	or by model classes who want their morphic views to be stepped."	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 12/16/2011 18:27'!(Boolean) wantsStepsIn: aSystemWindow		^ self wantsSteps! !!Object methodsFor: 'tracing' stamp: 'EstebanAllende 12/16/2011 18:28'!(Self) crTrace      self crTrace: self printString! !!Object methodsFor: 'tracing' stamp: 'EstebanAllende 12/16/2011 18:27'!(Self) crTrace: (String)aString	"Log the argument. Use self crTrace: instead of Transcript cr; show: "		Transcript cr; show: aString.! !!Object methodsFor: 'tracing' stamp: 'EstebanAllende 12/16/2011 18:27'!(Self) trace      self trace: self printString! !!Object methodsFor: 'tracing' stamp: 'EstebanAllende 12/16/2011 18:27'!(Self) trace: (String)aString	"Log the argument. Use self trace: instead of Transcript show: "		Transcript show: aString.! !!Object methodsFor: 'tracing' stamp: 'EstebanAllende 12/16/2011 18:27'!(Self) traceCr      self traceCr: self printString! !!Object methodsFor: 'tracing' stamp: 'EstebanAllende 2/21/2012 21:26'!(Self) traceCr: (String)aString	"Log the argument. Use self traceCr: 'something' instead of Transcript show: 'something'  ; cr "		Transcript show: aString ; cr! !!Object methodsFor: 'updating' stamp: 'EstebanAllende 12/16/2011 18:32'!(Self) changed	"Receiver changed in a general way; inform all the dependents by 	sending each dependent an update: message."	self changed: self! !!Object methodsFor: 'updating' stamp: 'EstebanAllende 12/16/2011 18:32'!(Self) changed: (Object)aParameter 	"Receiver changed. The change is denoted by the argument aParameter. 	Usually the argument is a Symbol that is part of the dependent's change 	protocol. Inform all of the dependents."	self dependents do: [:(Object)aDependent | aDependent update: aParameter]! !!Object methodsFor: 'updating' stamp: 'EstebanAllende 12/16/2011 18:32'!(Self) changed: (Object)anAspect with: (Object)anObject	"Receiver changed. The change is denoted by the argument anAspect. 	Usually the argument is a Symbol that is part of the dependent's change 	protocol. Inform all of the dependents. Also pass anObject for additional information."	self dependents do: [:(Object)aDependent | aDependent update: anAspect with: anObject]! !!Object methodsFor: 'updating' stamp: 'EstebanAllende 12/16/2011 18:31'!(Self) noteSelectionIndex: (Integer)anInteger for: (Symbol)aSymbol	"backstop"! !!Object methodsFor: 'updating' stamp: 'EstebanAllende 12/16/2011 18:31'!(Boolean) okToChange	"Allows a controller to ask this of any model"	^ true! !!Object methodsFor: 'updating' stamp: 'EstebanAllende 12/16/2011 18:29'!(Self) update: (Object)aParameter 	"Receive a change notice from an object of whom the receiver is a 	dependent. The default behavior is to do nothing; a subclass might want 	to change itself in some way."	^ self! !!Object methodsFor: 'updating' stamp: 'EstebanAllende 12/16/2011 18:30'!(Self)update: (Object)anAspect with: (Object)anObject	"Receive a change notice from an object of whom the receiver is a 	dependent. The default behavior is to call update:,	which by default does nothing; a subclass might want 	to change itself in some way."	^ self update: anAspect! !!Object methodsFor: 'updating' stamp: 'EstebanAllende 12/16/2011 18:30'!(Self) windowIsClosing	"This message is used to inform a models that its window is closing. Most models do nothing, but some, such as the Debugger, must do some cleanup. Note that this mechanism must be used with care by models that support multiple views, since one view may be closed while others left open."! !!Object methodsFor: 'user interface' stamp: 'EstebanAllende 12/16/2011 18:33'!(Self) addModelItemsToWindowMenu: (MenuMorph) aMenu	"aMenu is being constructed to be presented to the user in response to the user's pressing on the menu widget in the title bar of a morphic window.  Here, the model is given the opportunity to add any model-specific items to the menu, whose default target is the SystemWindow itself."! !!Object methodsFor: 'user interface' stamp: 'EstebanAllende 12/16/2011 18:34'!(Self) addModelMenuItemsTo: (MenuMorph) aCustomMenu forMorph: (Morph)aMorph hand: (HandMorph)aHandMorph 	"The receiver serves as the model for aMorph; a menu is being constructed for the morph, and here the receiver is able to add its own items"! !!Object methodsFor: 'user interface' stamp: 'EstebanAllende 12/16/2011 18:34'!(Self) modelSleep	"A window with me as model is being exited or collapsed or closed.	Default response is no-op" ! !!Object methodsFor: 'user interface' stamp: 'EstebanAllende 12/16/2011 18:34'!(Self) modelWakeUp	"A window with me as model is being entered or expanded.  Default response is no-op"  ! !!Object methodsFor: 'user interface' stamp: 'EstebanAllende 12/16/2011 18:34'!(Self) modelWakeUpIn: (Morph)aWindow	"A window with me as model is being entered or expanded.  Default response is no-op" 	self modelWakeUp! !!Object methodsFor: 'user interface' stamp: 'EstebanAllende 2/21/2012 01:20'!(Self) mouseUpBalk: (MorphicEvent)evt	"A button I own got a mouseDown, but the user moved out before letting up.  Certain kinds of objects (so-called 'radio buttons', for example, and other structures that must always have some selection, e.g. PaintBoxMorph) wish to take special action in this case; this default does nothing."! !!Object methodsFor: 'user interface' stamp: 'EstebanAllende 12/16/2011 18:35'!(UndefinedObject) notYetImplemented	self inform: 'Not yet implemented (', thisContext sender printString, ')'.	^nil! !!Object methodsFor: 'user interface' stamp: 'EstebanAllende 12/16/2011 18:36'!(Boolean) windowReqNewLabel: (String)labelString	"My window's title has been edited.	Return true if this is OK, and override for further behavior."	^ true! !!Object methodsFor: 'private' stamp: 'EstebanAllende 2/21/2012 20:54'!(Self) errorImproperStore	"Create an error notification that an improper store was attempted."	self error: 'Improper store into indexable object'! !!Object methodsFor: 'private' stamp: 'EstebanAllende 12/16/2011 18:36'!(?) errorNonIntegerIndex	"Create an error notification that an improper object was used as an index."	^self error: 'only integers should be used as indices'! !!Object methodsFor: 'private' stamp: 'EstebanAllende 12/16/2011 18:37'!(?) errorNotIndexable	"Create an error notification that the receiver is not indexable."	^self error: ('Instances of {1} are not indexable' translated format: {self class name})! !!Object methodsFor: 'private' stamp: 'EstebanAllende 2/21/2012 20:55'!(Self) errorSubscriptBounds: (Integer)index 	"Create an error notification that an improper integer was used as an index."	SubscriptOutOfBounds signalFor: index! !!Object methodsFor: 'private' stamp: 'EstebanAllende 12/16/2011 18:37'!(ClassDescription) species	"Answer the preferred class for reconstructing the receiver.  For example, 	collections create new collections whenever enumeration messages such as 	collect: or select: are invoked.  The new kind of collection is determined by 	the species of the original collection.  Species and class are not always the 	same.  For example, the species of Interval is Array."	<primitive: 111>	^(<?>self class)! !!Object methodsFor: 'private' stamp: 'EstebanAllende 2/21/2012 20:56'!(Self) storeAt: (Integer)offset inTempFrame: (ContextPart)aContext	"This message had to get sent to an expression already on the stack	as a Block argument being accessed by the debugger.	Just re-route it to the temp frame."	^ aContext tempAt: offset put: self! !!Object methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 2/21/2012 20:58'!(Boolean) instVarsInclude: (Object) anObject"Answers true if anObject is among my named or indexed instance variables, and false otherwise"	<primitive: 132>	1 to: self class instSize do:		[:(Integer)i | (self instVarAt: i) == anObject ifTrue: [^ true]].	1 to: self basicSize do:		[:(Integer)i | (self basicAt: i) == anObject ifTrue: [^ true]].	^ false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Object class	instanceVariableNames: ''!!Object class methodsFor: '*Compiler-Kernel' stamp: 'jb 7/1/2011 10:52'!readFrom: textStringOrStream	"Create an object based on the contents of textStringOrStream."	| object |	(self class evaluatorClass couldEvaluate: textStringOrStream)		ifFalse: [^ self error: 'expected String, Stream, or Text'].	object := self class evaluatorClass evaluate: textStringOrStream.	(object isKindOf: self) ifFalse: [self error: self name, ' expected'].	^object! !!Object class methodsFor: '*Polymorph-Widgets'!taskbarIcon	"Answer the icon for an instance of the receiver in a task bar	or nil for the default."	^nil ! !!Object class methodsFor: '*Polymorph-Widgets' stamp: 'gvc 1/31/2009 15:53'!taskbarLabel	"Answer the label string for the receiver in a task bar	or nil for the default."	^nil! !!Object class methodsFor: '*System-Support'!registerToolsOn: t1 	^ self! !!Object class methodsFor: '*Tools-FileList' stamp: 'md 2/15/2006 17:20'!services	"Backstop"	^#()! !!Object class methodsFor: 'class initialization' stamp: 'ar 2/11/2001 02:00'!flushDependents	DependentsFields keysAndValuesDo:[:key :dep|		key ifNotNil:[key removeDependent: nil].	].	DependentsFields finalizeValues.! !!Object class methodsFor: 'class initialization' stamp: 'rw 2/10/2002 13:09'!flushEvents	"Object flushEvents"	EventManager flushEvents. ! !!Object class methodsFor: 'class initialization'!initialize	DependentsFields		ifNil: [self initializeDependentsFields]! !!Object class methodsFor: 'class initialization' stamp: 'ar 2/11/2001 01:41'!initializeDependentsFields	"Object initialize"	DependentsFields := WeakIdentityKeyDictionary new.! !!Object class methodsFor: 'class initialization' stamp: 'ar 2/11/2001 01:45'!reInitializeDependentsFields	"Object reInitializeDependentsFields"	| oldFields |	oldFields := DependentsFields.	DependentsFields := WeakIdentityKeyDictionary new.	oldFields keysAndValuesDo:[:obj :deps|		deps do:[:d| obj addDependent: d]].! !!Object class methodsFor: 'documentation'!howToModifyPrimitives	"You are allowed to write methods which specify primitives, but please use 	caution.  If you make a subclass of a class which contains a primitive method, 	the subclass inherits the primitive.  The message which is implemented 	primitively may be overridden in the subclass (E.g., see at:put: in String's 	subclass Symbol).  The primitive behavior can be invoked using super (see 	Symbol string:). 	 	A class which attempts to mimic the behavior of another class without being 	its subclass may or may not be able to use the primitives of the original class.  	In general, if the instance variables read or written by a primitive have the 	same meanings and are in the same fields in both classes, the primitive will 	work.  	For certain frequently used 'special selectors', the compiler emits a 	send-special-selector bytecode instead of a send-message bytecode.  	Special selectors were created because they offer two advantages.  Code 	which sends special selectors compiles into fewer bytes than normal.  For 	some pairs of receiver classes and special selectors, the interpreter jumps 	directly to a primitive routine without looking up the method in the class.  	This is much faster than a normal message lookup. 	 	A selector which is a special selector solely in order to save space has a 	normal behavior.  Methods whose selectors are special in order to 	gain speed contain the comment, 'No Lookup'.  When the interpreter 	encounters a send-special-selector bytecode, it checks the class of the 	receiver and the selector.  If the class-selector pair is a no-lookup pair, 	then the interpreter swiftly jumps to the routine which implements the 	corresponding primitive.  (A special selector whose receiver is not of the 	right class to make a no-lookup pair, is looked up normally).  The pairs are 	listed below.  No-lookup methods contain a primitive number specification, 	<primitive: xx>, which is redundant.  Since the method is not normally looked 	up, deleting the primitive number specification cannot prevent this 	primitive from running.  If a no-lookup primitive fails, the method is looked 	up normally, and the expressions in it are executed. 	 	No Lookup pairs of (class, selector) 	 	SmallInteger with any of		+ - * /  \\  bitOr: bitShift: bitAnd:  // 	SmallInteger with any of		=  ~=  >  <  >=  <= 	Any class with					== 	Any class with 					@ 	Point with either of				x y 	ContextPart with					blockCopy: 	BlockContext with either of 		value value:	"	self error: 'comment only'! !!Object class methodsFor: 'documentation'!whatIsAPrimitive	"Some messages in the system are responded to primitively. A primitive   	response is performed directly by the interpreter rather than by evaluating   	expressions in a method. The methods for these messages indicate the   	presence of a primitive response by including <primitive: xx> before the   	first expression in the method.   	  	Primitives exist for several reasons. Certain basic or 'primitive' 	operations cannot be performed in any other way. Smalltalk without 	primitives can move values from one variable to another, but cannot add two 	SmallIntegers together. Many methods for arithmetic and comparison 	between numbers are primitives. Some primitives allow Smalltalk to 	communicate with I/O devices such as the disk, the display, and the keyboard. 	Some primitives exist only to make the system run faster; each does the same 	thing as a certain Smalltalk method, and its implementation as a primitive is 	optional.  	  	When the Smalltalk interpreter begins to execute a method which specifies a 	primitive response, it tries to perform the primitive action and to return a 	result. If the routine in the interpreter for this primitive is successful, 	it will return a value and the expressions in the method will not be evaluated. 	If the primitive routine is not successful, the primitive 'fails', and the 	Smalltalk expressions in the method are executed instead. These 	expressions are evaluated as though the primitive routine had not been 	called.  	  	The Smalltalk code that is evaluated when a primitive fails usually 	anticipates why that primitive might fail. If the primitive is optional, the 	expressions in the method do exactly what the primitive would have done (See 	Number @). If the primitive only works on certain classes of arguments, the 	Smalltalk code tries to coerce the argument or appeals to a superclass to find 	a more general way of doing the operation (see SmallInteger +). If the 	primitive is never supposed to fail, the expressions signal an error (see 	SmallInteger asFloat).  	  	Each method that specifies a primitive has a comment in it. If the primitive is 	optional, the comment will say 'Optional'. An optional primitive that is not 	implemented always fails, and the Smalltalk expressions do the work 	instead.  	 	If a primitive is not optional, the comment will say, 'Essential'. Some 	methods will have the comment, 'No Lookup'. See Object 	howToModifyPrimitives for an explanation of special selectors which are 	not looked up.  	  	For the primitives for +, -, *, and bitShift: in SmallInteger, and truncated 	in Float, the primitive constructs and returns a 16-bit 	LargePositiveInteger when the result warrants it. Returning 16-bit 	LargePositiveIntegers from these primitives instead of failing is 	optional in the same sense that the LargePositiveInteger arithmetic 	primitives are optional. The comments in the SmallInteger primitives say, 	'Fails if result is not a SmallInteger', even though the implementor has the 	option to construct a LargePositiveInteger. For further information on 	primitives, see the 'Primitive Methods' part of the chapter on the formal 	specification of the interpreter in the Smalltalk book."	self error: 'comment only'! !!Object class methodsFor: 'file list services' stamp: 'nk 6/12/2004 11:41'!fileReaderServicesForDirectory: aFileDirectory	"Backstop"	^#()! !!Object class methodsFor: 'file list services' stamp: 'nk 6/12/2004 11:30'!fileReaderServicesForFile: fullName suffix: suffix	"Backstop"	^#()! !!Object class methodsFor: 'instance creation' stamp: 'StephaneDucasse 2/20/2010 21:38'!newFrom: aSimilarObject	"Create an object that has similar contents to aSimilarObject. If the classes have any instance varaibles with the same names, copy them across. If this is bad for a class, override this method."	^ (self isVariable		ifTrue: [self basicNew: aSimilarObject basicSize]		ifFalse: [self basicNew]) copySameFrom: aSimilarObject! !!Object class methodsFor: 'objects from disk' stamp: 'tk 1/8/97'!createFrom: aSmartRefStream size: varsOnDisk version: instVarList	"Create an instance of me so objects on the disk can be read in.  Tricky part is computing the size if variable.  Inst vars will be filled in later.  "	^ self isVariable		ifFalse: [self basicNew]		ifTrue: ["instVarList is names of old class's inst vars plus a version number" 				self basicNew: (varsOnDisk - (instVarList size - 1))]! !!Object class methodsFor: 'private' stamp: 'mir 8/22/2001 15:20'!releaseExternalSettings	"Do nothing as a default"! !Object initialize!