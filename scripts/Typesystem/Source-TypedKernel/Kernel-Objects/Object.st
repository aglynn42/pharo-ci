'From Pharo1.4 of 18 April 2012 [Latest update: #14447] on 2 July 2012 at 5:44:44 pm'!ProtoObject subclass: #Object	instanceVariableNames: ''	classVariableNames: '(Dictionary<Object, Collection<Object>>)DependentsFields'	poolDictionaries: ''	category: 'Kernel-Objects'!!Object commentStamp: 'StephaneDucasse 1/3/2010 20:41' prior: 0!Object is the root class for almost all of the other classes in the class hierarchy. The exceptions are ProtoObject (the superclass of Object) and its subclasses.Class Object provides default behavior common to all normal objects, such as access, copying, comparison, error handling, message sending, and reflection. Also utility messages that all objects should respond to are defined here.Object has no instance variables, nor should any be added. This is due to several classes of objects that inherit from Object that have special implementations (SmallInteger and UndefinedObject for example) or the VM knows about and depends on the structure and layout of certain standard classes.Class Variables:	DependentsFields		an IdentityDictionary		Provides a virtual 'dependents' field so that any object may have one		or more dependent views, synchronized by the changed:/update: protocol.		Note that class Model has a real slot for its dependents, and overrides		the associated protocol with more efficient implementations.	EventsFields			an IdentityDictionary that maps each object to its dependents.		Registers a message send (consisting of a selector and a receiver object)		which should be performed when anEventSymbol is triggered by the receiver.		Part of a new event notification framework which could eventually replace		the existing changed/update mechanism.  It is intended to be compatible		with Dolphin Smalltalk and VSE as much as possible.Because Object is the root of the inheritance tree, methods are often defined in Object to give all objects special behaviors needed by certain subsystems or applications, or to respond to certain general test messages such as isMorph.About at: index accepting float and not only integers This behavior is also free in the sense that the failure code is only invoked when theprimitive fails and so adds nothing to the cost of successful accesses,which are the high dynamic frequency operation.  It will also show up underprofiling if one is concerned about efficiency, and so isn't a hidden cost.It is also in keeping with Smalltalk's mixed mode/arbitrary precisionimplicit coercion number system that one *can* use fractions or floats asindices.  Stripping out coercions like this will make the system more brittle.  So please do *not* remove this "hack".  I think it's a feature and a useful  one.Can you give me an example that demonstrates the usefulness of thisfeature?| a r |a := Array new: 10 withAll: 0.r := Random new.100 timesRepeat: [| v | v := r next * 10 + 1. a at: v put: (a at: v) + 1].ai.e. I didn't have to provide an explicit rounding step.  That's useful.  But in general anywhere where an index is derived by some calculation not having to provide the rounding step could be useful/helpful/more concise.  e.g. (n roundTo: 0.1) * 10 vs ((n roundTo: 0.1) * 10) asInteger.Some thought went into the original choice.  It is not a hack but there by intent.  The integers are simply a subset of the reals and forcing the programmer to use them is favouring the machine above the programmer.But I think you should justify getting rid of it rather than my having to justify keeping it.  Getting rid of it risks breaking code.  If it is there but does not harm then why get rid of it?best Eliot Miranda !!Object methodsFor: '*Graphics-Display Objects' stamp: 'sw 3/26/2001 12:12'!printDirectlyToDisplay	"For debugging: write the receiver's printString directly to the display at (0, 100); senders of this are detected by the check-for-slips mechanism."	self asString displayAt: 0@100"StringMorph someInstance printDirectlyToDisplay"! !!Object methodsFor: '*Kernel-Exceptions-debugging' stamp: 'MarcusDenker 2/29/2012 08:25'!halt	"This is the typical message to use for inserting breakpoints during debugging."		Halt now.! !!Object methodsFor: '*Kernel-Exceptions-debugging' stamp: 'MarcusDenker 2/29/2012 08:24'!halt: aString 	Halt now: aString! !!Object methodsFor: '*Kernel-Exceptions-debugging' stamp: 'SeanDeNigris 8/29/2011 10:51'!haltIf: condition	Halt if: condition.! !!Object methodsFor: '*Kernel-Exceptions-debugging' stamp: 'SeanDeNigris 8/29/2011 12:16'!haltIfShiftPressed	Halt ifShiftPressed.! !!Object methodsFor: '*Kernel-Exceptions-debugging' stamp: 'SeanDeNigris 8/29/2011 15:16'!haltOnCount: anInteger 	Halt onCount: anInteger.! !!Object methodsFor: '*Kernel-Exceptions-debugging' stamp: 'SeanDeNigris 8/29/2011 15:02'!haltOnce	Halt once.! !!Object methodsFor: '*Morphic' stamp: 'AlainPlantec 12/19/2009 23:13'!addModelYellowButtonMenuItemsTo: aCustomMenu forMorph: aMorph hand: aHandMorph 	"The receiver serves as the model for aMorph; a menu is being constructed for the morph, and here the receiver is able to add its own items"	Morph cmdGesturesEnabled ifTrue: [ "build mode"		aCustomMenu add: 'inspect model' translated target: self action: #inspect.	].	^aCustomMenu! !!Object methodsFor: '*Morphic' stamp: 'BenjaminVanRyseghem 10/7/2011 21:42'!asDraggableMorph	^(StringMorph contents: self asString)		color: Color white;		yourself! !!Object methodsFor: '*Morphic' stamp: 'AlainPlantec 10/20/2009 10:14'!asMorph	"Open a morph, as best one can, on the receiver"	^ self asStringMorph	"234 asMorph.(MenuIcons tinyMenuIcon) asMorph.'fred' asMorph."! !!Object methodsFor: '*Morphic' stamp: 'nk 2/26/2004 13:35'!asStringMorph	"Open a StringMorph, as best one can, on the receiver"	^ self asStringOrText asStringMorph! !!Object methodsFor: '*Morphic' stamp: 'nk 2/26/2004 13:35'!asTextMorph	"Open a TextMorph, as best one can, on the receiver"	^ TextMorph new contentsAsIs: self asStringOrText! !!Object methodsFor: '*Morphic' stamp: 'ar 3/18/2001 00:03'!currentEvent	"Answer the current Morphic event.  This method never returns nil."	^ActiveEvent ifNil:[self currentHand lastEvent]! !!Object methodsFor: '*Morphic' stamp: 'nk 9/1/2004 10:41'!currentHand	"Return a usable HandMorph -- the one associated with the object's current environment.  This method will always return a hand, even if it has to conjure one up as a last resort.  If a particular hand is actually handling events at the moment (such as a remote hand or a ghost hand), it will be returned."	^ActiveHand ifNil: [ self currentWorld primaryHand ]! !!Object methodsFor: '*Morphic' stamp: 'JuanVuletich 11/1/2010 15:18'!currentWorld	"Answer a morphic world that is the current UI focus."	^UIManager default currentWorld! !!Object methodsFor: '*Morphic' stamp: 'BenjaminVanRyseghem 10/7/2011 21:36'!dragPassengersFor: item inMorph: dragSource 	^ { item }! !!Object methodsFor: '*Morphic' stamp: 'HenrikSperreJohansen 6/28/2010 12:24'!externalName	"Answer an external name by which the receiver is known. Generic	implementation here is a transitional backstop. probably"	^ [(self asString copyWithout: Character cr)		truncateTo: 27]		ifError: [ ^ self class name printString] ! !!Object methodsFor: '*Morphic' stamp: 'AlainPlantec 12/19/2009 23:13'!hasModelYellowButtonMenuItems	^Morph cmdGesturesEnabled! !!Object methodsFor: '*Morphic' stamp: 'dgd 9/25/2004 23:17'!iconOrThumbnailOfSize: aNumberOrPoint 	"Answer an appropiate form to represent the receiver"	^ nil! !!Object methodsFor: '*Morphic' stamp: 'AlainPlantec 10/20/2009 10:15'!openAsMorph	"Open a morph, as best one can, on the receiver"	^ self asMorph openInHand"234 openAsMorph.(MenuIcons tinyMenuIcon) openAsMorph.'fred' openAsMorph."! !!Object methodsFor: '*Polymorph-EventEnhancements' stamp: 'gvc 10/25/2006 18:18'!when: anEventSelectorsend: aMessageSelectorto: anObjectexclusive: aValueHolder 	self		when: anEventSelector		evaluate: ((ExclusiveWeakMessageSend					receiver: anObject					selector: aMessageSelector)						basicExecuting: aValueHolder)! !!Object methodsFor: '*Polymorph-EventEnhancements' stamp: 'gvc 10/25/2006 18:17'!when: anEventSelectorsend: aMessageSelectorto: anObjectwith: anArgexclusive: aValueHolder     self        when: anEventSelector        evaluate: ((ExclusiveWeakMessageSend 		receiver: anObject		selector: aMessageSelector		arguments: (Array with: anArg))			basicExecuting: aValueHolder)! !!Object methodsFor: '*Polymorph-EventEnhancements' stamp: 'gvc 10/25/2006 18:17'!when: anEventSelectorsend: aMessageSelectorto: anObjectwithArguments: anArgArrayexclusive: aValueHolder     self        when: anEventSelector        evaluate: ((ExclusiveWeakMessageSend		receiver: anObject		selector: aMessageSelector		arguments: anArgArray)			basicExecuting: aValueHolder)! !!Object methodsFor: '*Polymorph-EventEnhancements' stamp: 'gvc 10/24/2006 11:50'!when: anEventSelectorsendOnce: aMessageSelectorto: anObject     self        when: anEventSelector        evaluate: (NonReentrantWeakMessageSend            receiver: anObject            selector: aMessageSelector)! !!Object methodsFor: '*Polymorph-EventEnhancements' stamp: 'gvc 10/24/2006 11:49'!when: anEventSelectorsendOnce: aMessageSelectorto: anObjectwith: anArg     self        when: anEventSelector        evaluate: (NonReentrantWeakMessageSend            receiver: anObject            selector: aMessageSelector		arguments: (Array with: anArg))! !!Object methodsFor: '*Polymorph-EventEnhancements' stamp: 'gvc 10/24/2006 11:49'!when: anEventSelectorsendOnce: aMessageSelectorto: anObjectwithArguments: anArgArray     self        when: anEventSelector        evaluate: (NonReentrantWeakMessageSend            receiver: anObject            selector: aMessageSelector		arguments: anArgArray)! !!Object methodsFor: '*Polymorph-TaskbarIcons'!taskbarIcon	"Answer the icon for the receiver in a task bar	or nil for the default."	^self class taskbarIcon! !!Object methodsFor: '*Polymorph-Widgets' stamp: 'gvc 1/10/2007 11:41'!okToClose	"Sent to models when a window closing.	Allows this check to be independent of okToChange."		^true! !!Object methodsFor: '*Polymorph-Widgets' stamp: 'gvc 1/31/2009 15:52'!taskbarLabel	"Answer the label string for the receiver in a task bar	or nil for the default."	^self class taskbarLabel! !!Object methodsFor: '*Polymorph-Widgets-Utilities'!asValueHolder	^ ValueHolder new contents: self; yourself! !!Object methodsFor: '*Ring-Core-Kernel' stamp: 'StephaneDucasse 7/16/2011 22:53'!isRingObject	^false! !!Object methodsFor: '*Shout-Parsing' stamp: 'SeanDeNigris 6/22/2012 18:24'!shoutParser: anSHParserST80	"Tools can define this method to customize the parser"! !!Object methodsFor: '*System-Breakpoints' stamp: 'bkv 7/1/2003 12:33'!break	"This is a simple message to use for inserting breakpoints during debugging.	The debugger is opened by sending a signal. This gives a chance to restore	invariants related to multiple processes."	BreakPoint signal.	"nil break."! !!Object methodsFor: '*System-Object Storage' stamp: 'tk 4/8/1999 12:46'!comeFullyUpOnReload: smartRefStream	"Normally this read-in object is exactly what we want to store. 7/26/96 tk"	^ self! !!Object methodsFor: '*System-Object Storage' stamp: 'RAA 1/10/2001 14:02'!indexIfCompact	^0		"helps avoid a #respondsTo: in publishing"! !!Object methodsFor: '*System-Object Storage' stamp: 'tk 2/24/1999 11:08'!objectForDataStream: refStrm    "Return an object to store on an external data stream."    ^ self! !!Object methodsFor: '*System-Object Storage' stamp: 'tk 4/8/1999 12:05'!readDataFrom: aDataStream size: varsOnDisk	"Fill in the fields of self based on the contents of aDataStream.  Return self.	 Read in the instance-variables written by Object>>storeDataOn:.	 NOTE: This method must send beginReference: before reading any objects from aDataStream that might reference it.	 Allow aDataStream to have fewer inst vars.  See SmartRefStream."	| cntInstVars cntIndexedVars |	cntInstVars := self class instSize.	self class isVariable		ifTrue: [cntIndexedVars := varsOnDisk - cntInstVars.				cntIndexedVars < 0 ifTrue: [					self error: 'Class has changed too much.  Define a convertxxx method']]		ifFalse: [cntIndexedVars := 0.				cntInstVars := varsOnDisk]. 	"OK if fewer than now"	aDataStream beginReference: self.	1 to: cntInstVars do:		[:i | self instVarAt: i put: aDataStream next].	1 to: cntIndexedVars do:		[:i | self basicAt: i put: aDataStream next].	"Total number read MUST be equal to varsOnDisk!!"	^ self	"If we ever return something other than self, fix calls 			on (super readDataFrom: aDataStream size: anInteger)"! !!Object methodsFor: '*System-Object Storage' stamp: 'tk 8/9/2001 15:40'!storeDataOn: aDataStream	"Store myself on a DataStream.  Answer self.  This is a low-level DataStream/ReferenceStream method. See also objectToStoreOnDataStream.  NOTE: This method must send 'aDataStream beginInstance:size:' and then (nextPut:/nextPutWeak:) its subobjects.  readDataFrom:size: reads back what we write here."	| cntInstVars cntIndexedVars |	cntInstVars := self class instSize.	cntIndexedVars := self basicSize.	aDataStream		beginInstance: self class		size: cntInstVars + cntIndexedVars.	1 to: cntInstVars do:		[:i | aDataStream nextPut: (self instVarAt: i)].	"Write fields of a variable length object.  When writing to a dummy 		stream, don't bother to write the bytes"	((aDataStream byteStream class == DummyStream) and: [self class isBits]) ifFalse: [		1 to: cntIndexedVars do:			[:i | aDataStream nextPut: (self basicAt: i)]].! !!Object methodsFor: '*System-Settings-Browser' stamp: 'alain.plantec 3/24/2009 23:21'!settingFixedDomainValueNodeFrom: aSettingNode 	^ aSettingNode fixedDomainValueNodeForObject: self! !!Object methodsFor: '*System-Settings-Browser' stamp: 'alain.plantec 3/19/2009 09:50'!settingStoreOn: aStream	^ self storeOn: aStream! !!Object methodsFor: '*System-Support'!systemNavigation	^ SystemNavigation default! !!Object methodsFor: '*Tools-Base' stamp: 'MarianoMartinezPeck 4/15/2011 17:12'!defaultBackgroundColor	"Answer the color to be used as the base window color for a window whose model is an object of the receiver's class"		"I don't want to do a self theme  because otherwise I will need to implement it on Object"	^  UITheme current  windowColorFor: self! !!Object methodsFor: '*Tools-Base' stamp: 'sw 1/18/2001 13:43'!showDiffs	"Answer whether the receiver, serving as the model of a text-bearing entity, is 'showing differences' -- if it is, the editor may wish to show special feedback"	^ false! !!Object methodsFor: '*Tools-Base' stamp: 'sw 10/19/1999 14:39'!updateListsAndCodeIn: aWindow	self canDiscardEdits ifFalse: [^ self].	aWindow updatablePanes do: [:aPane | aPane verifyContents]! !!Object methodsFor: '*Tools-Browser' stamp: 'BenjaminVanRyseghem 2/8/2012 17:10'!browse	^ self systemNavigation browseClass: self class! !!Object methodsFor: '*Tools-Browser' stamp: 'BenjaminVanRyseghem 1/7/2012 18:04'!browseHierarchy	self systemNavigation browseHierarchy: self class! !!Object methodsFor: '*Tools-Explorer' stamp: 'sma 11/12/2000 11:43'!asExplorerString	^ self printString! !!Object methodsFor: '*Tools-Explorer' stamp: 'yo 8/27/2008 23:16'!customizeExplorerContents	^ false.! !!Object methodsFor: '*Tools-Explorer' stamp: 'IgorStasenko 1/22/2012 14:38'!explore	^Smalltalk tools objectExplorer openOn: self! !!Object methodsFor: '*Tools-Explorer' stamp: 'md 8/13/2008 21:39'!hasContentsInExplorer	^self basicSize > 0 or: [self class allInstVarNames notEmpty]! !!Object methodsFor: '*Tools-Finder' stamp: 'MarcusDenker 9/20/2011 10:19'!closeTo: anObject	"Do not use this Method!! It is a workaround for MethodFinder"	^[self = anObject] ifError: [false]! !!Object methodsFor: '*Tools-Finder' stamp: 'pmm 3/13/2010 11:33'!copyTwoLevel	"one more level than a shallowCopy"	"do not use this method we will deprecated soon"	| newObject class index |	class := self class.	newObject := self shallowCopy.	newObject == self ifTrue: [^ self].	class isVariable		ifTrue: 			[index := self basicSize.			[index > 0]				whileTrue: 					[newObject basicAt: index put: (self basicAt: index) shallowCopy.					index := index - 1]].	index := class instSize.	[index > 0]		whileTrue: 			[newObject instVarAt: index put: (self instVarAt: index) shallowCopy.			index := index - 1].	^newObject! !!Object methodsFor: '*Tools-Inspector' stamp: 'IgorStasenko 1/22/2012 14:35'!basicInspect	"Create and schedule an Inspector in which the user can examine the 	receiver's variables. This method should not be overriden."	^Smalltalk tools basicInspector openOn: self! !!Object methodsFor: '*Tools-Inspector'!defaultLabelForInspector	"Answer the default label to be used for an Inspector window on the receiver."	^ self class name! !!Object methodsFor: '*Tools-Inspector' stamp: 'sbw 6/2/2004 08:45'!doExpiredInspectCount	self clearHaltOnce.	self removeHaltCount.	self inspect! !!Object methodsFor: '*Tools-Inspector' stamp: 'IgorStasenko 4/15/2011 17:31'!inspect	"Create and schedule an Inspector in which the user can examine the receiver's variables."	Smalltalk tools inspect: self! !!Object methodsFor: '*Tools-Inspector' stamp: 'sbw 6/2/2004 08:46'!inspectOnCount: int 	self haltOnceEnabled		ifTrue: [self hasHaltCount				ifTrue: [self decrementAndCheckHaltCount						ifTrue: [self doExpiredInspectCount]]				ifFalse: [int = 1						ifTrue: [self doExpiredInspectCount]						ifFalse: [self setHaltCountTo: int - 1]]]! !!Object methodsFor: '*Tools-Inspector' stamp: 'igorStasenko 1/30/2010 14:04'!inspectOnce	"Inspect unless we have already done it once."	self haltOnceEnabled		ifTrue: [self clearHaltOnce.				^ self inspect]! !!Object methodsFor: '*Tools-Inspector' stamp: 'sbw 6/2/2004 13:20'!inspectUntilCount: int 	self haltOnceEnabled		ifTrue: [self hasHaltCount				ifTrue: [self decrementAndCheckHaltCount						ifTrue: [self doExpiredInspectCount]						ifFalse: [self inspect]]				ifFalse: [int = 1						ifTrue: [self doExpiredInspectCount]						ifFalse: [self setHaltCountTo: int - 1]]]! !!Object methodsFor: '*Tools-Inspector' stamp: 'IgorStasenko 4/15/2011 17:30'!inspectWithLabel: aLabel	"Create and schedule an Inspector in which the user can examine the receiver's variables."	^Smalltalk tools inspect: self label: aLabel! !!Object methodsFor: '*Tools-Inspector' stamp: 'IgorStasenko 4/26/2011 16:58'!inspectorClass	"Answer the class of the inspector to be used on the receiver.  Called by inspect; 	use basicInspect to get a normal (less useful) type of inspector."	^ Smalltalk tools inspector! !!Object methodsFor: '*UIManager' stamp: 'rbb 3/1/2005 09:26'!confirm: queryString	"Put up a yes/no menu with caption queryString. Answer true if the 	response is yes, false if no. This is a modal question--the user must 	respond yes or no."	"nil confirm: 'Are you hungry?'"	^ UIManager default confirm: queryString! !!Object methodsFor: '*UIManager' stamp: 'rbb 3/1/2005 09:28'!inform: aString	"Display a message for the user to read and then dismiss. 6/9/96 sw"	aString isEmptyOrNil ifFalse: [UIManager default inform: aString]! !!Object methodsFor: '*UIManager' stamp: 'pavel.krivanek 11/21/2008 16:50'!primitiveError: aString 	"This method is called when the error handling results in a recursion in 	calling on error: or halt or halt:."	UIManager default onPrimitiveError: aString.! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:35'!checkHaltCountExpired	self deprecated: 'Was used internally by Object>>halt:onCount: See its deprecation warning' on: '8/29/2011' in: '1.4'.! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:56'!clearHaltOnce	"Turn on image-wide Halt once"	self deprecated: 'Use "Halt disableHaltOnce". This method bloats Object and wrongly suggests haltOnce may be per-object' on: '8/29/2011' in: '1.4'.	Halt disableHaltOnce.! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:36'!decrementAndCheckHaltCount	self deprecated: 'Was used internally by Object>>halt:onCount: See its deprecation warning' on: '8/29/2011' in: '1.4'.! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:36'!decrementHaltCount	self deprecated: 'Was used internally by Object>>halt:onCount: See its deprecation warning' on: '8/29/2011' in: '1.4'.! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:36'!doExpiredHaltCount	self deprecated: 'Was used internally by Object>>halt:onCount: See its deprecation warning' on: '8/29/2011' in: '1.4'.! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:35'!doExpiredHaltCount: aString	self deprecated: 'Was used internally by Object>>halt:onCount: See its deprecation warning' on: '8/29/2011' in: '1.4'.! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:57'!halt: aString onCount: anInteger 	"Deprecated: see below	Halt on the anInteger-th time through, showing message aString"			| currentCount |	currentCount := Halt isCounting 		ifTrue: [ Halt callsUntilHaltOnCount ]		ifFalse: [				self deprecated: 'Use #haltOnCount:. Since you end up in a debugger, aString provides little information' on: '8/29/2011' in: '1.4'.				anInteger ].	Halt callsUntilHaltOnCount: currentCount - 1.	Halt callsUntilHaltOnCount = 0 ifTrue: [ Halt now ].! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:36'!haltCount	self deprecated: 'Was used internally by Object>>halt:onCount: See its deprecation warning' on: '8/29/2011' in: '1.4'.! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:57'!haltOnce: aString 	"Halt unless we have already done it once."	self deprecated: 'Use #haltOnce:. Since you end up in a debugger, aString provides little information' on: '8/29/2011' in: '1.4'.	Halt isHaltOnceEnabled		ifTrue: [ Halt disableHaltOnce.				^ Halt signal: aString ]! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:57'!haltOnceEnabled	"is haltOnce enabled globally"	self deprecated: 'Use "Halt isHaltOnceEnabled".  This method bloats Object and wrongly suggests haltOnce may be per-object' on: '8/29/2011' in: '1.4'.	^ Halt isHaltOnceEnabled.! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 15:51'!hasHaltCount	self deprecated: 'Now private to Halt' on: '8/29/2011' in: '1.4'.	^ Halt isCounting.! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 15:51'!removeHaltCount	self deprecated: 'Now private to Halt' on: '8/29/2011' in: '1.4'.	^ Halt stopCounting.! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:55'!setHaltCountTo: int	self deprecated: 'Was used internally by Object>>halt:onCount: See its deprecation warning' on: '8/29/2011' in: '1.4'.! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:58'!setHaltOnce	"Turn on the halt once flag."	self deprecated: 'Use "Halt enableHaltOnce".  This method bloats Object and wrongly suggests haltOnce may be per-object' on: '8/29/2011' in: '1.4'.	Halt enableHaltOnce.! !!Object methodsFor: '*deprecated14' stamp: 'SeanDeNigris 8/29/2011 17:34'!toggleHaltOnce	self deprecated: 'See Halt for new API' on: '8/29/2011' in: '1.4'.	Halt isHaltOnceEnabled		ifTrue: [Halt disableHaltOnce]		ifFalse: [Halt enableHaltOnce]! !!Object methodsFor: '*necompletion-extensions' stamp: 'EstebanLorenzano 4/11/2012 15:47'!isCodeCompletionAllowed	^false! !!Object methodsFor: '*petitparser-core-converting' stamp: 'lr 12/18/2011 15:58'!asParser	"Answer a parser accepting the receiving object."	^ PPPredicateObjectParser expect: self! !!Object methodsFor: '*petitparser-core-testing' stamp: 'lr 2/7/2010 20:54'!isPetitFailure	^ false! !!Object methodsFor: '*petitparser-core-testing' stamp: 'lr 8/6/2010 16:44'!isPetitParser	^ false! !!Object methodsFor: '*prettypetit-converting' stamp: 'lr 3/11/2010 14:21'!asDocument	^ PPTextDocument string: self printString! !!Object methodsFor: '*system-object storage' stamp: 'StephaneDucasse 7/23/2010 12:37'!convertToCurrentVersion: varDict refStream: smartRefStrm	"subclasses should implement if they wish to convert old instances to modern ones"	"this method should not be removed since SmartRefStream use it"! !!Object methodsFor: '*typesystem-core' stamp: 'EstebanAllende 12/5/2011 12:52'!isType	^false! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 6/19/2012 17:40'!(?) at: (?)index 	"Primitive. Assumes receiver is indexable. Answer the value of an 	indexable element in the receiver. Fail if the argument index is not an 	Integer or is out of bounds. Essential. See Object documentation 	whatIsAPrimitive. Read the class comment for a discussion about that the fact	that the index can be a float."	<primitive: 60>	index isInteger ifTrue:		[self class isVariable			ifTrue: [self errorSubscriptBounds: index]			ifFalse: [self errorNotIndexable]].	index isNumber		ifTrue: [^self at: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 6/19/2012 18:08'!(A) at: (?)index modify: (?→A)aBlock	"Replace the element of the collection with itself transformed by the block"	^ self at: index put: (aBlock value: (self at: index))! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 6/19/2012 19:09'!(A) at: (?)index put: (A)value 	"Primitive. Assumes receiver is indexable. Store the argument value in 	the indexable element of the receiver indicated by index. Fail if the 	index is not an Integer or is out of bounds. Or fail if the value is not of 	the right type for this kind of collection. Answer the value that was 	stored. Essential. See Object documentation whatIsAPrimitive."	<primitive: 61>	index isInteger ifTrue:		[self class isVariable			ifTrue: [(index >= 1 and: [index <= self size])					ifTrue: [^self errorImproperStore]					ifFalse: [^self errorSubscriptBounds: index]]			ifFalse: [^self errorNotIndexable]].	index isNumber		ifTrue: [^self at: index asInteger put: value]		ifFalse: [^self errorNonIntegerIndex]! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 6/19/2012 18:53'!(?) basicAt: (Integer)index 	"Primitive. Assumes receiver is indexable. Answer the value of an 	indexable element in the receiver. Fail if the argument index is not an 	Integer or is out of bounds. Essential. Do not override in a subclass. See 	Object documentation whatIsAPrimitive."	<primitive: 60>	index isInteger ifTrue: [self errorSubscriptBounds: index].	index isNumber		ifTrue: [^self basicAt: index asInteger]		ifFalse: [^self errorNonIntegerIndex]! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 6/19/2012 18:53'!(A) basicAt: (Integer)index put: (A)value 	"Primitive. Assumes receiver is indexable. Store the second argument 	value in the indexable element of the receiver indicated by index. Fail 	if the index is not an Integer or is out of bounds. Or fail if the value is 	not of the right type for this kind of collection. Answer the value that 	was stored. Essential. Do not override in a subclass. See Object 	documentation whatIsAPrimitive."	<primitive: 61>	index isInteger		ifTrue: [(index >= 1 and: [index <= self size])					ifTrue: [^self errorImproperStore]					ifFalse: [^self errorSubscriptBounds: index]].	index isNumber		ifTrue: [^self basicAt: index asInteger put: value]		ifFalse: [^self errorNonIntegerIndex]! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 6/19/2012 18:54'!(Integer) basicSize	"Primitive. Answer the number of indexable variables in the receiver. 	This value is the same as the largest legal subscript. Essential. Do not 	override in any subclass. See Object documentation whatIsAPrimitive."	<primitive: 62>	"The number of indexable fields of fixed-length objects is 0"	^0	! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 6/19/2012 18:55'!(Object) enclosedSetElement	"The receiver is included into a set as an element. 	Since some objects require wrappers (see SetElement) to be able to be included into a Set,	a set sends this message to its element to make sure it getting real object,	instead of its wrapper.	Only SetElement instance or its subclasses allowed to answer something different than receiver itself"	! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 6/19/2012 18:57'!(A|B) ifNil: (→A)nilBlock ifNotNilDo: (Self → B)aBlock 	"Evaluate aBlock with the receiver as its argument."	^ aBlock value: self! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 6/19/2012 18:58'!(A) ifNotNilDo: (Self→A)aBlock	"Evaluate the given block with the receiver as its argument."	^ aBlock value: self! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 6/19/2012 18:58'!(A|B) ifNotNilDo: (Self → A)aBlock ifNil: (→B)nilBlock	"Evaluate aBlock with the receiver as its argument."	^ aBlock value: self! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 6/19/2012 18:59'!(A) in: (Self → A)aBlock	"Evaluate the given block with the receiver as its argument."	^ aBlock value: self! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 6/19/2012 19:03'!(Object) readFrom: (Stream)aStream 	^ self subclassResponsibility! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 6/19/2012 19:03'!(Object) readFromString: (String)aString 	"Create an object based on the contents of aString."	^ self readFrom: aString readStream! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 6/19/2012 19:03'!(Integer) size	"Primitive. Answer the number of indexable variables in the receiver. 	This value is the same as the largest legal subscript. Essential. See Object 	documentation whatIsAPrimitive."	<primitive: 62>	self class isVariable ifFalse: [self errorNotIndexable].	^ 0! !!Object methodsFor: 'accessing' stamp: 'EstebanAllende 6/19/2012 19:03'!(Self) yourself	"Answer self."	^self! !!Object methodsFor: 'associating' stamp: 'EstebanAllende 6/19/2012 19:05'!(Association<Self,A>) -> (A)anObject	"Answer an Association between self and anObject"	^Association basicNew key: self value: anObject! !!Object methodsFor: 'binding' stamp: 'EstebanAllende 6/19/2012 19:11'!(Association) bindingOf: (String)aString	^nil! !!Object methodsFor: 'casing' stamp: 'EstebanAllende 6/19/2012 19:20'!(A) caseOf: (Collection<Association< →Object , →A >>)aBlockAssociationCollection	"The elements of aBlockAssociationCollection are associations between blocks.	 Answer the evaluated value of the first association in aBlockAssociationCollection	 whose evaluated key equals the receiver.  If no match is found, report an error."	^ self caseOf: aBlockAssociationCollection otherwise: [self caseError]"| z | z := {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z""| z | z := {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z""The following are compiled in-line:""#b caseOf: {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}""#b caseOf: {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}"! !!Object methodsFor: 'casing' stamp: 'EstebanAllende 6/19/2012 19:17'!(A|B) caseOf: (Collection<Association< →Object , →A >>)aBlockAssociationCollection otherwise: (→B)aBlock	"The elements of aBlockAssociationCollection are associations between blocks.	 Answer the evaluated value of the first association in aBlockAssociationCollection	 whose evaluated key equals the receiver.  If no match is found, answer the result	 of evaluating aBlock."	aBlockAssociationCollection associationsDo:		[:(Association< →Object , →A >)assoc | (assoc key value = self) ifTrue: [^assoc value value]].	^ aBlock value"| z | z := {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]""| z | z := {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]""The following are compiled in-line:""#b caseOf: {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]""#b caseOf: {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]"! !!Object methodsFor: 'class membership' stamp: 'EstebanAllende 6/19/2012 19:21'!(Self class) class	"Primitive. Answer the object which is the receiver's class. Essential. See 	Object documentation whatIsAPrimitive."	<primitive: 111>	self primitiveFailed! !!Object methodsFor: 'class membership' stamp: 'EstebanAllende 6/19/2012 19:22'!(Boolean) isKindOf: (Behavior)aClass 	"Answer whether the class, aClass, is a superclass or class of the receiver."	self class == aClass		ifTrue: [^true]		ifFalse: [^self class inheritsFrom: aClass]! !!Object methodsFor: 'class membership' stamp: 'EstebanAllende 6/19/2012 19:22'!(Boolean) isMemberOf: (Behavior)aClass 	"Answer whether the receiver is an instance of the class, aClass."	^self class == aClass! !!Object methodsFor: 'class membership' stamp: 'EstebanAllende 6/19/2012 19:23'!(Boolean) respondsTo: (Symbol)aSymbol 	"Answer whether the method dictionary of the receiver's class contains 	aSymbol as a message selector."	^self class canUnderstand: aSymbol! !!Object methodsFor: 'class membership' stamp: 'EstebanAllende 6/19/2012 19:23'!(Self class) xxxClass	"For subclasses of nil, such as ObjectOut"	^ self class! !!Object methodsFor: 'comparing' stamp: 'EstebanAllende 6/19/2012 19:23'!(Integer) hash	"Answer a SmallInteger whose value is related to the receiver's identity.	May be overridden, and should be overridden in any classes that define = "	^ self identityHash ! !!Object methodsFor: 'comparing' stamp: 'EstebanAllende 6/19/2012 19:24'!(String) identityHashPrintString	"'fred' identityHashPrintString"	^ '(', self identityHash printString, ')'! !!Object methodsFor: 'comparing' stamp: 'EstebanAllende 6/19/2012 19:24'!(Boolean) literalEqual: (Object)other	^ self class == other class and: [self = other]! !!Object methodsFor: 'comparing' stamp: 'EstebanAllende 6/19/2012 19:24'!(Boolean) = (?)anObject 	"Answer whether the receiver and the argument represent the same 	object. If = is redefined in any subclass, consider also redefining the 	message hash."	^self == anObject ! !!Object methodsFor: 'comparing' stamp: 'EstebanAllende 6/19/2012 19:24'!(Boolean) ~= (Object)anObject 	"Answer whether the receiver and the argument do not represent the 	same object."	^self = anObject == false! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 6/19/2012 19:28'!(Boolean) adaptToFloat: (Float)rcvr andCompare: (Symbol)selector 	"If I am involved in comparison with a Float.	Default behaviour is to process comparison as any other selectors."	^ self adaptToFloat: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 6/19/2012 19:27'!(?) adaptToFloat: (Float)rcvr andSend: (Symbol)selector	"If no method has been provided for adapting an object to a Float,	then it may be adequate to simply adapt it to a number."	^ self adaptToNumber: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 6/19/2012 19:28'!(Boolean) adaptToFraction: (Fraction)rcvr andCompare: (Symbol)selector 	"If I am involved in comparison with a Fraction.	Default behaviour is to process comparison as any other selectors."	^ self adaptToFraction: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 6/19/2012 19:27'!(?) adaptToFraction: (Fraction)rcvr andSend: (Symbol)selector	"If no method has been provided for adapting an object to a Fraction,	then it may be adequate to simply adapt it to a number."	^ self adaptToNumber: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 6/19/2012 19:28'!(Boolean)adaptToInteger: (Integer)rcvr andCompare: (Symbol)selector 	"If I am involved in comparison with an Integer.	Default behaviour is to process comparison as any other selectors."	^ self adaptToInteger: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 6/19/2012 19:27'!(?) adaptToInteger: (Integer)rcvr andSend: (Symbol)selector	"If no method has been provided for adapting an object to a Integer,	then it may be adequate to simply adapt it to a number."	^ self adaptToNumber: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 6/19/2012 19:26'!(?) adaptToNumber: (Number)rcvr andSend: (Symbol)selector	^ self subclassResponsibility.! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 6/19/2012 19:29'!(WeakActionSequence) asActionSequence	^WeakActionSequence with: self! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 6/19/2012 19:29'!(WeakActionSequenceTrappingErrors) asActionSequenceTrappingErrors	^WeakActionSequenceTrappingErrors with: self! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 6/19/2012 19:30'!(Link) asLink	"Answer a string that represents the receiver."	^ ValueLink value: self! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 6/19/2012 19:31'!(OrderedCollection) asOrderedCollection	"Answer an OrderedCollection with the receiver as its only element."	^ OrderedCollection with: self! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 6/19/2012 19:31'!(Object) asSetElement	"Answer an object, which can be put into a Set as element , wrapped	by one of SetElement instance, if necessary. 	Default implementation is to answer self"! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 6/19/2012 19:31'!(String) asString	"Answer a string that represents the receiver."	^ self printString ! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 6/19/2012 19:31'!(String|Text) asStringOrText	"Answer a string that represents the receiver."	^ self printString ! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 6/19/2012 19:34'!(Object) as: (Object class)aSimilarClass	"Create an object of class aSimilarClass that has similar contents to the receiver."	^ aSimilarClass newFrom: self! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 6/19/2012 19:35'!(Object) complexContents	^self! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 6/19/2012 19:36'!(Boolean) mustBeBoolean	"Catches attempts to test truth of non-Booleans.  This message is sent from the VM.  The sending context is rewound to just before the jump causing this exception."	^ self mustBeBooleanIn: thisContext sender! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 6/19/2012 19:36'!(Boolean) mustBeBooleanIn: (ContextPart)context	"context is the where the non-boolean error occurred. Rewind context to before jump then raise error."	| proceedValue |	context skipBackBeforeJump.	proceedValue := NonBooleanReceiver new		object: self;		signal: 'proceed for truth.'.	^ proceedValue ~~ false! !!Object methodsFor: 'converting' stamp: 'EstebanAllende 6/19/2012 19:37'!(Object) withoutListWrapper	^self! !!Object methodsFor: 'copying' stamp: 'EstebanAllende 6/19/2012 19:38'!(Self) copy	"Answer another instance just like the receiver. Subclasses typically override postCopy; they typically do not override shallowCopy. Copy is a template method in the sense of Design Patterns. So do not override it. Override postCopy instead. Pay attention that normally you should call postCopy of your superclass too."	^self shallowCopy postCopy! !!Object methodsFor: 'copying' stamp: 'EstebanAllende 6/19/2012 19:40'!(Self) copyFrom: (Object)anotherObject	"Copy to myself all instance variables I have in common with anotherObject.  This is dangerous because it ignores an object's control over its own inst vars.  "	| (Collection<String>)mine (Collection<String>)his |	<primitive: 168>	mine := self class allInstVarNames.	his := anotherObject class allInstVarNames.	1 to: (mine size min: his size) do: [:(Integer)ind |		(mine at: ind) = (his at: ind) ifTrue: [			self instVarAt: ind put: (anotherObject instVarAt: ind)]].	self class isVariable & anotherObject class isVariable ifTrue: [		1 to: (self basicSize min: anotherObject basicSize) do: [:(Integer)ind |			self basicAt: ind put: (anotherObject basicAt: ind)]].! !!Object methodsFor: 'copying' stamp: 'EstebanAllende 7/2/2012 17:26'!(Self) copySameFrom: (Object)otherObject	"Copy to myself all instance variables named the same in otherObject.	This ignores otherObject's control over its own inst vars."	| (Array<String>)myInstVars (Array<String>)otherInstVars |	myInstVars := self class allInstVarNames.	otherInstVars := otherObject class allInstVarNames.	myInstVars doWithIndex: [:(String)each :(Integer)index | | (Integer)match |		(match := otherInstVars indexOf: each) > 0 ifTrue:			[self instVarAt: index put: (otherObject instVarAt: match)]].	1 to: (self basicSize min: otherObject basicSize) do: [:(Integer)i |		self basicAt: i put: (otherObject basicAt: i)].! !!Object methodsFor: 'copying' stamp: 'EstebanAllende 6/20/2012 12:20'!(Self) deepCopy	"Answer a copy of the receiver with its own copy of each instance variable. deepCopy does a deep copy. It should never be overridden and only be used if you want to get these very specific semantics.It doesn't handle cycles, #veryDeepCopy does. In the future we will make it handle cycles and deprecate veryDeepCopy"	| (Self)newObject (Self class)class (Integer)index |	class := self class.	(class == Object) ifTrue: [^self].	class isVariable		ifTrue: 			[index := self basicSize.			newObject := class basicNew: index.			[index > 0]				whileTrue: 					[newObject basicAt: index put: (self basicAt: index) deepCopy.					index := index - 1]]		ifFalse: [newObject := class basicNew].	index := class instSize.	[index > 0]		whileTrue: 			[newObject instVarAt: index put: (self instVarAt: index) deepCopy.			index := index - 1].	^newObject! !!Object methodsFor: 'copying' stamp: 'EstebanAllende 6/19/2012 19:38'!(Self) postCopy	"I'm a hook method in the sense of Design Patterns TemplateHook/Methods. I'm called by copy. self is a shallow copy, subclasses should copy fields as necessary to complete the full copy"	^ self ! !!Object methodsFor: 'copying' stamp: 'EstebanAllende 6/19/2012 19:37'!(Self) shallowCopy	"Answer a copy of the receiver which shares the receiver's instance variables. It should never be overridden. I'm invoked from the copy template method. Subclasses that need to specialize the copy should specialize the postCopy hook method."		| (Self class)class (Self)newObject (Integer)index |	<primitive: 148>	class := self class.	class isVariable		ifTrue: 			[index := self basicSize.			newObject := class basicNew: index.			[index > 0]				whileTrue: 					[newObject basicAt: index put: (self basicAt: index).					index := index - 1]]		ifFalse: [newObject := class basicNew].	index := class instSize.	[index > 0]		whileTrue: 			[newObject instVarAt: index put: (self instVarAt: index).			index := index - 1].	^ newObject! !!Object methodsFor: 'copying' stamp: 'EstebanAllende 6/20/2012 12:34'!(Self) veryDeepCopy	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  All references to the object in the copy of the tree will point to the new copy."	| (DeepCopier)copier (Self)new |	copier := DeepCopier new initialize: 4096 "self initialDeepCopierSize".	new := self veryDeepCopyWith: copier.	copier references associationsDo: [:(Association)assoc | 		assoc value veryDeepFixupWith: copier].	copier fixDependents.	^ new! !!Object methodsFor: 'copying' stamp: 'EstebanAllende 6/20/2012 12:31'!(Self) veryDeepCopyWith: (DeepCopier)deepCopier	"Copy me and the entire tree of objects I point to.  An object in the tree twice is copied once, and both references point to him.  deepCopier holds a dictionary of objects we have seen.  Some classes refuse to be copied.  Some classes are picky about which fields get deep copied."	| (Self class)class (Integer)index (Behavior)sub (Association)subAss (Self)new (Behavior)sup (?)has (Collection<String>)mine |	deepCopier references at: self ifPresent: [:(Object)newer | ^ (<Self>newer)]. 	"already did him"	class := self class.	class isMeta ifTrue: [^ self].		"a class"	new := self shallowCopy.	deepCopier references at: self put: new.	"remember"	(class isVariable and: [class isPointers]) ifTrue: 		[index := self basicSize.		[index > 0] whileTrue: 			[sub := self basicAt: index.			(subAss := deepCopier references associationAt: sub ifAbsent: [nil])				ifNil: [new basicAt: index put: (sub veryDeepCopyWith: deepCopier)]				ifNotNil: [new basicAt: index put: subAss value].			index := index - 1]].	"Ask each superclass if it wants to share (weak copy) any inst vars"	new veryDeepInner: deepCopier.		"does super a lot"	"other superclasses want all inst vars deep copied"	sup := class.  index := class instSize.	[has := sup compiledMethodAt: #veryDeepInner: ifAbsent: [nil].	has := has ifNil: [ false ] ifNotNil: [ true ].	mine := sup instVarNames.	has ifTrue: [index := index - mine size]	"skip inst vars"		ifFalse: [1 to: mine size do: [:(Integer)xx |				sub := self instVarAt: index.				(subAss := deepCopier references associationAt: sub ifAbsent: [nil])						"use association, not value, so nil is an exceptional value"					ifNil: [new instVarAt: index put: 								(sub veryDeepCopyWith: deepCopier)]					ifNotNil: [new instVarAt: index put: subAss value].				index := index - 1]].	(sup := sup superclass) == nil] whileFalse.	new rehash.	"force Sets and Dictionaries to rehash"	^ new! !!Object methodsFor: 'copying' stamp: 'EstebanAllende 6/20/2012 12:33'!(Self) veryDeepFixupWith: (DeepCopier)deepCopier	"I have no fields and no superclass.  Catch the super call."		"avoid to use me we will deprecate it in the future"! !!Object methodsFor: 'copying' stamp: 'EstebanAllende 6/20/2012 12:33'!(Self) veryDeepInner: (DeepCopier)deepCopier	"No special treatment for inst vars of my superclasses.  Override when some need to be weakly copied.  Object>>veryDeepCopyWith: will veryDeepCopy any inst var whose class does not actually define veryDeepInner:"	"avoid to use me we will deprecate it in the future"! !!Object methodsFor: 'dependents access' stamp: 'EstebanAllende 6/20/2012 14:38'!(A) addDependent: (A)anObject	<whereType:'(Object)A'>	"Make the given object one of the receiver's dependents."	| (Collection<Object>)dependents |	dependents := self dependents.	(dependents includes: anObject) ifFalse:		[self myDependents: (dependents copyWithDependent: anObject)].	^ anObject! !!Object methodsFor: 'dependents access' stamp: 'EstebanAllende 6/20/2012 14:54'!(Self) breakDependents	"Remove all of the receiver's dependents."	self myDependents: nil! !!Object methodsFor: 'dependents access' stamp: 'EstebanAllende 6/20/2012 14:54'!(Boolean) canDiscardEdits	"Answer true if none of the views on this model has unaccepted edits that matter."	self dependents		do: [:(Object)each | each canDiscardEdits ifFalse: [^ false]]		without: self.	^ true! !!Object methodsFor: 'dependents access' stamp: 'EstebanAllende 6/20/2012 12:37'!(Collection<Object>) dependents	"Answer a collection of objects that are 'dependent' on the receiver;	 that is, all objects that should be notified if the receiver changes."	^ self myDependents ifNil: [#()]! !!Object methodsFor: 'dependents access' stamp: 'EstebanAllende 6/20/2012 14:54'!(Boolean) hasUnacceptedEdits	"Answer true if any of the views on this object has unaccepted edits."	self dependents		do: [:(Object)each | each hasUnacceptedEdits ifTrue: [^ true]]		without: self.	^ false! !!Object methodsFor: 'dependents access' stamp: 'EstebanAllende 6/20/2012 12:36'!(Collection<Object>) myDependents	"Private. Answer a list of all the receiver's dependents."	^ DependentsFields at: self ifAbsent: []! !!Object methodsFor: 'dependents access' stamp: 'EstebanAllende 6/20/2012 12:37'!(Self) myDependents: (Collection<Object>)aCollectionOrNil	"Private. Set (or remove) the receiver's dependents list."	aCollectionOrNil		ifNil: [DependentsFields removeKey: self ifAbsent: []]		ifNotNil: [DependentsFields at: self put: aCollectionOrNil]! !!Object methodsFor: 'dependents access' stamp: 'EstebanAllende 6/20/2012 14:55'!(Self) release	"Remove references to objects that may refer to the receiver. This message 	should be overridden by subclasses with any cycles, in which case the 	subclass should also include the expression super release."	self releaseActionMap! !!Object methodsFor: 'dependents access' stamp: 'EstebanAllende 6/20/2012 14:55'!(A) removeDependent: (A)anObject	"Remove the given object as one of the receiver's dependents."	| (Collection<Object>)dependents |	dependents := self dependents reject: [:(Object)each | each == anObject].	self myDependents: (dependents isEmpty ifFalse: [dependents]).	^ anObject! !!Object methodsFor: 'drag and drop' stamp: 'EstebanAllende 6/20/2012 14:58'!(Boolean) acceptDroppingMorph: (Morph)transferMorph event: (MorphicEvent)evt inMorph: (Morph)dstListMorph 		^false.! !!Object methodsFor: 'drag and drop' stamp: 'EstebanAllende 6/20/2012 14:59'!(Morph) dragPassengerFor: (Morph)item inMorph: (Morph)dragSource 	^item! !!Object methodsFor: 'drag and drop' stamp: 'EstebanAllende 6/20/2012 15:00'!(TransferMorph) dragTransferType	^nil! !!Object methodsFor: 'drag and drop' stamp: 'EstebanAllende 6/20/2012 15:00'!(TransferMorph) dragTransferTypeForMorph: (Morph)dragSource 	^nil! !!Object methodsFor: 'drag and drop' stamp: 'EstebanAllende 6/20/2012 15:15'!(Boolean) wantsDroppedMorph: (Morph)aMorph event: (MorphicEvent)anEvent inMorph: (Morph)destinationLM 	^false ! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:28'!(Self) assert: (→ Boolean)aBlock	"Throw an assertion error if aBlock does not evaluates to true."		aBlock value ifFalse: [AssertionFailure signal: 'Assertion failed']! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:29'!(Self) assert: (→ Boolean)aBlock descriptionBlock: (→Object)descriptionBlock	"Throw an assertion error if aBlock does not evaluate to true."		aBlock value ifFalse: [AssertionFailure signal: descriptionBlock value asString ]! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:30'!(Self) assert: (→Boolean)aBlock description: (String)aString	"Throw an assertion error if aBlock does not evaluates to true."		aBlock value ifFalse: [AssertionFailure signal: aString ]! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:30'!(Nil) caseError	"Report an error from an in-line or explicit case statement."	self error: 'Case not found (', self printString, '), and no otherwise clause'.	^nil! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:32'!(Boolean | A) confirm: (String)aString orCancel: (→A)cancelBlock	"Put up a yes/no/cancel menu with caption aString. Answer true if  	the response is yes, false if no. If cancel is chosen, evaluate  	cancelBlock. This is a modal question--the user must respond yes or no."	^ UIManager default confirm: aString orCancel: cancelBlock! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:34'!(Self) deprecated: (String)anExplanationString	"this is not itself deprecated, but a compatibility method for old-style deprecation"	^ self deprecated: anExplanationString on: 'unknown'  in: 'unkown'! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:34'!(Self) deprecated: (String)anExplanationString on: (String)date in: (String)version	"Warn that the sending method has been deprecated"		(Deprecation		method: thisContext sender method		explanation: anExplanationString		on: date		in: version) signal! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:35'!(ProtoObject) doesNotUnderstand: (Message)aMessage 	 "Handle the fact that there was an attempt to send the given message to the receiver but the receiver does not understand this message (typically sent from the machine when a message is sent to the receiver and no method is defined for that selector)."	"Testing: (3 activeProcess)"	"fixed suggested by Eliot miranda to make sure 		[Object new blah + 1] 		on: MessageNotUnderstood 		do: [:e | e resume: 1] does not loop indefinitively"			| (MessageNotUnderstood)exception (ProtoObject)resumeValue |	(exception := MessageNotUnderstood new)		message: aMessage;		receiver: self.	resumeValue := exception signal.	^exception reachedDefaultHandler		ifTrue: [aMessage sentTo: self]		ifFalse: [resumeValue]! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:43'!(Self) dpsTrace: (Object)reportObject  	Transcript myDependents isNil ifTrue: [^self].	self dpsTrace: reportObject levels: 1 withContext: thisContext 		" nil dpsTrace: 'sludder'. "! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:43'!(Self) dpsTrace: (Object)reportObject levels: (Integer)anInt	self dpsTrace: reportObject levels: anInt withContext: thisContext"(1 to: 3) do: [:int | nil dpsTrace: int levels: 5.]"! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:41'!(Self) dpsTrace: (Object)reportObject levels: (Integer)anInt withContext: (ContextPart)currentContext	| (String)reportString (ContextPart)context (Boolean)displayCount |	reportString := (reportObject respondsTo: #asString)		ifTrue: [ reportObject asString ]		ifFalse: [ reportObject printString ].	(Smalltalk globals at: #Decompiler ifAbsent: [ nil ])		ifNil: [ 			Transcript				cr;				show: reportString ]		ifNotNil: [ 			context := currentContext.			displayCount := anInt > 1.			1 to: anInt do: [ :count | 				Transcript cr.				displayCount					ifTrue: [ Transcript show: count printString , ': ' ].				reportString notNil					ifTrue: [ 						Transcript show: context home class name , '/' , context sender selector , ' (' , reportString , ')'.						context := context sender.						reportString := nil ]					ifFalse: [ 						(context notNil and: [ (context := context sender) notNil ])							ifTrue: [ Transcript show: context receiver class name , '/' , context selector ] ] ]	"Transcript cr" ]! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:45'!(?) error	"Throw a generic Error exception."	^self error: 'Error!!'.! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:45'!(?)error: (String)aString 	"Throw a generic Error exception."	^Error new signal: aString! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:45'!(Nil) explicitRequirement	self error: 'Explicitly required method'.	^nil! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:45'!(Boolean) handles: (Exception)exception	"This method exists in case a non exception class is the first arg in an on:do: (for instance using a exception class that is not loaded). We prefer this to raising an error during error handling itself. Also, semantically it makes sense that the exception handler is not active if its exception class is not loaded"	^ false! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:46'!(Self) notify: (String)aString 	"Create and schedule a Notifier with the argument as the message in 	order to request confirmation before a process can proceed."	Warning signal: aString! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:46'!(Self) notify: (String)aString at: (Object)location	"Create and schedule a Notifier with the argument as the message in 	order to request confirmation before a process can proceed. Subclasses can	override this and insert an error message at location within aString."	self notify: aString	"nil notify: 'confirmation message' at: 12"! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:49'!(Nil) primitiveFail	"primitiveFail may be invoked by certain methods whose code is translated in C. In such a case primitiveFail and not primitiveFailed	 should be invoked. The reason is that this code is translated to C by VMMaker. #primitiveFail is 	implemented in Interpreter of VMMaker."	^ self primitiveFailed! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:49'!(Nil) primitiveFailed	"Announce that a primitive has failed and there is no appropriate Smalltalk code to run."	^self primitiveFailed: thisContext sender selector! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:49'!(Nil) primitiveFailed: (Symbol)selector	"Announce that a primitive has failed and there is no appropriate Smalltalk code to run."		PrimitiveFailed signalFor: selector.	^nil! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:50'!(Nil) requirement	self error: 'Implicitly required method'.	^nil! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:50'!(Nil) shouldBeImplemented	"Announce that this message should be implemented"	ShouldBeImplemented signalFor: thisContext sender selector.	^nil! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:51'!(Nil) shouldNotImplement	"Announce that, although the receiver inherits this message, 	it should not implement it."	ShouldNotImplement signalFor: thisContext sender selector.	^nil! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:51'!(Nil) subclassResponsibility	"This message sets up a framework for the behavior of the class' subclasses.	Announce that the subclass should have implemented this message."	SubclassResponsibility signalFor: thisContext sender selector.	^nil! !!Object methodsFor: 'error handling' stamp: 'EstebanAllende 6/19/2012 18:51'!(Nil) traitConflict	self error: 'A class or trait does not properly resolve a conflict between multiple traits it uses.'.	^nil! !!Object methodsFor: 'evaluating' stamp: 'EstebanAllende 6/20/2012 17:31'!(?) value	^self! !!Object methodsFor: 'evaluating' stamp: 'EstebanAllende 6/20/2012 17:32'!(?)valueWithArguments: (Collection<Object>)aSequenceOfArguments	^self! !!Object methodsFor: 'events-accessing' stamp: 'EstebanAllende 6/20/2012 17:57'!(Object)actionForEvent: (String)anEventSelector    "Answer the action to be evaluated when <anEventSelector> has been triggered."	| ({asMinimalRepresentation (→ Object)})actions |	actions := self actionMap		at: anEventSelector asSymbol		ifAbsent: [nil].	actions ifNil: [^nil].	^ actions asMinimalRepresentation! !!Object methodsFor: 'events-accessing' stamp: 'EstebanAllende 6/20/2012 18:11'!(Object)actionForEvent: (EventSelector)anEventSelectorifAbsent: (→ Object)anExceptionBlock    "Answer the action to be evaluated when <anEventSelector> has been triggered."	| ({asMinimalRepresentation (→ Object)})actions |	actions := self actionMap		at: anEventSelector asSymbol		ifAbsent: [nil].	actions ifNil: [^anExceptionBlock value].	^ actions asMinimalRepresentation! !!Object methodsFor: 'events-accessing' stamp: 'EstebanAllende 12/15/2011 18:20'!(Dictionary) actionMap	^EventManager actionMapFor: self! !!Object methodsFor: 'events-accessing' stamp: 'EstebanAllende 7/2/2012 17:38'!(WeakActionSequence) actionSequenceForEvent: (EventSelector) anEventSelector    ^(self actionMap        at: anEventSelector asSymbol        ifAbsent: [^WeakActionSequence new])            asActionSequence! !!Object methodsFor: 'events-accessing' stamp: 'EstebanAllende 2/21/2012 00:31'!(Self) actionsDo: (? → Object)aBlock	self actionMap do: aBlock! !!Object methodsFor: 'events-accessing' stamp: 'EstebanAllende 12/16/2011 16:03'!(Dictionary) createActionMap	^IdentityDictionary new! !!Object methodsFor: 'events-accessing' stamp: 'EstebanAllende 6/20/2012 17:52'!(Boolean) hasActionForEvent: (String)anEventSelector    "Answer true if there is an action associated with anEventSelector"    ^(self actionForEvent: anEventSelector) notNil! !!Object methodsFor: 'events-accessing' stamp: 'EstebanAllende 7/2/2012 17:39'!(Boolean) hasActionsWithReceiver: (Object) anObject	^self actionMap keys anySatisfy:		[:(EventSelector) eachEventSelector |			(self actionSequenceForEvent: eachEventSelector)				anySatisfy: [:anAction | anAction receiver == anObject]]! !!Object methodsFor: 'events-accessing' stamp: 'EstebanAllende 7/2/2012 17:39'!(Self) setActionSequence: ({asMinimalRepresentation (→ ?)}) actionSequence          forEvent: (EventSelector)anEventSelector    | (Object)action |    action := actionSequence asMinimalRepresentation.    action == nil        ifTrue:            [self removeActionsForEvent: anEventSelector]        ifFalse:            [self updateableActionMap                at: anEventSelector asSymbol                put: action]! !!Object methodsFor: 'events-accessing' stamp: 'EstebanAllende 12/16/2011 16:11'!(Dictionary) updateableActionMap	^EventManager updateableActionMapFor: self! !!Object methodsFor: 'events-registering' stamp: 'EstebanAllende 6/20/2012 18:11'!(Self) when: (EventSelector)anEventSelector evaluate: (Action)anAction 	|(WeakActionSequence)actions |	actions := self actionSequenceForEvent: anEventSelector.	(actions includes: anAction)		ifTrue: [^ self].	self 		setActionSequence: (actions copyWith: anAction)		forEvent: anEventSelector! !!Object methodsFor: 'events-registering' stamp: 'EstebanAllende 6/20/2012 18:05'!(Self) when: (EventSelector)anEventSelectorsend: (Symbol)aMessageSelectorto: (Object)anObject     self        when: anEventSelector        evaluate: (WeakMessageSend            receiver: anObject            selector: aMessageSelector)! !!Object methodsFor: 'events-registering' stamp: 'EstebanAllende 6/20/2012 18:06'!(Self) when: (EventSelector)anEventSelectorsend: (Symbol)aMessageSelectorto: (Object)anObjectwithArguments: (Array)anArgArray     self        when: anEventSelector        evaluate: (WeakMessageSend            receiver: anObject            selector: aMessageSelector		arguments: anArgArray)! !!Object methodsFor: 'events-registering' stamp: 'EstebanAllende 6/20/2012 18:06'!(Self)when: (EventSelector)anEventSelectorsend: (Symbol)aMessageSelectorto: (Object)anObjectwith: (Array)anArg     self        when: anEventSelector        evaluate: (WeakMessageSend            receiver: anObject            selector: aMessageSelector		arguments: (Array with: anArg))! !!Object methodsFor: 'events-removing' stamp: 'EstebanAllende 12/16/2011 16:18'!(Self) releaseActionMap	EventManager releaseActionMapFor: self! !!Object methodsFor: 'events-removing' stamp: 'EstebanAllende 6/20/2012 18:07'!(Self) removeActionsForEvent: (EventSelector)anEventSelector    | (Dictionary)map |    map := self actionMap.    map removeKey: anEventSelector asSymbol ifAbsent: [].    map isEmpty        ifTrue: [self releaseActionMap]! !!Object methodsFor: 'events-removing' stamp: 'EstebanAllende 7/2/2012 17:36'!(Self)removeActionsSatisfying: (? → Boolean)aBlock	self actionMap keys do:		[:(EventSelector)eachEventSelector |			self   				removeActionsSatisfying: aBlock				forEvent: eachEventSelector		]! !!Object methodsFor: 'events-removing' stamp: 'EstebanAllende 6/20/2012 18:08'!(Self) removeActionsSatisfying: (? → Boolean)aOneArgBlock forEvent: (EventSelector)anEventSelector    self        setActionSequence:            ((self actionSequenceForEvent: anEventSelector)                reject: [:(Object)anAction | aOneArgBlock value: anAction])        forEvent: anEventSelector! !!Object methodsFor: 'events-removing' stamp: 'EstebanAllende 7/2/2012 17:38'!(Self) removeActionsWithReceiver: (Object)anObject	self actionMap copy keysDo:		[:(EventSelector)eachEventSelector |			self   				removeActionsSatisfying: [:({receiver (→ ?)})anAction | anAction receiver == anObject]				forEvent: eachEventSelector		]! !!Object methodsFor: 'events-removing' stamp: 'EstebanAllende 7/2/2012 17:37'!(Self)removeActionsWithReceiver: (Object)anObjectforEvent: (EventSelector)anEventSelector    self        removeActionsSatisfying:            [:({receiver (→ ?)})anAction |            anAction receiver == anObject]        forEvent: anEventSelector! !!Object methodsFor: 'events-removing' stamp: 'EstebanAllende 7/2/2012 17:37'!(Self) removeAction: (Object)anActionforEvent: (EventSelector)anEventSelector    self        removeActionsSatisfying: [:action | action = anAction]        forEvent: anEventSelector! !!Object methodsFor: 'events-triggering' stamp: 'EstebanAllende 6/20/2012 18:12'!(?) triggerEvent: (EventSelector)anEventSelector	"Evaluate all actions registered for <anEventSelector>. Return the value of the last registered action."    ^(self actionForEvent: anEventSelector) value! !!Object methodsFor: 'events-triggering' stamp: 'EstebanAllende 6/20/2012 18:14'!(?) triggerEvent: (EventSelector)anEventSelectorifNotHandled: (→ Object)anExceptionBlock	"Evaluate all actions registered for <anEventSelector>. Return the value of the last registered action."    ^(self 		actionForEvent: anEventSelector		ifAbsent: [^anExceptionBlock value]) value! !!Object methodsFor: 'events-triggering' stamp: 'EstebanAllende 6/20/2012 18:14'!(?) triggerEvent: (EventSelector)anEventSelectorwithArguments: (Array)anArgumentList    ^(self actionForEvent: anEventSelector)        valueWithArguments: anArgumentList! !!Object methodsFor: 'events-triggering' stamp: 'EstebanAllende 6/20/2012 18:14'!(?)triggerEvent: (EventSelector)anEventSelectorwithArguments: (Array)anArgumentListifNotHandled: (→ Object)anExceptionBlock    ^(self 		actionForEvent: anEventSelector		ifAbsent: [^anExceptionBlock value])        valueWithArguments: anArgumentList! !!Object methodsFor: 'events-triggering' stamp: 'EstebanAllende 6/20/2012 18:15'!(?)triggerEvent: (EventSelector)anEventSelectorwith: (Object)anObject    ^self 		triggerEvent: anEventSelector		withArguments: (Array with: anObject)! !!Object methodsFor: 'events-triggering' stamp: 'EstebanAllende 6/20/2012 18:15'!(?)triggerEvent: (EventSelector)anEventSelectorwith: (Object)anObjectifNotHandled: (→ Object)anExceptionBlock    ^self 		triggerEvent: anEventSelector		withArguments: (Array with: anObject)		ifNotHandled: anExceptionBlock! !!Object methodsFor: 'filter streaming' stamp: 'EstebanAllende 6/20/2012 18:22'!(Nil) elementSeparator	^nil.! !!Object methodsFor: 'filter streaming' stamp: 'EstebanAllende 6/20/2012 18:22'!(Self) putOn: (Stream)aStream	^aStream nextPut:self.! !!Object methodsFor: 'finalization' stamp: 'EstebanAllende 6/20/2012 18:22'!(Self) actAsExecutor	"Prepare the receiver to act as executor for any resources associated with it"	self breakDependents! !!Object methodsFor: 'finalization' stamp: 'EstebanAllende 6/20/2012 18:23'!(Self) executor	"Return an object which can act as executor for finalization of the receiver"	^self shallowCopy actAsExecutor! !!Object methodsFor: 'finalization' stamp: 'EstebanAllende 6/20/2012 18:23'!(WeakRegistry) finalizationRegistry	"Answer the finalization registry associated with the receiver."	^WeakRegistry default! !!Object methodsFor: 'finalization' stamp: 'EstebanAllende 6/20/2012 18:23'!(Self) finalize	"Finalize the resource associated with the receiver. This message should only be sent during the finalization process. There is NO garantuee that the resource associated with the receiver hasn't been free'd before so take care that you don't run into trouble - this all may happen with interrupt priority."! !!Object methodsFor: 'finalization' stamp: 'EstebanAllende 6/20/2012 18:23'!(Boolean) hasMultipleExecutors	"All objects, except ObjectFinalizerCollection instances should answer false to this message"	^ false! !!Object methodsFor: 'finalization' stamp: 'EstebanAllende 6/20/2012 18:25'!(A) retryWithGC: (→A)execBlock until: (A→Boolean)testBlock	"Retry execBlock as long as testBlock returns false. Do an incremental GC after the first try, a full GC after the second try."	| (A)blockValue |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!Object methodsFor: 'finalization' stamp: 'EstebanAllende 6/20/2012 18:29'!(Self) toFinalizeSend: (Symbol)aSelector to: (Object)aFinalizer with: (Object)aResourceHandle	"When I am finalized (e.g., garbage collected) close the associated resource handle by sending aSelector to the appropriate finalizer (the guy who knows how to get rid of the resource).	WARNING: Neither the finalizer nor the resource handle are allowed to reference me. If they do, then I will NEVER be garbage collected. Since this cannot be validated here, it is up to the client to make sure this invariant is not broken."	self == aFinalizer ifTrue:[self error: 'I cannot finalize myself'].	self == aResourceHandle ifTrue:[self error: 'I cannot finalize myself'].	^self finalizationRegistry add: self executor:		(ObjectFinalizer new			receiver: aFinalizer			selector: aSelector			argument: aResourceHandle)! !!Object methodsFor: 'flagging' stamp: 'EstebanAllende 6/20/2012 18:30'!(Self) isThisEverCalled	^ self isThisEverCalled: thisContext sender printString! !!Object methodsFor: 'flagging' stamp: 'EstebanAllende 6/20/2012 18:30'!(Self) isThisEverCalled: (Object)msg	"Send this message, with some useful printable argument, from methods or branches of methods which you believe are never reached.  2/5/96 sw"	Halt halt: 'This is indeed called: ', msg printString! !!Object methodsFor: 'flagging' stamp: 'EstebanAllende 6/20/2012 18:30'!(Self) logEntry	Transcript show: 'Entered ', thisContext sender printString; cr.! !!Object methodsFor: 'flagging' stamp: 'EstebanAllende 6/20/2012 18:30'!(Self) logExecution	Transcript show: 'Executing ', thisContext sender printString; cr.! !!Object methodsFor: 'flagging' stamp: 'EstebanAllende 6/20/2012 18:30'!(Self) logExit	Transcript show:  'Exited ', thisContext sender printString; cr.! !!Object methodsFor: 'logging-Deprecated' stamp: 'StephaneDucasse 11/7/2011 22:43'!crLog      self crTrace: self printString! !!Object methodsFor: 'logging-Deprecated' stamp: 'StephaneDucasse 5/27/2011 19:09'!crLog: aString	"Log the argument. Use self log: instead of Transcript cr; show: "		Transcript cr; show: aString.! !!Object methodsFor: 'logging-Deprecated' stamp: 'StephaneDucasse 5/23/2011 22:09'!log: aString	"Log the argument. Use self log: instead of Transcript show: "		Transcript show: aString.! !!Object methodsFor: 'logging-Deprecated' stamp: 'StephaneDucasse 11/5/2011 10:49'!logCr      self logCr: self printString! !!Object methodsFor: 'logging-Deprecated' stamp: 'StephaneDucasse 5/23/2011 22:09'!logCr: aString	"Log the argument. Use self logCr: 'something' instead of Transcript show: 'something'  ; cr "		Transcript show: aString ; cr! !!Object methodsFor: 'logging-Deprecated' stamp: 'StephaneDucasse 5/27/2011 19:07'!logCrTab: aString	"Log the argument. Use self logCr: 'something' instead of Transcript show: 'something'  ; cr ; tab"		Transcript show: aString ; cr ; tab! !!Object methodsFor: 'macpal' stamp: 'EstebanAllende 6/20/2012 18:31'!(Self) contentsChanged	self changed: #contents! !!Object methodsFor: 'macpal' stamp: 'EstebanAllende 6/20/2012 18:31'!(Self) flash	"Do nothing."! !!Object methodsFor: 'macpal' stamp: 'EstebanAllende 6/20/2012 18:31'!(Boolean) refusesToAcceptCode	"Answer whether the receiver is a code-bearing instrument which at the moment refuses to allow its contents to be submitted"	^ false	! !!Object methodsFor: 'memory usage' stamp: 'EstebanAllende 6/20/2012 18:31'!(Integer) sizeInMemory    "Answer the number of bytes consumed by this instance including object header."    | (Integer)contentBytes |	contentBytes := Smalltalk wordSize. "base header"	contentBytes := contentBytes + (self class instSize * Smalltalk wordSize). "instance vars"	self class isVariable ifTrue:[ | (Integer)bytesPerElement | "indexed elements"		bytesPerElement := self class isBytes ifTrue: [1] ifFalse: [4].		contentBytes := contentBytes + (self basicSize * bytesPerElement)	].	contentBytes > 255 ifTrue:	[ contentBytes := contentBytes +  (2 * Smalltalk wordSize) ]						ifFalse:	[ self class isCompact									ifFalse: [ contentBytes := contentBytes + Smalltalk wordSize]								].	^contentBytes! !!Object methodsFor: 'message handling' stamp: 'EstebanAllende 6/20/2012 18:32'!(?) perform: (Symbol)aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Object methodsFor: 'message handling' stamp: 'EstebanAllende 6/20/2012 18:33'!(?) perform: (Symbol)selector orSendTo: (Object)otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!Object methodsFor: 'message handling' stamp: 'EstebanAllende 6/20/2012 18:33'!(?) perform: (Symbol)selector withArguments: (Array)argArray 	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Fail if the number of arguments expected by the selector 	does not match the size of argArray.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 84>	^ self perform: selector withArguments: argArray inSuperclass: self class! !!Object methodsFor: 'message handling' stamp: 'EstebanAllende 6/20/2012 19:01'!(?) perform: (Symbol)selector withArguments: (Array)argArray inSuperclass: (Behavior)lookupClass	"NOTE:  This is just like perform:withArguments:, except that	the message lookup process begins, not with the receivers's class,	but with the supplied superclass instead.  It will fail if lookupClass	cannot be found among the receiver's superclasses.	Primitive. Essential. See Object documentation whatIsAPrimitive."	<primitive: 100>	(selector isSymbol)		ifFalse: [^ self error: 'selector argument must be a Symbol'].	(selector numArgs = argArray size)		ifFalse: [^ self error: 'incorrect number of arguments'].	(self class == lookupClass or: [self class inheritsFrom: lookupClass])		ifFalse: [^ self error: 'lookupClass is not in my inheritance chain'].	self primitiveFailed! !!Object methodsFor: 'message handling' stamp: 'EstebanAllende 6/20/2012 19:02'!(?) perform: (Symbol)selector withEnoughArguments: (Array)anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| (Integer)numArgs (Array)args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!Object methodsFor: 'message handling' stamp: 'EstebanAllende 6/20/2012 19:02'!(?)perform: (Symbol)aSymbol with: (Object)anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Object methodsFor: 'message handling' stamp: 'EstebanAllende 6/20/2012 19:02'!(?) perform: (Symbol)aSymbol with: (Object)firstObject with: (Object)secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Object methodsFor: 'message handling' stamp: 'EstebanAllende 6/20/2012 19:03'!(?) perform: (Symbol)aSymbol with: (Object)firstObject with: (Object)secondObject with: (Object)thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 83>	^ self perform: aSymbol		withArguments: (Array with: firstObject with: secondObject with: thirdObject)! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 6/20/2012 19:04'!(String) fullPrintString	"Answer a String whose characters are a description of the receiver."	^ String streamContents: [:(Stream)s | self printOn: s]! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 6/20/2012 19:04'!(Boolean) isLiteral	"Answer whether the receiver has a literal text form recognized by the 	compiler."	^false! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 6/20/2012 19:12'!(Self) longPrintOn: (WriteStream)aStream	"Append to the argument, aStream, the names and values of all 	of the receiver's instance variables."	self class allInstVarNames doWithIndex:		[:(String)title :(Integer)index |		aStream nextPutAll: title;		 nextPut: $:;		 space;		 tab;		 print: (self instVarAt: index);		 cr]! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 6/20/2012 19:13'!(Self) longPrintOn: (WriteStream)aStream limitedTo: (Integer)sizeLimit indent: (Integer)indent	"Append to the argument, aStream, the names and values of all of the receiver's instance variables.  Limit is the length limit for each inst var."	self class allInstVarNames doWithIndex:		[:(String)title :(Integer)index |		indent timesRepeat: [aStream tab].		aStream nextPutAll: title;		 nextPut: $:;		 space;		 tab;		 nextPutAll: 			((self instVarAt: index) printStringLimitedTo: (sizeLimit -3 -title size max: 1));		 cr]! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 6/20/2012 19:14'!(String) longPrintString	"Answer a String whose characters are a description of the receiver."		| (String)str |	str := String streamContents: [:(WriteStream)aStream | self longPrintOn: aStream].	"Objects without inst vars should return something"	^ str isEmpty ifTrue: [self printString, String cr] ifFalse: [str]! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 6/20/2012 19:14'!(String) longPrintStringLimitedTo: (Integer)aLimitValue	"Answer a String whose characters are a description of the receiver."		| (String)str |	str := String streamContents: [:(WriteStream)aStream | self longPrintOn: aStream limitedTo: aLimitValue indent: 0].	"Objects without inst vars should return something"	^ str isEmpty ifTrue: [self printString, String cr] ifFalse: [str]! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 6/20/2012 19:15'!(Self) nominallyUnsent: (Symbol)aSelectorSymbol	"From within the body of a method which is not formally sent within the system, but which you intend to have remain in the system (for potential manual invocation, or for documentation, or perhaps because it's sent by commented-out-code that you anticipate uncommenting out someday, send this message, with the selector itself as the argument.This will serve two purposes:	(1)  The method will not be returned by searches for unsent selectors (because it, in a manner of speaking, sends itself).	(2)	You can locate all such methods by browsing senders of #nominallyUnsent:"	false ifTrue: [self flag: #nominallyUnsent:]    "So that this method itself will appear to be sent"! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 6/20/2012 19:15'!(Self) printOn: (Stream)aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| (String)title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);		nextPutAll: title! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 6/20/2012 19:15'!(String) printString	"Answer a String whose characters are a description of the receiver. 	If you want to print without a character limit, use fullPrintString."	^ self printStringLimitedTo: 50000! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 6/20/2012 19:16'!(String) printStringLimitedTo: (Integer)limit	"Answer a String whose characters are a description of the receiver.	If you want to print without a character limit, use fullPrintString."	| (String)limitedString |	limitedString := String streamContents: [:(Stream)s | self printOn: s] limitedTo: limit.	limitedString size < limit ifTrue: [^ limitedString].	^ limitedString , '...etc...'! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 6/20/2012 19:16'!(Self) printWithClosureAnalysisOn: (Stream)aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| (String)title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);		nextPutAll: title! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 6/20/2012 19:18'!(Self) storeOn: (WriteStream)aStream 	"Append to the argument aStream a sequence of characters that is an 	expression whose evaluation creates an object similar to the receiver."	aStream nextPut: $(.	self class isVariable		ifTrue: [aStream nextPutAll: '(', self class name, ' basicNew: ';					store: self basicSize;					nextPutAll: ') ']		ifFalse: [aStream nextPutAll: self class name, ' basicNew'].	1 to: self class instSize do:		[:(Integer)i |		aStream nextPutAll: ' instVarAt: ';			store: i;			nextPutAll: ' put: ';			store: (self instVarAt: i);			nextPut: $;].	1 to: self basicSize do:		[:(Integer)i |		aStream nextPutAll: ' basicAt: ';			store: i;			nextPutAll: ' put: ';			store: (self basicAt: i);			nextPut: $;].	aStream nextPutAll: ' yourself)'! !!Object methodsFor: 'printing' stamp: 'EstebanAllende 6/20/2012 19:18'!(String) storeString	"Answer a String representation of the receiver from which the receiver 	can be reconstructed."	^ String streamContents: [:(WriteStream)s | self storeOn: s]! !!Object methodsFor: 'self evaluating' stamp: 'EstebanAllende 6/20/2012 19:18'!(Boolean) isSelfEvaluating	^ self isLiteral! !!Object methodsFor: 'splitjoin' stamp: 'EstebanAllende 6/20/2012 19:37'!(Self) appendTo: (SequenceableCollection{addLast: (? → ?)})aCollection  	"double dispatch for join:"	^ aCollection addLast: self! !!Object methodsFor: 'splitjoin' stamp: 'EstebanAllende 6/20/2012 19:31'!(SequenceableCollection<A | Self>) join: (SequenceableCollection<A>)aSequenceableCollection	^ (Array with: self) join: aSequenceableCollection! !!Object methodsFor: 'splitjoin' stamp: 'EstebanAllende 6/20/2012 19:27'!(Self) joinTo: (Stream)stream	"double dispatch for join:"	^ stream nextPut: self! !!Object methodsFor: 'splitjoin' stamp: 'EstebanAllende 6/20/2012 19:30'!(OrderedCollection<SequenceableCollection<A>>) split: (SequenceableCollection<A>)aSequenceableCollection	"optimized version for single delimiters:	Example:		$/ split: '/foo/bar'"			| (OrderedCollection<SequenceableCollection<A>>)result (Integer)position (Integer)oldPosition |		result := OrderedCollection new: (aSequenceableCollection size / 2) asInteger.	position := 1.	oldPosition := position.		position := aSequenceableCollection indexOf: self startingAt: position.	[ position > 0 ] whileTrue: [		result add: (aSequenceableCollection copyFrom: oldPosition to: position - 1).		position := position + 1.		oldPosition := position.		position := aSequenceableCollection indexOf: self startingAt: position.	].	result add: (aSequenceableCollection copyFrom: oldPosition to: aSequenceableCollection size).	^ result! !!Object methodsFor: 'system primitives' stamp: 'EstebanAllende 6/20/2012 19:39'!(ProtoObject) becomeForward: (Object)otherObject 	"Primitive. All variables in the entire system that used to point	to the receiver now point to the argument.	Fails if either argument is a SmallInteger."	(Array with: self)		elementsForwardIdentityTo:			(Array with: otherObject)! !!Object methodsFor: 'system primitives' stamp: 'EstebanAllende 6/20/2012 19:39'!(ProtoObject) becomeForward: (Object)otherObject copyHash: (Boolean)copyHash	"Primitive. All variables in the entire system that used to point to the receiver now point to the argument.	If copyHash is true, the argument's identity hash bits will be set to those of the receiver.	Fails if either argument is a SmallInteger."	(Array with: self)		elementsForwardIdentityTo:			(Array with: otherObject)				copyHash: copyHash! !!Object methodsFor: 'system primitives' stamp: 'EstebanAllende 6/20/2012 19:39'!(String) className	"Answer a string characterizing the receiver's class, for use in list views for example"	^ self class name asString! !!Object methodsFor: 'system primitives' stamp: 'EstebanAllende 6/20/2012 19:40'!(?) instVarAt: (Integer)index 	"Primitive. Answer a fixed variable in an object. The numbering of the 	variables corresponds to the named instance variables. Fail if the index 	is not an Integer or is not the index of a fixed variable. Essential. See 	Object documentation whatIsAPrimitive."	<primitive: 73>	"Access beyond fixed variables."	^self basicAt: index - self class instSize		! !!Object methodsFor: 'system primitives' stamp: 'EstebanAllende 6/20/2012 19:40'!(?) instVarAt: (Integer)anInteger put: (Object)anObject 	"Primitive. Store a value into a fixed variable in the receiver. The 	numbering of the variables corresponds to the named instance variables. 	Fail if the index is not an Integer or is not the index of a fixed variable. 	Answer the value stored as the result. Using this message violates the 	principle that each object has sovereign control over the storing of 	values into its instance variables. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 74>	"Access beyond fixed fields"	^self basicAt: anInteger - self class instSize put: anObject! !!Object methodsFor: 'system primitives' stamp: 'EstebanAllende 6/20/2012 19:41'!(?) instVarNamed: (String)aString	"Return the value of the instance variable in me with that name.  Slow and unclean, but very useful. "	^ self instVarAt: ((<ClassDescription>self class)						instVarIndexFor: aString asString						ifAbsent: [self error: 'no such inst var'])! !!Object methodsFor: 'system primitives' stamp: 'EstebanAllende 6/20/2012 19:43'!(?) instVarNamed: (String)aString put: (Object)aValue	"Store into the value of the instance variable in me of that name.  Slow and unclean, but very useful. "	^self		instVarAt: ((<ClassDescription>self class)						instVarIndexFor: aString asString						ifAbsent: [self error: 'no such inst var'])		put: aValue! !!Object methodsFor: 'system primitives' stamp: 'EstebanAllende 6/20/2012 19:47'!(Boolean) instVarsInclude: (Object)anObject"Answers true if anObject is among my named or indexed instance variables, and false otherwise"	<primitive: 132>	1 to: self class instSize do:		[:(Integer)i | (self instVarAt: i) == anObject ifTrue: [^ true]].	1 to: self basicSize do:		[:(Integer)i | (self basicAt: i) == anObject ifTrue: [^ true]].	^ false! !!Object methodsFor: 'system primitives' stamp: 'EstebanAllende 6/20/2012 19:49'!(Self) primitiveChangeClassTo: (Behavior)anObject	"Primitive. Change the class of the receiver into the class of the argument given that the format of the receiver matches the format of the argument's class. Fail if receiver or argument are SmallIntegers, or the receiver is an instance of a compact class and the argument isn't, or when the argument's class is compact and the receiver isn't, or when the format of the receiver is different from the format of the argument's class, or when the arguments class is fixed and the receiver's size differs from the size that an instance of the argument's class should have.	Note: The primitive will fail in most cases that you think might work. This is mostly because of a) the difference between compact and non-compact classes, and b) because of differences in the format. As an example, '(Array new: 3) primitiveChangeClassTo: Morph basicNew' would fail for three of the reasons mentioned above. Array is compact, Morph is not (failure #1). Array is variable and Morph is fixed (different format - failure #2). Morph is a fixed-field-only object and the array is too short (failure #3).	The facility is really provided for certain, very specific applications (mostly related to classes changing shape) and not for casual use."	<primitive: 115>	self primitiveFailed! !!Object methodsFor: 'system primitives' stamp: 'EstebanAllende 6/20/2012 19:49'!(ProtoObject) someObject	"Primitive. Answer the first object in the enumeration of all	 objects."	<primitive: 138>	self primitiveFailed.! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:49'!(Self) haltIfNil! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:54'!(Boolean) hasLiteralSuchThat: (Object →Boolean)testBlock	"This is the end of the imbedded structure path so return false."	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:55'!(Boolean) is: (Symbol)aSymbol	"A means for cleanly replacing all isXXX like methods.	Please use judiciously!!	Suggested by Igor Stasenko at	http://lists.squeakfoundation.org/pipermail/squeak-dev/2009-June/136793.html.	all isXXX should be converted following the pattern		ColorForm>>isColorForm 			^ true	Object>>isColorForm 			^ false 	is: aSymbol		^ aSymbol = #ColorForm or: [ super is: aSymbol ]"	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:55'!(Boolean) isArray	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:55'!(Boolean) isBehavior	"Return true if the receiver is a behavior.	Note: Do not override in any class except behavior."	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:56'!(Boolean) isBlock	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:56'!(Boolean) isCharacter	^ false.! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:56'!(Boolean) isClosure	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:56'!(Boolean) isCollection	"Return true if the receiver is some sort of Collection and responds to basic collection messages such as #size and #do:"	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:56'!(Boolean) isColor	"Answer true if receiver is a Color. False by default."	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:56'!(Boolean) isColorForm	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:56'!(Boolean) isCompiledMethod	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:56'!(Boolean) isComplex	"Answer true if receiver is a Complex number. False by default."	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:56'!(Boolean) isContext	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:56'!(Boolean) isDictionary	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:56'!(Boolean) isFloat	"Overridden to return true in Float, natch"	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:57'!(Boolean) isForm	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:57'!(Boolean) isFraction	"Answer true if the receiver is a Fraction."	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:57'!(Boolean) isHeap	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:57'!(Boolean) isInteger	"Overridden to return true in Integer."	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:57'!(Boolean) isInterval	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:57'!(Boolean) isMessageSend	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:57'!(Boolean) isMethodProperties	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:57'!(Boolean) isMorph	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:57'!(Boolean) isMorphicEvent	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:57'!(Boolean) isMorphicModel	"Return true if the receiver is a morphic model"	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:57'!(Boolean) isNumber	"Overridden to return true in Number, natch"	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:57'!(Boolean) isPoint	"Overridden to return true in Point."	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:58'!(Boolean) isRectangle	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:58'!(Boolean) isStream	"Return true if the receiver responds to the stream protocol"	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:58'!(Boolean) isString	"Overridden to return true in String, natch"	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:58'!(Boolean) isSymbol	^ false ! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:58'!(Boolean) isSystemWindow"answer whatever the receiver is a SystemWindow"	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:58'!(Boolean) isText	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:58'!(Boolean) isTrait	^false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:58'!(Boolean) isVariableBinding	"Return true if I represent a literal variable binding"	^false	! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:58'!(String) name	"Answer a name for the receiver.  This is used generically in the title of certain inspectors, such as the referred-to inspector, and specificially by various subsystems.  By default, we let the object just print itself out..  "	^ self printString ! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:58'!(Boolean) notNil	"Coerces nil to false and everything else to true."	^true! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:59'!(Boolean) refersToLiteral: (Object)literal 	"Answer true if literal is identical to any literal in this array, even if imbedded in further structures.  This is the end of the imbedded structure path so return false."	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 19:59'!(Boolean) shouldBePrintedAsLiteral	^self isLiteral! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 20:00'!(Self) step	^ self subclassResponsibility! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 20:04'!(Self) stepAt: (Integer)millisecondClockValue in: (SystemWindow)aWindow	^ self stepIn: aWindow! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 20:04'!(Self) stepIn: (SystemWindow)aWindow	^ self step! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 20:04'!(Integer) stepTime		^ 1000 "milliseconds -- default backstop for objects serving as models of system windows"! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 20:05'!(Integer) stepTimeIn: (SystemWindow)aSystemWindow		^ 1000 "milliseconds -- default backstop for objects serving as models of system windows"! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 20:05'!(Boolean) wantsDiffFeedback	"Answer whether the receiver, serving as the model of a text-bearing entity, would like for 'diffs' green pane-border feedback to be shown"	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 20:05'!(Boolean) wantsSteps	"Overridden by morphic classes whose instances want to be stepped,	or by model classes who want their morphic views to be stepped."	^ false! !!Object methodsFor: 'testing' stamp: 'EstebanAllende 6/20/2012 20:05'!(Boolean) wantsStepsIn: (SystemWindow)aSystemWindow		^ self wantsSteps! !!Object methodsFor: 'tracing' stamp: 'EstebanAllende 6/20/2012 20:05'!(Self) crTrace      self crTrace: self printString! !!Object methodsFor: 'tracing' stamp: 'EstebanAllende 6/20/2012 20:06'!(Self) crTrace: (String)aString	"Log the argument. Use self crTrace: instead of Transcript cr; show: "		Transcript cr; show: aString.! !!Object methodsFor: 'tracing' stamp: 'EstebanAllende 6/20/2012 20:06'!(Self) trace      self trace: self printString! !!Object methodsFor: 'tracing' stamp: 'EstebanAllende 6/20/2012 20:06'!(Self) trace: (String)aString	"Log the argument. Use self trace: instead of Transcript show: "		Transcript show: aString.! !!Object methodsFor: 'tracing' stamp: 'EstebanAllende 6/20/2012 20:06'!(Self) traceCr      self traceCr: self printString! !!Object methodsFor: 'tracing' stamp: 'EstebanAllende 6/20/2012 20:06'!(Self) traceCr: (String)aString	"Log the argument. Use self traceCr: 'something' instead of Transcript show: 'something'  ; cr "		Transcript show: aString ; cr! !!Object methodsFor: 'updating' stamp: 'EstebanAllende 6/20/2012 20:06'!(Self) changed	"Receiver changed in a general way; inform all the dependents by 	sending each dependent an update: message."	self changed: self! !!Object methodsFor: 'updating' stamp: 'EstebanAllende 6/20/2012 20:07'!(Self) changed: (Object)aParameter 	"Receiver changed. The change is denoted by the argument aParameter. 	Usually the argument is a Symbol that is part of the dependent's change 	protocol. Inform all of the dependents."	self dependents do: [:(Object)aDependent | aDependent update: aParameter]! !!Object methodsFor: 'updating' stamp: 'EstebanAllende 6/20/2012 20:07'!(Self) changed: (Object)anAspect with: (Object)anObject	"Receiver changed. The change is denoted by the argument anAspect. 	Usually the argument is a Symbol that is part of the dependent's change 	protocol. Inform all of the dependents. Also pass anObject for additional information."	self dependents do: [:(Object)aDependent | aDependent update: anAspect with: anObject]! !!Object methodsFor: 'updating' stamp: 'EstebanAllende 6/20/2012 20:08'!(Self) noteSelectionIndex: (Integer)anInteger for: (Symbol)aSymbol	"backstop"! !!Object methodsFor: 'updating' stamp: 'EstebanAllende 6/20/2012 20:09'!(Boolean) okToChange	"Allows a controller to ask this of any model"	^ true! !!Object methodsFor: 'updating' stamp: 'EstebanAllende 6/20/2012 20:08'!(Self) update: (Object)aParameter 	"Receive a change notice from an object of whom the receiver is a 	dependent. The default behavior is to do nothing; a subclass might want 	to change itself in some way."	^ self! !!Object methodsFor: 'updating' stamp: 'EstebanAllende 6/20/2012 20:08'!(Self) update: (Object)anAspect with: (Object)anObject	"Receive a change notice from an object of whom the receiver is a 	dependent. The default behavior is to call update:,	which by default does nothing; a subclass might want 	to change itself in some way."	^ self update: anAspect! !!Object methodsFor: 'updating' stamp: 'EstebanAllende 6/20/2012 20:09'!(Self) windowIsClosing	"This message is used to inform a models that its window is closing. Most models do nothing, but some, such as the Debugger, must do some cleanup. Note that this mechanism must be used with care by models that support multiple views, since one view may be closed while others left open."! !!Object methodsFor: 'user interface' stamp: 'EstebanAllende 12/16/2011 18:33'!(Self) addModelItemsToWindowMenu: (MenuMorph) aMenu	"aMenu is being constructed to be presented to the user in response to the user's pressing on the menu widget in the title bar of a morphic window.  Here, the model is given the opportunity to add any model-specific items to the menu, whose default target is the SystemWindow itself."! !!Object methodsFor: 'user interface' stamp: 'EstebanAllende 12/16/2011 18:34'!(Self) addModelMenuItemsTo: (MenuMorph) aCustomMenu forMorph: (Morph)aMorph hand: (HandMorph)aHandMorph 	"The receiver serves as the model for aMorph; a menu is being constructed for the morph, and here the receiver is able to add its own items"! !!Object methodsFor: 'user interface' stamp: 'EstebanAllende 12/16/2011 18:34'!(Self) modelSleep	"A window with me as model is being exited or collapsed or closed.	Default response is no-op" ! !!Object methodsFor: 'user interface' stamp: 'EstebanAllende 12/16/2011 18:34'!(Self) modelWakeUp	"A window with me as model is being entered or expanded.  Default response is no-op"  ! !!Object methodsFor: 'user interface' stamp: 'EstebanAllende 12/16/2011 18:34'!(Self) modelWakeUpIn: (Morph)aWindow	"A window with me as model is being entered or expanded.  Default response is no-op" 	self modelWakeUp! !!Object methodsFor: 'user interface' stamp: 'EstebanAllende 2/21/2012 01:20'!(Self) mouseUpBalk: (MorphicEvent)evt	"A button I own got a mouseDown, but the user moved out before letting up.  Certain kinds of objects (so-called 'radio buttons', for example, and other structures that must always have some selection, e.g. PaintBoxMorph) wish to take special action in this case; this default does nothing."! !!Object methodsFor: 'user interface' stamp: 'EstebanAllende 12/16/2011 18:35'!(UndefinedObject) notYetImplemented	self inform: 'Not yet implemented (', thisContext sender printString, ')'.	^nil! !!Object methodsFor: 'user interface' stamp: 'EstebanAllende 12/16/2011 18:36'!(Boolean) windowReqNewLabel: (String)labelString	"My window's title has been edited.	Return true if this is OK, and override for further behavior."	^ true! !!Object methodsFor: 'private' stamp: 'EstebanAllende 6/20/2012 20:10'!(Nil) errorImproperStore	"Create an error notification that an improper store was attempted."	self error: 'Improper store into indexable object'.	^nil! !!Object methodsFor: 'private' stamp: 'EstebanAllende 6/20/2012 20:10'!(Nil) errorNonIntegerIndex	"Create an error notification that an improper object was used as an index."	self error: 'only integers should be used as indices'.	^nil! !!Object methodsFor: 'private' stamp: 'EstebanAllende 6/20/2012 20:10'!(Nil) errorNotIndexable	"Create an error notification that the receiver is not indexable."	self error: ('Instances of {1} are not indexable' translated format: {self class name}).	^nil! !!Object methodsFor: 'private' stamp: 'EstebanAllende 6/20/2012 20:11'!(Nil) errorSubscriptBounds: (Integer)index 	"Create an error notification that an improper integer was used as an index."	SubscriptOutOfBounds signalFor: index.	^nil! !!Object methodsFor: 'private' stamp: 'EstebanAllende 6/20/2012 20:11'!(Self class) species	"Answer the preferred class for reconstructing the receiver.  For example, 	collections create new collections whenever enumeration messages such as 	collect: or select: are invoked.  The new kind of collection is determined by 	the species of the original collection.  Species and class are not always the 	same.  For example, the species of Interval is Array."	<primitive: 111>	^self class! !!Object methodsFor: 'private' stamp: 'EstebanAllende 6/20/2012 20:12'!(Self) storeAt: (Integer)offset inTempFrame: (ContextPart)aContext	"This message had to get sent to an expression already on the stack	as a Block argument being accessed by the debugger.	Just re-route it to the temp frame."	^ aContext tempAt: offset put: self! !!Object methodsFor: 'pointers' stamp: 'EstebanAllende 6/20/2012 20:16'!(OrderedCollection) pointersTo	^self pointersToExcept: #()! !!Object methodsFor: 'pointers' stamp: 'EstebanAllende 7/2/2012 17:44'!(OrderedCollection<Any>) pointersToExcept: (Collection<Any>)objectsToExclude	"Find all objects in the system that hold a pointer to me, excluding those listed"	| (ContextPart)c (OrderedCollection<Any>)pointers (Any)object (Array)objectsToAlwaysExclude |	Smalltalk garbageCollect.	pointers := OrderedCollection new.	"SystemNavigation >> #allObjectsDo: is inlined here with a slight modification: the marker object is pointers. This gives better results, because the value of pointers, it's inner objects and transient method contexts will not be iterated over."	object := self someObject.	[ object == pointers ] whileFalse: [		( object pointsTo: self ) ifTrue: [			pointers add: object ].		object := object nextObject ].	objectsToAlwaysExclude := {		thisContext.		thisContext sender.		thisContext sender sender.		objectsToExclude.	}.	c := thisContext.	^(pointers removeAllSuchThat: [ :(Any)ea |		(ea == thisContext sender) or: [ "warning: this expression is dependent on closure structure of this method"			(objectsToAlwaysExclude identityIncludes: ea)				or: [objectsToExclude identityIncludes: ea ]] ]) asArray! !!Object methodsFor: 'pointers' stamp: 'EstebanAllende 6/20/2012 20:16'!(Boolean) pointsTo: (Object)anObject	"Answers true if I hold a reference to anObject, or false otherwise"	^ (self instVarsInclude: anObject)		or: [ ^self class == anObject and: [ self class isCompact not ] ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Object class	instanceVariableNames: ''!!Object class methodsFor: '*Compiler-Kernel' stamp: 'jb 7/1/2011 10:52'!readFrom: textStringOrStream	"Create an object based on the contents of textStringOrStream."	| object |	(self class evaluatorClass couldEvaluate: textStringOrStream)		ifFalse: [^ self error: 'expected String, Stream, or Text'].	object := self class evaluatorClass evaluate: textStringOrStream.	(object isKindOf: self) ifFalse: [self error: self name, ' expected'].	^object! !!Object class methodsFor: '*Polymorph-TaskbarIcons'!taskbarIcon	"Answer the icon for an instance of the receiver in a task bar	or nil for the default."	^nil ! !!Object class methodsFor: '*Polymorph-Widgets' stamp: 'gvc 1/31/2009 15:53'!taskbarLabel	"Answer the label string for the receiver in a task bar	or nil for the default."	^nil! !!Object class methodsFor: '*System-Support'!registerToolsOn: t1 	^ self! !!Object class methodsFor: '*Tools-FileList' stamp: 'md 2/15/2006 17:20'!services	"Backstop"	^#()! !!Object class methodsFor: 'class initialization' stamp: 'ar 2/11/2001 02:00'!flushDependents	DependentsFields keysAndValuesDo:[:key :dep|		key ifNotNil:[key removeDependent: nil].	].	DependentsFields finalizeValues.! !!Object class methodsFor: 'class initialization' stamp: 'rw 2/10/2002 13:09'!flushEvents	"Object flushEvents"	EventManager flushEvents. ! !!Object class methodsFor: 'class initialization'!initialize	DependentsFields		ifNil: [self initializeDependentsFields]! !!Object class methodsFor: 'class initialization' stamp: 'ar 2/11/2001 01:41'!initializeDependentsFields	"Object initialize"	DependentsFields := WeakIdentityKeyDictionary new.! !!Object class methodsFor: 'class initialization' stamp: 'ar 2/11/2001 01:45'!reInitializeDependentsFields	"Object reInitializeDependentsFields"	| oldFields |	oldFields := DependentsFields.	DependentsFields := WeakIdentityKeyDictionary new.	oldFields keysAndValuesDo:[:obj :deps|		deps do:[:d| obj addDependent: d]].! !!Object class methodsFor: 'documentation'!howToModifyPrimitives	"You are allowed to write methods which specify primitives, but please use 	caution.  If you make a subclass of a class which contains a primitive method, 	the subclass inherits the primitive.  The message which is implemented 	primitively may be overridden in the subclass (E.g., see at:put: in String's 	subclass Symbol).  The primitive behavior can be invoked using super (see 	Symbol string:). 	 	A class which attempts to mimic the behavior of another class without being 	its subclass may or may not be able to use the primitives of the original class.  	In general, if the instance variables read or written by a primitive have the 	same meanings and are in the same fields in both classes, the primitive will 	work.  	For certain frequently used 'special selectors', the compiler emits a 	send-special-selector bytecode instead of a send-message bytecode.  	Special selectors were created because they offer two advantages.  Code 	which sends special selectors compiles into fewer bytes than normal.  For 	some pairs of receiver classes and special selectors, the interpreter jumps 	directly to a primitive routine without looking up the method in the class.  	This is much faster than a normal message lookup. 	 	A selector which is a special selector solely in order to save space has a 	normal behavior.  Methods whose selectors are special in order to 	gain speed contain the comment, 'No Lookup'.  When the interpreter 	encounters a send-special-selector bytecode, it checks the class of the 	receiver and the selector.  If the class-selector pair is a no-lookup pair, 	then the interpreter swiftly jumps to the routine which implements the 	corresponding primitive.  (A special selector whose receiver is not of the 	right class to make a no-lookup pair, is looked up normally).  The pairs are 	listed below.  No-lookup methods contain a primitive number specification, 	<primitive: xx>, which is redundant.  Since the method is not normally looked 	up, deleting the primitive number specification cannot prevent this 	primitive from running.  If a no-lookup primitive fails, the method is looked 	up normally, and the expressions in it are executed. 	 	No Lookup pairs of (class, selector) 	 	SmallInteger with any of		+ - * /  \\  bitOr: bitShift: bitAnd:  // 	SmallInteger with any of		=  ~=  >  <  >=  <= 	Any class with					== 	Any class with 					@ 	Point with either of				x y 	ContextPart with					blockCopy: 	BlockContext with either of 		value value:	"	self error: 'comment only'! !!Object class methodsFor: 'documentation'!whatIsAPrimitive	"Some messages in the system are responded to primitively. A primitive   	response is performed directly by the interpreter rather than by evaluating   	expressions in a method. The methods for these messages indicate the   	presence of a primitive response by including <primitive: xx> before the   	first expression in the method.   	  	Primitives exist for several reasons. Certain basic or 'primitive' 	operations cannot be performed in any other way. Smalltalk without 	primitives can move values from one variable to another, but cannot add two 	SmallIntegers together. Many methods for arithmetic and comparison 	between numbers are primitives. Some primitives allow Smalltalk to 	communicate with I/O devices such as the disk, the display, and the keyboard. 	Some primitives exist only to make the system run faster; each does the same 	thing as a certain Smalltalk method, and its implementation as a primitive is 	optional.  	  	When the Smalltalk interpreter begins to execute a method which specifies a 	primitive response, it tries to perform the primitive action and to return a 	result. If the routine in the interpreter for this primitive is successful, 	it will return a value and the expressions in the method will not be evaluated. 	If the primitive routine is not successful, the primitive 'fails', and the 	Smalltalk expressions in the method are executed instead. These 	expressions are evaluated as though the primitive routine had not been 	called.  	  	The Smalltalk code that is evaluated when a primitive fails usually 	anticipates why that primitive might fail. If the primitive is optional, the 	expressions in the method do exactly what the primitive would have done (See 	Number @). If the primitive only works on certain classes of arguments, the 	Smalltalk code tries to coerce the argument or appeals to a superclass to find 	a more general way of doing the operation (see SmallInteger +). If the 	primitive is never supposed to fail, the expressions signal an error (see 	SmallInteger asFloat).  	  	Each method that specifies a primitive has a comment in it. If the primitive is 	optional, the comment will say 'Optional'. An optional primitive that is not 	implemented always fails, and the Smalltalk expressions do the work 	instead.  	 	If a primitive is not optional, the comment will say, 'Essential'. Some 	methods will have the comment, 'No Lookup'. See Object 	howToModifyPrimitives for an explanation of special selectors which are 	not looked up.  	  	For the primitives for +, -, *, and bitShift: in SmallInteger, and truncated 	in Float, the primitive constructs and returns a 16-bit 	LargePositiveInteger when the result warrants it. Returning 16-bit 	LargePositiveIntegers from these primitives instead of failing is 	optional in the same sense that the LargePositiveInteger arithmetic 	primitives are optional. The comments in the SmallInteger primitives say, 	'Fails if result is not a SmallInteger', even though the implementor has the 	option to construct a LargePositiveInteger. For further information on 	primitives, see the 'Primitive Methods' part of the chapter on the formal 	specification of the interpreter in the Smalltalk book."	self error: 'comment only'! !!Object class methodsFor: 'file list services' stamp: 'nk 6/12/2004 11:41'!fileReaderServicesForDirectory: aFileDirectory	"Backstop"	^#()! !!Object class methodsFor: 'file list services' stamp: 'nk 6/12/2004 11:30'!fileReaderServicesForFile: fullName suffix: suffix	"Backstop"	^#()! !!Object class methodsFor: 'instance creation' stamp: 'StephaneDucasse 2/20/2010 21:38'!newFrom: aSimilarObject	"Create an object that has similar contents to aSimilarObject. If the classes have any instance varaibles with the same names, copy them across. If this is bad for a class, override this method."	^ (self isVariable		ifTrue: [self basicNew: aSimilarObject basicSize]		ifFalse: [self basicNew]) copySameFrom: aSimilarObject! !!Object class methodsFor: 'objects from disk' stamp: 'tk 1/8/97'!createFrom: aSmartRefStream size: varsOnDisk version: instVarList	"Create an instance of me so objects on the disk can be read in.  Tricky part is computing the size if variable.  Inst vars will be filled in later.  "	^ self isVariable		ifFalse: [self basicNew]		ifTrue: ["instVarList is names of old class's inst vars plus a version number" 				self basicNew: (varsOnDisk - (instVarList size - 1))]! !!Object class methodsFor: 'private' stamp: 'mir 8/22/2001 15:20'!releaseExternalSettings	"Do nothing as a default"! !Object initialize!