'From Pharo1.4a of ''16 June 2011'' [Latest update: #14301] on 28 February 2012 at 8:30:46 pm'!Object subclass: #Collection	uses: TTyped	instanceVariableNames: ''	classVariableNames: '(Semaphore)MutexForPicking (Random)RandomForPicking'	poolDictionaries: ''	category: 'Collections-Abstract'!!Collection commentStamp: '<historical>' prior: 0!I am the abstract superclass of all classes that represent a group of elements.!!Collection methodsFor: '*Collections-arithmetic' stamp: 'EstebanAllende 2/28/2012 13:03'!(?) * ({adaptToCollection:andSend: (Collection Symbol → Object)})arg	^ arg adaptToCollection: self andSend: #*! !!Collection methodsFor: '*Collections-arithmetic' stamp: 'EstebanAllende 2/28/2012 13:03'!(?) + ({adaptToCollection:andSend: (Collection Symbol → Object)})arg	^ arg adaptToCollection: self andSend: #+! !!Collection methodsFor: '*Collections-arithmetic' stamp: 'EstebanAllende 2/28/2012 13:04'!(?) - ({adaptToCollection:andSend: (Collection Symbol → Object)})arg	^ arg adaptToCollection: self andSend: #-! !!Collection methodsFor: '*Collections-arithmetic' stamp: 'EstebanAllende 2/28/2012 13:04'!(?) / ({adaptToCollection:andSend: (Collection Symbol → Object)})arg	^ arg adaptToCollection: self andSend: #/! !!Collection methodsFor: '*Collections-arithmetic' stamp: 'EstebanAllende 2/28/2012 13:04'!(?) // ({adaptToCollection:andSend: (Collection Symbol → Object)})arg	^ arg adaptToCollection: self andSend: #//! !!Collection methodsFor: '*Collections-arithmetic' stamp: 'EstebanAllende 2/28/2012 13:04'!(?) \\ ({adaptToCollection:andSend: (Collection Symbol → Object)})arg	^ arg adaptToCollection: self andSend: #\\! !!Collection methodsFor: '*Collections-arithmetic' stamp: 'EstebanAllende 2/28/2012 13:24'!(?) average	^ self sum / self size! !!Collection methodsFor: '*Collections-arithmetic' stamp: 'EstebanAllende 2/28/2012 13:16'!(?) max	^ self inject: self anyOne into: [:(?)max :(?)each | max max: each]! !!Collection methodsFor: '*Collections-arithmetic' stamp: 'EstebanAllende 2/28/2012 13:17'!(?)min	^ self inject: self anyOne into: [:(?)min :(?)each | min min: each]! !!Collection methodsFor: '*Collections-arithmetic' stamp: 'EstebanAllende 2/28/2012 13:16'!(?) raisedTo: ({adaptToCollection:andSend: (Collection Symbol → Object)})arg	^ arg adaptToCollection: self andSend: #raisedTo:! !!Collection methodsFor: '*Collections-arithmetic' stamp: 'EstebanAllende 2/28/2012 13:24'!(?) range	^ self max - self min! !!Collection methodsFor: '*Collections-arithmetic' stamp: 'EstebanAllende 2/28/2012 13:25'!(?) sum	"This is implemented using a variant of the normal inject:into: pattern. 	The reason for this is that it is not known whether we're in the normal 	number line, i.e. whether 0 is a good initial value for the sum. 	Consider a collection of measurement objects, 0 would be the unitless 	value and would not be appropriate to add with the unit-ed objects."	| sum sample |	sample := self anyOne.	sum := self inject: sample into: [:(?)accum :(?)each | accum + each].	^ sum - sample! !!Collection methodsFor: '*Collections-arithmetic-collectors' stamp: 'EstebanAllende 2/28/2012 17:12'!(Self) abs	"Absolute value of all elements in the collection"	^ self collect: [:(?)a | a abs]! !!Collection methodsFor: '*Collections-arithmetic-collectors' stamp: 'EstebanAllende 2/28/2012 17:12'!(Self) arcCos	^self collect: [:(?)each | each arcCos]! !!Collection methodsFor: '*Collections-arithmetic-collectors' stamp: 'EstebanAllende 2/28/2012 17:12'!(Self) arcSin	^self collect: [:(?)each | each arcSin]! !!Collection methodsFor: '*Collections-arithmetic-collectors' stamp: 'EstebanAllende 2/28/2012 17:13'!(Self) arcTan	^self collect: [:(?)each | each arcTan]! !!Collection methodsFor: '*Collections-arithmetic-collectors' stamp: 'EstebanAllende 2/28/2012 17:13'!(Self) ceiling	^ self collect: [:(?)a | a ceiling]! !!Collection methodsFor: '*Collections-arithmetic-collectors' stamp: 'EstebanAllende 2/28/2012 17:14'!(Self)cos	^self collect: [:(?)each | each cos]! !!Collection methodsFor: '*Collections-arithmetic-collectors' stamp: 'EstebanAllende 2/28/2012 17:14'!(Self)degreeCos	^self collect: [:(?)each | each degreeCos]! !!Collection methodsFor: '*Collections-arithmetic-collectors' stamp: 'EstebanAllende 2/28/2012 17:14'!(Self) degreeSin	^self collect: [:(?)each | each degreeSin]! !!Collection methodsFor: '*Collections-arithmetic-collectors' stamp: 'EstebanAllende 2/28/2012 17:15'!(Self) exp	^self collect: [:(?)each | each exp]! !!Collection methodsFor: '*Collections-arithmetic-collectors' stamp: 'EstebanAllende 2/28/2012 17:15'!(Self) floor	^ self collect: [:(?)a | a floor]! !!Collection methodsFor: '*Collections-arithmetic-collectors' stamp: 'EstebanAllende 2/28/2012 17:15'!(Self) ln	^self collect: [:(?)each | each ln]! !!Collection methodsFor: '*Collections-arithmetic-collectors' stamp: 'EstebanAllende 2/28/2012 17:15'!(Self) log	^ self collect: [:(?)each | each log]! !!Collection methodsFor: '*Collections-arithmetic-collectors' stamp: 'EstebanAllende 2/28/2012 17:16'!(Self) negated	"Negated value of all elements in the collection"	^ self collect: [:(?)a | a negated]! !!Collection methodsFor: '*Collections-arithmetic-collectors' stamp: 'EstebanAllende 2/28/2012 17:16'!(Self) reciprocal	"Return the reciever full of reciprocated elements"	^ self collect: [:(?)a | a reciprocal]! !!Collection methodsFor: '*Collections-arithmetic-collectors' stamp: 'EstebanAllende 2/28/2012 17:16'!(Self) roundTo: (?)quantum	^self collect: [ :(?)ea | ea roundTo: quantum ]! !!Collection methodsFor: '*Collections-arithmetic-collectors' stamp: 'EstebanAllende 2/28/2012 17:16'!(Self) rounded	^ self collect: [:(?)a | a rounded]! !!Collection methodsFor: '*Collections-arithmetic-collectors' stamp: 'EstebanAllende 2/28/2012 17:17'!(Self) sign	^self collect: [:(?)each | each sign]! !!Collection methodsFor: '*Collections-arithmetic-collectors' stamp: 'EstebanAllende 2/28/2012 17:17'!(Self) sin	^self collect: [:(?)each | each sin]! !!Collection methodsFor: '*Collections-arithmetic-collectors' stamp: 'EstebanAllende 2/28/2012 17:17'!(Self) sqrt	^ self collect: [:(?)each | each sqrt]! !!Collection methodsFor: '*Collections-arithmetic-collectors' stamp: 'EstebanAllende 2/28/2012 17:17'!(Self) squared	^ self collect: [:(?)each | each * each]! !!Collection methodsFor: '*Collections-arithmetic-collectors' stamp: 'EstebanAllende 2/28/2012 17:17'!(Self) tan	^self collect: [:(?)each | each tan]! !!Collection methodsFor: '*Collections-arithmetic-collectors' stamp: 'EstebanAllende 2/28/2012 17:18'!(Self) truncated	^ self collect: [:(?)a | a truncated]! !!Collection methodsFor: '*Morphic-Basic' stamp: 'EstebanAllende 2/28/2012 17:12'!(StringMorph)asDraggableMorph	| (String)string (Collection)strCol |	strCol := self collect: [:(Object)each | each asString ].	string := (<SequenceableCollection>strCol) joinUsing: Character space.	^ ( StringMorph contents: string )		color: Color white;		yourself! !!Collection methodsFor: '*Tools-Explorer' stamp: 'EstebanAllende 2/28/2012 17:09'!(OrderedCollection) explorerContents	^self explorerContentsWithIndexCollect: [:(?)value :(Integer)index |		ObjectExplorerWrapper			with: value			name: index printString			model: self]! !!Collection methodsFor: '*Tools-Explorer' stamp: 'EstebanAllende 2/28/2012 16:45'!(OrderedCollection) explorerContentsWithIndexCollect: (? Integer -> ?)twoArgBlock	^ self asOrderedCollection withIndexCollect: twoArgBlock! !!Collection methodsFor: '*petitparser-core-converting' stamp: 'EstebanAllende 2/28/2012 16:43'!(PPChoiceParser) asChoiceParser	^ PPChoiceParser withAll: (self collect: [ :(Object)each | each asParser ])! !!Collection methodsFor: '*petitparser-core-converting' stamp: 'EstebanAllende 2/28/2012 16:44'!(PPSequenceParser) asSequenceParser	^ PPSequenceParser withAll: (self collect: [ :(Object)each | each asParser ])! !!Collection methodsFor: '*prettypetit' stamp: 'EstebanAllende 2/28/2012 16:43'!(PPDocument) asDocument	^ PPSequenceDocument withAll: (self collect: [ :(Object)each | each asDocument ])! !!Collection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 13:25'!(?) anyOne	"Answer a representative sample of the receiver. This method can	be helpful when needing to preinfer the nature of the contents of 	semi-homogeneous collections."	self emptyCheck.	self do: [:(Object)each | ^ each]! !!Collection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 13:25'!(?) atRandom	"Answer a random element of the receiver.  Uses a shared random 	number generator owned by class Collection.  If you use this a lot, 	define your own instance of Random and use #atRandom:.  Causes 	an error if self has no elements."	^ self class mutexForPicking critical: [		self atRandom: self class randomForPicking ]"Examples:	#('one' 'or' 'the' 'other') atRandom	(1 to: 10) atRandom	'Just pick one of these letters at random' atRandom	#(3 7 4 9 21) asSet atRandom		(just to show it also works for Sets)"! !!Collection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 13:31'!(?) atRandom: (Random)aGenerator	"Answer a random element of the receiver. Uses aGenerator which    should be kept by the user in a variable and used every time. Use    this instead of #atRandom for better uniformity of random numbers because 	only you use the generator. Causes an error if self has no elements."	| (Integer)rand (Integer)index |	self emptyCheck.	rand := aGenerator nextInt: self size.	index := 1.	self do: [:each |		index = rand ifTrue: [^each].		index := index + 1].	^ self errorEmptyCollection! !!Collection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 13:31'!(Integer) capacity	"Answer the current capacity of the receiver."	^ self size! !!Collection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 13:31'!(Integer) size	"Answer how many elements the receiver contains."	| (Integer)tally |	tally := 0.	self do: [:(Object)each | tally := tally + 1].	^ tally! !!Collection methodsFor: 'adapting' stamp: 'EstebanAllende 2/28/2012 20:30'!(?) adaptToCollection: (Collection)rcvr andSend: (Symbol)selector	"If I am involved in arithmetic with another Collection, return a Collection of	the results of each element combined with the scalar in that expression."	rcvr isSequenceable & self isSequenceable ifFalse:		[self error: 'Only sequenceable collections may be combined arithmetically'].	^ (<SequenceableCollection>rcvr) with: (<SequenceableCollection>(<?>self)) collect:		[:(?)rcvrElement :(?)myElement | rcvrElement perform: selector with: myElement]! !!Collection methodsFor: 'adapting' stamp: 'EstebanAllende 2/28/2012 14:21'!(Self) adaptToNumber: (Number)rcvr andSend: (Symbol)selector	"If I am involved in arithmetic with a scalar, return a Collection of	the results of each element combined with the scalar in that expression."	^ self collect: [:(Object)element | rcvr perform: selector with: element]! !!Collection methodsFor: 'adapting' stamp: 'EstebanAllende 2/28/2012 14:22'!(Self) adaptToPoint: (Point)rcvr andSend: (Symbol)selector	"If I am involved in arithmetic with a scalar, return a Collection of	the results of each element combined with the scalar in that expression."	^ self collect: [:(Object)element | rcvr perform: selector with: element]! !!Collection methodsFor: 'adapting' stamp: 'EstebanAllende 2/28/2012 20:30'!(?) adaptToString: (String)rcvr andSend: (Symbol)selector	"If I am involved in arithmetic with a String, convert it to a Number."	^ rcvr asNumber perform: selector with: self! !!Collection methodsFor: 'adding' stamp: 'EstebanAllende 2/28/2012 14:25'!(Object) add: (Object)newObject 	"Include newObject as one of the receiver's elements. Answer newObject. 	ArrayedCollections cannot respond to this message."	^self subclassResponsibility! !!Collection methodsFor: 'adding' stamp: 'EstebanAllende 2/28/2012 14:25'!(Object) add: (Object)newObject withOccurrences: (Integer)anInteger	"Add newObject anInteger times to the receiver. Answer newObject."	anInteger timesRepeat: [self add: newObject].	^ newObject! !!Collection methodsFor: 'adding' stamp: 'EstebanAllende 2/28/2012 14:27'!(Collection) addAll: (Collection)aCollection 	"Include all the elements of aCollection as the receiver's elements. Answer 	aCollection. Actually, any object responding to #do: can be used as argument."	aCollection do: [:(Object)each | self add: each].	^ aCollection! !!Collection methodsFor: 'adding' stamp: 'EstebanAllende 2/28/2012 14:27'!(Object) addIfNotPresent: (Object)anObject	"Include anObject as one of the receiver's elements, but only if there	is no such element already. Anwser anObject."	(self includes: anObject) ifFalse: [self add: anObject].	^ anObject! !!Collection methodsFor: 'comparing' stamp: 'EstebanAllende 2/28/2012 14:27'!(Integer) hash	"Answer an integer hash value for the receiver such that,	  -- the hash value of an unchanged object is constant over time, and	  -- two equal objects have equal hash values"	| (Integer)hash |	hash := self species hash.	self size <= 10 ifTrue:		[self do: [:(Object)elem | hash := hash bitXor: elem hash]].	^hash bitXor: self size hash! !!Collection methodsFor: 'converting' stamp: 'EstebanAllende 2/28/2012 14:28'!(Array) asArray	"Answer an Array whose elements are the elements of the receiver.	Implementation note: Cannot use ''Array withAll: self'' as that only	works for SequenceableCollections which support the replacement 	primitive."	| (Array)array (Integer)index |	array := Array new: self size.	index := 0.	self do: [:(Object)each | array at: (index := index + 1) put: each].	^ array! !!Collection methodsFor: 'converting' stamp: 'EstebanAllende 2/28/2012 14:28'!(Bag) asBag	"Answer a Bag whose elements are the elements of the receiver."	^ Bag withAll: self! !!Collection methodsFor: 'converting' stamp: 'EstebanAllende 2/28/2012 14:29'!(ByteArray) asByteArray	"Answer a ByteArray whose elements are the elements of the receiver.	Implementation note: Cannot use ''ByteArray withAll: self'' as that only	works for SequenceableCollections which support the replacement 	primitive."	| (ByteArray)array (Integer)index |	array := ByteArray new: self size.	index := 0.	self do: [:(Integer)each | array at: (index := index + 1) put: each].	^ array! !!Collection methodsFor: 'converting' stamp: 'EstebanAllende 2/28/2012 14:29'!(CharacterSet) asCharacterSet	"Answer a CharacterSet whose elements are the unique elements of the receiver.	The reciever should only contain characters."	^ CharacterSet newFrom: self! !!Collection methodsFor: 'converting' stamp: 'EstebanAllende 2/28/2012 14:32'!(Dictionary) asDictionary	^ (<Dictionary>self as: Dictionary)! !!Collection methodsFor: 'converting' stamp: 'EstebanAllende 2/28/2012 14:32'!(IdentitySet) asIdentitySet	^(IdentitySet new: self size) addAll: self; yourself! !!Collection methodsFor: 'converting' stamp: 'EstebanAllende 2/28/2012 14:33'!(OrderedCollection) asOrderedCollection	"Answer an OrderedCollection whose elements are the elements of the	receiver. The order in which elements are added depends on the order	in which the receiver enumerates its elements. In the case of unordered	collections, the ordering is not necessarily the same for multiple 	requests for the conversion."	^ (<OrderedCollection> self as: OrderedCollection)! !!Collection methodsFor: 'converting' stamp: 'EstebanAllende 2/28/2012 14:33'!(Set) asSet	"Answer a Set whose elements are the unique elements of the receiver."	^ Set withAll: self! !!Collection methodsFor: 'converting' stamp: 'EstebanAllende 2/28/2012 14:34'!(SortedCollection) asSortedCollection	"Answer a SortedCollection whose elements are the elements of the receiver. The sort order is the default less than or equal. Note that you should use #sorted: if you don't really need a SortedCollection, but a sorted collection."	^ (<SortedCollection>self as: SortedCollection)! !!Collection methodsFor: 'converting' stamp: 'EstebanAllende 2/28/2012 14:40'!(SortedCollection) asSortedCollection: (? ? → Boolean)aSortBlock 	"Answer a SortedCollection whose elements are the elements of the receiver. The sort order is defined by the argument, aSortBlock. Note that this is better to use #sorted: if you don't really need a SortedCollection, but a sorted collection!!!!"	| (SortedCollection)aSortedCollection |	aSortedCollection := SortedCollection new: self size.	aSortedCollection sortBlock: aSortBlock.	aSortedCollection addAll: self.	^ aSortedCollection! !!Collection methodsFor: 'copying' stamp: 'EstebanAllende 2/28/2012 14:37'!(Self) , (Collection)aCollection	^self copy addAll: aCollection; yourself! !!Collection methodsFor: 'copying' stamp: 'EstebanAllende 2/28/2012 14:37'!(Self) copyWith: (Object)newElement	"Answer a new collection with newElement added (as last	element if sequenceable)."	^ self copy		add: newElement;		yourself! !!Collection methodsFor: 'copying' stamp: 'EstebanAllende 2/28/2012 14:38'!(Self) copyWithDependent: (Object)newElement	"Answer a new collection with newElement added (as last	element if sequenceable)."	^self copyWith: newElement! !!Collection methodsFor: 'copying' stamp: 'EstebanAllende 2/28/2012 14:38'!(Self) copyWithout: (Object)oldElement 	"Answer a copy of the receiver that does not contain any	elements equal to oldElement."	^ self reject: [:(Object)each | each = oldElement]"Examples:	'fred the bear' copyWithout: $e	#(2 3 4 5 5 6) copyWithout: 5"! !!Collection methodsFor: 'copying' stamp: 'EstebanAllende 2/28/2012 14:38'!(Self) copyWithoutAll: (Collection)aCollection	"Answer a copy of the receiver that does not contain any elements 	equal to those in aCollection."	^ self reject: [:each | aCollection includes: each]! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:07'!(Boolean) allSatisfy: (? → Boolean)aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns false for any element return false.	Otherwise return true."	self do: [:(?)each | (aBlock value: each) ifFalse: [^ false]].	^ true! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:07'!(Boolean) anySatisfy: (? → Boolean)aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns true for any element return true.	Otherwise return false."	self do: [:(?)each | (aBlock value: each) ifTrue: [^ true]].	^ false! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:07'!(Self) associationsDo: (? → Object)aBlock	"Evaluate aBlock for each of the receiver's elements (key/value 	associations).  If any non-association is within, the error is not caught now,	but later, when a key or value message is sent to it."	self do: aBlock! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:07'!(Self) collect: (? → Object)aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| (Self)newCollection |	newCollection := (<Self>(<?>self species new)).	self do: [:(?)each | newCollection add: (aBlock value: each)].	^ newCollection! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:07'!(?) collect: (? → Object)aBlock as: (Collection class)aClass	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into an instance of aClass. Answer the resulting collection."	^(aClass new: self size) fillFrom: self with: aBlock! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 14:48'!(Collection) collect: (? → Object)aBlock into: (Collection)aCollection	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into aCollection. Answer aCollection."	^aCollection fillFrom: self with: aBlock! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:08'!(Self) collect: (? → Boolean) collectBlock thenDo: (?→Object)doBlock 	"Utility method to improve readability."	^ (self collect: collectBlock) do: doBlock! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:31'!(Self) collect: (?→Object) collectBlock thenSelect: (?→Boolean)selectBlock	"Utility method to improve readability."	^ (self collect: collectBlock) select: selectBlock! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:08'!(Integer) count: (? → Boolean)aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the number of elements that answered true."	| (Integer)sum |	sum := 0.	self do: [:(?)each | (aBlock value: each) ifTrue: [sum := sum + 1]].	^ sum! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:09'!(?) detect: (?→Boolean)aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the first element for which aBlock evaluates to true."	^ self detect: aBlock ifNone: [self errorNotFound: aBlock]! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:09'!(?) detect: (? → Boolean)aBlock ifNone: (→ ?)exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the first element for which aBlock evaluates to true. If none  	evaluate to true, then evaluate the argument, exceptionBlock."	self do: [:(?)each | (aBlock value: each) ifTrue: [^ each]].	^ exceptionBlock value! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:11'!(?) detectMax: (?→Magnitude) aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the element for which aBlock evaluates to the highest magnitude.	If collection empty, return nil.  This method might also be called elect:."	| (?)maxElement (Magnitude)maxValue |	self do: [:(?)each | | (Magnitude)val | 		maxValue == nil			ifFalse: [				(val := aBlock value: each) > maxValue ifTrue: [					maxElement := each.					maxValue := val]]			ifTrue: ["first element"				maxElement := each.				maxValue := aBlock value: each].				"Note that there is no way to get the first element that works 				for all kinds of Collections.  Must test every one."].	^ maxElement! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:12'!(?) detectMin: (? → Magnitude)aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the element for which aBlock evaluates to the lowest number.	If collection empty, return nil."	| (?)minElement (Magnitude)minValue |	self do: [:(?)each | | (Magnitude)val | 		minValue == nil			ifFalse: [				(val := aBlock value: each) < minValue ifTrue: [					minElement := each.					minValue := val]]			ifTrue: ["first element"				minElement := each.				minValue := aBlock value: each].				"Note that there is no way to get the first element that works 				for all kinds of Collections.  Must test every one."].	^ minElement! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:18'!(?) detectSum: (?→ Integer)aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Return the sum of the answers."	| (Integer)sum |	sum := 0.	self do: [:(?)each | 		sum := (aBlock value: each) + sum].  	^ sum! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:18'!(Self) difference: (Collection)aCollection	"Answer the set theoretic difference of two collections."	^ self reject: [:(?)each | aCollection includes: each]! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 14:51'!(Self) do: (? → Object)aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument."	self subclassResponsibility! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:04'!(Self) do: (? → Object)aBlock displayingProgress: (Object)aStringOrBlock	"Enumerate aBlock displaying progress information. 	If the argument is a string, use a static label for the process. 	If the argument is a block, evaluate it with the element to retrieve the label.		Smalltalk allClasses 			do:[:aClass| (Delay forMilliseconds: 1) wait]			displayingProgress: 'Processing...'.		Smalltalk allClasses 			do:[:aClass| (Delay forMilliseconds: 1) wait]			displayingProgress:[:aClass| 'Processing ', aClass name].	"	^self do: aBlock displayingProgress: aStringOrBlock every: 20! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:04'!(Self) do: (? → Object)aBlock displayingProgress: (Object)aStringOrBlock every: (Integer)msecs       "Enumerate aBlock displaying progress information.       If the argument is a string, use a static label for the process.       If the argument is a block, evaluate it with the element to retrieve the label.       The msecs argument ensures that updates happen at most every msecs.       Example:               Smalltalk allClasses                       do:[:aClass| (Delay forMilliseconds: 1) wait]                       displayingProgress:[:aClass| 'Processing ', aClass name]                       every: 0."	| size (?→String)labelBlock (Integer)count (String)oldLabel (Integer)lastUpdate |	labelBlock := aStringOrBlock isString               ifTrue: [[:(Object)item| (<String>aStringOrBlock)]]               ifFalse: [(<?→String>aStringOrBlock)].	oldLabel := nil.	count := lastUpdate := 0.	size := self size.	'' displayProgressFrom: 0 to: size during: [:(Integer → Object)bar |		self do: [:(?)each| | (String)newLabel |				"Special handling for first and last element"				(count = 0 or: [count+1 = size					or: [(Time millisecondsSince: lastUpdate) >= msecs]]) 						ifTrue:							[bar value: count.							oldLabel = (newLabel := (labelBlock value: each) ifNil: [oldLabel]) 								ifFalse: [ProgressNotification signal: '' extra: (oldLabel := newLabel)].				lastUpdate := Time millisecondClockValue ].                       aBlock value: each.                       count := count + 1]]! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:05'!(Self) do: (? → Object)elementBlock separatedBy: (→ Object)separatorBlock	"Evaluate the elementBlock for all elements in the receiver,	and evaluate the separatorBlock between."	| (Boolean)beforeFirst | 	beforeFirst := true.	self do:		[:(?)each |		beforeFirst			ifTrue: [beforeFirst := false]			ifFalse: [separatorBlock value].		elementBlock value: each]! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:06'!(Self) do: (? → Object)aBlock without: (Object)anItem 	"Enumerate all elements in the receiver. 	Execute aBlock for those elements that are not equal to the given item"	^ self do: [:(?)each | anItem = each ifFalse: [aBlock value: each]]! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:19'!(Integer) findFirstInByteString: (ByteString)aByteString startingAt: (Integer)start	"Find the index of first character starting at start in aByteString that is included in the receiver.	Default is to use a naive algorithm.	Subclasses might want to implement a more efficient scheme"	start to: aByteString size do:		[:(Integer)index |		(self includes: (aByteString at: index)) ifTrue: [^ index]].	^ 0! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:46'!(?) fold: (? ? → ?)binaryBlock	"Evaluate the block with the first two elements of the receiver,	then with the result of the first evaluation and the next element,	and so on.  Answer the result of the final evaluation. If the receiver	is empty, raise an error. If the receiver has a single element, answer	that element."	"#('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') fold: [:a :b | a, ' ', b]"	^self reduce: binaryBlock! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:21'!(Array) gather: (?→Collection)aBlock	^ Array streamContents:		[:(Stream)stream |		self do: [:(?)ea | stream nextPutAll: (aBlock value: ea)]]! !!Collection methodsFor: 'enumerating' stamp: 'StephaneDucasse 1/3/2010 20:15'!groupBy: keyBlock having: selectBlock 	"This message is deprecated. Please use groupedBy:having:. 	But we let it right now without warning because we are not sure to 	remove in the next iteration."	^ self groupedBy: keyBlock having: selectBlock ! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:24'!(Dictionary) groupedBy: (?→?)aBlock	"Answer a dictionary whose keys are the result of evaluating aBlock	for all my elements, and the value for each key is the selection of 	my elements that evaluated to that key. Uses species."	| (PluggableDictionary)groups |	groups := PluggableDictionary integerDictionary.	self do: [ :(?)each |		(groups at: (aBlock value: each) ifAbsentPut: [ OrderedCollection new ]) add: each ].	self species ~~ OrderedCollection ifTrue: [		groups associationsDo: [ :(Association)association |			association value: ((<Collection class>self species) withAll: association value) ]].	^ groups! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:31'!(?) groupedBy: (?→?) aBlock having: (?→Boolean)aSelectionBlock	"Like in SQL operation - Split the recievers contents into collections of 	elements for which keyBlock returns the same results, and return those 	collections allowed by selectBlock."	^ (self groupedBy: aBlock) select: aSelectionBlock! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:34'!(?) inject: (?)thisValue into: (? ?→?)binaryBlock 	"Accumulate a running value associated with evaluating the argument, 	binaryBlock, with the current value of the argument, thisValue, and the 	receiver as block arguments. For instance, to sum the numeric elements 	of a collection, aCollection inject: 0 into: [:subTotal :next | subTotal + 	next]."	| (?)nextValue |	nextValue := thisValue.	self do: [:(?)each | nextValue := binaryBlock value: nextValue value: each].	^nextValue! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:43'!(Self) intersection: (Collection)aCollection	"Answer the set theoretic intersection of two collections."	^ self select: [:(Object)each | aCollection includes: each]! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:44'!(Boolean) noneSatisfy: (? → Boolean)aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns false for all elements return true.	Otherwise return false"	self do: [:(?)item | (aBlock value: item) ifTrue: [^ false]].	^ true! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:28'!(?) reduce: (BlockClosure)aBlock	"Fold the result of the receiver into aBlock. The argument aBlock must take two or more arguments. It applies the argument, binaryBlock cumulatively to the elements of the receiver. For sequenceable collections the elements will be used in order, for unordered collections the order is unspecified."	"#(1 2 3) asSet reduce: [ :a :b | a + b ]		--> 1 + 2 + 3 = 6	#(1 2 3 4 5) asSet reduce: [ :a :b :c | a + b + c ]		--> 1 + 2 + 3 + 4 + 5 = 15"			^self asOrderedCollection reduce: aBlock! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:49'!(Self) reject: (? → Boolean)aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new collection like the receiver only those elements for 	which aBlock evaluates to false. Answer the new collection."	^self select: [:(?)element | (aBlock value: element) == false]! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:52'!(Self) reject: (?→Boolean)rejectBlock thenDo: (?→Object)doBlock 	"Utility method to improve readability."	^ (self reject: rejectBlock) do: doBlock! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:29'!(Self) select: (?→Boolean)aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new collection like the receiver, only those elements for 	which aBlock evaluates to true. Answer the new collection."	| (Self)newCollection |	newCollection := (<Self class>self species) new.	self do: [:(?)each | (aBlock value: each) ifTrue: [newCollection add: each]].	^newCollection! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:29'!(Self) select: (?→Boolean) selectBlock thenCollect: (?→Object)collectBlock	"Utility method to improve readability."	^ (self select: selectBlock) collect: collectBlock! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:30'!(Self) select: (?→Boolean) selectBlock thenDo: (?→Object)doBlock    "Utility method to improve readability.	Do not create the intermediate collection."    self do: [: (?)each |        ( selectBlock value: each ) 			ifTrue: [ doBlock value: each ]    ].! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:58'!(SequenceableCollection) sorted	"Return a new sequenceable collection which contains the same elements as self but its elements are sorted in ascending order using the #'<=' operator."		^self sorted: nil! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:55'!(SequenceableCollection) sorted: (? ? → Boolean)aSortBlockOrNil	"Return a new sequenceable collection which contains the same elements as self but its elements are sorted by aSortBlockOrNil. The block should take two arguments and return true if the first element should preceed the second one. If aSortBlock is nil then <= is used for comparison."		^self asArray sort: aSortBlockOrNil! !!Collection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 15:58'!(Set) union: (Collection)aCollection	"Answer the set theoretic union of two collections."	^ self asSet addAll: aCollection; yourself! !!Collection methodsFor: 'filter streaming' stamp: 'EstebanAllende 2/28/2012 16:00'!(Self) contents	^ self! !!Collection methodsFor: 'filter streaming' stamp: 'EstebanAllende 2/28/2012 16:00'!(?) write: (Object)anObject 	^ self add: anObject! !!Collection methodsFor: 'math functions' stamp: 'EstebanAllende 2/28/2012 16:00'!(?)median	^ self asSortedCollection median! !!Collection methodsFor: 'math functions' stamp: 'EstebanAllende 2/28/2012 16:00'!(?) stdev	| (?)avg (?)sample (?)sum |	avg := self average. 	"see comment in self sum"	sample := self anyOne.	sum := self inject: sample into: [:accum :each | accum + (each - avg) squared].	sum := sum - sample.	^ (sum / (self size - 1)) sqrt! !!Collection methodsFor: 'math functions' stamp: 'EstebanAllende 2/28/2012 16:02'!(?) sum: (?→?)aBlock	"This is implemented using a variant of the normal inject:into: pattern. 	The reason for this is that it is not known whether we're in the normal 	number line, i.e. whether 0 is a good initial value for the sum. 	Consider a collection of measurement objects, 0 would be the unitless 	value and would not be appropriate to add with the unit-ed objects."	| (?)sum (?)sample |	sample := aBlock value: self anyOne.	sum := self inject: sample into: [ :(?)previousValue :(?)each |  previousValue + (aBlock value: each) ].	^ sum - sample! !!Collection methodsFor: 'printing' stamp: 'EstebanAllende 2/28/2012 16:03'!(String) asCommaString	"Return collection printed as 'a, b, c' "	^String streamContents: [:(Stream)s | self asStringOn: s delimiter: ', ']		! !!Collection methodsFor: 'printing' stamp: 'EstebanAllende 2/28/2012 16:05'!(String) asCommaStringAnd	"Return collection printed as 'a, b and c' "	^String streamContents: [:(Stream)s | self asStringOn: s delimiter: ', ' last: ' and ']		! !!Collection methodsFor: 'printing' stamp: 'EstebanAllende 2/28/2012 16:03'!(Self) asStringOn: (Stream)aStream delimiter: (String)delimString	"Print elements on a stream separated	with a delimiter String like: 'a, b, c'	Uses #asString instead of #print:."	self do: [:(Object)elem | aStream nextPutAll: elem asString]		separatedBy: [aStream nextPutAll: delimString]! !!Collection methodsFor: 'printing' stamp: 'EstebanAllende 2/28/2012 16:05'!(Self) asStringOn: (Stream)aStream delimiter: (String)delimString last: (String)lastDelimString	"Print elements on a stream separated	with a delimiter between all the elements and with	a special one before the last like: 'a, b and c'.	Uses #asString instead of #print:	Note: Feel free to improve the code to detect the last element."	| (Integer)n (Integer)sz |	n := 1.	sz := self size.	self do: [:(Object)elem |		n := n + 1.		aStream nextPutAll: elem asString]	separatedBy: [		aStream nextPutAll: (n = sz ifTrue: [lastDelimString] ifFalse: [delimString])]! !!Collection methodsFor: 'printing' stamp: 'EstebanAllende 2/28/2012 16:06'!(Self) printElementsOn: (WriteStream)aStream	"The original code used #skip:, but some streams do not support that,	 and we don't really need it."	aStream nextPut: $(.	self do: [:(Object)element | aStream print: element] separatedBy: [aStream space].	aStream nextPut: $)! !!Collection methodsFor: 'printing' stamp: 'EstebanAllende 2/28/2012 16:06'!(Self) printNameOn: (Stream)aStream	super printOn: aStream! !!Collection methodsFor: 'printing' stamp: 'EstebanAllende 2/28/2012 16:06'!(Self) printOn: (Stream)aStream 	"Append a sequence of characters that identify the receiver to aStream."	self printNameOn: aStream.	self printElementsOn: (<WriteStream>aStream)! !!Collection methodsFor: 'printing' stamp: 'EstebanAllende 2/28/2012 16:07'!(Self) printOn: (Stream)aStream delimiter: (String)delimString	"Print elements on a stream separated	with a delimiter String like: 'a, b, c' "	self do: [:(Object)elem | aStream print: elem] separatedBy: [aStream print: delimString]		! !!Collection methodsFor: 'printing' stamp: 'EstebanAllende 2/28/2012 16:07'!(Self) printOn: (Stream)aStream delimiter: (String)delimString last: (String)lastDelimString	"Print elements on a stream separated	with a delimiter between all the elements and with	a special one before the last like: 'a, b and c'	Note: Feel free to improve the code to detect the last element."	| (Integer)n (Integer)sz |	n := 1.	sz := self size.	self do: [:(Object)elem |		n := n + 1.		aStream print: elem]	separatedBy: [		n = sz			ifTrue: [aStream print: lastDelimString]			ifFalse: [aStream print: delimString]]! !!Collection methodsFor: 'printing' stamp: 'EstebanAllende 2/28/2012 16:09'!(Self) storeOn: (WriteStream)aStream 	"Refer to the comment in Object|storeOn:."	| (Boolean)noneYet |	aStream nextPutAll: '(('.	aStream nextPutAll: self class name.	aStream nextPutAll: ' new)'.	noneYet := true.	self do: 		[:(Object)each | 		noneYet			ifTrue: [noneYet := false]			ifFalse: [aStream nextPut: $;].		aStream nextPutAll: ' add: '.		aStream store: each].	noneYet ifFalse: [aStream nextPutAll: '; yourself'].	aStream nextPut: $)! !!Collection methodsFor: 'removing' stamp: 'EstebanAllende 2/28/2012 16:09'!(Self) remove: (Object)oldObject 	"Remove oldObject from the receiver's elements. Answer oldObject 	unless no element is equal to oldObject, in which case, raise an error.	ArrayedCollections cannot respond to this message."	^ self remove: oldObject ifAbsent: [self errorNotFound: oldObject]! !!Collection methodsFor: 'removing' stamp: 'EstebanAllende 2/28/2012 16:10'!(Self) remove: (Object)oldObject ifAbsent: (→Object)anExceptionBlock 	"Remove oldObject from the receiver's elements. If several of the 	elements are equal to oldObject, only one is removed. If no element is 	equal to oldObject, answer the result of evaluating anExceptionBlock. 	Otherwise, answer the argument, oldObject. ArrayedCollections cannot 	respond to this message."	self subclassResponsibility! !!Collection methodsFor: 'removing' stamp: 'EstebanAllende 2/28/2012 16:10'!(Self) removeAll	"Remove each element from the receiver and leave it empty.	ArrayedCollections cannot respond to this message.	There are two good reasons why a subclass should override this message:	1) the subclass does not support being modified while being iterated	2) the subclass provides a much faster way than iterating through each element"	self do: [:(Object)each | self remove: each].! !!Collection methodsFor: 'removing' stamp: 'EstebanAllende 2/28/2012 16:11'!(Collection) removeAll: (Collection)aCollection 	"Remove each element of aCollection from the receiver. If successful for 	each, answer aCollection. Otherwise create an error notification.	ArrayedCollections cannot respond to this message."	aCollection == self ifTrue: [^self removeAll].	aCollection do: [:(Object)each | self remove: each].	^ aCollection! !!Collection methodsFor: 'removing' stamp: 'EstebanAllende 2/28/2012 16:11'!(Collection) removeAllFoundIn: (Collection)aCollection 	"Remove each element of aCollection which is present in the receiver 	from the receiver. Answer aCollection. No error is raised if an element	isn't found. ArrayedCollections cannot respond to this message."	aCollection do: [:(Object)each | self remove: each ifAbsent: []].	^ aCollection! !!Collection methodsFor: 'removing' stamp: 'EstebanAllende 2/28/2012 16:12'!(Self) removeAllSuchThat: (?→Boolean)aBlock 	"Evaluate aBlock for each element and remove all that elements from	the receiver for that aBlock evaluates to true.  Use a copy to enumerate 	collections whose order changes when an element is removed (i.e. Sets)."	self copy do: [:(?)each | (aBlock value: each) ifTrue: [self remove: each]]! !!Collection methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 16:20'!(Boolean) contains: (?→Boolean)aBlock	"VW compatibility"	^self anySatisfy: aBlock! !!Collection methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 16:21'!(Boolean) identityIncludes: (Object)anObject 	"Answer whether anObject is one of the receiver's elements."	self do: [:(Object)each | anObject == each ifTrue: [^true]].	^false! !!Collection methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 16:22'!(?) ifEmpty: (→?)aBlock	"Evaluate the given block with the receiver as argument, answering its value if the receiver is empty, otherwise answer the receiver."		"Note that the fact that this method returns its argument in case the receiver is not empty allows one to write expressions like the following ones: self classifyMethodAs: (myProtocol ifEmpty: ['As yet unclassified'])"	^ self isEmpty 		ifTrue: [ ^aBlock value ]		ifFalse: [ self ]! !!Collection methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 16:22'!(?) ifEmpty: (→?)emptyBlock ifNotEmpty: (BlockClosure)notEmptyBlock	"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise"	" If the notEmptyBlock has an argument, eval with the receiver as its argument"	self isEmpty ifTrue: [ ^emptyBlock value ].	^notEmptyBlock cull: self! !!Collection methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 16:23'!(?) ifEmpty: (→?) emptyBlock ifNotEmptyDo: (Self→?)notEmptyBlock	"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise"	"Evaluate the notEmptyBlock with the receiver as its argument"	self isEmpty ifTrue: [ ^emptyBlock value ].	^notEmptyBlock value: self! !!Collection methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 16:23'!(?) ifNotEmpty: (BlockClosure)aBlock	"Evaluate the given block with the receiver as argument, answering its value      unless the receiver is empty, in which case answer the receiver      If the block has an argument, eval with the receiver as its argument,      but it might be better to use ifNotEmptyDo: to make the code easier to      understand"	"Note that the fact that this method returns its argument in case the receiver is empty	allows one to write expressions like the following ones:		self classifyMethodAs: (myProtocol ifEmpty: ['As yet unclassified']"	    ^self isEmpty          ifTrue: [self]          ifFalse: [aBlock cull: self]! !!Collection methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 16:24'!(?) ifNotEmpty: (BlockClosure)notEmptyBlock ifEmpty: (→?)emptyBlock	"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise	 If the notEmptyBlock has an argument, eval with the receiver as its argument"	self isEmpty ifFalse: [ ^notEmptyBlock cull: self ].	^emptyBlock value! !!Collection methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 16:25'!(?) ifNotEmptyDo: (Self → ?)aBlock	"Evaluate the given block with the receiver as its argument."	self isEmpty ifFalse: [^ aBlock value: self].! !!Collection methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 16:25'!(?) ifNotEmptyDo: (Self → ?)notEmptyBlock ifEmpty: (→?)emptyBlock	"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise	Evaluate the notEmptyBlock with the receiver as its argument"	self isEmpty ifFalse: [ ^notEmptyBlock value: self ].	^emptyBlock value! !!Collection methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 16:25'!(Boolean) includes: (Object)anObject 	"Answer whether anObject is one of the receiver's elements."	^ self anySatisfy: [:(Object)each | each = anObject]! !!Collection methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 16:26'!(Boolean) includesAllOf: (Collection)aCollection 	"Answer whether all the elements of aCollection are in the receiver."	aCollection do: [:(Object)elem | (self includes: elem) ifFalse: [^ false]].	^ true! !!Collection methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 16:27'!(Boolean) includesAnyOf: (Collection)aCollection 	"Answer whether any element of aCollection is one of the receiver's elements."	aCollection do: [:(Object)elem | (self includes: elem) ifTrue: [^ true]].	^ false! !!Collection methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 16:29'!(Boolean) includesSubstringAnywhere: (String)testString	"Answer whether the receiver includes, anywhere in its nested structure, a string that has testString as a substring"	self do:		[:(Object)element |			(element isString)				ifTrue:					[((<String>element) includesSubString: testString) ifTrue: [^ true]].			(element isCollection)				ifTrue:					[((<Collection>element) includesSubstringAnywhere: testString) ifTrue: [^ true]]].	^ false"#(first (second third) ((allSentMessages ('Elvis' includes:)))) includesSubstringAnywhere:  'lvi'"! !!Collection methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 16:29'!(Boolean) isCollection	"Return true if the receiver is some sort of Collection and responds to basic collection messages such as #size and #do:"	^true! !!Collection methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 16:29'!(Boolean) isEmpty	"Answer whether the receiver contains any elements."	^self size = 0! !!Collection methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 16:29'!(Boolean) isEmptyOrNil	"Answer whether the receiver contains any elements, or is nil.  Useful in numerous situations where one wishes the same reaction to an empty collection or to nil"	^ self isEmpty! !!Collection methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 16:29'!(Boolean) isSequenceable	^ false! !!Collection methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 16:29'!(Boolean) notEmpty	"Answer whether the receiver contains any elements."	^ self isEmpty not! !!Collection methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 16:30'!(Integer) occurrencesOf: (Object)anObject 	"Answer how many of the receiver's elements are equal to anObject."	| (Integer)tally |	tally := 0.	self do: [:(Object)each | anObject = each ifTrue: [tally := tally + 1]].	^tally! !!Collection methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 16:30'!(Self) emptyCheck	self isEmpty ifTrue: [self errorEmptyCollection]! !!Collection methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 16:30'!(Self) errorEmptyCollection	"Signal a CollectionIsEmpty exception"	CollectionIsEmpty signalWith: self! !!Collection methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 16:30'!(Self) errorNoMatch	"Signal a SizeMismatch exception"	SizeMismatch signal! !!Collection methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 16:30'!(Self) errorNotFound: (Object)anObject	"Raise a NotFound exception."	NotFound signalFor: anObject! !!Collection methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 16:31'!(Self) errorNotKeyed	self error: ('Instances of {1} do not respond to keyed accessing messages.' translated format: {self class name})! !!Collection methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 16:31'!(Self) fillFrom: (Collection)aCollection with: (? → ?)aBlock	"Evaluate aBlock with each of aCollections's elements as the argument.  	Collect the resulting values into self. Answer self."	aCollection do: [ :(?)each |		self add: (aBlock value: each) ]! !!Collection methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 16:32'!(Self) toBraceStack: (Integer)itsSize 	"Push receiver's elements onto the stack of thisContext sender.  Error if receiver does	 not have itsSize elements or if receiver is unordered.	 Do not call directly: this is called by {a. b} := ... constructs."	self size ~= itsSize ifTrue:		[self error: 'Trying to store ', self size printString,					' values into ', itsSize printString, ' variables.'].	thisContext sender push: itsSize fromIndexable: self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Collection class	uses: TTyped classTrait	instanceVariableNames: ''!!Collection class methodsFor: 'instance creation' stamp: 'EstebanAllende 2/28/2012 16:33'!(Self instance) with: (Object)anObject 	"Answer an instance of me containing anObject."	^ self new		add: anObject;		yourself! !!Collection class methodsFor: 'instance creation' stamp: 'EstebanAllende 2/28/2012 16:33'!(Self instance) with: (Object)firstObject with: (Object)secondObject 	"Answer an instance of me containing the two arguments as elements."	^ self new		add: firstObject;		add: secondObject;		yourself! !!Collection class methodsFor: 'instance creation' stamp: 'EstebanAllende 2/28/2012 16:35'!(Self instance) with: (Object)firstObject with: (Object)secondObject with: (Object)thirdObject 	"Answer an instance of me containing the three arguments as elements."	^ self new		add: firstObject;		add: secondObject;		add: thirdObject;		yourself! !!Collection class methodsFor: 'instance creation' stamp: 'EstebanAllende 2/28/2012 16:35'!(Self instance) with: (Object)firstObject with: (Object)secondObject with: (Object)thirdObject with: (Object)fourthObject 	"Answer an instance of me, containing the four arguments as the elements."	^ self new		add: firstObject;		add: secondObject;		add: thirdObject;		add: fourthObject;		yourself! !!Collection class methodsFor: 'instance creation' stamp: 'EstebanAllende 2/28/2012 16:36'!(Self instance) with: (Object)firstObject with: (Object)secondObject with: (Object)thirdObject with: (Object)fourthObject with: (Object)fifthObject	"Answer an instance of me, containing the five arguments as the elements."	^ self new		add: firstObject;		add: secondObject;		add: thirdObject;		add: fourthObject;		add: fifthObject;		yourself! !!Collection class methodsFor: 'instance creation' stamp: 'EstebanAllende 2/28/2012 16:36'!(Self instance) with: (Object)firstObject with: (Object)secondObject with: (Object)thirdObject with: (Object)fourthObject with: (Object)fifthObject with: (Object)sixthObject	"Answer an instance of me, containing the six arguments as the elements."	^ self new		add: firstObject;		add: secondObject;		add: thirdObject;		add: fourthObject;		add: fifthObject;		add: sixthObject;		yourself! !!Collection class methodsFor: 'instance creation' stamp: 'EstebanAllende 2/28/2012 16:37'!(Self instance) withAll: (Collection)aCollection	"Create a new collection containing all the elements from aCollection."	^ (self new: aCollection size)		addAll: aCollection;		yourself! !!Collection class methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 16:32'!(Self) initialize	"Set up a Random number generator to be used by atRandom when the 	user does not feel like creating his own Random generator."	RandomForPicking := Random new.	MutexForPicking := Semaphore forMutualExclusion! !!Collection class methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 16:37'!(Semaphore) mutexForPicking	^ MutexForPicking! !!Collection class methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 16:37'!(Random) randomForPicking	^ RandomForPicking! !Collection initialize!