'From Pharo1.4a of ''16 June 2011'' [Latest update: #14301] on 28 February 2012 at 8:27:48 pm'!Collection subclass: #SequenceableCollection	uses: TSortable	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Abstract'!!SequenceableCollection commentStamp: '<historical>' prior: 0!I am an abstract superclass for collections that have a well-defined order associated with their elements. Thus each element is externally-named by integers referred to as indices.!!SequenceableCollection methodsFor: '*Balloon' stamp: 'EstebanAllende 2/28/2012 20:06'!(PointArray) asPointArray	"Answer an PointArray whose elements are the elements of the receiver, in 	the same order."	| (PointArray)pointArray |	pointArray := PointArray new: self size.	1 to: self size do:[:(Integer)i| pointArray at: i put: (self at: i)].	^pointArray! !!SequenceableCollection methodsFor: '*Graphics-Display Objects' stamp: 'EstebanAllende 2/28/2012 20:06'!(ColorArray) asColorArray	^ColorArray withAll: self! !!SequenceableCollection methodsFor: '*Kernel-Extensions' stamp: 'EstebanAllende 2/28/2012 20:07'!(Self) putOn: (Stream)aStream	self do: [ :(Object)each | each putOn: aStream ]! !!SequenceableCollection methodsFor: '*Morphic-Basic' stamp: 'EstebanAllende 2/28/2012 20:07'!(Cubic) asCubic	"Convert this point array to a Cubic object"	[self size = 4] assert.	[self allSatisfy: [:(Object)each | each isPoint]] assert.	^ Cubic withAll: self! !!SequenceableCollection methodsFor: '*Morphic-Basic' stamp: 'StephaneDucasse 6/5/2011 16:16'!assertSlopesWith: knots from: start to: end	"We trust everything has been checked. 	The following assertions should hold at this point: "		[ self size = knots size ] assert. 	"Sizes must be consistent." 	[ end > start] assert. 	"There must be at least one slope to clamp." 	[ 0 < start and: [start <= knots size] ] assert. 	"The clamped slope may be the last one."	[  end  <= knots size + start ] assert. 	"We can wrap. There may be only one known slope."	"xxx self assert: [ end = knots size + start ifTrue: [ (self at: start) notNil ] ] . xxx"		"xxx If we overlap slope must be known. xxx"	{ start . end } 		do: [ :index | | slope | slope := (self at: index ).	[ slope isNil 		or: [ slope isNumber 		or: [ slope isPoint ] ] ] assert ] . 	"And a known and reasonalble value or nil." 		^true 	! !!SequenceableCollection methodsFor: '*Morphic-Basic' stamp: 'EstebanAllende 2/28/2012 20:09'!(Array) changeInSlopes: (SequenceableCollection)slopes 	"A message to knots of a spline. Returns an array with the 3rd cubic coeff."	"The last nth item is correct iff this is a closed cubic.	Presumably that is the only time we care.	We always return the same sized array as self."	| (Integer)n (Array)slopeChanges |	n := self size.	n = slopes size		ifFalse: [^ self error: 'vertices and slopes differ in number'].	slopeChanges := Array new: n.	(1 to: n)		do: [:(Integer)i | slopeChanges at: i put: (self atWrap: i + 1)					- (self at: i) * 3 - ((slopes at: i)						* 2)					- (slopes atWrap: i + 1)].	^ slopeChanges! !!SequenceableCollection methodsFor: '*Morphic-Basic' stamp: 'EstebanAllende 2/28/2012 20:11'!(Array) changeOfChangesInSlopes: (SequenceableCollection)slopes 	"A message to knots of a spline. Returns an array with the 4rd 	cubic coeff."	"The last nth item is correct iff this is a closed cubic. 	Presumably that is the only time we care. 	We always return the same sized array as self."	| (Integer)n (Array)changes |	n := self size.	n = slopes size		ifFalse: [^ self error: 'vertices and slopes differ in number'].	changes := Array new: n.	1 to: n do: [:(Integer)i | changes at: i put: (self at: i)					- (self atWrap: i + 1) * 2					+ (slopes at: i)					+ (slopes atWrap: i + 1)].	^ changes! !!SequenceableCollection methodsFor: '*Morphic-Basic' stamp: 'EstebanAllende 2/28/2012 20:14'!(Array) closedCubicSlopes	"Sent to knots returns the slopes of a closed cubic spline.	From the same set of java sources as naturalCubic. This is a squeak  	transliteration of the java code."	"from java code NatCubicClosed extends NatCubic  	solves for the set of equations for all knots: 	b1+4*b2+b3=3*(a3-a1)	where a1 is (knots atWrap: index + 1) etc.	and the b's are the slopes .		by decomposing the matrix into upper triangular and lower matrices  	and then back sustitution. See Spath 'Spline Algorithms for Curves  	and Surfaces' pp 19--21. The D[i] are the derivatives at the knots.  	"		| (Array)v (Array)w (Self)x (Array)y (Float)z (Integer)n1  (Array)D (Number)F (Number)G (Float)H |	n1 := self size.	n1 < 3		ifTrue: [self error: 'Less than 3 points makes a poor curve'].	v := Array new: n1.	w := Array new: n1.	y := Array new: n1.		D := Array new: n1.	x := self.	z := 1.0 / 4.0.	v at: 2 put: z.	w at: 2 put: z.	y at: 1 put: z * 3.0 * ((x at: 2) - (x at: n1)).	H := 4.0.	F := 3 * ((x at: 1) - (x at: n1 - 1)).	G := 1.	(2 to: n1 - 1)		do: [:(Integer)k | 			z := 1.0 / (4.0 - (v at: k)).			v at: k + 1 put: z.			w at: k + 1 put: z negated					* (w at: k).			y at: k put: z * (3.0 * ((x at: k + 1) - (x at: k - 1)) - (y at: k - 1)).			H := H - (G * (w at: k)).			F := F - (G * (y at: k - 1)).			G := (v at: k) negated * G].	H := H - (G + 1 * ((v at: n1) + (w at: n1))).	y at: n1 put: F - (G + 1 * (y at: n1 - 1)).	D at: n1 put: (y at: n1) / H.	D at: n1 - 1 put: (y at: n1 - 1) - ((v at: n1) + (w at: n1) * (D at: n1)).	(1 to: n1 - 2)		reverseDo: [:(Integer)k | D at: k put: (y at: k)					- ((v at: k + 1) * (D at: k + 1)) - ((w at: k + 1) * (D at: n1))].	^ D ! !!SequenceableCollection methodsFor: '*Morphic-Basic' stamp: 'StephaneDucasse 6/5/2011 16:18'!closedCubicSlopes: clampedSlopes	"Sent to knots returns a copy of clampedSlopes with the values of the undefined (nil)  slopes filled in.	lampedSlopes must be the same size as knots)" 		"Between known slopes we solve the equation for knots with end conditions:  	4*b1+b2 = 3(a2 - a0) - b0 	bN2+4*bN1 = 3*(aN-aN2) - bN	and inbetween:	b2+4*b3+b4=3*(a4-a2)	where a2 is (knots atWrap: index + 1) etc.	and the b's are the slopes .	N is the last index (knots size)	N1 is N-1.	 	by using row operations to convert the matrix to upper  	triangular and then back substitution. 	"	| slopes tripleKnots list |	(list := clampedSlopes closedFillinList) = { 0 to: self size } ifTrue: [ ^ self closedCubicSlopes ] .	"Special case all unknown."		tripleKnots := self * 3.0 . 	" Premultiply and convert numbers or point coords to Floats "	slopes := clampedSlopes copy. "slopes contents will be modified."		list do: [ :r | slopes slopesWith: tripleKnots from: r first to: r last ] .		^ slopes! !!SequenceableCollection methodsFor: '*Morphic-Basic' stamp: 'StephaneDucasse 6/5/2011 16:19'!closedFillinList	"Answers a list of ranges between which values are undertermined.	Reciever is a list that combines known values and nil entries for	undetermined values.	Answer a list of ranges. Each range starts and ends with a known	value. 	The range inbetween the known values are nil. The ranges start and	ends may overlap. 	Each nil element in the list appears in exactly one range. 	If the list starts or ends with nil the last range will wrap around to the	next known value. There may be only one known value in the list but	there must be atleast one know value.		(self allsatisfy: [ :e | e isNil ] ) ifTrue: [ self error: 'list must contain at	least one known value' ] 	"	| changes n |	changes := self nilTransitions .	changes isEmpty ifTrue: [ ^ { 0 to: self size } "Special case. All unknowns." ] .	 	changes = #(1) ifTrue: [ ^ #() "Special case. no unknowns." ] . 	changes = { n :=  self size } ifTrue: [ ^ { n to: n + n } ] .	"Special case. Only last element known."		changes size even		 ifTrue: [changes add: self size + (changes at: 1)]		ifFalse: [ changes first = 1 					ifFalse: [ changes add: self size + 1;								add: self size + changes first ]].	^ changes allButFirst pairsCollect: [ :s :e | ( s - 1 to: e ) ] .	! !!SequenceableCollection methodsFor: '*Morphic-Basic' stamp: 'StephaneDucasse 6/5/2011 16:19'!cubicPointPolynomialAt: vIndex	"From curve information assemble a 4-array of points representing the coefficents for curve segment between to points. Beginning point is first point in array endpoint is the pointSum of the array. Meant to be sent to newcurves idea of curve coefficents." 		^ ((1 to: 4)		collect: [:i | ((self at: i)				at: vIndex)				@ ((self at: 4 + i)						at: vIndex)]) asCubic! !!SequenceableCollection methodsFor: '*Morphic-Basic' stamp: 'StephaneDucasse 6/5/2011 16:20'!naturalCubicSlopes	"Sent to knots returns the slopes of a natural cubic curve fit."	"We solve the equation for knots with end conditions:  	2*b1+b2 = 3(a1 - a0) 	bN1+2*bN = 3*(aN-aN1)	and inbetween:	b2+4*b3+b4=3*(a4-a2)	where a2 is (knots atWrap: index + 1) etc.	and the b's are the slopes .	N is the last index (knots size)	N1 is N-1.	 	by using row operations to convert the matrix to upper  	triangular and then back sustitution. The D[i] are the derivatives at the  	knots."		| x gamma delta D n1 |	n1 := self size.	n1 < 3		ifTrue: [self error: 'Less than 3 points makes a poor curve'].	x := self.	gamma := Array new: n1.	delta := Array new: n1.		D := Array new: n1.	gamma at: 1 put: 1.0 / 2.0.	(2 to: n1 - 1)		do: [:i | gamma at: i put: 1.0 / (4.0						- (gamma at: i - 1))].	gamma at: n1 put: 1.0 / (2.0				- (gamma at: n1 - 1)).	delta at: 1 put: 3.0 * ((x at: 2)				- (x at: 1))			* (gamma at: 1).	2 to: n1 - 1 do: [:i | delta at: i put: 3.0 * ((x at: i + 1)						- (x at: i - 1))					- (delta at: i - 1)					* (gamma at: i)].	delta at: n1 put: 3.0 * ((x at: n1)				- (x at: n1 - 1))			- (delta at: n1 - 1)			* (gamma at: n1).	D		at: n1		put: (delta at: n1).	(1 to: n1 - 1)		reverseDo: [:i | D at: i put: (delta at: i)					- ((gamma at: i)							* (D at: i + 1))].	^ D! !!SequenceableCollection methodsFor: '*Morphic-Basic' stamp: 'StephaneDucasse 6/5/2011 16:20'!naturalCubicSlopes: clampedSlopes	"Sent to knots returns a copy of clampedSlopes with the values of the undefined (nil)  slopes filled in.	clampedSlopes must be the same size as knots)" 		"Between known slopes we solve the equation for knots with end conditions:  	4*b1+b2 = 3(a2 - a0) - b0 	bN2+4*bN1 = 3*(aN-aN2) - bN	and inbetween:	b2+4*b3+b4=3*(a4-a2)	where a2 is (knots atWrap: index + 1) etc.	and the b's are the slopes .	N is the last index (knots size)	N1 is N-1.	 	by using row operations to convert the matrix to upper  	triangular and then back substitution. 	"	| slopes tripleKnots |	tripleKnots := self * 3.0 . 	" Premultiply and convert numbers or point coords to Floats "	slopes := clampedSlopes copy. "slopes will be modified."	clampedSlopes naturalFillinList do: [ :r | slopes slopesWith: tripleKnots from: r first to: r last ] .		^ slopes! !!SequenceableCollection methodsFor: '*Morphic-Basic' stamp: 'StephaneDucasse 6/5/2011 16:21'!naturalFillinList	"Return a list of fillin ranges to be used to calculate natural or clamped slopes.	Note that this list is slightly different in mission from the closedFillinList"	"Answers a list of ranges between which value are undertermined.	Reciever is a list that combines known values and nil entries for	undetermined values.	Answer a list of ranges. Each range starts and ends with a known value. 	With the exception of the first and last slopes on the list which may be unknown.	If no slopes are known then the only range is the whole list.	If all slopes are known then the fillin list is empty.	The range inbetween the known values are nil. The ranges start and	ends may overlap if the slope at the overlap is known.	Each nil element in the list appears in exactly one range.  	"	| changes  |	changes := self nilTransitions .	changes isEmpty ifTrue: [ ^ { 1 to: self size } "Special case all unknown." ] .	 	changes = #(1) ifTrue: [ ^ #() "Special case. no unknowns." ] . 		changes size even 			ifTrue: [changes add: self size ].  "Last slope is unknown"	changes first = 1			ifTrue: [ ^ changes allButFirst pairsCollect: [ :s :e | (  s - 1 to: e ) ] ].	"Otherwise first slope is unknown."			^ { 1 to: changes first } , (changes allButFirst pairsCollect: [ :s :e | ( ( s - 1) to: e ) ]) 	! !!SequenceableCollection methodsFor: '*Morphic-Basic' stamp: 'StephaneDucasse 6/5/2011 16:21'!nilTransitions	"Return an OrderedCollection of transition indexes.  	Indexes represent where the list elements transitions 	from nil to nonNil  or from nonNil to nil.	1 is an index in the list iff the first element is nonNil. "		| changes nilSkip |	changes := OrderedCollection new.	nilSkip := true .	1 to: self size do: [:i | (self atWrap: i) isNil == nilSkip				ifFalse: [changes add: i.						nilSkip := nilSkip not]].	^ changes ! !!SequenceableCollection methodsFor: '*Morphic-Basic' stamp: 'StephaneDucasse 6/5/2011 16:21'!segmentedSlopes	"For a collection of floats. Returns the slopes for straight 	segments between vertices."	"last slope closes the polygon. Always return same size as 	self. "	^ self collectWithIndex: [:x :i | (self atWrap: i + 1) - x]! !!SequenceableCollection methodsFor: '*Morphic-Basic' stamp: 'StephaneDucasse 6/5/2011 16:21'!slopesWith: tripleKnots from: start to: end 	"Sent to modifiable list of slopes. Fills in the slope values between start	and end. Start and end slopes can be either clamped or nil. 	If nil the natural slope for that value will be filled in. 	We expect that the parameters meets the assertions in	self assertSlopesWith: knots from: start to: end."	"		/* We solve the equation for knots with end conditions either known or unknown: 	4*b1+b2 = 3*(a2 - a0) - b0			b0 known	Or	2*b0+b1 = 3*(a1 - a0) .			b0 == nil		bN2+4*bN1 = 3*(aN-aN2)-bN		bN known	Or	bN1+2*bN = 3*(aN-aN1)			bN == nil	 .	b0, bN are starting and ending slopes.		We now handle the special closed cubic case where a0 == aN ( i.e. N = knots size )	and b0 == bN == nil .		and inbetween:	b2+4*b3+b4=3*(a4-a2)	where a2 is (knots  atWrap: index + 1) etc.	and the b's are the slopes.	by using row operations to convert the matrix to upper 	triangular and then back substitution. "	| gamma delta n range isOpenRange |	n := self size.	gamma := Array new: n.	delta := Array new: n.	isOpenRange := end < (start + self size) .	(self at: start)		ifNotNil: [			gamma at: start put: 0.0.			delta				at: start				put: (self at: start).			range := ( start + 1 to: end - 1 ) .			] " clamped initial conditions"		ifNil: [				isOpenRange				ifTrue:				[gamma at: start put: 2.0 reciprocal.			delta				at: start				put:  ((tripleKnots atWrap: start + 1)					- tripleKnots at: start ) * (gamma at: start) .			range := ( start  to: end - 1 ) . ]  "natural initial conditions "				ifFalse: 			[ gamma at: start put: 4.0 reciprocal.			delta				at: start				put:  ((tripleKnots atWrap: start + 1)					- tripleKnots atWrap: start - 1 ) * (gamma at: start) .			range := ( start + 1  to: end - 1 ) .				]  "closed initial conditions "				] .	(start + 1 to: end - 1)		do: [:i | gamma atWrap: i put: 1.0 / (4.0						- (gamma atWrap: i - 1))].	(start + 1 to: end - 1)		do: [:i | delta atWrap: i put: ((tripleKnots atWrap: i + 1)						- (tripleKnots atWrap: i - 1))					- (delta atWrap: i - 1)					* (gamma atWrap: i)].	(self atWrap: end) 		ifNil: [ isOpenRange			ifTrue: [			gamma atWrap: end put: 1.0 / (2.0  										- (gamma atWrap: end - 1 )).			delta				atWrap: end				put:  ((tripleKnots atWrap: end )							- tripleKnots atWrap: end - 1 )					 	- (delta at: end - 1 ) * (gamma atWrap: end)] "natural end conditions"					ifFalse: [			gamma atWrap: end put: 1.0 / (4.0  										- (gamma atWrap: end - 1 )).			delta				atWrap: end				put:  ((tripleKnots atWrap: end + 1 )							- tripleKnots atWrap: end - 1 ) 						- (delta at: end - 1 ) * (gamma atWrap: end)] "closed end conditions"  					.			self atWrap: end put: (delta atWrap: end ) .				] 	ifNotNil: [ 			gamma atWrap: end put: 0.0 .			delta				atWrap: end				put: (self atWrap: end)  .					] "clamped end conditions" .			range		reverseDo: [:i | self atWrap: i put: 					(delta atWrap: i)					- ((gamma atWrap: i)							* (self atWrap: i + 1)) ] .	" reciever now contains the filled in slopes."	^ self ! !!SequenceableCollection methodsFor: '*Polymorph-EventEnhancements' stamp: 'EstebanAllende 2/28/2012 20:17'!(Self)aggregateRuns: (? → ?)aBlock	"Answer a new collection of the same species as the	receiver with elements being collections (of the receiver	species) containing those elements of the receiver	for which the given block consecutively evaluates to	the same object."	| (WriteStream)str (WriteStream)eStr (?)r|	str := Array new writeStream.	r := nil.	eStr := Array new writeStream.	self do: [:(?)e | | (?)t |		(t := aBlock value: e) = r			ifTrue: [eStr nextPut: e]			ifFalse: [r := t.					eStr isEmpty						ifFalse: [str nextPut: (eStr contents as: self species).								eStr reset].					eStr nextPut: e]].	eStr isEmpty ifFalse: [str nextPut: (eStr contents as: self species)].	^str contents as: self species	! !!SequenceableCollection methodsFor: '*Tools-Explorer' stamp: 'EstebanAllende 2/28/2012 20:17'!(Boolean) customizeExplorerContents	^ true.! !!SequenceableCollection methodsFor: '*Traits' stamp: 'EstebanAllende 2/28/2012 20:17'!(TraitComposition) asTraitComposition	"For convenience the composition {T1. T2 ...} is the same as T1 + T2 + ..."	^self isEmpty		ifFalse: [			self size = 1				ifTrue: [self first asTraitComposition]				ifFalse: [					self copyWithoutFirst 						inject: self first						into: [:(?)left :(?)right | left + right]]]		ifTrue: [			TraitComposition new]! !!SequenceableCollection methodsFor: '*opalcompiler-core' stamp: 'EstebanAllende 2/28/2012 20:19'!(Integer) literalIndexOf: (Object)anElement ifAbsent: (→Integer)exceptionBlock	"Answer the index of anElement within the receiver. If the receiver does 	not contain anElement, answer the result of evaluating the argument, 	exceptionBlock."	1 to: self size do:		[:i | ((self at: i) literalEqual: anElement) ifTrue: [^ i]].	^ exceptionBlock value! !!SequenceableCollection methodsFor: '*petitparser-core-converting' stamp: 'lr 12/18/2011 15:57'!asParser	self notify: 'SequenceableCollection>>#asParser is no longer supported. If you would like to create a PPSequenceParser from a Collection consider using #asSequenceParser instead.'.	^ self asSequenceParser! !!SequenceableCollection methodsFor: '*petitparser-core-converting' stamp: 'EstebanAllende 2/28/2012 20:20'!(PPStream) asPetitStream	^ PPStream on: self! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:36'!(?) after: (Object)target	"Answer the element after target.  Raise an error if target is not	in the receiver, or if there are no elements after it."	^ self after: target ifAbsent: [self errorNotFound: target]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:35'!(?) after: (Object)target ifAbsent: (→?)exceptionBlock	"Answer the element after target.  Answer the result of evaluation	the exceptionBlock if target is not in the receiver, or if there are 	no elements after it."	| (Integer)index |	index := self indexOf: target.	^ (index = 0 or: [index = self size])		ifTrue: [exceptionBlock value]		ifFalse: [self at: index + 1]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:36'!(Self) allButFirst	"Answer a copy of the receiver containing all but the first	element. Raise an error if there are not enough elements."	^ self allButFirst: 1! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:36'!(Self) allButFirst: (Integer)n	"Answer a copy of the receiver containing all but the first n	elements. Raise an error if there are not enough elements."	^ self copyFrom: n + 1 to: self size! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:37'!(Self) allButLast	"Answer a copy of the receiver containing all but the last	element. Raise an error if there are not enough elements."	^ self allButLast: 1! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:37'!(Self) allButLast: (Integer)n	"Answer a copy of the receiver containing all but the last n	elements. Raise an error if there are not enough elements."	^ self copyFrom: 1 to: self size - n! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:37'!(?) anyOne	^ self first! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:38'!(Self) atAllPut: (Object)anObject 	"Put anObject at every one of the receiver's indices."	| (Integer)size |	(size := self size) > 26 "first method faster from 27 accesses and on"		ifTrue: [self from: 1 to: size put: anObject]		ifFalse: [1 to: size do: [:(Integer)index | self at: index put: anObject]]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 20:24'!(Self) atAll: (Collection)indexArray	"Answer a new collection like the receiver which contains all elements	of the receiver at the indices of indexArray."	"#('one' 'two' 'three' 'four') atAll: #(3 2 4)"	| (Self)newCollection |	newCollection := ((<Self class>self species) ofSize: indexArray size).	1 to: indexArray size do:		[:(Integer)index |		newCollection at: index put: (self at: (indexArray at: index))].	^ newCollection! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 20:25'!(Collection) atAll: (SequenceableCollection)indexArray putAll: (SequenceableCollection)valueArray	"Store the elements of valueArray into the slots	of this collection selected by indexArray."	indexArray with: valueArray do: [:(Integer)index :(Object)value | self at: index put: value].	^ valueArray! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:43'!(Object) atAll: (Collection)aCollection put: (Object)anObject 	"Put anObject at every index specified by the elements of aCollection."	aCollection do: [:(Integer)index | self at: index put: anObject].	^ anObject! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:44'!(?) atLast: (Integer)indexFromEnd	"Return element at indexFromEnd from the last position.	 atLast: 1, returns the last element"	^ self atLast: indexFromEnd ifAbsent: [self error: 'index out of range']! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:45'!(?) atLast: (Integer)indexFromEnd ifAbsent: (→ ?)block	"Return element at indexFromEnd from the last position.	 atLast: 1 ifAbsent: [] returns the last element"	^ self at: self size + 1 - indexFromEnd ifAbsent: block! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:45'!(?) atLast: (Integer)indexFromEnd put: (Object)obj	"Set the element at indexFromEnd from the last position.	 atLast: 1 put: obj, sets the last element"	^ self at: self size + 1 - indexFromEnd put: obj! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:46'!(?) atPin: (Integer)index 	"Return the index'th element of me if possible.	Return the first or last element if index is out of bounds."	index < 1 ifTrue: [^ self first].	index > self size ifTrue: [^ self last].	^ self at: index! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:46'!(?) atRandom: (Random)aGenerator	"Answer a random element of the receiver.  Uses aGenerator which	should be kept by the user in a variable and used every time. Use	this instead of #atRandom for better uniformity of random numbers 	because only you use the generator.  Causes an error if self has no 	elements."	^ self at: (aGenerator nextInt: self size)! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:47'!(?) atWrap: (Integer)index 	"Answer the index'th element of the receiver.  If index is out of bounds,	let it wrap around from the end to the beginning until it is in bounds."	^ self at: index - 1 \\ self size + 1! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:47'!(?) atWrap: (Integer)index put: (Object)value	"Store value into the index'th element of the receiver.  If index is out	of bounds, let it wrap around from the end to the beginning until it 	is in bounds. Answer value."	^ self at: index  - 1 \\ self size + 1 put: value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:47'!(?) at: (Integer)index ifAbsent: (→?)exceptionBlock 	"Answer the element at my position index. If I do not contain an element 	at index, answer the result of evaluating the argument, exceptionBlock."	(index between: 1 and: self size) ifTrue: [^ self at: index].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:48'!(?) at: (Integer)index incrementBy: (Object)value	^self at: index put: (self at: index) + value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:49'!(?) before: (Object)target	"Answer the receiver's element immediately before target. Raise an	error if target is not an element of the receiver, or if there are no 	elements before it (i.e. it is the first element)."	^ self before: target ifAbsent: [self errorNotFound: target]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:48'!(?) before: (Object)target ifAbsent: (→?)exceptionBlock	"Answer the receiver's element immediately before target. Answer	the result of evaluating the exceptionBlock if target is not an element	of the receiver, or if there are no elements before it."	| (Integer)index |	index := self indexOf: target.	^ (index = 0 or: [index = 1])		ifTrue: [exceptionBlock value]		ifFalse: [self at: index - 1]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:49'!(?) eighth	"Answer the eighth element of the receiver.	Raise an error if there are not enough elements."	^ self at: 8! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:49'!(?) fifth	"Answer the fifth element of the receiver.	Raise an error if there are not enough elements."	^ self at: 5! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:49'!(?) first	"Answer the first element of the receiver"	^ self at: 1! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:49'!(Self) first: (Integer)n	"Answer the first n elements of the receiver.	Raise an error if there are not enough elements."	^ self copyFrom: 1 to: n! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:49'!(?) fourth	"Answer the fourth element of the receiver.	Raise an error if there are not enough elements."	^ self at: 4! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:50'!(Object) from: (Integer)startIndex to: (Integer)endIndex put: (Object)anObject	"Put anObject in all indexes between startIndex 	and endIndex. Very fast. Faster than to:do: for	more than 26 positions. Answer anObject"	| (Integer)written (Integer)toWrite (Integer)thisWrite |	startIndex > endIndex ifTrue: [^self].	self at: startIndex put: anObject.	written := 1.	toWrite := endIndex - startIndex + 1.	[written < toWrite] whileTrue:		[			thisWrite := written min: toWrite - written.			self 				replaceFrom: startIndex + written				to: startIndex + written + thisWrite - 1				with: self startingAt: startIndex.			written := written + thisWrite		].	^anObject! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:51'!(Integer) identityIndexOf: (Object)anElement 	"Answer the index of anElement within the receiver. If the receiver does 	not contain anElement, answer 0."	^self identityIndexOf: anElement ifAbsent: [0]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:51'!(Integer) identityIndexOf: (Object)anElement ifAbsent: (→Integer)exceptionBlock	"Answer the index of anElement within the receiver. If the receiver does 	not contain anElement, answer the result of evaluating the argument, 	exceptionBlock."	1 to: self size do:		[:(Integer)i | (self at: i) == anElement ifTrue: [^ i]].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:53'!(Integer) indexOf: (Object)anElement startingAt: (Integer)start       "Answer the index of the first occurence of anElement after start within the receiver. If the receiver does not contain anElement, answer 0."	^self indexOf: anElement startingAt: start ifAbsent: [0]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:55'!(Integer) indexOfAnyOf: (Collection)aCollection	"Answer the index of the first occurence of any element included in aCollection within the receiver.	If the receiver does not contain anElement, answer zero, which is an invalid index."	^self indexOfAnyOf: aCollection startingAt: 1 ifAbsent: [0]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:55'!(Integer) indexOfAnyOf: (Collection)aCollection ifAbsent: (→Integer)exceptionBlock	"Answer the index of the first occurence of any element included in aCollection within the receiver.	If the receiver does not contain anElement, answer the result of evaluating the argument, exceptionBlock."	^self indexOfAnyOf: aCollection startingAt: 1 ifAbsent: exceptionBlock! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:54'!(Integer) indexOfAnyOf: (Collection)aCollection startingAt: (Integer)start	"Answer the index of the first occurence of any element included in aCollection after start within the receiver.	If the receiver does not contain anElement, answer zero, which is an invalid index."	^self indexOfAnyOf: aCollection startingAt: start ifAbsent: [0]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:54'!(Integer) indexOfAnyOf: (Collection)aCollection startingAt: (Integer)start ifAbsent: (→Integer)exceptionBlock	"Answer the index of the first occurence of any element included in aCollection after start within the receiver.	If the receiver does not contain anElement, answer the result of evaluating the argument, exceptionBlock.	Note: it is user responsibility to provide aCollection that behaves relatevily fast when asked for includes: (like a Set)"	start to: self size do:		[:(Integer)index |		(aCollection includes: (self at: index)) ifTrue: [^ index]].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:57'!(Integer) indexOfSubCollection: (SequenceableCollection)aSubCollection startingAt: (Integer)anIndex 	"Answer the index of the receiver's first element, such that that element 	equals the first element of aSubCollection, and the next elements equal 	the rest of the elements of aSubCollection. Begin the search at element 	anIndex of the receiver. If no such match is found, answer 0."	^self		indexOfSubCollection: aSubCollection		startingAt: anIndex		ifAbsent: [0]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:56'!(Integer) indexOfSubCollection: (SequenceableCollection)sub startingAt: (Integer)start ifAbsent: (→Integer)exceptionBlock	"Answer the index of the receiver's first element, such that that element 	equals the first element of sub, and the next elements equal 	the rest of the elements of sub. Begin the search at element 	start of the receiver. If no such match is found, answer the result of 	evaluating argument, exceptionBlock."	| (Object)first (Integer)index |	sub isEmpty ifTrue: [^ exceptionBlock value].	first := sub first.	start to: self size - sub size + 1 do:		[:(Integer)startIndex |		(self at: startIndex) = first ifTrue:			[index := 1.			[(self at: startIndex+index-1) = (sub at: index)]				whileTrue:				[index = sub size ifTrue: [^startIndex].				index := index+1]]].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:34'!(Integer) indexOf: (Object)anElement	"Answer the index of the first occurence of anElement within the  	receiver. If the receiver does not contain anElement, answer 0."	^ self indexOf: anElement ifAbsent: [0]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:34'!(Integer) indexOf: (Object)anElement ifAbsent: (→Integer)exceptionBlock	"Answer the index of the first occurence of anElement within the  	receiver. If the receiver does not contain anElement, answer the 	result of evaluating the argument, exceptionBlock."	^ self indexOf: anElement startingAt: 1 ifAbsent: exceptionBlock! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:34'!(Integer) indexOf: (Object)anElement startingAt: (Integer)start ifAbsent: (→Integer)exceptionBlock	"Answer the index of the first occurence of anElement after start	within the receiver. If the receiver does not contain anElement, 	answer the 	result of evaluating the argument, exceptionBlock."	start to: self size do:		[:(Integer)index |		(self at: index) = anElement ifTrue: [^ index]].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:57'!(Integer) integerAt: (Integer)index	"Return the integer at the given index"	^self at: index! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:57'!(Integer) integerAt: (Integer)index put: (Integer)value	"Return the integer at the given index"	^self at: index put: value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:58'!(?) last	"Answer the last element of the receiver"	^ self at: self size! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:59'!(Integer) lastIndexOf: (Object)anElement	"Answer the index of the last occurence of anElement within the 	receiver. If the receiver does not contain anElement, answer 0."	^ self lastIndexOf: anElement startingAt: self size ifAbsent: [0]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:59'!(Integer) lastIndexOf: (Object)anElement ifAbsent: (→Integer)exceptionBlock	"Answer the index of the last occurence of anElement within the  	receiver. If the receiver does not contain anElement, answer the	result of evaluating the argument, exceptionBlock."	^self lastIndexOf: anElement startingAt: self size ifAbsent: exceptionBlock! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:58'!(Integer) lastIndexOf: (Object)anElement startingAt: (Integer)lastIndex ifAbsent: (→Integer)exceptionBlock	"Answer the index of the last occurence of anElement within the  	receiver. If the receiver does not contain anElement, answer the	result of evaluating the argument, exceptionBlock."	lastIndex to: 1 by: -1 do:		[:(Integer)index |		(self at: index) = anElement ifTrue: [^ index]].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 17:59'!(Self) last: (Integer)n	"Answer the last n elements of the receiver.  	Raise an error if there are not enough elements."	| size |	size := self size.	^ self copyFrom: size - n + 1 to: size! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 18:00'!(Integer) lastIndexOfAnyOf: (Collection)aCollection startingAt: (Integer)lastIndex ifAbsent: (→Integer)exceptionBlock	"Answer the index of the last occurence of anElement within the  	receiver. If the receiver does not contain anElement, answer the	result of evaluating the argument, exceptionBlock."	lastIndex to: 1 by: -1 do:		[:(Integer)index |		(aCollection includes: (self at: index)) ifTrue: [^ index]].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 18:00'!(?) middle	"Answer the middle element of the receiver."	^ self at: self size // 2 + 1! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 18:01'!(?) ninth	"Answer the ninth element of the receiver.	Raise an error if there are not enough elements."	^ self at: 9! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 18:01'!(Self) replaceAll: (Object)oldObject with: (Object)newObject 	"Replace all occurences of oldObject with newObject"	| (Integer)index |	index := self				indexOf: oldObject				startingAt: 1				ifAbsent: [0].	[index = 0]		whileFalse: 			[self at: index put: newObject.			index := self						indexOf: oldObject						startingAt: index + 1						ifAbsent: [0]]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 18:04'!(Self) replaceFrom: (Integer)start to: (Integer)stop with: (Object)replacement 	"This destructively replaces elements from start to stop in the receiver. 	Answer the receiver itself. Use copyReplaceFrom:to:with: for 	insertion/deletion which may alter the size of the result."	replacement size = (stop - start + 1)		ifFalse: [self error: 'Size of replacement doesnt match'].	^self replaceFrom: start to: stop with: replacement startingAt: 1! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 18:04'!(Self) replaceFrom: (Integer)start to: (Integer)stop with: (Object)replacement startingAt: (Integer)repStart 	"This destructively replaces elements from start to stop in the receiver 	starting at index, repStart, in the sequenceable collection, 	replacementCollection. Answer the receiver. No range checks are 	performed."	| (Integer)index (Integer)repOff |	repOff := repStart - start.	index := start - 1.	[(index := index + 1) <= stop]		whileTrue: [self at: index put: (replacement at: repOff + index)]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 18:04'!(?) second	"Answer the second element of the receiver.	Raise an error if there are not enough elements."	^ self at: 2! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 18:04'!(?) seventh	"Answer the seventh element of the receiver.	Raise an error if there are not enough elements."	^ self at: 7! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 18:04'!(?) sixth	"Answer the sixth element of the receiver.	Raise an error if there are not enough elements."	^ self at: 6! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 18:05'!(Self) swap: (Integer)oneIndex with: (Integer)anotherIndex 	"Move the element at oneIndex to anotherIndex, and vice-versa."	| (Object)element |	element := self at: oneIndex.	self at: oneIndex put: (self at: anotherIndex).	self at: anotherIndex put: element! !!SequenceableCollection methodsFor: 'accessing' stamp: 'EstebanAllende 2/28/2012 18:05'!(?) third	"Answer the third element of the receiver.	Raise an error if there are not enough elements."	^ self at: 3! !!SequenceableCollection methodsFor: 'comparing' stamp: 'EstebanAllende 2/28/2012 18:07'!(Boolean) hasEqualElements: (Object)otherCollection	"Answer whether the receiver's size is the same as otherCollection's	size, and each of the receiver's elements equal the corresponding 	element of otherCollection.	This should probably replace the current definition of #= ."	| (Integer)size |	(otherCollection isKindOf: SequenceableCollection) ifFalse: [^ false].	(size := self size) = (<SequenceableCollection>otherCollection) size ifFalse: [^ false].	1 to: size do:		[:(Integer)index |		(self at: index) = (otherCollection at: index) ifFalse: [^ false]].	^ true! !!SequenceableCollection methodsFor: 'comparing' stamp: 'EstebanAllende 2/28/2012 18:07'!(Integer) hash	| (Integer)hash |	hash := self species hash.	1 to: self size do: [:(Integer)i | hash := (hash + (self at: i) hash) hashMultiply].	^hash! !!SequenceableCollection methodsFor: 'comparing' stamp: 'EstebanAllende 2/28/2012 18:08'!(Boolean) = (Object)otherCollection 	"Answer true if the receiver is equivalent to the otherCollection.	First test for identity, then rule out different species and sizes of	collections. As a last resort, examine each element of the receiver	and the otherCollection."	self == otherCollection ifTrue: [^ true].	self species == otherCollection species ifFalse: [^ false].	^ self hasEqualElements: otherCollection! !!SequenceableCollection methodsFor: 'converting' stamp: 'EstebanAllende 2/28/2012 18:08'!(Array) asArray	"Answer an Array whose elements are the elements of the receiver."	^ Array withAll: self! !!SequenceableCollection methodsFor: 'converting' stamp: 'EstebanAllende 2/28/2012 18:08'!(ByteArray) asByteArray	"Answer a ByteArray whose elements are the elements of the receiver."	^ ByteArray withAll: self! !!SequenceableCollection methodsFor: 'converting' stamp: 'EstebanAllende 2/28/2012 18:09'!(FloatArray) asFloatArray	"Answer a FloatArray whose elements are the elements of the receiver, in 	the same order."	| (FloatArray)floatArray |	floatArray := FloatArray new: self size.	1 to: self size do:[:(Integer)i| floatArray at: i put: (self at: i) asFloat ].	^floatArray! !!SequenceableCollection methodsFor: 'converting' stamp: 'EstebanAllende 2/28/2012 18:09'!(IntegerArray) asIntegerArray	"Answer an IntegerArray whose elements are the elements of the receiver, in 	the same order."	| (IntegerArray)intArray |	intArray := IntegerArray new: self size.	1 to: self size do:[:(Integer)i| intArray at: i put: (self at: i)].	^intArray! !!SequenceableCollection methodsFor: 'converting' stamp: 'EstebanAllende 2/28/2012 18:09'!(String) asStringWithCr	"Convert to a string with returns between items.  Elements areusually strings.	 Useful for labels for PopUpMenus."	| (WriteStream)labelStream |	labelStream := (String new: 200) writeStream.	self do: [:(Object)each |		each isString			ifTrue: [labelStream nextPutAll: each; cr]			ifFalse: [each printOn: labelStream. labelStream cr]].	self size > 0 ifTrue: [labelStream skip: -1].	^ labelStream contents! !!SequenceableCollection methodsFor: 'converting' stamp: 'EstebanAllende 2/28/2012 18:10'!(WordArray) asWordArray	"Answer a WordArray whose elements are the elements of the receiver, in 	the same order."	| (WordArray)wordArray |	wordArray := WordArray new: self size.	1 to: self size do:[:(Integer)i| wordArray at: i put: (self at: i)].	^wordArray! !!SequenceableCollection methodsFor: 'converting' stamp: 'EstebanAllende 2/28/2012 18:12'!(Array) concatenation	|(Array)result (Integer)index|	result := Array new: (self inject: 0 into: [:(Integer)sum :(Collection)each | sum + each size]).	index := 0.	self do: [:(Collection)each | each do: [:(Object)item | result at: (index := index+1) put: item]].	^result! !!SequenceableCollection methodsFor: 'converting' stamp: 'EstebanAllende 2/28/2012 18:12'!(Boolean) isSequenceable	^ true! !!SequenceableCollection methodsFor: 'converting' stamp: 'EstebanAllende 2/28/2012 18:12'!(ReadStream) readStream	^ ReadStream on: self! !!SequenceableCollection methodsFor: 'converting' stamp: 'EstebanAllende 2/28/2012 18:13'!(Self) reverse	"Answer a copy of the receiver with element order reversed, as expected by ANSI."	^ self reversed! !!SequenceableCollection methodsFor: 'converting' stamp: 'EstebanAllende 2/28/2012 18:13'!(Self) reversed	"Answer a copy of the receiver with element order reversed."	"Example: 'frog' reversed"	| (Integer)n (Self)result (Integer)src |	n := self size.	result := (<Self class>self species) new: n.	src := n + 1.	1 to: n do: [:(Integer)i | result at: i put: (self at: (src := src - 1))].	^ result! !!SequenceableCollection methodsFor: 'converting' stamp: 'EstebanAllende 2/28/2012 18:13'!(WriteStream) writeStream	^ WriteStream on: self! !!SequenceableCollection methodsFor: 'converting' stamp: 'EstebanAllende 2/28/2012 20:26'!(Self) @ (SequenceableCollection)aCollection 	^ self with: aCollection collect: [:(?)a :(?)b | a @ b]! !!SequenceableCollection methodsFor: 'copying' stamp: 'EstebanAllende 2/28/2012 18:17'!(Self) copyAfterLast: (Object)anElement	"Answer a copy of the receiver from after the last occurence	of anElement up to the end. If no such element exists, answer 	an empty copy."	^ self allButFirst: (self lastIndexOf: anElement ifAbsent: [^ self copyEmpty])! !!SequenceableCollection methodsFor: 'copying' stamp: 'EstebanAllende 2/28/2012 18:17'!(Self) copyAfter: (Object)anElement	"Answer a copy of the receiver from after the first occurence	of anElement up to the end. If no such element exists, answer 	an empty copy."	^ self allButFirst: (self indexOf: anElement ifAbsent: [^ self copyEmpty])! !!SequenceableCollection methodsFor: 'copying' stamp: 'EstebanAllende 2/28/2012 18:17'!(Self) copyEmpty	^ (<Self class>self species) new: 0! !!SequenceableCollection methodsFor: 'copying' stamp: 'EstebanAllende 2/28/2012 18:19'!(Self) copyFrom: (Integer)start to: (Integer)stop 	"Answer a copy of a subset of the receiver, starting from element at 	index start until element at index stop."	| (Integer)newSize |	newSize := stop - start + 1.	^((<Self class>self species) new: newSize)		replaceFrom: 1		to: newSize		with: self		startingAt: start! !!SequenceableCollection methodsFor: 'copying' stamp: 'sma 6/1/2000 16:06'!copyLast: num	"Deprecated. Use #last:"	^ self last: num! !!SequenceableCollection methodsFor: 'copying'!copyReplaceAll: oldSubstring with: newSubstring 	"Default is not to do token matching.	See also String copyReplaceTokens:with:"	^ self copyReplaceAll: oldSubstring with: newSubstring asTokens: false	"'How now brown cow?' copyReplaceAll: 'ow' with: 'ello'"	"'File asFile Files File''s File' copyReplaceTokens: 'File' with: 'Pile'"! !!SequenceableCollection methodsFor: 'copying' stamp: 'EstebanAllende 2/28/2012 18:21'!(Self) copyReplaceFrom: (Integer)start to: (Integer)stop with: (Collection)replacementCollection 	"Answer a copy of the receiver satisfying the following conditions: If 	stop is less than start, then this is an insertion; stop should be exactly 	start-1, start = 1 means insert before the first character, start = size+1 	means append after last character. Otherwise, this is a replacement; start 	and stop have to be within the receiver's bounds."	| (Self)newSequenceableCollection (Integer)newSize (Integer)endReplacement |	newSize := self size - (stop - start + 1) + replacementCollection size.	endReplacement := start - 1 + replacementCollection size.	newSequenceableCollection := (<Self class>self species) new: newSize.	start > 1 ifTrue:[		newSequenceableCollection			replaceFrom: 1			to: start - 1			with: self			startingAt: 1].	start <= endReplacement ifTrue:[		newSequenceableCollection			replaceFrom: start			to: endReplacement			with: replacementCollection			startingAt: 1].	endReplacement < newSize ifTrue:[		newSequenceableCollection			replaceFrom: endReplacement + 1			to: newSize			with: self			startingAt: stop + 1].	^newSequenceableCollection! !!SequenceableCollection methodsFor: 'copying' stamp: 'EstebanAllende 2/28/2012 18:22'!(Self) copyUpThrough: (Object)anElement    "Answer all elements up to and including anObject. If there     is no such object, answer a copy of the receiver."	^self first: (self indexOf: anElement ifAbsent: [^ self copy])! !!SequenceableCollection methodsFor: 'copying' stamp: 'EstebanAllende 2/28/2012 18:22'!(Self) copyUpToLast: (Object)anElement	"Answer a copy of the receiver from index 1 to the last occurrence of 	anElement, not including anElement."	^ self first: (self lastIndexOf: anElement ifAbsent: [^ self copy]) - 1! !!SequenceableCollection methodsFor: 'copying' stamp: 'EstebanAllende 2/28/2012 18:23'!(Self) copyUpTo: (Object)anElement 	"Answer all elements up to but not including anObject. If there	is no such object, answer a copy of the receiver."	^ self first: (self indexOf: anElement ifAbsent: [^ self copy]) - 1! !!SequenceableCollection methodsFor: 'copying' stamp: 'EstebanAllende 2/28/2012 18:24'!(Self) copyWithFirst: (Object)newElement 	"Answer a copy of the receiver that is 1 bigger than the receiver with newElement as the first element."	| (Self)newIC |	newIC := (<Self class>self species) ofSize: self size + 1.	newIC 		replaceFrom: 2		to: self size + 1		with: self		startingAt: 1.	newIC at: 1 put: newElement.	^ newIC! !!SequenceableCollection methodsFor: 'copying' stamp: 'sma 6/1/2000 15:38'!copyWithoutFirst	"Deprecatd. Return a copy of the receiver which doesn't include	the first element."	^ self allButFirst! !!SequenceableCollection methodsFor: 'copying' stamp: 'EstebanAllende 2/28/2012 18:25'!(Self) copyWithoutIndex: (Integer)index	"Return a copy containing all elements except the index-th."	| (Self)copy |	copy := (<Self class>self species) ofSize: self size - 1.	copy replaceFrom: 1 to: index-1 with: self startingAt: 1.	copy replaceFrom: index to: copy size with: self startingAt: index+1.	^ copy! !!SequenceableCollection methodsFor: 'copying' stamp: 'EstebanAllende 2/28/2012 18:25'!(Self) copyWith: (Object)newElement 	"Answer a copy of the receiver that is 1 bigger than the receiver and has 	newElement at the last element."	| (Self)newIC |	newIC := (<Self class>self species) new: self size + 1.	newIC 		replaceFrom: 1		to: self size		with: self		startingAt: 1.	newIC at: newIC size put: newElement.	^newIC! !!SequenceableCollection methodsFor: 'copying' stamp: 'EstebanAllende 2/28/2012 18:26'!(Self) forceTo: (Integer)length paddingStartWith: (Object)elem 	"Force the length of the collection to length, padding  	the beginning of the result if necessary with elem.  	Note that this makes a copy."	| (Self)newCollection (Integer)padLen |	newCollection := (<Self class>self species) ofSize: length.	padLen := length - self size max: 0.	newCollection		from: 1		to: padLen		put: elem.	newCollection		replaceFrom: padLen + 1		to: ((padLen + self size) min: length)		with: self		startingAt:  1.	^ newCollection! !!SequenceableCollection methodsFor: 'copying' stamp: 'EstebanAllende 2/28/2012 18:33'!(Self) forceTo: (Integer)length paddingWith: (Object)elem	"Force the length of the collection to length, padding	if necessary with elem.  Note that this makes a copy."	| (Self)newCollection |	newCollection := (<Self>(<?>(<Self class{new:withAll: (Integer Object → Self)}>(<?>self species)) new: length withAll: elem)).	newCollection replaceFrom: 1 to: (self size min: length) with: self startingAt: 1.	^ newCollection! !!SequenceableCollection methodsFor: 'copying' stamp: 'EstebanAllende 2/28/2012 18:35'!(Self) grownBy: (Integer)length	"Answer a copy of receiver collection with size grown by length"	| (Self)newCollection |	newCollection := (<Self class>self species) ofSize: self size + length.	newCollection replaceFrom: 1 to: self size with: self startingAt: 1.	^ newCollection! !!SequenceableCollection methodsFor: 'copying' stamp: 'EstebanAllende 2/28/2012 18:36'!(Self) shuffled	^ self shuffledBy: Collection randomForPicking"Examples:	($A to: $Z) shuffled"! !!SequenceableCollection methodsFor: 'copying' stamp: 'EstebanAllende 2/28/2012 18:36'!(Self) , (Collection)otherCollection 	"Concatenate two Strings or Collections."		^ self copyReplaceFrom: self size + 1		  to: self size		  with: otherCollection"#(2 4 6 8) , #(who do we appreciate)((2989 storeStringBase: 16) copyFrom: 4 to: 6) , ' boy!!'"! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 18:37'!(Self) allButFirstDo: (?→Object)block	2 to: self size do:		[:(Integer)index | block value: (self at: index)]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 18:38'!(Self) allButLastDo: (?→Object)block	1 to: self size - 1 do:		[:(Integer)index | block value: (self at: index)]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 18:39'!(Self) allPairsDo: (? ? → Object)aBinaryBlock	"	Iterate over all the pairs of the receiver and apply the binaryBlock	to each pair. 		| res | 	res := OrderedCollection new. 	#(0 1 2 3) allPairsDo: [:first :second | res add: {first . second} ].	res 	 an OrderedCollection(#(0 0) #(0 1) #(0 2) #(0 3) #(1 0) #(1 1) #(1 2) #(1 3) #(2 0) #(2 1) #(2 2) #(2 3) #(3 0) #(3 1) #(3 2) #(3 3))	"		self do: [:(?)first| self do: [:(?)second| aBinaryBlock value: first value: second]]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 18:42'!(Self) asDigitsToPower: (Integer)anInteger do: (Array → Object)aBlock	"Repeatedly value aBlock with a single Array.  Adjust the collection	so that aBlock is presented all (self size raisedTo: anInteger) possible 	combinations of the receiver's elements taken as digits of an anInteger long number."	"(0 to: 1) asDigitsToPower: 4 do: [:each | Transcript cr; show: each printString]"	| (Array)aCollection |	aCollection := Array new: anInteger.	self asDigitsAt: 1 in: aCollection do: aBlock! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 7/13/97 09:44'!collectWithIndex: elementAndIndexBlock	"Use the new version with consistent naming"	^ self withIndexCollect: elementAndIndexBlock! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 18:43'!(Self) collect: (? → ?)aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| (Self)newCollection |	newCollection := (<Self class>self species) new: self size.	1 to: self size do:		[:(Integer)index |		newCollection at: index put: (aBlock value: (self at: index))].	^ newCollection! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 18:45'!(Self) collect: (?→?)aBlock from: (Integer)firstIndex to: (Integer)lastIndex	"Refer to the comment in Collection|collect:."	| (Integer)size (Self)result (Integer)j |	size := lastIndex - firstIndex + 1.	result := (<Self class>self species) new: size.	j := firstIndex.	1 to: size do: [:(Integer)i | result at: i put: (aBlock value: (self at: j)). j := j + 1].	^ result! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 18:57'!(Self) combinations: (Integer)kk atATimeDo: (Array→Object)aBlock	"Take the items in the receiver, kk at a time, and evaluate the block for each combination.  Hand in an array of elements of self as the block argument.  Each combination only occurs once, and order of the elements does not matter.  There are (self size take: kk) combinations."	" 'abcde' combinations: 3 atATimeDo: [:each | Transcript cr; show: each printString]"	| (Array)aCollection |	aCollection := Array new: kk.	self combinationsAt: 1 in: aCollection after: 0 do: aBlock! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 7/13/97 09:43'!doWithIndex: elementAndIndexBlock	"Use the new version with consistent naming"	^ self withIndexDo: elementAndIndexBlock! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 18:58'!(Self) do: (?→Object)aBlock 	"Refer to the comment in Collection|do:."	1 to: self size do:		[:(Integer)index | aBlock value: (self at: index)]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 18:58'!(Self) do: (?→Object)elementBlock separatedBy: (→Object)separatorBlock	"Evaluate the elementBlock for all elements in the receiver,	and evaluate the separatorBlock between."	1 to: self size do:		[:(Integer)index |		index = 1 ifFalse: [separatorBlock value].		elementBlock value: (self at: index)]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 18:59'!(Self) do: (?→Object)aBlock without: (Object)anItem	"Enumerate all elements in the receiver.	Execute aBlock for those elements that are not equal to the given item"	"Refer to the comment in Collection|do:."	1 to: self size do:		[:(Integer)index | anItem = (self at: index) ifFalse:[aBlock value: (self at: index)]]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:11'!(?) findBinary: (? → Integer) aBlock do: (?→?)actionBlock ifNone: (BlockClosure)exceptionBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If found, evaluate actionBlock with the found element as argument	If no matching element is found, evaluate exceptionBlock,	with the  'bounding' elements (or nil) as arguments.	Examples:		#(1 3 5 7 11 15 23)			findBinary: [ :arg | 11 - arg ]			do: [ :found | found print ]			ifNone: [ :a :b | ('between: ', {a. b} printString) print]		#(1 3 5 7 11 15 23)			findBinary: [ :arg | 12 - arg ]			do: [ :found | found print ]			ifNone: [ :a :b | ('between: ', {a. b} printString) print]		#(1 3 5 7 11 15 23)			findBinary: [ :arg | 0.5 - arg ]			do: [ :found | found print ]			ifNone: [ :a :b | ('between: ', {a. b} printString) print]		#(1 3 5 7 11 15 23)			findBinary: [ :arg | 25 - arg ]			do: [ :found | found print ]			ifNone: [ :a :b | ('between: ',{a. b} printString) print]	"	^ self		findBinaryIndex: aBlock		do: [ :(Integer)foundIndex |			actionBlock value: (self at: foundIndex) ]		ifNone: [ :(Integer)prevIndex :(Integer)nextIndex |			exceptionBlock				value:					(prevIndex > 0 ifTrue: [ self at: prevIndex ])				value:					(nextIndex <= self size ifTrue: [ self at: nextIndex ]) ].! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:07'!(Integer) findBinaryIndex: (?→Integer)aBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If no matching element is found, raise an error.	Examples:		#(1 3 5 7 11 15 23) findBinaryIndex: [ :arg | 11 - arg ]	"	^self findBinaryIndex: aBlock do: [ :(Integer)found | found ] ifNone: [ self errorNotFound: aBlock.^nil]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:02'!(?) findBinaryIndex: (? → Integer)aBlock do: (Integer→?)actionBlock ifNone: (BlockClosure)exceptionBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If found, evaluate actionBlock with the index as argument	If no matching element is found, evaluate exceptionBlock,	with the indexes of the  'bounding' elements as arguments.	Warning: Might give invalid indexes, see examples below	Examples:		#(1 3 5 7 11 15 23)			findBinaryIndex: [ :arg | 11 - arg ]			do: [ :found | found print ]			ifNone: [ :a :b | ('between: ', {a. b} printString) print]		#(1 3 5 7 11 15 23)			findBinaryIndex: [ :arg | 12 - arg ]			do: [ :found | found print ]			ifNone: [ :a :b | ('between: ', {a. b} printString) print]		#(1 3 5 7 11 15 23)			findBinaryIndex: [ :arg | 0.5 - arg ]			do: [ :found | found print ]			ifNone: [ :a :b | ('between: ', {a. b} printString) print]		#(1 3 5 7 11 15 23)			findBinaryIndex: [ :arg | 25 - arg ]			do: [ :found | found print ]			ifNone: [ :a :b | ('between: ',{a. b} printString) print]	"	| (Integer)index (Integer)low (Integer)high (Integer)test |	low := 1.	high := self size.	[		index := high + low // 2.		low > high ] whileFalse: [		test := aBlock value: (self at: index).		test = 0 			ifTrue: [ ^actionBlock value: index ]			ifFalse: [ test > 0				ifTrue: [ low := index + 1 ]				ifFalse: [ high := index - 1 ]]].	^exceptionBlock valueWithPossibleArgs: {high. low}! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:05'!(Integer) findBinaryIndex: (? → Integer)aBlock ifNone: (→Integer)exceptionBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If no matching element is found, evaluate exceptionBlock."	| (Integer)index (Integer)low (Integer)high (Integer)test |	low := 1.	high := self size.	[index := high + low // 2.	low > high] whileFalse:[		test := aBlock value: (self at: index).		test = 0 			ifTrue:[^index]			ifFalse:[test > 0				ifTrue: [low := index + 1]				ifFalse: [high := index - 1]]].	^exceptionBlock value! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:11'!(?) findBinary: (?→Integer)aBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If no matching element is found, raise an error.	Examples:		#(1 3 5 7 11 15 23) findBinary: [ :arg | 11 - arg ]	"	^self findBinary: aBlock do: [ :(?)found | found ] ifNone: [ self errorNotFound: aBlock.nil ]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:13'!(?) findBinary: (?→Integer)aBlock ifNone: (→?)exceptionBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If no matching element is found, evaluate exceptionBlock."	| (Integer)index (Integer)low (Integer)high (Integer)test (?)item |	low := 1.	high := self size.	[index := high + low // 2.	low > high] whileFalse:[		test := aBlock value: (item := self at: index).		test = 0 			ifTrue:[^item]			ifFalse:[test > 0				ifTrue: [low := index + 1]				ifFalse: [high := index - 1]]].	^exceptionBlock value! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:13'!(Integer) findFirst: (?→Boolean)aBlock	"Return the index of my first element for which aBlock evaluates as true."	| (Integer) index |	index := 0.	[(index := index + 1) <= self size] whileTrue:		[(aBlock value: (self at: index)) ifTrue: [^index]].	^ 0! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:14'!(Integer) findLast: (?→Boolean)aBlock	"Return the index of my last element for which aBlock evaluates as true."	| (Integer)index |	index := self size + 1.	[(index := index - 1) >= 1] whileTrue:		[(aBlock value: (self at: index)) ifTrue: [^index]].	^ 0! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:15'!(Self) from: (Integer)start to: (Integer)stop do: (?→Object)aBlock	"Evaluate aBlock for all elements between start and stop (inclusive)."	start to: stop do: [:(Integer)index | aBlock value: (self at: index)]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:18'!(Array)groupsOf: (Integer)n atATimeCollect: (BlockClosure)aBlock 	"Evaluate aBlock with my elements taken n at a time. Ignore any 	leftovers at the end. 	Allows use of a flattened  	array for things that naturally group into groups of n. 	If aBlock has a single argument, pass it an array of n items, 	otherwise, pass the items as separate arguments. 	See also pairsDo:"	| (Boolean)passArray |	passArray := aBlock numArgs = 1.	^(n		to: self size		by: n)		collect: [:(Integer)index | | (Array)args | 			args := (self copyFrom: index - n + 1 to: index) asArray.			passArray				ifTrue: [aBlock value: args]				ifFalse: [aBlock valueWithArguments: args]]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:19'!(Self) groupsOf: (Integer)n atATimeDo: (BlockClosure)aBlock 	"Evaluate aBlock with my elements taken n at a time. Ignore any leftovers at the end.	Allows use of a flattened 	array for things that naturally group into groups of n.	If aBlock has a single argument, pass it an array of n items,	otherwise, pass the items as separate arguments.	See also pairsDo:"	| (Boolean)passArray |	passArray := (aBlock numArgs = 1).	n		to: self size		by: n		do: [:(Integer)index | | (Array)args | 			args := (self copyFrom: index - n + 1 to: index) asArray.			passArray ifTrue: [ aBlock value: args ]				ifFalse: [ aBlock valueWithArguments: args ]].! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:19'!(Self) keysAndValuesDo: (Integer ? →Object)aBlock 	"Enumerate the receiver with all the keys (aka indices) and values."	1 to: self size do: [:(Integer)index | aBlock value: index value: (self at: index)]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:19'!(?) nextToLast	^self at: self size - 1! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:21'!(Self) overlappingPairsCollect: (? ? → Object)aBlock 	"Answer the result of evaluating aBlock with all of the overlapping pairs of my elements."	| (Self)retval |	retval := (<Self class>self species) ofSize: self size - 1.	1 to: self size - 1		do: [:(Integer)i | retval at: i put: (aBlock value: (self at: i) value: (self at: i + 1)) ].	^retval! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:21'!(Self) overlappingPairsDo: (? ? → Object)aBlock 	"Emit overlapping pairs of my elements into aBlock"	1 to: self size - 1		do: [:(Integer)i | aBlock value: (self at: i) value: (self at: i + 1)]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:22'!(Self) overlappingPairsWithIndexDo: (? ? Integer → Object)aBlock 	"Emit overlapping pairs of my elements into aBlock, along with an index."	1 to: self size - 1		do: [:(Integer)i | aBlock value: (self at: i) value: (self at: i + 1) value: i ]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:23'!(Self) paddedWith: (SequenceableCollection)otherCollection do: (? ? → Object)twoArgBlock 	"Evaluate twoArgBlock with corresponding elements from this collection and otherCollection.	Missing elements from either will be passed as nil."	1 to: (self size max: otherCollection size) do:		[:(Integer)index | twoArgBlock value: (self at: index ifAbsent: [])				value: (otherCollection at: index ifAbsent: [])]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:24'!(Array) pairsCollect: (? ? → ?)aBlock 	"Evaluate aBlock with my elements taken two at a time, and return an Array with the results"	^ (1 to: self size // 2) collect:		[:(Integer)index | aBlock value: (self at: 2 * index - 1) value: (self at: 2 * index)]"#(1 'fred' 2 'charlie' 3 'elmer') pairsCollect:	[:a :b | b, ' is number ', a printString]"! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:25'!(Self) pairsDo: (? ? → Object)aBlock 	"Evaluate aBlock with my elements taken two at a time.  If there's an odd number of items, ignore the last one.  Allows use of a flattened array for things that naturally group into pairs.  See also pairsCollect:"	1 to: self size // 2 do:		[:(Integer)index | aBlock value: (self at: 2 * index - 1) value: (self at: 2 * index)]"#(1 'fred' 2 'charlie' 3 'elmer') pairsDo:	[:a :b | Transcript cr; show: b, ' is number ', a printString]"! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:25'!(Self) permutationsDo: (Self → Object)aBlock	"Repeatly value aBlock with a single copy of the receiver. Reorder the copy	so that aBlock is presented all (self size factorial) possible permutations."	"(1 to: 4) permutationsDo: [:each | Transcript cr; show: each printString]"	self shallowCopy permutationsStartingAt: 1 do: aBlock! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:27'!(Number) polynomialEval: (Number)thisX	| (Number)sum (Number)valToPower |	"Treat myself as the coeficients of a polynomial in X.  Evaluate it with thisX.  First element is the constant and last is the coeficient for the highest power."	"  #(1 2 3) polynomialEval: 2   "   "is 3*X^2 + 2*X + 1 with X = 2"	sum := self first.	valToPower := thisX.	2 to: self size do: [:ind | 		sum := sum + ((self at: ind) * valToPower).		valToPower := valToPower * thisX].	^ sum! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:29'!(?) reduce: (BlockClosure)aBlock	"Fold the result of the receiver into aBlock. The argument aBlock must take two or more arguments. It applies the argument, binaryBlock cumulatively to the elements of the receiver. For sequenceable collections the elements will be used in order, for unordered collections the order is unspecified."		"#(1 2 3) reduce: [ :a :b | a + b ]		--> 1 + 2 + 3 = 6	#(1 2 3 4 5) reduce: [ :a :b :c | a + b + c ]		--> 1 + 2 + 3 + 4 + 5 = 15"			^ self reduceLeft: aBlock! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:31'!(?) reduceLeft: (BlockClosure)aBlock	"Fold the result of the receiver from left to right into aBlock. The argument aBlock must take two or more arguments."	"#(1 2 3) reduceLeft: [ :a :b | a - b ].		--> ((1 - 2) - 3) = -4	#(1 + 3 - 5) reduceLeft: [ :a :op :b | a perform: op with: b ].		--> ((1 + 3) - 5) = -1"	| (Array)arguments |	self emptyCheck.	arguments := Array new: aBlock argumentCount.	(arguments size = 0 or: [ (self size + 1) \\ (arguments size - 1) > 0 ])		ifTrue: [ self error: 'Collection size and block argument count do not match.' ].	arguments at: 1 put: self first.	2 to: self size by: arguments size - 1 do: [ :(Integer)index |		arguments			replaceFrom: 2 to: arguments size with: self startingAt: index;			at: 1 put: (aBlock valueWithArguments: arguments) ].	^ arguments first! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:32'!(?) reduceRight: (BlockClosure)aBlock	"Fold the result of the receiver from right to left into aBlock. The argument aBlock must take two or more arguments."	"#(1 2 3) reduceRight: [ :a :b | a - b ].		--> (1 - (2 - 3)) = 2	#(1 + 3 - 5) reduceRight: [ :a :op :b | a perform: op with: b ].		--> (1 + (3 - 5)) = -1"	| (Array)arguments |	self emptyCheck.	arguments := Array new: aBlock argumentCount.	(arguments size = 0 or: [ (self size + 1) \\ (arguments size - 1) > 0 ])		ifTrue: [ self error: 'Collection size and block argument count do not match.' ].	arguments at: arguments size put: self last.	self size - arguments size + 1 to: 1 by: 1 - arguments size do: [ :(Integer)index |		arguments			replaceFrom: 1 to: aBlock argumentCount - 1 with: self startingAt: index;			at: arguments size put: (aBlock valueWithArguments: arguments) ].	^ arguments last! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:32'!(Self) replace: (?→?)aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into self."	1 to: self size do: [ :(Integer)index |		self at: index put: (aBlock value: (self at: index)) ]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:33'!(Self) reverseDo: (?→Object)aBlock	"Evaluate aBlock with each of the receiver's elements as the argument, 	starting with the last element and taking each in sequence up to the 	first. For SequenceableCollections, this is the reverse of the enumeration 	for do:."	self size to: 1 by: -1 do: [:(Integer)index | aBlock value: (self at: index)]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:33'!(Self) reverseWith: (SequenceableCollection)aSequenceableCollection do: (? ? → Object)aBlock 	"Evaluate aBlock with each of the receiver's elements, in reverse order, 	along with the  	corresponding element, also in reverse order, from 	aSequencableCollection. "	self size ~= aSequenceableCollection size ifTrue: [^ self errorNoMatch].	self size		to: 1		by: -1		do: [:(Integer)index | aBlock value: (self at: index)				value: (aSequenceableCollection at: index)]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:35'!(Self) select: (?→Boolean)aBlock 	"Refer to the comment in Collection|select:."	| (WriteStream)aStream |	aStream := ((<Self class>self species) new: self size) writeStream.	1 to: self size do: 		[:(Integer)index |		(aBlock value: (self at: index))			ifTrue: [aStream nextPut: (self at: index)]].	^ aStream contents! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:36'!(Self) withIndexCollect: (? Integer → ?)elementAndIndexBlock 	"Just like with:collect: except that the iteration index supplies the second argument to the block."	| (Self)result |	result := (<Self class>self species) new: self size.	1 to: self size do:		[:(Integer)index | result at: index put:		(elementAndIndexBlock			value: (self at: index)			value: index)].	^ result! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:36'!(Self) withIndexDo: (? Integer → ?)elementAndIndexBlock 	"Just like with:do: except that the iteration index supplies the second argument to the block."	1 to: self size do:		[:(Integer)index |		elementAndIndexBlock			value: (self at: index)			value: index]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:38'!(Self) with: (SequenceableCollection)otherCollection collect: (? ? → ?)twoArgBlock 	"Collect and return the result of evaluating twoArgBlock with corresponding elements from this collection and otherCollection."	| (Self)result |	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].	result := (<Self class>self species) new: self size.	1 to: self size do:		[:(Integer)index | result at: index put:		(twoArgBlock			value: (self at: index)			value: (otherCollection at: index))].	^ result! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'EstebanAllende 2/28/2012 19:38'!(Self) with: (SequenceableCollection)otherCollection do: (? ? → Object)twoArgBlock 	"Evaluate twoArgBlock with corresponding elements from this collection and otherCollection."	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].	1 to: self size do:		[:(Integer)index |		twoArgBlock value: (self at: index)				value: (otherCollection at: index)]! !!SequenceableCollection methodsFor: 'removing' stamp: 'EstebanAllende 2/28/2012 19:39'!(Self) remove: (Object)oldObject ifAbsent: (→Object)anExceptionBlock 	"SequencableCollections cannot implement removing."	self shouldNotImplement! !!SequenceableCollection methodsFor: 'shuffling' stamp: 'EstebanAllende 2/28/2012 19:41'!(Self) shuffle	^self shuffleBy: Collection randomForPicking! !!SequenceableCollection methodsFor: 'shuffling' stamp: 'EstebanAllende 2/28/2012 19:40'!(Self) shuffleBy: (Random)aRandom	"Durstenfeld's version of the Fisher-Yates shuffle"	self size to: 2 by: -1 do: [ :(Integer)i | 		self swap: i with: (aRandom nextInt: i) ]! !!SequenceableCollection methodsFor: 'shuffling' stamp: 'EstebanAllende 2/28/2012 19:40'!(Self) shuffledBy: (Random)aRandom	"Durstenfeld's version of the Fisher-Yates shuffle"	^self copy shuffleBy: aRandom! !!SequenceableCollection methodsFor: 'sorting' stamp: 'EstebanAllende 2/28/2012 19:42'!(Boolean) isSorted	"Return true if the receiver is sorted by the given criterion.	Optimization for isSortedBy: [:a :b | a <= b]."	| (?)lastElm (?)elm |	self isEmpty ifTrue: [^ true].	lastElm := self first.	2 to: self size do: 		[:(Integer)index | 		elm := self at: index.		lastElm <= elm ifFalse: [^ false].		lastElm := elm].	^ true! !!SequenceableCollection methodsFor: 'sorting' stamp: 'EstebanAllende 2/28/2012 19:43'!(Boolean) isSortedBy: (? ? → Boolean) aBlock	"Return true if the receiver is sorted by the given criterion."	| (?)lastElm (?)elm |	self isEmpty ifTrue: [^ true].	lastElm := self first.	2 to: self size do: 		[:(Integer)index | 		elm := self at: index.		(aBlock value: lastElm value: elm) ifFalse: [^ false].		lastElm := elm].	^ true! !!SequenceableCollection methodsFor: 'sorting' stamp: 'EstebanAllende 2/28/2012 19:44'!(Self) mergeFirst: (Integer)first middle: (Integer)middle last: (Integer)last into: (SequenceableCollection)dst by: (? ? → Boolean)aBlock	"Private. Merge the sorted ranges [first..middle] and [middle+1..last] 	of the receiver into the range [first..last] of dst."	| (Integer)i1 (Integer)i2 (Integer)val1 (Integer)val2 (Integer)out |	i1 := first.	i2 := middle + 1.	val1 := self at: i1.	val2 := self at: i2.	out := first - 1.  "will be pre-incremented"	"select 'lower' half of the elements based on comparator"	[(i1 <= middle) and: [i2 <= last]] whileTrue:		[(aBlock value: val1 value: val2)			ifTrue: [dst at: (out := out + 1) put: val1.					val1 := self at: (i1 := i1 + 1)]			ifFalse: [dst at: (out := out + 1) put: val2.					i2 := i2 + 1.					i2 <= last ifTrue: [val2 := self at: i2]]].	"copy the remaining elements"	i1 <= middle		ifTrue: [dst replaceFrom: out + 1 to: last with: self startingAt: i1]		ifFalse: [dst replaceFrom: out + 1 to: last with: self startingAt: i2]! !!SequenceableCollection methodsFor: 'sorting' stamp: 'EstebanAllende 2/28/2012 19:45'!(Self) mergeSortFrom: (Integer)startIndex to: (Integer)stopIndex by: (? ?→ Boolean)aBlock	"Sort the given range of indices using the mergesort algorithm.	Mergesort is a worst-case O(N log N) sorting algorithm that usually	does only half as many comparisons as heapsort or quicksort."	"Details: recursively split the range to be sorted into two halves,	mergesort each half, then merge the two halves together. An extra 	copy of the data is used as temporary storage and successive merge 	phases copy data back and forth between the receiver and this copy.	The recursion is set up so that the final merge is performed into the	receiver, resulting in the receiver being completely sorted."	self size <= 1 ifTrue: [^ self].  "nothing to do"	startIndex = stopIndex ifTrue: [^ self].	[startIndex >= 1 and: [startIndex < stopIndex]] assert. "bad start index"	[stopIndex <= self size] assert. "bad stop index"	self		mergeSortFrom: startIndex		to: stopIndex 		src: self copy 		dst: self 		by: aBlock! !!SequenceableCollection methodsFor: 'sorting' stamp: 'EstebanAllende 2/28/2012 19:46'!(Self) mergeSortFrom: (Integer)first to: (Integer)last src: (SequenceableCollection)src dst: (SequenceableCollection)dst by: (? ? → Boolean)aBlock	"Private. Split the range to be sorted in half, sort each half, and 	merge the two half-ranges into dst."	| (Integer)middle |	first = last ifTrue: [^ self].	middle := (first + last) // 2.	self mergeSortFrom: first to: middle src: dst dst: src by: aBlock.	self mergeSortFrom: middle + 1 to: last src: dst dst: src by: aBlock.	src mergeFirst: first middle: middle last: last into: dst by: aBlock! !!SequenceableCollection methodsFor: 'sorting' stamp: 'EstebanAllende 2/28/2012 19:47'!(Self) sort	"Sort this collection into ascending order using the '<=' operator."	self sort: [:a :b | a <= b]! !!SequenceableCollection methodsFor: 'sorting' stamp: 'EstebanAllende 2/28/2012 19:47'!(Self) sort: (? ? → Boolean)aSortBlock 	"Sort this array using aSortBlock. The block should take two arguments	and return true if the first element should preceed the second one."	self		mergeSortFrom: 1		to: self size		by: aSortBlock! !!SequenceableCollection methodsFor: 'splitjoin' stamp: 'EstebanAllende 2/28/2012 19:51'!(?) appendTo: (SequenceableCollection{addLast: (? → ?)})aCollection	"double dispatch for join:"	^ (<{addAllLast: (? → ?)}>(<?>aCollection)) addAllLast: self! !!SequenceableCollection methodsFor: 'splitjoin' stamp: 'EstebanAllende 2/28/2012 20:00'!(Self) join: (Collection)aCollection	"NB: this implementation only works for Array, since WriteStreams only work for Arrays and Strings. (!!)	Overridden in OrderedCollection and SortedCollection."	^ self class		streamContents: [:(Stream)stream | aCollection				do: [:(Object)each | each joinTo: stream]				separatedBy: [stream nextPutAll: self]]! !!SequenceableCollection methodsFor: 'splitjoin' stamp: 'EstebanAllende 2/28/2012 20:00'!(Self) joinTo: (Stream)stream	"double dispatch for join:"	^ stream nextPutAll: self! !!SequenceableCollection methodsFor: 'splitjoin' stamp: 'EstebanAllende 2/28/2012 20:01'!(?) joinUsing: (?)joiner	"joiner - character, string or sequenceable collection	returns collection of the same collection class as 'joiner', or a String"	^ joiner join: self! !!SequenceableCollection methodsFor: 'splitjoin' stamp: 'EstebanAllende 2/28/2012 20:01'!(?) joinUsing: (?)joiner last: (?)last 	"#(1 2 3 4) joinUsing: ', ' last: 'and'. => '1, 2, 3 and 4"	^ last join: (Array				with: (joiner join: self allButLast)				with: self last)! !!SequenceableCollection methodsFor: 'splitjoin' stamp: 'EstebanAllende 2/28/2012 20:02'!(OrderedCollection) split: (SequenceableCollection)aSequencableCollection	| (OrderedCollection)result (Integer)position (Integer)oldPosition |	result := OrderedCollection new.	position := 1.	oldPosition := position.	position := aSequencableCollection indexOfSubCollection: self startingAt: position.	[ position > 0 ] whileTrue: [		result add: (aSequencableCollection copyFrom: oldPosition to: position - 1).		position := position + self size.		oldPosition := position.		position := aSequencableCollection indexOfSubCollection: self startingAt: position.	].	result add: (aSequencableCollection copyFrom: oldPosition to: aSequencableCollection size).	^ result! !!SequenceableCollection methodsFor: 'splitjoin' stamp: 'EstebanAllende 2/28/2012 20:02'!(?) splitOn: (?)splitter 	"splitter - can be a subsequence, a Block or a Regex (String receiver only).	Any other object used as a splitter is treated as an Array containing that object."	^ splitter split: self! !!SequenceableCollection methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 20:03'!(Boolean) beginsWith: (SequenceableCollection)aSequenceableCollection	"Answer true if the receiver starts with the argument collection"	(aSequenceableCollection isEmpty or: [self size < aSequenceableCollection size]) ifTrue: [^false].	aSequenceableCollection withIndexDo: [:(?)each :(Integer)index | (self at: index) ~= each ifTrue: [^false]].	^true! !!SequenceableCollection methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 20:04'!(Boolean) beginsWithAnyOf: (Collection)aCollection	"Return true if the receiver starts with any of the elements in aCollection."	^aCollection anySatisfy:[:(SequenceableCollection)prefix| self beginsWith: prefix]! !!SequenceableCollection methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 20:05'!(Boolean) endsWith: (SequenceableCollection)aSequenceableCollection	"Answer true if the receiver ends with the argument collection"		| (Integer)start |	(aSequenceableCollection isEmpty or: [self size < aSequenceableCollection size]) ifTrue: [^false].	start := self size - aSequenceableCollection size.	aSequenceableCollection withIndexDo: [:(?)each :(Integer)index | (self at: start + index) ~= each ifTrue: [^false]].	^true! !!SequenceableCollection methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 20:05'!(Boolean) endsWithAnyOf: (Collection)aCollection	"Return true if the receiver ends with any of the elements in aCollection."	^aCollection anySatisfy:[:(SequenceableCollection)suffix| self endsWith: suffix]! !!SequenceableCollection methodsFor: 'testing' stamp: 'EstebanAllende 2/28/2012 20:06'!(Boolean) includes: (Object)anObject	"Answer whether anObject is one of the receiver's elements."	^ (self indexOf: anObject) ~= 0! !!SequenceableCollection methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 18:48'!(Self) asDigitsAt: (Integer)anInteger in: (Collection)aCollection do: (?→Object)aBlock	"(0 to: 1) asDigitsToPower: 4 do: [:each | Transcript cr; show: each printString]"	self do: 		[:(Object)each | 		aCollection at: anInteger put: each.		anInteger = aCollection size 			ifTrue: [aBlock value: aCollection]			ifFalse: [self asDigitsAt: anInteger + 1 in: aCollection do: aBlock]].! !!SequenceableCollection methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 18:48'!(?) checkedAt: (Integer)index	index > self size ifTrue: [self error: 'not enough elements'].	^ self at: index! !!SequenceableCollection methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 18:50'!(Self) combinationsAt: (Integer)jj in: (Collection)aCollection after: (Integer)nn do: (?→Object)aBlock	"Choose k of N items and put in aCollection.  jj-1 already chosen.  Indexes of items are in numerical order, to avoid the same combo being used twice.  In this slot, we are allowed to use items in self indexed by nn+1 to self size.  nn is the index used for position jj-1."	"(1 to: 6) combinationsSize: 3 do: [:each | Transcript cr; show: each printString]"nn+1 to: self size do: [:index | 		aCollection at: jj put: (self at: index).		jj = aCollection size 			ifTrue: [aBlock value: aCollection]			ifFalse: [self combinationsAt: jj + 1 in: aCollection after: index do: aBlock]].! !!SequenceableCollection methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 18:53'!(Self) copyReplaceAll: (SequenceableCollection)oldSubstring with: (SequenceableCollection)newSubstring asTokens: (Boolean)ifTokens	"Answer a copy of the receiver in which all occurrences of	oldSubstring have been replaced by newSubstring.	ifTokens (valid for Strings only) specifies that the characters	surrounding the recplacement must not be alphanumeric.		Bruce Simth,  must be incremented by 1 and not 	newSubstring if ifTokens is true.  See example below. "	| (Self)aString (Integer)startSearch (Integer)currentIndex (Integer)endIndex |	(ifTokens and: [(self isString) not])		ifTrue: [(self isKindOf: Text) ifFalse: [			self error: 'Token replacement only valid for Strings']].	aString := self.	startSearch := 1.	[(currentIndex := aString indexOfSubCollection: oldSubstring startingAt: startSearch)			 > 0]		whileTrue: 		[endIndex := currentIndex + oldSubstring size - 1.		(ifTokens not			or: [(currentIndex = 1					or: [(aString at: currentIndex-1) isAlphaNumeric not])				and: [endIndex = aString size					or: [(aString at: endIndex+1) isAlphaNumeric not]]])			ifTrue: [aString := aString					copyReplaceFrom: currentIndex					to: endIndex					with: newSubstring.				startSearch := currentIndex + newSubstring size]			ifFalse: [				ifTokens 					ifTrue: [startSearch := currentIndex + 1]					ifFalse: [startSearch := currentIndex + newSubstring size]]].	^ aString"Test case:	'test te string' copyReplaceAll: 'te' with: 'longone' asTokens: true   "! !!SequenceableCollection methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 18:53'!(Self) errorFirstObject: anObject	self error: 'specified object is first object'! !!SequenceableCollection methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 18:53'!(Self) errorLastObject: anObject	self error: 'specified object is last object'! !!SequenceableCollection methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 18:53'!(Self) errorOutOfBounds	SubscriptOutOfBounds signal! !!SequenceableCollection methodsFor: 'private' stamp: 'EstebanAllende 2/28/2012 18:56'!(Self) permutationsStartingAt: (Integer)anInteger do: (Self → Object)aBlock	"#(1 2 3 4) permutationsDo: [:each | Transcript cr; show: each printString]"	anInteger > self size ifTrue: [^self].	anInteger = self size ifTrue: [aBlock value: self. ^self].	anInteger to: self size do:		[:i | self swap: anInteger with: i.		self permutationsStartingAt: anInteger + 1 do: aBlock.		self swap: anInteger with: i]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SequenceableCollection class	uses: TSortable classTrait	instanceVariableNames: ''!!SequenceableCollection class methodsFor: 'instance creation' stamp: 'EstebanAllende 2/28/2012 20:20'!(Self instance) ofSize: (Integer)n	"Create a new collection of size n with nil as its elements.	This method exists because OrderedCollection new: n creates an	empty collection,  not one of size n."	^ self new: n! !!SequenceableCollection class methodsFor: 'stream creation' stamp: 'EstebanAllende 2/28/2012 20:21'!(Self instance) new: (Integer)newSize streamContents: (WriteStream → Object)blockWithArg	| (WriteStream)stream |	stream := WriteStream on: (self new: newSize).	blockWithArg value: stream.	stream position = newSize		ifTrue: [ ^stream originalContents ]		ifFalse: [ ^stream contents ]! !!SequenceableCollection class methodsFor: 'stream creation' stamp: 'EstebanAllende 2/28/2012 20:21'!(Self instance) streamContents: (WriteStream → Object)blockWithArg	^self new: 100 streamContents: blockWithArg! !!SequenceableCollection class methodsFor: 'stream creation' stamp: 'EstebanAllende 2/28/2012 20:23'!(Self instance) streamContents: (LimitedWriteStream → Object)blockWithArg limitedTo: (Integer)sizeLimit	| (LimitedWriteStream)stream |	stream := LimitedWriteStream on: (self new: ((<Integer>100) min: sizeLimit)).	stream setLimit: sizeLimit limitBlock: [^ stream contents].	blockWithArg value: stream.	^ stream contents"String streamContents: [:s | 1000 timesRepeat: [s nextPutAll: 'Junk']] limitedTo: 25 'JunkJunkJunkJunkJunkJunkJ'"! !