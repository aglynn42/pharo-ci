Object subclass: #TypedClassDescription	instanceVariableNames: 'untypedClass typedSuperclass instVars methods'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!TypedClassDescription methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/3/2012 19:19'!defineInstVar: varName withType: aType	instVars addLast: (varName -> aType)	! !!TypedClassDescription methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/3/2012 19:19'!defineMethod: methodName as: aMethodDeclaration	methods at: methodName put: aMethodDeclaration! !!TypedClassDescription methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/4/2012 11:17'!getMethodDeclaration: selector	^methods at: selector ifAbsent: [		(untypedClass includesSelector: selector) ifTrue: [ |md argSize|			md := MethodDeclaration new.			md ownerClassDescription: untypedClass.			argSize := (untypedClass lookupSelector: selector) numArgs.			md type: (LambdaType new params: (Array new: argSize withAll: Type defaultType) asOrderedCollection; return: Type defaultType; yourself).			methods at: selector put: md.			^md		].		^typedSuperclass ifNotNil: [^typedSuperclass getMethodDeclaration: selector].	].! !!TypedClassDescription methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/3/2012 18:24'!initialize	untypedClass := nil.	instVars := OrderedCollection new.	methods := Dictionary new.	! !!TypedClassDescription methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 15:53'!partialReset	self refreshUntypedClass.	instVars reset.	! !!TypedClassDescription methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 16:02'!refreshSuperclassUsing: aDict	^self	! !!TypedClassDescription methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 15:51'!refreshUntypedClass	^self subclassResponsibility	! !!TypedClassDescription methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/3/2012 19:21'!reset	instVars reset.	methods removeAll.	! !!TypedClassDescription methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/4/2012 11:05'!typeOfInstVar: varName 	|assoc|	(untypedClass hasInstVarNamed: varName) ifFalse: [		typedSuperclass ifNotNil: [^typedSuperclass typeOfInstVar: varName].	].	assoc := instVars detect: [:each| each key = varName] ifNone: [^Type defaultType].	^assoc value.	! !!TypedClassDescription methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/3/2012 19:19'!typedSuperclass	^typedSuperclass	! !!TypedClassDescription methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/3/2012 19:19'!typedSuperclass: aTypedClass	typedSuperclass := aTypedClass	! !!TypedClassDescription methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/4/2012 11:16'!untypedClass	^untypedClass	! !!TypedClassDescription methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/4/2012 11:15'!untypedClass: aClassDescription	untypedClass := aClassDescription	! !Object subclass: #Type	uses: TTyped	instanceVariableNames: '(OrderedCollection)classParametrics (Symbol)usedAlias'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!Type methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/7/2011 11:19'!(Boolean) isDyn	^false! !!Type methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/7/2011 11:19'!(Boolean) isLambda	^false! !!Type methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/7/2011 11:19'!(Boolean) isNominal	^false! !!Type methodsFor: '*typesystem-types'!(Boolean) isParametric	^false! !!Type methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/7/2011 11:20'!(Boolean) isSelf	^false! !!Type methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/7/2011 11:20'!(Boolean) isStructural	^false! !!Type methodsFor: '*typesystem-types'!(Boolean) isUnion	^false! !!Type methodsFor: 'accessing' stamp: 'EstebanAllende 3/20/2012 18:30'!(OrderedCollection) classParametrics	^ classParametrics! !!Type methodsFor: 'accessing' stamp: 'EstebanAllende 3/20/2012 18:46'!(Self) classParametrics: (OrderedCollection)anObject		classParametrics := anObject! !!Type methodsFor: 'accessing' stamp: 'EstebanAllende 4/5/2012 11:24'!(Symbol) usedAlias	^ usedAlias! !!Type methodsFor: 'accessing' stamp: 'EstebanAllende 4/5/2012 11:25'!(Self) usedAlias: (Symbol)anObject	usedAlias := anObject! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 7/2/2012 17:51'!(Boolean) = another"   This method declaration is useful when cast are inserted into code. Until then, it useless.       |(Type)a (Type)b ({simplify (→Type)})c|       another ifNil: [^false].       a:= self simplify.       [c := another] on: CastError do: [:ex | ^ false].       b:= c simplify.       ^[a typeEquality: b] on: CastError do: [:ex | false]"|(Type)a (Type)b|another ifNil: [^false].a:= self simplify.b:= another simplify.(a class = b class) ifFalse: [^false].^a typeEquality: b! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 7/2/2012 12:26'!(Self) addAlias: (Symbol) alias	TypeDictionary uniqueInstance name: alias aliasTo: self.! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/23/2011 12:02'!(Type) annotateSelfWith: (ClassDescription)aClass inMethod: (MethodSignature) aMethodSignature withKind: (Symbol) aSymbol	^self subclassResponsibility! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/28/2012 15:16'!(NominalType) asNominalType	^nil! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/5/2012 11:26'!(String) asString	usedAlias notNil ifTrue: [^usedAlias asString].	(classParametrics isNil or: [classParametrics size = 0])		ifTrue: [^self baseString]		ifFalse: [^self baseString,'<',(', ' join: classParametrics),'>']! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 1/26/2012 14:43'!(StructuralType) asStructuralType	^nil! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 11:04'!(Self) asType	^self! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 11:04'!(String) baseString		^self subclassResponsibility! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/6/2011 23:08'!(Type) classType	^self subclassResponsibility! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 7/2/2012 23:56'!(Self) generateDictionaryWith: (Type) aType andDictionary: (Dictionary) dict	"aType isSubtype."	|(Collection)aTypeClassParametrics (Integer)min|	aType isUnion ifTrue: [		(<UnionType>aType) union do: [:(Type)each|self generateDictionaryWith: each andDictionary: dict].		^self.	].	classParametrics ifNil:[^self].	aTypeClassParametrics := aType classParametrics ifNil: [#()].	min := classParametrics size min: aTypeClassParametrics size.	1 to: classParametrics size do: [ :(Integer)i| |(Type)each|		each := classParametrics at: i.		(i <= min) 			ifTrue: [ each generateDictionaryWith: (aTypeClassParametrics at: i) andDictionary: dict]			ifFalse: [each generateDictionaryWith: DynType implicitInstance andDictionary: dict].	].	"(classParametrics size = aType classParametrics size) ifFalse: [ResolveError signal: 'Incorrect numbers of generics between (', self asString,') and (',aType asString,')'].	classParametrics with: aType classParametrics do: [:(Type)each :(Type)another| each generateDictionaryWith: another andDictionary: dict]."	^self! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/6/2011 23:08'!(Integer) hash	^self subclassResponsibility! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/6/2011 23:08'!(Type) instanceType	^self subclassResponsibility! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/20/2012 13:36'!(Boolean) isCasteableTo: (Type) aType	^Type is: self casteableTo: aType! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/6/2011 23:08'!(Boolean) isConsistentSubtypeOf: (Type) aType	^Type is: self consistentSubtypeOf: aType! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/6/2011 23:08'!(Boolean) isSubtypeOf: (Type) aType	^Type is: self subtypeOf: aType! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/6/2011 23:08'!(Boolean) isType	^true! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/22/2011 12:06'!(Boolean) isValid	^self validate size = 0! !!Type methodsFor: 'as yet unclassified'!(Type) lowestCommonAncestorBetween: (Type) another	^self subclassResponsibility.! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/6/2011 23:08'!(Type) pureType	^self	! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/6/2011 23:08'!(Type) replaceSelfWith: (Type) aType	^self subclassResponsibility.! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 12:04'!(Type) resolveLocalWith: (TypeEnvironment) env	^self resolveWith: env ifNotFoundStore: [:(Symbol)name| 		|(ParametricType) pRes|		pRes := ParametricType new.		pRes kind: #local.		pRes name: name.		pRes	].	! !!Type methodsFor: 'as yet unclassified'!(OrderedCollection) resolveParametricInGenericsWithReceiver: (Type)receiver andDictionary: (Dictionary) dict	^classParametrics ifNotNil: [		classParametrics collect: [:(Type)each| each resolveParametricWithReceiver: receiver andDictionary: dict].	] ifNil: [nil].! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/26/2012 16:30'!(Type) resolveParametricWith: (Type)aType andReceiver: (Type) receiver	|(Dictionary) dict|	dict := Dictionary new.	self generateDictionaryWith: aType andDictionary: dict.	^self resolveParametricWithReceiver: receiver andDictionary: dict.	! !!Type methodsFor: 'as yet unclassified'!(Type) resolveParametricWithReceiver: (Type)receiver andDictionary: (Dictionary) dict	^self subclassResponsibility.! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/19/2012 18:04'!(Type) resolveWith: (TypeEnvironment) env	^self resolveWith: env ifNotFoundStore: [:(Symbol)name| 		|(ParametricType) pRes|		pRes := ParametricType new.		env local ifTrue: [pRes kind: #local] ifFalse: [pRes kind: #method].		pRes name: name.		pRes	].! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 11:44'!(Type) resolveWith: (TypeEnvironment) env ifNotFoundStore: (Symbol → Type) aBlock	classParametrics ifNotNil: [		classParametrics := classParametrics collect: [:each| each resolveWith: env ifNotFoundStore: aBlock].	].	^self.	! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/6/2011 23:08'!(Type) simplify	^self! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/13/2011 18:47'!(Boolean) typeEquality: (Self) another	<access: #protected>	^self subclassResponsibility.! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:49'!(Type) typeOfSelector: (Symbol)selector fromClass: (ClassDescription) requestor	^self subclassResponsibility.! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/22/2011 12:14'!(OrderedCollection) validate	^#() asOrderedCollection! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Type class	uses: TTyped classTrait	instanceVariableNames: ''!!Type class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 02:12'!compilerContext	^OTCSupport defaultCompilerContext! !!Type class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 7/2/2012 12:33'!(Type) defaultType	^TypeConfiguration uniqueInstance defaultType! !!Type class methodsFor: 'as yet unclassified'!(Boolean) is: (Type) type1 casteableTo: (Type) type2	^TypeConfiguration uniqueInstance castingRules is: type1 relatedWith: type2.! !!Type class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 1/30/2012 14:00'!(Boolean) is: (Type) type1 consistentSubtypeOf: (Type) type2	^TypeConfiguration uniqueInstance consistentSubtypeRules is: type1 relatedWith: type2.! !!Type class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 1/30/2012 14:00'!(Boolean) is: (Type) type1 subtypeOf: (Type) type2	^TypeConfiguration uniqueInstance subtypeRules is: type1 relatedWith: type2.! !TypedClassDescription subclass: #TypedMetaclass	instanceVariableNames: 'typedNonMetaClass'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!TypedMetaclass methodsFor: 'accessing' stamp: 'EstebanAllende 4/3/2012 18:29'!typedNonMetaClass	^ typedNonMetaClass! !!TypedMetaclass methodsFor: 'accessing' stamp: 'EstebanAllende 4/3/2012 18:29'!typedNonMetaClass: anObject	typedNonMetaClass := anObject! !!TypedMetaclass methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 16:11'!refreshUntypedClass	untypedClass := (Smalltalk at: (untypedClass theNonMetaClass name)) theMetaClass.! !Object subclass: #MethodDeclaration	uses: TTyped	instanceVariableNames: '(ClassDescription)ownerClassDescription (Type)type (Symbol)access'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:00'!(Symbol) access	^ access! !!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:00'!(Self) access: (Symbol) anObject	access := anObject! !!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:00'!(Self) initialize	access := #public! !!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 4/4/2012 11:28'!(ClassDescription) ownerClassDescription	^ ownerClassDescription! !!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 4/4/2012 11:28'!(Self) ownerClassDescription: (ClassDescription)anObject	ownerClassDescription := anObject! !!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:01'!(Type) type	^ type! !!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:01'!(Self) type: (Type) anObject	type := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MethodDeclaration class	uses: TTyped classTrait	instanceVariableNames: ''!Object subclass: #TypeDictionary	uses: TTyped	instanceVariableNames: '(Dictionary)classes (Dictionary)aliases'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!TypeDictionary methodsFor: 'as yet unclassified'!(Dictionary) aliasDictionary	^aliases! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/3/2012 19:10'!(Type) class:(Class) aClass atClassVar: (Symbol)varName	|(TypedClass) tc|	tc := self getTypedClass: aClass.	^tc typeOfClassVar: varName.! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/4/2012 15:23'!(Self) class:(Class) aClass atClassVar: (Symbol)varName putType: (Type) aType	|(TypedClass) tc|	tc := self getTypedClass: aClass.	tc defineClassVar: varName withType: aType! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/4/2012 11:02'!(Type) class:(ClassDescription) aClass atInstVar: (Symbol)varName	|(TypedClassDescription) tc|	tc := self getTypedClassDescription: aClass.	^tc typeOfInstVar: varName.! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/4/2012 15:25'!(Self) class: (ClassDescription)aClass atInstVar: (Symbol)varName putType: (Type)aType	|(TypedClassDescription) tc|	tc := self getTypedClassDescription: aClass.	tc defineInstVar: varName withType: aType.! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/4/2012 17:19'!(Type) class: (ClassDescription)aClass atSelector: (Symbol)aSelector fromClass: (ClassDescription)requestor	|(TypedClassDescription)tcd (MethodDeclaration)md (Symbol) access (Class)nonMetaDefClass (Class)nonMetaReqClass|	tcd := self getTypedClassDescription: aClass.	md := tcd getMethodDeclaration: aSelector.	md ifNil: [^nil].	access := md access.	nonMetaDefClass := Smalltalk at: (md ownerClassDescription theNonMetaClass name).	nonMetaReqClass := requestor theNonMetaClass.	(access = #public) ifTrue: [^md type].	(((access = #private) | (access = #protected)) and: [nonMetaDefClass = nonMetaReqClass]) ifTrue: [^md type].	((access = #protected) and: [nonMetaReqClass inheritsFrom: nonMetaDefClass ]) ifTrue: [^md type].	^nil.			! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/3/2012 19:06'!(Self) class: (ClassDescription)aClass atSelector: (Symbol)aSelector putMethodDeclaration: (MethodDeclaration)md	|(TypedClassDescription) tcd|	tcd := self getTypedClassDescription: aClass.	md ownerClassDescription: aClass.	tcd defineMethod: aSelector as: md. ! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/4/2012 15:22'!(Self) class:(Class) aClass defineParamVar: (Symbol)varName withUpperBound: (Type) aType andPosition: (Integer) pos	|(TypedClass) tc|	tc := self getTypedClass: aClass.	tc defineParamVar: varName withUpperBound: aType andPosition: pos.! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/4/2012 15:37'!(Self) class:(Class) aClass defineParamVarWithLocalParametricType: (ParametricType) aType andPosition: (Integer) pos	|(TypedClass) tc|	tc := self getTypedClass: aClass.	tc defineParamVarWithLocalParametric: aType andPosition: pos.! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/4/2012 11:24'!(Self) emptyVariableDictionaryInClassDescription: (ClassDescription) aClass	|(TypedClassDescription) tc|	tc := self getTypedClassDescription: aClass.	tc partialReset.! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/28/2012 00:23'!(OrderedCollection) getClassOldParametricList: (Class) aClass	|(TypedClass) tc|	tc := self getTypedClass: aClass.	^tc classOldParamList.! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 10:18'!(OrderedCollection) getClassParametricList: (Class) aClass	|(TypedClass) tc|	tc := self getTypedClass: aClass.	^tc classParamList.! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/28/2012 00:25'!(TypeEnvironment) getClassTypeEnvironmentFor: (Class) aClass	|(TypeEnvironment)res (OrderedCollection)list  (OrderedCollection)list2 (TypeEnvironment)parentEnv|	parentEnv := aClass					ifNil: [^TypeEnvironment globalEnvironment]					ifNotNil: [self getClassTypeEnvironmentFor: (<Class>aClass superclass)].	list := self getClassParametricList: aClass.	list2 := self getClassOldParametricList: aClass.	((list size + list2 size) = 0) ifTrue: [^parentEnv].	res := TypeEnvironment new.	res parent: parentEnv.	list do: [:(ParametricType)each|res define: each name as: each].	list2 do: [:(ParametricType)each|res define: each name as: each].	^res.! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/28/2012 00:23'!(OrderedCollection) getLocalOldParametricList: (Class) aClass	|(TypedClass) tc|	tc := self getTypedClass: aClass.	^tc localOldParamList.! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/4/2012 16:30'!(OrderedCollection) getLocalParametricList: (Class) aClass	|(TypedClass) tc|	tc := self getTypedClass: aClass.	^tc localParamList.! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/28/2012 00:29'!(TypeEnvironment) getLocalTypeEnvironmentFor: (Class) aClass	|(TypeEnvironment)res (OrderedCollection)list (OrderedCollection)list2 (TypeEnvironment)parentEnv|	parentEnv := aClass					ifNil: [^TypeEnvironment globalEnvironment]					ifNotNil: [self getLocalTypeEnvironmentFor: (<Class>aClass superclass)].	list := self getLocalParametricList: aClass.	list2 := self getLocalOldParametricList: aClass.	((list size + list2 size) = 0) ifTrue: [^parentEnv].	res := TypeEnvironment new.	res parent: parentEnv.	list do: [:(ParametricType)each|res define: each name as: each].	list2 do: [:(ParametricType)each|res define: each name as: each].	^res.! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/30/2012 17:30'!(TypedClass) getTypedClass: (Class) aClass	"aClass isMeta ifTrue: [self halt]."	^classes at: aClass name ifAbsent: [ |(TypedClass)res (TypedMetaclass)metaRes|		res := TypedClass new.		metaRes := TypedMetaclass new.		res typedMetaclass: metaRes.		metaRes typedNonMetaClass: res.		res untypedClass: aClass.		metaRes untypedClass: aClass class.		classes at: aClass name put: res.		aClass superclass ifNotNil: [			|typedSuperclass|			typedSuperclass := self getTypedClass: (<Class>aClass superclass).			res typedSuperclass: (typedSuperclass).			metaRes typedSuperclass: (typedSuperclass typedMetaclass).		] ifNil: [metaRes typedSuperclass: (self getTypedClass: Class)].		res	]! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/3/2012 19:01'!(TypedClassDescription) getTypedClassDescription: (ClassDescription) aClassDescription	|(TypedClass) tc|	tc := self getTypedClass: aClassDescription theNonMetaClass.	^aClassDescription isMeta ifTrue: [tc typedMetaclass] ifFalse: [tc].	! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 10:38'!(Self) initialize	classes := IdentityDictionary new.	aliases := IdentityDictionary new.! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/5/2012 11:27'!(Self) name: (Symbol) name aliasTo: (Type) toAlias	|(Type) toAlias|	toAlias := toAlias copy.	toAlias usedAlias: name.	aliases at: name put: toAlias	 ! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 16:06'!(Self) resetTypedClassDescription: (ClassDescription)aClassDescription	|(TypedClassDescription) tc|	tc := self getTypedClassDescription: aClassDescription.	tc partialReset.	tc refreshSuperclassUsing: self.	"aClassDescription superclass ifNotNil: [tc typedSuperclass: (self getTypedClassDescription: aClassDescription superclass)]."! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TypeDictionary class	uses: TTyped classTrait	instanceVariableNames: 'uniqueInstance'!!TypeDictionary class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/12/2011 17:50'!(Self) initialize	OTCSupport bootstrapping ifFalse: [^self].	uniqueInstance := self new.! !!TypeDictionary class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 10:59'!(TypeDictionary) uniqueInstance	^uniqueInstance! !Object subclass: #TypeEnvironment	instanceVariableNames: 'dictionary parent local'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!TypeEnvironment methodsFor: 'accessing' stamp: 'EstebanAllende 3/21/2012 23:08'!define: aSymbol as: aType	((dictionary == Smalltalk) or: [dictionary == TypeDictionary uniqueInstance aliasDictionary]) ifTrue: [Error signal: 'Cannot make definitions in global type environments'].	dictionary at: aSymbol put: aType.	! !!TypeEnvironment methodsFor: 'accessing' stamp: 'EstebanAllende 6/19/2012 18:02'!dictionary	^ dictionary! !!TypeEnvironment methodsFor: 'accessing'!dictionary: anObject	dictionary := anObject! !!TypeEnvironment methodsFor: 'accessing' stamp: 'EstebanAllende 6/19/2012 18:02'!local	^ local! !!TypeEnvironment methodsFor: 'accessing' stamp: 'EstebanAllende 6/19/2012 18:02'!local: anObject	local := anObject! !!TypeEnvironment methodsFor: 'accessing' stamp: 'EstebanAllende 6/28/2012 01:59'!lookupType: aSymbol		|res|	res := dictionary at: aSymbol ifAbsent: [ ^parent ifNil:[nil] ifNotNil: [parent lookupType: aSymbol]].	^res asType.	! !!TypeEnvironment methodsFor: 'accessing'!parent	^ parent! !!TypeEnvironment methodsFor: 'accessing'!parent: anObject	parent := anObject! !!TypeEnvironment methodsFor: 'initialize-release' stamp: 'EstebanAllende 6/19/2012 18:01'!initialize	dictionary := Dictionary new.	parent := nil.	local := false.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TypeEnvironment class	instanceVariableNames: 'globalEnvironment nominalEnvironment'!!TypeEnvironment class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 10:25'!globalEnvironment	globalEnvironment ifNil: [		globalEnvironment := self basicNew.		globalEnvironment parent: self nominalEnvironment.		globalEnvironment dictionary: TypeDictionary uniqueInstance aliasDictionary.	].	^globalEnvironment.! !!TypeEnvironment class methodsFor: 'as yet unclassified'!initialize	globalEnvironment := nil.	nominalEnvironment := nil.! !!TypeEnvironment class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 10:25'!nominalEnvironment	nominalEnvironment ifNil: [		nominalEnvironment := self basicNew.		nominalEnvironment parent: nil.		nominalEnvironment dictionary: Smalltalk.	].	^nominalEnvironment.! !TypedClassDescription subclass: #TypedClass	instanceVariableNames: 'classVars paramVars oldParamVars typedMetaclass oldpvar'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!TypedClass methodsFor: 'accessing' stamp: 'EstebanAllende 6/27/2012 15:59'!oldpvar	^ oldpvar! !!TypedClass methodsFor: 'accessing' stamp: 'EstebanAllende 6/27/2012 15:59'!oldpvar: anObject	oldpvar := anObject! !!TypedClass methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/28/2012 00:28'!classOldParamList	oldParamVars ifNil: [oldParamVars := OrderedCollection new].	^oldParamVars collect: [:each| each value second].	! !!TypedClass methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/4/2012 15:11'!classParamList	^paramVars collect: [:each| each value second].	! !!TypedClass methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/3/2012 14:06'!defineClassVar: varName withType: aType	classVars addLast: (varName -> aType)	! !!TypedClass methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/28/2012 00:19'!defineOldParamVar: varName withLocalType: localType andClassType: classType	oldParamVars addLast: (varName -> {localType. classType}).	! !!TypedClass methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/3/2012 14:13'!defineParamVar: varName withUpperBound: aType andPosition: anInteger	|localParametric classParametric|	localParametric := ParametricType new.	localParametric name: varName.	localParametric kind: #local.	localParametric upperBound: aType.		classParametric := ParametricType new.	classParametric name: varName.	classParametric kind: #class.	classParametric pos: anInteger.	classParametric upperBound: aType.		paramVars addLast: (varName -> {localParametric. classParametric}).	! !!TypedClass methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/4/2012 15:36'!defineParamVarWithLocalParametric: aParametricType andPosition: anInteger	|classParametric|	classParametric := ParametricType new.	classParametric name: aParametricType name.	classParametric kind: #class.	classParametric pos: anInteger.	classParametric upperBound: aParametricType upperBound.		paramVars addLast: (aParametricType name -> {aParametricType. classParametric}).	! !!TypedClass methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/28/2012 00:16'!initialize	super initialize.	classVars := OrderedCollection new.	paramVars := SortedCollection sortBlock: [:x :y| x value second pos < y value second pos].	oldParamVars := OrderedCollection new.	! !!TypedClass methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/28/2012 00:28'!localOldParamList	oldParamVars ifNil: [oldParamVars := OrderedCollection new].	^oldParamVars collect: [:each| each value first].	! !!TypedClass methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/4/2012 15:10'!localParamList	^paramVars collect: [:each| each value first].	! !!TypedClass methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/4/2012 15:59'!partialReset	super partialReset.	classVars reset.	paramVars reset.	! !!TypedClass methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 16:19'!refreshSuperclassUsing: aDict	self untypedClass superclass ifNotNil: [		self typedSuperclass: (aDict getTypedClass: self untypedClass superclass).	].	self typedMetaclass typedSuperclass: (aDict getTypedClassDescription: self typedMetaclass untypedClass superclass).	! !!TypedClass methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 15:52'!refreshUntypedClass	untypedClass := Smalltalk at: (untypedClass name).	! !!TypedClass methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/3/2012 18:27'!reset	super reset.	classVars reset.	paramVars reset.	! !!TypedClass methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/4/2012 15:52'!sortParamVars	paramVars sort: [:x :y| x value second pos < y value second pos]	! !!TypedClass methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/4/2012 11:07'!typeOfClassVar: varName 	|assoc|	(untypedClass hasClassVarNamed: varName) ifFalse: [		typedSuperclass ifNotNil: [^typedSuperclass typeOfClassVar: varName].	].	assoc := classVars detect: [:each| each key = varName] ifNone: [^Type defaultType].	^assoc value.! !!TypedClass methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/3/2012 18:30'!typedMetaclass	^typedMetaclass! !!TypedClass methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/3/2012 18:30'!typedMetaclass: anObject	typedMetaclass := anObject! !Object subclass: #TypeConfiguration	uses: TTyped	instanceVariableNames: '(Type)defaultType (RelationRules)subtypeRules (RelationRules)consistentSubtypeRules (RelationRules)castingRules (Boolean)disable'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!TypeConfiguration methodsFor: 'accessing'!castingRules	^ castingRules! !!TypeConfiguration methodsFor: 'accessing'!castingRules: anObject	castingRules := anObject! !!TypeConfiguration methodsFor: 'accessing' stamp: 'EstebanAllende 1/30/2012 13:58'!consistentSubtypeRules	^ consistentSubtypeRules! !!TypeConfiguration methodsFor: 'accessing' stamp: 'EstebanAllende 1/30/2012 13:58'!consistentSubtypeRules: anObject	consistentSubtypeRules := anObject! !!TypeConfiguration methodsFor: 'accessing' stamp: 'EstebanAllende 1/30/2012 13:50'!(Type)defaultType	^defaultType! !!TypeConfiguration methodsFor: 'accessing' stamp: 'EstebanAllende 1/30/2012 13:53'!(Self)defaultType: (Type)aType	defaultType := aType.	PPTypedSmalltalkParser dynType: aType.! !!TypeConfiguration methodsFor: 'accessing' stamp: 'EstebanAllende 6/28/2012 11:51'!disable	^ disable! !!TypeConfiguration methodsFor: 'accessing' stamp: 'EstebanAllende 6/28/2012 12:23'!disable: anObject	disable := anObject.	self bootstrap: anObject.! !!TypeConfiguration methodsFor: 'accessing' stamp: 'EstebanAllende 1/30/2012 13:58'!subtypeRules	^ subtypeRules! !!TypeConfiguration methodsFor: 'accessing' stamp: 'EstebanAllende 1/30/2012 13:58'!subtypeRules: anObject	subtypeRules := anObject! !!TypeConfiguration methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 02:17'!(Boolean) bootstrap	^OTCSupport bootstrapping.! !!TypeConfiguration methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 02:17'!(Self) bootstrap: (Boolean)aBoolean	OTCSupport bootstrapping: aBoolean.	"Must reinitialize everything after changing bootstrap variable"	PPTypedSmalltalkGrammar initialize.	PPTypedSmalltalkParser initialize.	! !!TypeConfiguration methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/28/2012 11:56'!(Self) initialize	disable := false.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TypeConfiguration class	uses: TTyped classTrait	instanceVariableNames: 'uniqueInstance'!!TypeConfiguration class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/12/2011 17:50'!(Self) initialize	OTCSupport bootstrapping ifFalse: [^self].	uniqueInstance := self new.! !!TypeConfiguration class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 02:18'!(TypeConfiguration) uniqueInstance	^uniqueInstance! !TypeDictionary initialize!TypeEnvironment initialize!TypeConfiguration initialize!