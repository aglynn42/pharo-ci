Object subclass: #TypeConfiguration	uses: TTyped	instanceVariableNames: '(Type)defaultType (RelationRules)subtypeRules (RelationRules)consistentSubtypeRules (RelationRules)castingRules (RelationRules)runtimeCastingRules (Boolean)disable (Boolean)enableAnalisis (Boolean)enableCasts (Boolean)enableInstrumentation'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!TypeConfiguration commentStamp: 'EstebanAllende 10/1/2012 00:44' prior: 0!A TypeConfiguration allows to change all configuration variables of Gradualtalk. !!TypeConfiguration methodsFor: 'configurations' stamp: 'EstebanAllende 12/7/2011 02:17'!(Boolean) bootstrap	^OTCSupport bootstrapping.! !!TypeConfiguration methodsFor: 'configurations' stamp: 'EstebanAllende 12/7/2011 02:17'!(Self) bootstrap: (Boolean)aBoolean	OTCSupport bootstrapping: aBoolean.	"Must reinitialize everything after changing bootstrap variable"	PPTypedSmalltalkGrammar initialize.	PPTypedSmalltalkParser initialize.	! !!TypeConfiguration methodsFor: 'configurations' stamp: 'EstebanAllende 7/13/2012 14:52'!(RelationRules) castingRules	^ castingRules! !!TypeConfiguration methodsFor: 'configurations' stamp: 'EstebanAllende 7/13/2012 14:53'!(Self) castingRules: (RelationRules)anObject	castingRules := anObject! !!TypeConfiguration methodsFor: 'configurations' stamp: 'EstebanAllende 7/13/2012 14:53'!(RelationRules) consistentSubtypeRules	^ consistentSubtypeRules! !!TypeConfiguration methodsFor: 'configurations' stamp: 'EstebanAllende 7/13/2012 14:53'!(Self) consistentSubtypeRules: (RelationRules)anObject	consistentSubtypeRules := anObject! !!TypeConfiguration methodsFor: 'configurations' stamp: 'EstebanAllende 1/30/2012 13:50'!(Type)defaultType	^defaultType! !!TypeConfiguration methodsFor: 'configurations' stamp: 'EstebanAllende 1/30/2012 13:53'!(Self)defaultType: (Type)aType	defaultType := aType.	PPTypedSmalltalkParser dynType: aType.! !!TypeConfiguration methodsFor: 'configurations' stamp: 'EstebanAllende 7/13/2012 14:53'!(Boolean) disable	^ disable! !!TypeConfiguration methodsFor: 'configurations' stamp: 'EstebanAllende 7/13/2012 14:53'!(Self) disable: (Boolean)anObject	disable := anObject.	self bootstrap: anObject.! !!TypeConfiguration methodsFor: 'configurations' stamp: 'EstebanAllende 7/13/2012 14:53'!(Boolean) enableAnalisis	^ enableAnalisis! !!TypeConfiguration methodsFor: 'configurations' stamp: 'EstebanAllende 7/13/2012 14:54'!(Self) enableAnalisis: (Boolean)anObject	enableAnalisis := anObject! !!TypeConfiguration methodsFor: 'configurations' stamp: 'EstebanAllende 7/16/2012 10:15'!(Boolean) enableCasts	^ enableCasts! !!TypeConfiguration methodsFor: 'configurations' stamp: 'EstebanAllende 7/16/2012 10:16'!(Self) enableCasts: (Boolean)anObject	enableCasts := anObject! !!TypeConfiguration methodsFor: 'configurations' stamp: 'EstebanAllende 7/16/2012 10:21'!(Boolean) enableInstrumentation	^ enableInstrumentation! !!TypeConfiguration methodsFor: 'configurations' stamp: 'EstebanAllende 7/16/2012 10:21'!(Self) enableInstrumentation: (Boolean)anObject	enableInstrumentation := anObject! !!TypeConfiguration methodsFor: 'configurations' stamp: 'EstebanAllende 9/13/2012 13:54'!(RelationRules) runtimeCastingRules	^ runtimeCastingRules! !!TypeConfiguration methodsFor: 'configurations' stamp: 'EstebanAllende 9/13/2012 13:54'!(Self) runtimeCastingRules: (RelationRules)anObject	runtimeCastingRules := anObject! !!TypeConfiguration methodsFor: 'configurations' stamp: 'EstebanAllende 7/13/2012 14:54'!(RelationRules) subtypeRules	^ subtypeRules! !!TypeConfiguration methodsFor: 'configurations' stamp: 'EstebanAllende 7/13/2012 14:54'!(Self) subtypeRules: (RelationRules)anObject	subtypeRules := anObject! !!TypeConfiguration methodsFor: 'initialize-release' stamp: 'EstebanAllende 7/16/2012 10:21'!(Self) initialize	disable := false.	enableAnalisis := false.	enableCasts := false.	enableInstrumentation := false.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TypeConfiguration class	uses: TTyped classTrait	instanceVariableNames: '(TypeConfiguration)uniqueInstance'!!TypeConfiguration class methodsFor: 'class initialization' stamp: 'EstebanAllende 12/12/2011 17:50'!(Self) initialize	OTCSupport bootstrapping ifFalse: [^self].	uniqueInstance := self new.! !!TypeConfiguration class methodsFor: 'instance access' stamp: 'EstebanAllende 7/13/2012 14:56'!(TypeConfiguration) uniqueInstance	^uniqueInstance! !Object subclass: #TypeSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!TypeSystem commentStamp: 'EstebanAllende 10/1/2012 01:08' prior: 0!TypeSystem is the class that contains all utilities method usable by users of the type system which does not change the configuration of it.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TypeSystem class	instanceVariableNames: ''!!TypeSystem class methodsFor: 'instance creation' stamp: 'EstebanAllende 7/3/2012 11:59'!new	^self error: 'TypeSystem is not an instanceable class'! !!TypeSystem class methodsFor: 'statistics' stamp: 'EstebanAllende 7/7/2012 13:44'!generateLegend	|res|	res := Dictionary new.	res at: #ImplicitDyn put: 'Dyn type implicitly introduced by the typesystem'.	res at: #ExplicitDyn put: 'Dyn types introduced by the programmer'.	res at: #DynType put: 'Dyn types (Explicit + Implicit)'.	res at: #LambdaType put: 'Closures'.	res at: #NominalType put: 'Nominal types'.	res at: #ParametricType put: 'Parametric variable usage (Ex. E)'.	res at: #GenericUsage put: 'Generic instantiation (Ex: Array<Integer>)'.	res at: #SelfType put: 'Self type (Self instance + Self class + Self) '.	res at: #SelfInstance put: 'Self instance'.	res at: #SelfClass put: 'Self class'.	res at: #Self put: 'Literal Self'.	res at: #StructuralType put: 'StructuralType (Only structural + Mixed structural)'.	res at: #OnlyStructural put: 'Pure structural'.	res at: #MixedStructural put: 'Nominal type + structural'.	res at: #UnionType put: 'Union type'.		res at: #ExplicitCasts put: 'Explicit cast put by the programmer'.	res at: #Total put: 'Typed'.	res at: #total put: 'Typed and untyped'.	^res.! !!TypeSystem class methodsFor: 'statistics' stamp: 'EstebanAllende 7/7/2012 13:46'!statisticsForCategory: aCategory	"Recollect statistical information obtained with the analysis of the type declarations"		"Legend (Valid except for the subelement #Total and #total) 		#legend  Description for 'X' on each subelement	#classes    Number of classes that uses X	#metaclasses      Number of metaclasses that uses X	#classMethods       Number of methods in classes that uses X	#metaclassMethods         Number of methods in metaclasses that uses X	#methods        Number of methods that uses X	#classTotal         Number of type annotations in classes that are X	#metaclassTotal     Number of type annotations in metaclasses that are X	#all        Number of type annotations in total that are X		Legend for #Total and #total subelements	#legend       Description of Y for #Total or #total	#classes     Number of classes that are Y	#metaclass     Number of metaclasses that are Y	#classMethods      Number of methods in a class that are Y	#metaclassMethods     Number of methods in a metaclass that are Y	#methods    Number of methods that are Y	#classTotal     Number of type annotation declared (explicit or implicitly) in a class (For #Total)	#metaclassTotal     Number of type annotation declared (explicit or implicitly) in a metaclass (For #Total)	#all     Number of type annotation declared (explicit or implicitly) (For #Total)			"	|classesToCheck res classDict metaDict|	res := Dictionary new.	classDict := Dictionary new.	metaDict := Dictionary new.	res at: #classes put: classDict.	res at: #metaclasses put: metaDict.	res at: #legend put: self generateLegend.	classesToCheck := SystemNavigation default allClassesInPackageNamed: aCategory.	classesToCheck do: [:each|		|stats|		stats := self statisticsForClass: each.		stats associationsDo: [:dict| |resDict|			resDict := res at: dict key ifAbsentPut: Dictionary new.			dict value associationsDo: [:entry|				|val|				val := resDict at: entry key ifAbsent: [0].				resDict at: entry key put: val + entry value.			]		].		(stats at: #classMethods) associationsDo: [:entry|			|val|			val := classDict at: entry key ifAbsent: [0].			(entry value > 0 ) ifTrue: [val := val +1].			classDict at: entry key put: val.		].		(stats at: #metaclassMethods) associationsDo: [:entry|			|val|			val := metaDict at: entry key ifAbsent: [0].			(entry value > 0 ) ifTrue: [val := val +1].			metaDict at: entry key put: val.		].	].	^res! !!TypeSystem class methodsFor: 'statistics' stamp: 'EstebanAllende 7/3/2012 17:27'!statisticsForClass: aClass	^TypeDictionary uniqueInstance collectStatisticsFor: aClass! !!TypeSystem class methodsFor: 'type checking' stamp: 'EstebanAllende 7/16/2012 02:35'!typeCheckCategory: aCategory	|classesToCheck|	classesToCheck := SystemNavigation default allClassesInPackageNamed: aCategory.	2 timesRepeat: [classesToCheck do: [:each|		"[each compileAll] on: Exception do: [:ex| ex messageText: each name,': ',ex messageText. ex signal]"		each compileAll.	]]! !Object subclass: #TypeEnvironment	instanceVariableNames: 'dictionary parent local'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!TypeEnvironment commentStamp: 'EstebanAllende 10/1/2012 01:04' prior: 0!A TypeEnvironment is an environment used to lookup types using a name in the system.!!TypeEnvironment methodsFor: 'accessing' stamp: 'EstebanAllende 6/19/2012 18:02'!dictionary	^ dictionary! !!TypeEnvironment methodsFor: 'accessing'!dictionary: anObject	dictionary := anObject! !!TypeEnvironment methodsFor: 'accessing' stamp: 'EstebanAllende 6/19/2012 18:02'!local	^ local! !!TypeEnvironment methodsFor: 'accessing' stamp: 'EstebanAllende 6/19/2012 18:02'!local: anObject	local := anObject! !!TypeEnvironment methodsFor: 'accessing'!parent	^ parent! !!TypeEnvironment methodsFor: 'accessing'!parent: anObject	parent := anObject! !!TypeEnvironment methodsFor: 'environment' stamp: 'EstebanAllende 3/21/2012 23:08'!define: aSymbol as: aType	((dictionary == Smalltalk) or: [dictionary == TypeDictionary uniqueInstance aliasDictionary]) ifTrue: [Error signal: 'Cannot make definitions in global type environments'].	dictionary at: aSymbol put: aType.	! !!TypeEnvironment methodsFor: 'environment' stamp: 'EstebanAllende 6/28/2012 01:59'!lookupType: aSymbol		|res|	res := dictionary at: aSymbol ifAbsent: [ ^parent ifNil:[nil] ifNotNil: [parent lookupType: aSymbol]].	^res asType.	! !!TypeEnvironment methodsFor: 'initialize-release' stamp: 'EstebanAllende 6/19/2012 18:01'!initialize	dictionary := Dictionary new.	parent := nil.	local := false.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TypeEnvironment class	instanceVariableNames: 'globalEnvironment nominalEnvironment'!!TypeEnvironment class methodsFor: 'class initialization'!initialize	globalEnvironment := nil.	nominalEnvironment := nil.! !!TypeEnvironment class methodsFor: 'special environments' stamp: 'EstebanAllende 4/9/2012 10:25'!globalEnvironment	globalEnvironment ifNil: [		globalEnvironment := self basicNew.		globalEnvironment parent: self nominalEnvironment.		globalEnvironment dictionary: TypeDictionary uniqueInstance aliasDictionary.	].	^globalEnvironment.! !!TypeEnvironment class methodsFor: 'special environments' stamp: 'EstebanAllende 4/9/2012 10:25'!nominalEnvironment	nominalEnvironment ifNil: [		nominalEnvironment := self basicNew.		nominalEnvironment parent: nil.		nominalEnvironment dictionary: Smalltalk.	].	^nominalEnvironment.! !Object subclass: #TypedClassDescription	instanceVariableNames: 'untypedClass typedSuperclass instVars methods'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!TypedClassDescription commentStamp: 'EstebanAllende 10/1/2012 01:17' prior: 0!A TypedClassDescription is the abstract structure that store the common information between classes and metaclases in the type dictionary. !!TypedClassDescription methodsFor: 'accessing' stamp: 'EstebanAllende 4/3/2012 19:19'!typedSuperclass	^typedSuperclass	! !!TypedClassDescription methodsFor: 'accessing' stamp: 'EstebanAllende 4/3/2012 19:19'!typedSuperclass: aTypedClass	typedSuperclass := aTypedClass	! !!TypedClassDescription methodsFor: 'accessing' stamp: 'EstebanAllende 4/4/2012 11:16'!untypedClass	^untypedClass	! !!TypedClassDescription methodsFor: 'accessing' stamp: 'EstebanAllende 4/4/2012 11:15'!untypedClass: aClassDescription	untypedClass := aClassDescription	! !!TypedClassDescription methodsFor: 'initialize-release' stamp: 'EstebanAllende 9/13/2012 16:49'!initialize	untypedClass := nil.	instVars := Dictionary new.	methods := Dictionary new.	! !!TypedClassDescription methodsFor: 'instance variables' stamp: 'EstebanAllende 9/14/2012 20:00'!defineInstVar: varName withType: aType	|varDeclaration|	varDeclaration := instVars at: varName ifAbsentPut: [VariableDeclaration new].	varDeclaration kind: #instVar.	varDeclaration type: aType.	"instVars at: varName put: varDeclaration"	! !!TypedClassDescription methodsFor: 'instance variables' stamp: 'EstebanAllende 9/14/2012 20:18'!getInstVariableDeclaration: name	^instVars at: name ifAbsent: [		(untypedClass hasInstVarNamed: name ) ifTrue: [ |vd|			vd := VariableDeclaration new.			vd kind: #instVar.			vd type: Type defaultType.			instVars at: name put: vd.			^vd		].		^typedSuperclass ifNotNil: [^typedSuperclass getInstVariableDeclaration: name] ifNil:[nil].	].! !!TypedClassDescription methodsFor: 'instance variables' stamp: 'EstebanAllende 9/13/2012 17:09'!typeOfInstVar: varName 	|assoc|	(untypedClass hasInstVarNamed: varName) ifFalse: [		typedSuperclass ifNotNil: [^typedSuperclass typeOfInstVar: varName].	].	"assoc := instVars detect: [:each| each key = varName] ifNone: [^Type defaultType].	^assoc value."		^(instVars at: varName ifAbsent: [^Type defaultType]) type.! !!TypedClassDescription methodsFor: 'methods' stamp: 'EstebanAllende 9/21/2012 15:15'!defineMethod: methodName as: aMethodDeclaration	|mDeclaration|	mDeclaration := methods at: methodName ifAbsentPut: [MethodDeclaration new].	mDeclaration dependencies ifNotNil:[		|oldSet newSet|		oldSet := mDeclaration dependencies difference: aMethodDeclaration dependencies.		newSet := aMethodDeclaration dependencies difference: mDeclaration dependencies.		oldSet do: [:each| 			each removeDependent: mDeclaration.		].		newSet do: [:each|			each addDependent: mDeclaration.		].	] ifNil: [		aMethodDeclaration dependencies do: [:each|			each addDependent: mDeclaration.		].	].	mDeclaration classDependencies ifNotNil: [		|oldSet newSet|		oldSet := mDeclaration classDependencies difference: aMethodDeclaration classDependencies.		newSet := aMethodDeclaration classDependencies difference: mDeclaration classDependencies.		oldSet do: [:each| 			each removeDependent: mDeclaration.		].		newSet do: [:each|			each addDependent: mDeclaration.		].	] ifNil: [		aMethodDeclaration classDependencies do: [:each|			each addDependent: mDeclaration.		].	].	mDeclaration assign: aMethodDeclaration.! !!TypedClassDescription methodsFor: 'methods' stamp: 'OzC 11/12/2012 15:52'!getMethodDeclaration: selector	^methods at: selector ifAbsent: [ |md|		(untypedClass includesSelector: selector) ifTrue: [ |argSize|			md := MethodDeclaration new.			md ownerClassDescription: untypedClass.			argSize := (untypedClass lookupSelector: selector) numArgs.			md type: (LambdaType new params: (Array new: argSize withAll: Type defaultType) asOrderedCollection; return: Type defaultType; yourself).			methods at: selector put: md.			^md		].		md:=typedSuperclass ifNotNil: [typedSuperclass getMethodDeclarationWithOutGhosts:  selector] ifNil:[nil].		md ifNotNil: [^ md].		"Ghost!!!!!!"		md:=GhostMethodDeclaration fromSelector: selector .		md ownerClassDescription: untypedClass.		methods at: selector put: md.		^ md	].! !!TypedClassDescription methodsFor: 'methods' stamp: 'OzC 11/12/2012 09:41'!getMethodDeclarationWithOutGhosts: selector	^methods at: selector ifAbsent: [		(untypedClass includesSelector: selector) ifTrue: [ |md argSize|			md := MethodDeclaration new.			md ownerClassDescription: untypedClass.			argSize := (untypedClass lookupSelector: selector) numArgs.			md type: (LambdaType new params: (Array new: argSize withAll: Type defaultType) asOrderedCollection; return: Type defaultType; yourself).			methods at: selector put: md.			^md		].		^typedSuperclass ifNotNil: [^typedSuperclass getMethodDeclaration: selector] ifNil:[nil].	].! !!TypedClassDescription methodsFor: 'methods' stamp: 'EstebanAllende 9/20/2012 14:03'!removeAllMethods	|res|	methods valuesDo: [:md|		|dep|		dep := md value dependencies.		dep ifNotNil:[			dep do: [:each| 				each removeDependent: each value.			].			].	].	res := methods values copy asOrderedCollection.	methods removeAll.	^res! !!TypedClassDescription methodsFor: 'methods' stamp: 'EstebanAllende 9/20/2012 01:55'!removeMethod: methodName	|mDeclaration|	mDeclaration := methods at: methodName ifAbsent: [^nil].	mDeclaration dependencies ifNotNil:[		|oldSet|		oldSet := mDeclaration dependencies.		oldSet do: [:each| 			each removeDependent: mDeclaration.		].	].	methods removeKey: methodName.	^mDeclaration ! !!TypedClassDescription methodsFor: 'resetting' stamp: 'EstebanAllende 9/13/2012 17:16'!partialReset	self refreshUntypedClass.	instVars removeAll.	! !!TypedClassDescription methodsFor: 'resetting' stamp: 'EstebanAllende 4/9/2012 16:02'!refreshSuperclassUsing: aDict	^self	! !!TypedClassDescription methodsFor: 'resetting' stamp: 'EstebanAllende 4/9/2012 15:51'!refreshUntypedClass	^self subclassResponsibility	! !!TypedClassDescription methodsFor: 'resetting' stamp: 'EstebanAllende 9/13/2012 17:17'!reset	instVars removeAll.	methods removeAll.	! !!TypedClassDescription methodsFor: 'statistics' stamp: 'EstebanAllende 7/13/2012 15:56'!collectStatistics	|res total methodsDict|	res := Dictionary new.	total := Dictionary new.	methodsDict := Dictionary new.	res at: #all put: total.	res at: #methods put: methodsDict.	"total at: #total put: 0."	methodsDict at: #total put: 0.	methodsDict at: #LOC put: 0.	untypedClass selectors do: [:sel| |dict|		dict := (self getMethodDeclaration: sel) analisisDict.		((self untypedClass isMeta) and: [sel = #compilerContext]) ifTrue: [dict := nil]."		(self untypedClass whichCategoryIncludesSelector: sel) first = $* ifTrue: [dict := nil]."		methodsDict at: #total modify:[:x| x+1].		dict ifNotNil: [			methodsDict at: #LOC modify: [:x | x + (self untypedClass lookupSelector: sel) linesOfCode].			dict associationsDo: [:each|				|val|				val := total at: each key ifAbsent: [0].				total at: each key put: val+ each value.				"total at: #total modify: [:x| x + each value]."				val := methodsDict at: each key ifAbsent: [0].				(each value > 0)	ifTrue: [val := val +1].				methodsDict at: each key put: val.			].		].	].	^res! !!TypedClassDescription methodsFor: 'variables' stamp: 'EstebanAllende 9/14/2012 20:38'!getVariableDeclaration: name	^self getInstVariableDeclaration: name! !TypedClassDescription subclass: #TypedClass	instanceVariableNames: 'name classVars paramVars oldParamVars typedMetaclass oldpvar'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!TypedClass commentStamp: 'EstebanAllende 10/1/2012 01:18' prior: 0!A TypedClass is the structure used by the type dictionary to store all information about a class.!!TypedClass methodsFor: 'accessing' stamp: 'EstebanAllende 9/13/2012 15:37'!name	^name	! !!TypedClass methodsFor: 'accessing' stamp: 'EstebanAllende 6/27/2012 15:59'!oldpvar	^ oldpvar! !!TypedClass methodsFor: 'accessing' stamp: 'EstebanAllende 6/27/2012 15:59'!oldpvar: anObject	oldpvar := anObject! !!TypedClass methodsFor: 'accessing' stamp: 'EstebanAllende 4/3/2012 18:30'!typedMetaclass	^typedMetaclass! !!TypedClass methodsFor: 'accessing' stamp: 'EstebanAllende 4/3/2012 18:30'!typedMetaclass: anObject	typedMetaclass := anObject! !!TypedClass methodsFor: 'accessing' stamp: 'EstebanAllende 9/13/2012 15:37'!untypedClass: aClassDescription	name := aClassDescription name.	super untypedClass: aClassDescription! !!TypedClass methodsFor: 'class variables' stamp: 'EstebanAllende 9/17/2012 15:18'!defineClassVar: varName withType: aType	|varDeclaration|	varDeclaration := classVars at: varName ifAbsentPut: [VariableDeclaration new].	varDeclaration kind: #classVar.	varDeclaration type: aType.	"classVars at: varName put: varDeclaration."	! !!TypedClass methodsFor: 'class variables' stamp: 'EstebanAllende 9/14/2012 20:18'!getClassVariableDeclaration: cname	^classVars at: cname ifAbsent: [		(untypedClass hasClassVarNamed: cname ) ifTrue: [ |vd|			vd := VariableDeclaration new.			vd kind: #classVar.			vd type: Type defaultType.			classVars at: cname put: vd.			^vd		].		^typedSuperclass ifNotNil: [^typedSuperclass getInstVariableDeclaration: cname] ifNil:[nil].	].! !!TypedClass methodsFor: 'class variables' stamp: 'EstebanAllende 9/13/2012 17:15'!typeOfClassVar: varName 	|assoc|	(untypedClass hasClassVarNamed: varName) ifFalse: [		typedSuperclass ifNotNil: [^typedSuperclass typeOfClassVar: varName].		^nil.	].	"assoc := classVars detect: [:each| each key = varName] ifNone: [^Type defaultType].	^assoc value."	^(classVars at: varName ifAbsent: [^Type defaultType]) type ! !!TypedClass methodsFor: 'initialize-release' stamp: 'EstebanAllende 9/13/2012 17:11'!initialize	super initialize.	classVars := Dictionary new.	paramVars := SortedCollection sortBlock: [:x :y| x value second pos < y value second pos].	oldParamVars := OrderedCollection new.	! !!TypedClass methodsFor: 'parametrics' stamp: 'EstebanAllende 7/13/2012 12:56'!classOldParamList	oldParamVars ifNil: [oldParamVars := OrderedCollection new].	^oldParamVars collect: [:each| {each key. each value second}].	! !!TypedClass methodsFor: 'parametrics' stamp: 'EstebanAllende 7/9/2012 16:48'!classParamList	(paramVars size = 0 and: [oldParamVars isEmptyOrNil]) ifTrue: [		typedSuperclass ifNotNil: [^typedSuperclass classParamList]	].	^paramVars collect: [:each| each value second].	! !!TypedClass methodsFor: 'parametrics' stamp: 'EstebanAllende 6/28/2012 00:19'!defineOldParamVar: varName withLocalType: localType andClassType: classType	oldParamVars addLast: (varName -> {localType. classType}).	! !!TypedClass methodsFor: 'parametrics' stamp: 'EstebanAllende 4/3/2012 14:13'!defineParamVar: varName withUpperBound: aType andPosition: anInteger	|localParametric classParametric|	localParametric := ParametricType new.	localParametric name: varName.	localParametric kind: #local.	localParametric upperBound: aType.		classParametric := ParametricType new.	classParametric name: varName.	classParametric kind: #class.	classParametric pos: anInteger.	classParametric upperBound: aType.		paramVars addLast: (varName -> {localParametric. classParametric}).	! !!TypedClass methodsFor: 'parametrics' stamp: 'EstebanAllende 4/4/2012 15:36'!defineParamVarWithLocalParametric: aParametricType andPosition: anInteger	|classParametric|	classParametric := ParametricType new.	classParametric name: aParametricType name.	classParametric kind: #class.	classParametric pos: anInteger.	classParametric upperBound: aParametricType upperBound.		paramVars addLast: (aParametricType name -> {aParametricType. classParametric}).	! !!TypedClass methodsFor: 'parametrics' stamp: 'EstebanAllende 7/13/2012 12:56'!localOldParamList	oldParamVars ifNil: [oldParamVars := OrderedCollection new].	^oldParamVars collect: [:each| {each key. each value first}].	! !!TypedClass methodsFor: 'parametrics' stamp: 'EstebanAllende 7/9/2012 16:47'!localParamList	(paramVars size = 0 and: [oldParamVars isEmptyOrNil]) ifTrue: [		typedSuperclass ifNotNil: [^typedSuperclass localParamList]	].	^paramVars collect: [:each| each value first].	! !!TypedClass methodsFor: 'parametrics' stamp: 'EstebanAllende 4/4/2012 15:52'!sortParamVars	paramVars sort: [:x :y| x value second pos < y value second pos]	! !!TypedClass methodsFor: 'resetting' stamp: 'EstebanAllende 9/13/2012 17:14'!partialReset	super partialReset.	classVars removeAll.	paramVars reset.	oldParamVars reset.	oldpvar := nil.	! !!TypedClass methodsFor: 'resetting' stamp: 'EstebanAllende 4/9/2012 16:19'!refreshSuperclassUsing: aDict	self untypedClass superclass ifNotNil: [		self typedSuperclass: (aDict getTypedClass: self untypedClass superclass).	].	self typedMetaclass typedSuperclass: (aDict getTypedClassDescription: self typedMetaclass untypedClass superclass).	! !!TypedClass methodsFor: 'resetting' stamp: 'EstebanAllende 9/13/2012 15:37'!refreshUntypedClass	untypedClass := Smalltalk at: name.	! !!TypedClass methodsFor: 'resetting' stamp: 'EstebanAllende 9/13/2012 17:15'!reset	super reset.	classVars removeAll.	paramVars reset.	oldParamVars reset.	oldpvar := nil.	! !!TypedClass methodsFor: 'statistics' stamp: 'EstebanAllende 7/3/2012 17:30'!collectStatistics	|classStat metaStat res total methodsDict|	res := Dictionary new.	total := Dictionary new.	methodsDict := Dictionary new.	res at: #all put: total.	res at: #methods put: methodsDict.	res at: #classMethods put: Dictionary new.	res at: #metaclassMethods put: Dictionary new.	res at: #classTotal put: Dictionary new.	res at: #metaclassTotal put: Dictionary new.	classStat := super collectStatistics.	metaStat := typedMetaclass collectStatistics.	(classStat at: #all) associationsDo: [:each|		total at: each key put: each value.		(res at: #classTotal) at: each key put: each value.	].	(classStat at: #methods) associationsDo: [:each|		methodsDict at: each key put: each value.		(res at: #classMethods) at: each key put: each value.	].	(metaStat at: #all) associationsDo: [:each|		|val|		val := total at: each key ifAbsent: [0].		total at: each key put: val + each value.		(res at: #metaclassTotal) at: each key put: each value.	].	(metaStat at: #methods) associationsDo: [:each|		|val|		val := methodsDict at: each key ifAbsent: [0].		methodsDict at: each key put: val + each value.		(res at: #metaclassMethods) at: each key put: each value.	].	^res! !!TypedClass methodsFor: 'variables' stamp: 'EstebanAllende 9/14/2012 20:39'!getVariableDeclaration: varName	|res|	res := self getInstVariableDeclaration: varName.	res ifNil: [res := self getClassVariableDeclaration: varName].	^res! !TypedClass subclass: #GhostClass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!GhostClass methodsFor: 'as yet unclassified' stamp: 'OzC 11/12/2012 09:42'!getMethodDeclaration: selector	(typedSuperclass getMethodDeclarationWithOutGhosts: selector) ifNotNilDo: [:smd| ^ smd].	^methods at: selector ifAbsentPut: [			GhostMethodDeclaration fromSelector: selector 	].! !Object subclass: #MethodDeclaration	uses: TTyped	instanceVariableNames: '(Symbol)name (ClassDescription)ownerClassDescription (Type)type (Symbol)access (Dictionary<Symbol, Integer>)analisisDict dependencies classDependencies'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!MethodDeclaration commentStamp: 'EstebanAllende 10/1/2012 00:51' prior: 0!A MethodDeclaration is an structure that store all associated information about a method in the type dictionary.!!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:00'!(Symbol) access	^ access! !!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:00'!(Self) access: (Symbol) anObject	access := anObject! !!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 7/13/2012 14:51'!(Dictionary<Symbol, Integer>) analisisDict	^ analisisDict! !!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 7/13/2012 14:51'!(Self) analisisDict: (Dictionary<Symbol,Integer>)anObject	analisisDict := anObject! !!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 9/21/2012 12:41'!classDependencies	^ classDependencies! !!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 9/21/2012 12:41'!classDependencies: anObject	classDependencies := anObject! !!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 9/16/2012 02:22'!dependencies	^ dependencies! !!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 9/16/2012 02:22'!dependencies: anObject	dependencies := anObject! !!MethodDeclaration methodsFor: 'accessing' stamp: 'OzC 11/12/2012 09:49'!isGhostMethod	^ false! !!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 9/16/2012 13:29'!name	^name! !!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 9/16/2012 13:29'!name: anObject	name := anObject! !!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 4/4/2012 11:28'!(ClassDescription) ownerClassDescription	^ ownerClassDescription! !!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 4/4/2012 11:28'!(Self) ownerClassDescription: (ClassDescription)anObject	ownerClassDescription := anObject! !!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:01'!(Type) type	^ type! !!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:01'!(Self) type: (Type) anObject	type := anObject! !!MethodDeclaration methodsFor: 'as yet unclassified' stamp: 'OzC 11/12/2012 09:46'!printOn: stream 	ownerClassDescription printOn: stream .	stream nextPutAll: '>> '.	type printOn: stream .	stream nextPutAll: ' '.	name printOn: stream .! !!MethodDeclaration methodsFor: 'initialize-release' stamp: 'EstebanAllende 12/7/2011 11:00'!(Self) initialize	access := #public! !!MethodDeclaration methodsFor: 'operation' stamp: 'EstebanAllende 9/21/2012 12:50'!(Self) assign: (MethodDeclaration)md	name := md name.	access := md access.	analisisDict := md analisisDict.	ownerClassDescription := md ownerClassDescription.	type := md type.	dependencies := md dependencies.	classDependencies := md classDependencies.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MethodDeclaration class	uses: TTyped classTrait	instanceVariableNames: ''!Object subclass: #VariableDeclaration	instanceVariableNames: 'kind type dependencies'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!VariableDeclaration commentStamp: 'EstebanAllende 10/1/2012 01:19' prior: 0!A VariableDeclaration is an structure that store all information about instance and class variables in the type dictionary.!!VariableDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 9/15/2012 22:31'!dependencies	^ dependencies! !!VariableDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 9/15/2012 22:31'!dependencies: anObject	dependencies := anObject! !!VariableDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 9/13/2012 16:57'!kind	^ kind! !!VariableDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 9/13/2012 16:57'!kind: anObject	kind := anObject! !!VariableDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 9/13/2012 16:57'!type	^ type! !!VariableDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 9/13/2012 16:57'!type: anObject	type := anObject! !!VariableDeclaration methodsFor: 'initialize-release' stamp: 'EstebanAllende 9/15/2012 22:32'!initialize	dependencies := OrderedCollection new.! !TypedClassDescription subclass: #TypedMetaclass	instanceVariableNames: 'typedNonMetaClass'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!TypedMetaclass commentStamp: 'EstebanAllende 10/1/2012 01:18' prior: 0!A TypedMetaclass is the structure used by the type dictionary to store all the information about a metaclass.!!TypedMetaclass methodsFor: 'accessing' stamp: 'EstebanAllende 4/3/2012 18:29'!typedNonMetaClass	^ typedNonMetaClass! !!TypedMetaclass methodsFor: 'accessing' stamp: 'EstebanAllende 4/3/2012 18:29'!typedNonMetaClass: anObject	typedNonMetaClass := anObject! !!TypedMetaclass methodsFor: 'resetting' stamp: 'EstebanAllende 9/13/2012 15:39'!refreshUntypedClass	untypedClass := (Smalltalk at: typedNonMetaClass name) theMetaClass.! !TypedMetaclass subclass: #GhostMetaclass	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!GhostMetaclass methodsFor: 'as yet unclassified' stamp: 'OzC 11/11/2012 23:26'!refreshUntypedClass	! !MethodDeclaration subclass: #GhostMethodDeclaration	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!GhostMethodDeclaration methodsFor: 'as yet unclassified' stamp: 'OzC 11/12/2012 09:03'!initialize 	super initialize .	ownerClassDescription := nil.! !!GhostMethodDeclaration methodsFor: 'as yet unclassified' stamp: 'OzC 11/12/2012 09:49'!isGhostMethod 	^ true.! !!GhostMethodDeclaration methodsFor: 'as yet unclassified' stamp: 'OzC 11/12/2012 09:44'!printOn: stream	stream nextPut: $&.	super printOn: stream .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GhostMethodDeclaration class	instanceVariableNames: ''!!GhostMethodDeclaration class methodsFor: 'as yet unclassified' stamp: 'OzC 11/12/2012 09:30'!fromSelector: selector 				|md argSize|			md := self  new name: selector. 			"md ownerClassDescription: untypedClass. <--nil !!!!"			argSize := selector numArgs.			md type: (LambdaType new params: (Array new: argSize withAll: Type defaultType) asOrderedCollection; return: Type defaultType; yourself).			^ md ! !Object subclass: #Type	uses: TTyped	instanceVariableNames: '(Integer)startPosition (Integer)endPosition (OrderedCollection<Type>)classParametrics (Symbol)usedAlias'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!Type commentStamp: 'EstebanAllende 9/30/2012 23:29' prior: 0!Type is the abstract root class of all types in Gradualtalk. All subclasses understand all of its messages (except UnlinkedType).!!Type methodsFor: '*typesystem-core' stamp: 'EstebanAllende 7/13/2012 14:23'!(Boolean) isType	^true! !!Type methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/7/2011 11:19'!(Boolean) isDyn	^false! !!Type methodsFor: '*typesystem-types' stamp: 'OzC 11/11/2012 19:15'!isGhost	^ false! !!Type methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/7/2011 11:19'!(Boolean) isLambda	^false! !!Type methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/7/2011 11:19'!(Boolean) isNominal	^false! !!Type methodsFor: '*typesystem-types'!(Boolean) isParametric	^false! !!Type methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/7/2011 11:20'!(Boolean) isSelf	^false! !!Type methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/7/2011 11:20'!(Boolean) isStructural	^false! !!Type methodsFor: '*typesystem-types' stamp: 'EstebanAllende 9/21/2012 11:52'!(Boolean) isSuper	^false! !!Type methodsFor: '*typesystem-types'!(Boolean) isUnion	^false! !!Type methodsFor: 'accessing' stamp: 'EstebanAllende 7/13/2012 14:49'!(OrderedCollection<Type>) classParametrics	^ classParametrics! !!Type methodsFor: 'accessing' stamp: 'EstebanAllende 7/13/2012 14:49'!(Self) classParametrics: (OrderedCollection<Type>)anObject		classParametrics := anObject! !!Type methodsFor: 'accessing' stamp: 'EstebanAllende 7/13/2012 14:49'!(Symbol) usedAlias	^ usedAlias! !!Type methodsFor: 'accessing' stamp: 'EstebanAllende 7/13/2012 14:49'!(Self) usedAlias: (Symbol)anObject	usedAlias := anObject! !!Type methodsFor: 'aliasing' stamp: 'EstebanAllende 9/16/2012 13:20'!(Self) addAlias: (Symbol) alias	TypeDictionary uniqueInstance name: alias aliasTo: self.! !!Type methodsFor: 'analisis' stamp: 'EstebanAllende 7/13/2012 14:20'!(Self) addCountIn: (Dictionary<Symbol, Integer>)aDictionary	|(Integer)implicitDyn (ClassDescription)classRef|	aDictionary at: #Total modify: [:(Integer)act| act +1].	classRef := self asNominalType classRef.	classRef isMeta ifTrue: [classRef := Class].	self classParametrics ifNotNil: [ 		(self classParametrics size > 0)			ifTrue: [aDictionary at: #GenericUsage modify: [:(Integer)act| act + 1]].		self classParametrics do: [:(Type)each| each addCountIn: aDictionary].		implicitDyn := ((TypeDictionary uniqueInstance getLocalParametricList: (<Class>classRef)) size) -  (self classParametrics size).		(implicitDyn > 0) ifTrue: [			aDictionary at: #ImplicitDyn modify: [:(Integer)act| act+ implicitDyn].			aDictionary at: #DynType modify: [:(Integer)act| act+ implicitDyn].			aDictionary at: #Total modify: [:(Integer)act| act + implicitDyn].		]	] ifNil: [		implicitDyn := (TypeDictionary uniqueInstance getLocalParametricList: (<Class>classRef)) size.		(implicitDyn > 0) ifTrue: [			aDictionary at: #ImplicitDyn modify: [:(Integer)act| act+ implicitDyn].			aDictionary at: #DynType modify: [:(Integer)act| act+ implicitDyn].			aDictionary at: #Total modify: [:(Integer)act| act + implicitDyn].		]	].! !!Type methodsFor: 'comparing' stamp: 'EstebanAllende 9/16/2012 19:08'!(Boolean) = (Object)another"   This method declaration is useful when cast are inserted into code. Until then, it useless.       |(Type)a (Type)b ({simplify (→Type)})c|       another ifNil: [^false].       a:= self simplify.       [c := another] on: CastError do: [:ex | ^ false].       b:= c simplify.       ^[a typeEquality: b] on: CastError do: [:ex | false]"|(Type)a (Type)b|another ifNil: [^false].another isType ifFalse: [^false].a:= self simplify.b:= (<Type>another) simplify.(a class = b class) ifFalse: [^false].^a typeEquality: b! !!Type methodsFor: 'comparing' stamp: 'EstebanAllende 7/13/2012 14:23'!(Integer) hash	^self subclassResponsibility! !!Type methodsFor: 'comparing' stamp: 'EstebanAllende 7/13/2012 14:25'!(Boolean) typeEquality: (Self) another	<access: #protected>	^self subclassResponsibility.! !!Type methodsFor: 'converting' stamp: 'EstebanAllende 7/13/2012 14:21'!(NominalType) asNominalType	^nil! !!Type methodsFor: 'converting' stamp: 'EstebanAllende 7/13/2012 14:21'!(String) asString	usedAlias notNil ifTrue: [^usedAlias asString].	(classParametrics isNil or: [classParametrics size = 0])		ifTrue: [^self baseString]		ifFalse: [^self baseString,'<',(', ' join: classParametrics),'>']! !!Type methodsFor: 'converting' stamp: 'EstebanAllende 7/13/2012 14:21'!(StructuralType) asStructuralType	^nil! !!Type methodsFor: 'converting' stamp: 'EstebanAllende 7/13/2012 14:21'!(Self) asType	^self! !!Type methodsFor: 'parallel hierarchies' stamp: 'EstebanAllende 7/13/2012 14:21'!(Type) classType	^self subclassResponsibility! !!Type methodsFor: 'parallel hierarchies' stamp: 'EstebanAllende 7/13/2012 14:23'!(Type) instanceType	^self subclassResponsibility! !!Type methodsFor: 'queries' stamp: 'EstebanAllende 7/13/2012 14:23'!(Type) lowestCommonAncestorBetween: (Type) another	^self subclassResponsibility.! !!Type methodsFor: 'queries' stamp: 'EstebanAllende 7/13/2012 14:25'!(Type) typeOfSelector: (Symbol)selector fromClass: (ClassDescription) requestor	^self subclassResponsibility.! !!Type methodsFor: 'relationships' stamp: 'EstebanAllende 7/13/2012 14:23'!(Boolean) isCasteableTo: (Type) aType	^Type is: self casteableTo: aType! !!Type methodsFor: 'relationships' stamp: 'EstebanAllende 7/13/2012 14:23'!(Boolean) isConsistentSubtypeOf: (Type) aType	^Type is: self consistentSubtypeOf: aType! !!Type methodsFor: 'relationships' stamp: 'EstebanAllende 9/13/2012 14:51'!(Boolean) isRuntimeCasteableTo: (Type) aType	^Type is: self runtimeCasteableTo: aType! !!Type methodsFor: 'relationships' stamp: 'EstebanAllende 7/13/2012 14:23'!(Boolean) isSubtypeOf: (Type) aType	^Type is: self subtypeOf: aType! !!Type methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 14:21'!(Type) annotateSelfWith: (ClassDescription)aClass inMethod: (MethodSignature) aMethodSignature withKind: (Symbol) aSymbol	^self subclassResponsibility! !!Type methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 14:22'!(Self) generateDictionaryWith: (Type) aType andDictionary: (Dictionary<Symbol, Type>) dict	"aType isSubtype."	|(Collection<Type>)aTypeClassParametrics (Integer)min|	aType isUnion ifTrue: [		(<UnionType>aType) union do: [:(Type)each|self generateDictionaryWith: each andDictionary: dict].		^self.	].	classParametrics ifNil:[^self].	aTypeClassParametrics := aType classParametrics ifNil: [#()].	min := classParametrics size min: aTypeClassParametrics size.	1 to: classParametrics size do: [ :(Integer)i| |(Type)each|		each := classParametrics at: i.		(i <= min) 			ifTrue: [ each generateDictionaryWith: (aTypeClassParametrics at: i) andDictionary: dict]			ifFalse: [each generateDictionaryWith: DynType implicitInstance andDictionary: dict].	].	"(classParametrics size = aType classParametrics size) ifFalse: [ResolveError signal: 'Incorrect numbers of generics between (', self asString,') and (',aType asString,')'].	classParametrics with: aType classParametrics do: [:(Type)each :(Type)another| each generateDictionaryWith: another andDictionary: dict]."	^self! !!Type methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 14:23'!(Type) replaceSelfWith: (Type) aType	^self subclassResponsibility.! !!Type methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 14:23'!(Type) resolveLocalWith: (TypeEnvironment) env	^self resolveWith: env ifNotFoundStore: [:(Symbol)name| 		|(ParametricType) pRes|		pRes := ParametricType new.		pRes kind: #local.		pRes name: name.		pRes	].	! !!Type methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 14:24'!(OrderedCollection<Type>) resolveParametricInGenericsWithReceiver: (Type)receiver andDictionary: (Dictionary<Symbol, Type>) dict	^classParametrics ifNotNil: [		classParametrics collect: [:(Type)each| each resolveParametricWithReceiver: receiver andDictionary: dict].	] ifNil: [nil].! !!Type methodsFor: 'type resolution' stamp: 'EstebanAllende 11/20/2012 12:34'!(Type) resolveParametricWith: (Type)aType andReceiver: (Type) receiver	|(Dictionary<Symbol, Type>) dict|	dict := Dictionary new.	dict at: #rcv put: receiver.	self generateDictionaryWith: aType andDictionary: dict.	^self resolveParametricWithReceiver: receiver andDictionary: dict.	! !!Type methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 14:25'!(Type) resolveParametricWithReceiver: (Type)receiver andDictionary: (Dictionary<Symbol, Type>) dict	^self subclassResponsibility.! !!Type methodsFor: 'type resolution' stamp: 'EstebanAllende 6/19/2012 18:04'!(Type) resolveWith: (TypeEnvironment) env	^self resolveWith: env ifNotFoundStore: [:(Symbol)name| 		|(ParametricType) pRes|		pRes := ParametricType new.		env local ifTrue: [pRes kind: #local] ifFalse: [pRes kind: #method].		pRes name: name.		pRes	].! !!Type methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 14:25'!(Type) resolveWith: (TypeEnvironment) env ifNotFoundStore: (Symbol → Type) aBlock	classParametrics ifNotNil: [		classParametrics := classParametrics collect: [:(Type)each| each resolveWith: env ifNotFoundStore: aBlock].	].	^self.	! !!Type methodsFor: 'validation' stamp: 'EstebanAllende 7/13/2012 14:23'!(Boolean) isValid	^self validate size = 0! !!Type methodsFor: 'validation' stamp: 'EstebanAllende 7/13/2012 14:26'!(OrderedCollection<Error>) validate	^#() asOrderedCollection! !!Type methodsFor: 'private' stamp: 'EstebanAllende 7/13/2012 14:21'!(String) baseString		^self subclassResponsibility! !!Type methodsFor: 'private' stamp: 'EstebanAllende 7/13/2012 14:23'!(Type) pureType	^self	! !!Type methodsFor: 'private' stamp: 'EstebanAllende 7/13/2012 14:25'!(Type) simplify	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Type class	uses: TTyped classTrait	instanceVariableNames: ''!!Type class methodsFor: '*compiler-frontend' stamp: 'EstebanAllende 12/7/2011 02:12'!compilerContext	^OTCSupport defaultCompilerContext! !!Type class methodsFor: 'accessing' stamp: 'EstebanAllende 7/3/2012 18:03'!(Type) defaultType	^TypeConfiguration uniqueInstance defaultType! !!Type class methodsFor: 'relationships'!(Boolean) is: (Type) type1 casteableTo: (Type) type2	^TypeConfiguration uniqueInstance castingRules is: type1 relatedWith: type2.! !!Type class methodsFor: 'relationships' stamp: 'EstebanAllende 1/30/2012 14:00'!(Boolean) is: (Type) type1 consistentSubtypeOf: (Type) type2	^TypeConfiguration uniqueInstance consistentSubtypeRules is: type1 relatedWith: type2.! !!Type class methodsFor: 'relationships' stamp: 'EstebanAllende 9/13/2012 11:33'!(Boolean) is: (Type) type1 runtimeCasteableTo: (Type) type2	^TypeConfiguration uniqueInstance runtimeCastingRules is: type1 relatedWith: type2.! !!Type class methodsFor: 'relationships' stamp: 'EstebanAllende 1/30/2012 14:00'!(Boolean) is: (Type) type1 subtypeOf: (Type) type2	^TypeConfiguration uniqueInstance subtypeRules is: type1 relatedWith: type2.! !Object subclass: #TypeDictionary	uses: TTyped	instanceVariableNames: '(Dictionary<Symbol, TypedClass>)classes (Dictionary<Symbol, Type>)aliases (Boolean)dependencyChecking'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!TypeDictionary commentStamp: 'EstebanAllende 10/1/2012 01:00' prior: 0!A TypeDictionary is the storage of all type information in the system.!!TypeDictionary methodsFor: 'aliasing' stamp: 'EstebanAllende 7/13/2012 14:55'!(Dictionary<Symbol, Type>) aliasDictionary	^aliases! !!TypeDictionary methodsFor: 'aliasing' stamp: 'EstebanAllende 4/5/2012 11:27'!(Self) name: (Symbol) name aliasTo: (Type) toAlias	|(Type) toAlias|	toAlias := toAlias copy.	toAlias usedAlias: name.	aliases at: name put: toAlias	 ! !!TypeDictionary methodsFor: 'class parametrics' stamp: 'EstebanAllende 7/13/2012 14:59'!(OrderedCollection<Array<Symbol|Type>>) getClassOldParametricList: (Class) aClass	|(TypedClass) tc|	tc := self getTypedClass: aClass.	^tc classOldParamList.! !!TypeDictionary methodsFor: 'class parametrics' stamp: 'EstebanAllende 7/13/2012 15:08'!(OrderedCollection<ParametricType>) getClassParametricList: (Class) aClass	|(TypedClass) tc|	tc := self getTypedClass: aClass.	^tc classParamList.! !!TypeDictionary methodsFor: 'class parametrics' stamp: 'EstebanAllende 7/13/2012 15:09'!(TypeEnvironment) getClassTypeEnvironmentFor: (Class) aClass	|(TypeEnvironment)res (OrderedCollection<ParametricType>)list  (OrderedCollection<Array<Symbol|Type>>)list2 (TypeEnvironment)parentEnv|	parentEnv := aClass					ifNil: [^TypeEnvironment globalEnvironment]					ifNotNil: [self getClassTypeEnvironmentFor: (<Class>aClass superclass)].	list := self getClassParametricList: aClass.	list2 := self getClassOldParametricList: aClass.	((list size + list2 size) = 0) ifTrue: [^parentEnv].	res := TypeEnvironment new.	res parent: parentEnv.	list do: [:(ParametricType)each|res define: each name as: each].	list2 do: [:(Array<Symbol|Type>)each|res define: (<Symbol>each first) as: (<Type>each second)].	^res.! !!TypeDictionary methodsFor: 'class parametrics' stamp: 'EstebanAllende 7/13/2012 15:11'!(OrderedCollection<Array<Symbol|Type>>) getLocalOldParametricList: (Class) aClass	|(TypedClass) tc|	tc := self getTypedClass: aClass.	^tc localOldParamList.! !!TypeDictionary methodsFor: 'class parametrics' stamp: 'EstebanAllende 7/13/2012 15:11'!(OrderedCollection<ParametricType>) getLocalParametricList: (Class) aClass	|(TypedClass) tc|	tc := self getTypedClass: aClass.	^tc localParamList.! !!TypeDictionary methodsFor: 'class parametrics' stamp: 'EstebanAllende 7/13/2012 15:12'!(TypeEnvironment) getLocalTypeEnvironmentFor: (Class) aClass	|(TypeEnvironment)res (OrderedCollection<ParametricType>)list (OrderedCollection<Array<Symbol|Type>>)list2 (TypeEnvironment)parentEnv|	parentEnv := aClass					ifNil: [^TypeEnvironment globalEnvironment]					ifNotNil: [self getLocalTypeEnvironmentFor: (<Class>aClass superclass)].	list := self getLocalParametricList: aClass.	list2 := self getLocalOldParametricList: aClass.	((list size + list2 size) = 0) ifTrue: [^parentEnv].	res := TypeEnvironment new.	res parent: parentEnv.	list do: [:(ParametricType)each|res define: each name as: each].	list2 do: [:(Array<Symbol|Type>)each|res define: each first as: each second].	^res.! !!TypeDictionary methodsFor: 'definitions' stamp: 'EstebanAllende 7/13/2012 14:57'!(Self) class:(Class) aClass atClassVar: (Symbol)varName putType: (Type) aType	|(TypedClass) tc|	tc := self getTypedClass: aClass.	tc defineClassVar: varName withType: aType! !!TypeDictionary methodsFor: 'definitions' stamp: 'EstebanAllende 7/13/2012 14:57'!(Self) class: (ClassDescription)aClass atInstVar: (Symbol)varName putType: (Type)aType	|(TypedClassDescription) tc|	tc := self getTypedClassDescription: aClass.	tc defineInstVar: varName withType: aType.! !!TypeDictionary methodsFor: 'definitions' stamp: 'EstebanAllende 9/20/2012 01:48'!(Self) class: (ClassDescription)aClass atSelector: (Symbol)aSelector putMethodDeclaration: (MethodDeclaration)md	|(TypedClassDescription) tcd|	tcd := self getTypedClassDescription: aClass.	md ownerClassDescription: aClass.	tcd defineMethod: aSelector as: md. 	self recompileDependents: (tcd getMethodDeclaration: aSelector). ! !!TypeDictionary methodsFor: 'definitions' stamp: 'EstebanAllende 4/4/2012 15:22'!(Self) class:(Class) aClass defineParamVar: (Symbol)varName withUpperBound: (Type) aType andPosition: (Integer) pos	|(TypedClass) tc|	tc := self getTypedClass: aClass.	tc defineParamVar: varName withUpperBound: aType andPosition: pos.! !!TypeDictionary methodsFor: 'definitions' stamp: 'EstebanAllende 4/4/2012 15:37'!(Self) class:(Class) aClass defineParamVarWithLocalParametricType: (ParametricType) aType andPosition: (Integer) pos	|(TypedClass) tc|	tc := self getTypedClass: aClass.	tc defineParamVarWithLocalParametric: aType andPosition: pos.! !!TypeDictionary methodsFor: 'dependencies' stamp: 'EstebanAllende 10/2/2012 12:18'!recompileDependents: (MethodDeclaration)md	dependencyChecking ifFalse: [ 		dependencyChecking := true.		[ |(Collection)dep (OrderedCollection) errors|			errors := OrderedCollection new.			dep := md myDependents copy. "When recompiling others methods, the dependence can change"			dep ifNotNil:[ 				dep do: [:(MethodDeclaration)each|					TSLogger info: 'Recompiling dependant: ',each ownerClassDescription name, ' >> ', each name.					[[each ownerClassDescription recompile: each name.] on: TypecheckerError do: [:(TypecheckerError)ex|						errors add: ex.]] on: Exception do: [:(Exception)ex|].				] displayingProgress: 'Recompiling dependents'.				errors notEmpty ifTrue:[ ObjectExplorer new openExplorerFor: errors withLabel: 'Broken dependencies' "; explore" .].			]		] ensure: [dependencyChecking := false].	].! !!TypeDictionary methodsFor: 'initialize-release' stamp: 'EstebanAllende 9/16/2012 18:49'!(Self) initialize	classes := IdentityDictionary new.	aliases := IdentityDictionary new.	dependencyChecking := false.! !!TypeDictionary methodsFor: 'internal data' stamp: 'OzC 11/11/2012 23:33'!(GhostClass) getGhostClass: (String) aClassName	^classes at: aClassName ifAbsentPut: [ |(GhostClass)res (GhostMetaclass)metaRes (TypedClass)typedSuperclass|		TSLogger info: 'Creating new ghost class in type dictionary: ', aClassName.		res := GhostClass new.		metaRes := GhostMetaclass new.		res typedMetaclass: metaRes.		metaRes typedNonMetaClass: res.		res untypedClass: nil.		metaRes untypedClass: nil.		"super object"			typedSuperclass := self getTypedClass: (<Class>Object).			res typedSuperclass: (typedSuperclass).			metaRes typedSuperclass: (typedSuperclass typedMetaclass).		res 	]  ! !!TypeDictionary methodsFor: 'internal data' stamp: 'EstebanAllende 9/14/2012 20:34'!(MethodDeclaration) getMethodDeclaration: (Symbol) methodName from: (ClassDescription) aClassDescription	|(TypedClassDescription) tc|	tc := self getTypedClassDescription: aClassDescription.	^tc getMethodDeclaration: methodName.! !!TypeDictionary methodsFor: 'internal data' stamp: 'EstebanAllende 10/2/2012 12:10'!(TypedClass) getTypedClass: (Class) aClass	aClass isMeta ifTrue: [self halt].	^classes at: aClass name ifAbsent: [ |(TypedClass)res (TypedMetaclass)metaRes|		TSLogger info: 'Creating new class in type dictionary: ', aClass name.		res := TypedClass new.		metaRes := TypedMetaclass new.		res typedMetaclass: metaRes.		metaRes typedNonMetaClass: res.		res untypedClass: aClass.		metaRes untypedClass: aClass class.		classes at: aClass name put: res.		aClass superclass ifNotNil: [			|(TypedClass)typedSuperclass|			typedSuperclass := self getTypedClass: (<Class>aClass superclass).			res typedSuperclass: (typedSuperclass).			metaRes typedSuperclass: (typedSuperclass typedMetaclass).		] ifNil: [metaRes typedSuperclass: (self getTypedClass: Class)].		res	]! !!TypeDictionary methodsFor: 'internal data' stamp: 'EstebanAllende 4/3/2012 19:01'!(TypedClassDescription) getTypedClassDescription: (ClassDescription) aClassDescription	|(TypedClass) tc|	tc := self getTypedClass: aClassDescription theNonMetaClass.	^aClassDescription isMeta ifTrue: [tc typedMetaclass] ifFalse: [tc].	! !!TypeDictionary methodsFor: 'internal data' stamp: 'EstebanAllende 9/14/2012 20:39'!(VariableDeclaration) getVariableDeclaration: (Symbol) varName from: (ClassDescription) aClassDescription	|(TypedClassDescription) tc|	tc := self getTypedClassDescription: aClassDescription.	^tc getVariableDeclaration: varName.! !!TypeDictionary methodsFor: 'queries' stamp: 'EstebanAllende 9/16/2012 19:08'!(Type) class:(Class) aClass atClassVar: (Symbol)varName	|(TypedClass) tc|	tc := self getTypedClass: aClass.	^tc typeOfClassVar: varName.! !!TypeDictionary methodsFor: 'queries' stamp: 'EstebanAllende 7/13/2012 14:57'!(Type) class:(ClassDescription) aClass atInstVar: (Symbol)varName	|(TypedClassDescription) tc|	tc := self getTypedClassDescription: aClass.	^tc typeOfInstVar: varName.! !!TypeDictionary methodsFor: 'queries' stamp: 'OzC 11/12/2012 10:27'!(Type) class: (ClassDescription)aClass atSelector: (Symbol)aSelector fromClass: (ClassDescription)requestor	|(TypedClassDescription)tcd (MethodDeclaration)md (Symbol) access (Class)nonMetaDefClass (Class)nonMetaReqClass|	tcd := self getTypedClassDescription: aClass.	md := tcd getMethodDeclaration: aSelector.	md ifNil: [^nil].	md isGhostMethod ifTrue: [^ md type]. 	access := md access.	nonMetaDefClass := Smalltalk at: (md ownerClassDescription theNonMetaClass name).	nonMetaReqClass := requestor theNonMetaClass.	(access = #public) ifTrue: [^md type].	(((access = #private) | (access = #protected)) and: [nonMetaDefClass = nonMetaReqClass]) ifTrue: [^md type].	((access = #protected) and: [nonMetaReqClass inheritsFrom: nonMetaDefClass ]) ifTrue: [^md type].	^nil.			! !!TypeDictionary methodsFor: 'queries' stamp: 'OzC 11/12/2012 08:47'!(Type) ghost: (String)aClassName atSelector: (Symbol)aSelector fromClass: (ClassDescription)requestor	|(GhostClass)tcd (MethodDeclaration)md (Symbol) access (Class)nonMetaDefClass (Class)nonMetaReqClass|	tcd := self getGhostClass: aClassName.	md := tcd getMethodDeclaration: aSelector.	"md ifNil: [^nil].	access := md access.	nonMetaDefClass := Smalltalk at: (md ownerClassDescription theNonMetaClass name).	nonMetaReqClass := requestor theNonMetaClass.	(access = #public) ifTrue: [^md type].	(((access = #private) | (access = #protected)) and: [nonMetaDefClass = nonMetaReqClass]) ifTrue: [^md type].	((access = #protected) and: [nonMetaReqClass inheritsFrom: nonMetaDefClass ]) ifTrue: [^md type]."	^md type.			! !!TypeDictionary methodsFor: 'removal' stamp: 'EstebanAllende 9/20/2012 01:57'!(Self) class: (ClassDescription)aClass removeSelector: (Symbol)aSelector	|(TypedClassDescription) tcd (MethodDeclaration)md|	tcd := self getTypedClassDescription: aClass.	md := tcd removeMethod: aSelector.	self recompileDependents: md. ! !!TypeDictionary methodsFor: 'removal' stamp: 'EstebanAllende 4/4/2012 11:24'!(Self) emptyVariableDictionaryInClassDescription: (ClassDescription) aClass	|(TypedClassDescription) tc|	tc := self getTypedClassDescription: aClass.	tc partialReset.! !!TypeDictionary methodsFor: 'removal' stamp: 'EstebanAllende 9/21/2012 15:37'!(Self) removeClass: (Class)aClass	|(TypedClass) tc (Collection<MethodDeclaration>)col|	tc := self getTypedClass: aClass.	col := tc typedMetaclass removeAllMethods.	col addAll: tc removeAllMethods.	col addAll: tc dependents asOrderedCollection.	classes removeKey: aClass name.	col do: [:each|		self recompileDependents: each.	].		! !!TypeDictionary methodsFor: 'removal' stamp: 'EstebanAllende 4/9/2012 16:06'!(Self) resetTypedClassDescription: (ClassDescription)aClassDescription	|(TypedClassDescription) tc|	tc := self getTypedClassDescription: aClassDescription.	tc partialReset.	tc refreshSuperclassUsing: self.	"aClassDescription superclass ifNotNil: [tc typedSuperclass: (self getTypedClassDescription: aClassDescription superclass)]."! !!TypeDictionary methodsFor: 'statistics' stamp: 'EstebanAllende 7/13/2012 14:58'!(Dictionary<Symbol,Dictionary<Symbol,Integer>>) collectStatisticsFor: (Class) aClass	^(self getTypedClass: aClass) collectStatistics! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TypeDictionary class	uses: TTyped classTrait	instanceVariableNames: '(TypeDictionary)uniqueInstance'!!TypeDictionary class methodsFor: 'class initialization' stamp: 'EstebanAllende 12/12/2011 17:50'!(Self) initialize	OTCSupport bootstrapping ifFalse: [^self].	uniqueInstance := self new.! !!TypeDictionary class methodsFor: 'instance access' stamp: 'EstebanAllende 12/7/2011 10:59'!(TypeDictionary) uniqueInstance	^uniqueInstance! !TypeConfiguration initialize!TypeEnvironment initialize!TypeDictionary initialize!