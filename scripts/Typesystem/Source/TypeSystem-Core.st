Object subclass: #TypeDictionary	uses: TTyped	instanceVariableNames: '(Dictionary)classes (Dictionary)aliases (Dictionary<Symbol, TypeEnvironment>)classEnvironments'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!TypeDictionary methodsFor: 'as yet unclassified'!(Dictionary) aliasDictionary	^aliases! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 2/21/2012 22:15'!(Type) class:(ClassDescription) aClass atClassVar: (Symbol)varName	|(Dictionary)dict (ClassDescription)defclass|	defclass := aClass classThatDefinesClassVariable: varName.	defclass ifNil: [^nil].	(defclass = UndefinedObject) 		ifTrue: [ (Smalltalk at: #TUndefinedObject ifAbsent: [nil]) ifNotNil: [:v| defclass := v]. ].	dict := classes at: defclass name asSymbol ifAbsentPut: [self emptyClassDictionary].	^(dict at: #cvars) at: varName ifAbsentPut: [Type defaultType]! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 2/21/2012 22:15'!(Type) class:(ClassDescription) aClass atClassVar: (Symbol)varName putType: (Type) aType	|(Dictionary)dict (ClassDescription)defclass|	defclass := aClass classThatDefinesClassVariable: varName.	defclass ifNil: [^nil].	(defclass = UndefinedObject) 		ifTrue: [ (Smalltalk at: #TUndefinedObject ifAbsent: [nil]) ifNotNil: [:v| defclass := v]. ].	dict := classes at: defclass name asSymbol ifAbsentPut: [self emptyClassDictionary].	^(dict at: #cvars) at: varName put: aType.! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 2/21/2012 22:15'!(Type) class:(ClassDescription) aClass atInstVar: (Symbol)varName	|(Dictionary)dict (ClassDescription)defclass|	defclass := aClass classThatDefinesInstanceVariable: varName.	defclass ifNil: [^nil].	(defclass = UndefinedObject) 		ifTrue: [ (Smalltalk at: #TUndefinedObject ifAbsent: [nil]) ifNotNil: [:v| defclass := v]. ].	dict := classes at: defclass name asSymbol ifAbsentPut: [self emptyClassDictionary].	^(dict at: #ivars) at: varName ifAbsentPut: [Type defaultType]! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 2/21/2012 22:16'!(Type) class: (ClassDescription)aClass atInstVar: (Symbol)varName putType: (Type)aType	|(Dictionary)dict (ClassDescription)defclass|	defclass := aClass classThatDefinesInstanceVariable: varName.	defclass ifNil: [^nil].	(defclass = UndefinedObject) 		ifTrue: [ (Smalltalk at: #TUndefinedObject ifAbsent: [nil]) ifNotNil: [:v| defclass := v]. ].	dict := classes at: defclass name asSymbol ifAbsentPut: [self emptyClassDictionary].	^(dict at: #ivars) at: varName put: aType! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/28/2012 16:58'!(Type) class: (ClassDescription)aClass atSelector: (Symbol)aSelector fromClass: (ClassDescription)requestor	|(Dictionary)dict (ClassDescription)defclass (MethodDeclaration) md (Symbol)access (Class)nonMetaDefClass (Class)nonMetaReqClass|	defclass := self definingClassOfMethod: aSelector startingInClass: aClass.	defclass ifNil: [^nil].	(defclass = UndefinedObject) 		ifTrue: [ (Smalltalk at: #TUndefinedObject ifAbsent: [nil]) ifNotNil: [:v| defclass := v]. ].	dict := classes at: defclass name asSymbol ifAbsentPut: [self emptyClassDictionary].	md := (dict at: #methods) at: aSelector ifAbsentPut: [ |(CompiledMethod)mth (MethodDeclaration)dmd (OrderedCollection) params|		mth:=aClass lookupSelector: aSelector.		mth ifNil: [^nil]. 		dmd := MethodDeclaration new.		params := ((1 to: mth numArgs) collect: [:(Integer)i|Type defaultType]).		dmd type: (params -> Type defaultType) asType.	].	access := md access.	nonMetaDefClass := defclass theNonMetaClass.	nonMetaReqClass := requestor theNonMetaClass.	(access = #public) ifTrue: [^md type].	(((access = #private) | (access = #protected)) and: [nonMetaDefClass = nonMetaReqClass]) ifTrue: [^md type].	((access = #protected) and: [nonMetaReqClass inheritsFrom: nonMetaDefClass ]) ifTrue: [^md type].	^nil.! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/21/2011 17:30'!(Self) class: (ClassDescription)aClass atSelector: (Symbol)aSelector putMethodDeclaration: (MethodDeclaration)md	|(Dictionary)dict|	dict := classes at: aClass name asSymbol ifAbsentPut: [self emptyClassDictionary].	md := (dict at: #methods) at: aSelector put: md.! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:51'!(ClassDescription) definingClassOfMethod: (Symbol)aMethod startingInClass: (ClassDescription)aClass		|(CompiledMethod) compiledMethod |	compiledMethod := aClass lookupSelector: aMethod.	compiledMethod ifNil: [^nil].	^compiledMethod classBinding value.! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 10:58'!(Dictionary) emptyClassDictionary	^ Dictionary newFrom: {#methods -> Dictionary new . #ivars -> Dictionary new . #cvars -> Dictionary new}! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:52'!(Self) emptyVariableDictionaryInClass: (ClassDescription) aClass	|(Dictionary)dict|	dict := classes at: aClass ifAbsent: [^self].	dict at: #cvars put: Dictionary new.	dict at: #ivars put: Dictionary new.! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/30/2012 17:13'!(TypeEnvironment) getRawTypeEnvironmentFor: (Class) aClass	|(TypeEnvironment)res |	res := classEnvironments at: aClass name ifAbsent:[^nil].	^res.! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/28/2012 16:45'!(TypeEnvironment) getTypeEnvironmentFor: (Class) aClass	|(TypeEnvironment)res  (TypeEnvironment)parentEnv|	parentEnv := aClass					ifNil: [TypeEnvironment globalEnvironment]					ifNotNil: [self getTypeEnvironmentFor: (<Class>aClass superclass)].	res := classEnvironments at: aClass name ifAbsent:[^parentEnv].	res parent: parentEnv.	^res.! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/21/2012 11:28'!(Self) initialize	classes := IdentityDictionary new.	aliases := IdentityDictionary new.	classEnvironments := IdentityDictionary new.! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/15/2012 14:39'!(Self) name: (Symbol) name aliasTo: (Type) toAlias		aliases at: name put: toAlias	 ! !!TypeDictionary methodsFor: 'as yet unclassified'!(Self) putTypeEnvironment: (TypeEnvironment) typeEnv for: (Class) aClass	^classEnvironments at: aClass name put: typeEnv.! !!TypeDictionary methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/21/2012 11:30'!(Self) specialInitialize	classEnvironments := IdentityDictionary new.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TypeDictionary class	uses: TTyped classTrait	instanceVariableNames: '(TypeDictionary)uniqueInstance'!!TypeDictionary class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/12/2011 17:50'!(Self) initialize	OTCSupport bootstrapping ifFalse: [^self].	uniqueInstance := self new.! !!TypeDictionary class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 10:59'!(TypeDictionary) uniqueInstance	^uniqueInstance! !Object subclass: #TypeEnvironment	instanceVariableNames: 'dictionary parent pvar'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!TypeEnvironment methodsFor: 'accessing' stamp: 'EstebanAllende 3/21/2012 23:08'!define: aSymbol as: aType	((dictionary == Smalltalk) or: [dictionary == TypeDictionary uniqueInstance aliasDictionary]) ifTrue: [Error signal: 'Cannot make definitions in global type environments'].	dictionary at: aSymbol put: aType.	! !!TypeEnvironment methodsFor: 'accessing'!dictionary: anObject	dictionary := anObject! !!TypeEnvironment methodsFor: 'accessing' stamp: 'EstebanAllende 3/15/2012 15:20'!lookupType: aSymbol		|res|	res := dictionary at: aSymbol ifAbsent: [ ^parent ifNil:[nil] ifNotNil: [parent lookupType: aSymbol]].	^res asType.	! !!TypeEnvironment methodsFor: 'accessing'!parent	^ parent! !!TypeEnvironment methodsFor: 'accessing'!parent: anObject	parent := anObject! !!TypeEnvironment methodsFor: 'accessing'!pvar	^ pvar! !!TypeEnvironment methodsFor: 'accessing'!pvar: anObject	pvar := anObject! !!TypeEnvironment methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/21/2012 22:49'!initialize	dictionary := Dictionary new.	parent := nil.	pvar := ''.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TypeEnvironment class	instanceVariableNames: 'globalEnvironment nominalEnvironment'!!TypeEnvironment class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/21/2012 23:02'!globalEnvironment	globalEnvironment ifNil: [		globalEnvironment := self basicNew.		globalEnvironment parent: self nominalEnvironment.		globalEnvironment dictionary: TypeDictionary uniqueInstance aliasDictionary.		globalEnvironment pvar: ''.	].	^globalEnvironment.! !!TypeEnvironment class methodsFor: 'as yet unclassified'!initialize	globalEnvironment := nil.	nominalEnvironment := nil.! !!TypeEnvironment class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/21/2012 23:02'!nominalEnvironment	nominalEnvironment ifNil: [		nominalEnvironment := self basicNew.		nominalEnvironment parent: nil.		nominalEnvironment dictionary: Smalltalk.		nominalEnvironment pvar: ''.	].	^nominalEnvironment.! !Object subclass: #MethodDeclaration	uses: TTyped	instanceVariableNames: '(Type)type (Symbol)access'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:00'!(Symbol) access	^ access! !!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:00'!(Self) access: (Symbol) anObject	access := anObject! !!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:00'!(Self) initialize	access := #public! !!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:01'!(Type) type	^ type! !!MethodDeclaration methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:01'!(Self) type: (Type) anObject	type := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MethodDeclaration class	uses: TTyped classTrait	instanceVariableNames: ''!Object subclass: #Type	uses: TTyped	instanceVariableNames: '(OrderedCollection)classParametrics'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!Type methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/7/2011 11:19'!(Boolean) isDyn	^false! !!Type methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/7/2011 11:19'!(Boolean) isLambda	^false! !!Type methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/7/2011 11:19'!(Boolean) isNominal	^false! !!Type methodsFor: '*typesystem-types'!(Boolean) isParametric	^false! !!Type methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/7/2011 11:20'!(Boolean) isSelf	^false! !!Type methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/7/2011 11:20'!(Boolean) isStructural	^false! !!Type methodsFor: '*typesystem-types'!(Boolean) isUnion	^false! !!Type methodsFor: 'accessing' stamp: 'EstebanAllende 3/20/2012 18:30'!(OrderedCollection) classParametrics	^ classParametrics! !!Type methodsFor: 'accessing' stamp: 'EstebanAllende 3/20/2012 18:46'!(Self) classParametrics: (OrderedCollection)anObject		classParametrics := anObject! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/15/2011 12:25'!(Boolean) = another       |(Type)a (Type)b ({simplify (→Type)})c|       another ifNil: [^false].       a:= self simplify.       [c := another] on: CastError do: [:ex | ^ false].       b:= c simplify.       ^[a typeEquality: b] on: CastError do: [:ex | false]! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/28/2012 19:22'!(Self) addAlias: (Symbol) alias	TypeDictionary uniqueInstance name: alias aliasTo: self.! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/23/2011 12:02'!(Type) annotateSelfWith: (ClassDescription)aClass inMethod: (MethodSignature) aMethodSignature withKind: (Symbol) aSymbol	^self subclassResponsibility! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/28/2012 15:16'!(NominalType) asNominalType	^nil! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/21/2012 14:29'!(String) asString	(classParametrics isNil or: [classParametrics size = 0])		ifTrue: [^self baseString]		ifFalse: [^self baseString,'<',(', ' join: classParametrics),'>']! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 1/26/2012 14:43'!(StructuralType) asStructuralType	^nil! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/27/2012 11:44'!(Self) asType	^self! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/27/2012 11:44'!(String) baseString		^self subclassResponsibility! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/6/2011 23:08'!(Type) classType	^self subclassResponsibility! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/27/2012 11:59'!(Self) generateDictionaryWith: (Type) aType andDictionary: (Dictionary) dict	"aType isSubtype."	classParametrics ifNil:[^self].	(classParametrics size = aType classParametrics size) ifFalse: [ResolveError signal: 'Incorrect numbers of generics between (', self asString,') and (',aType asString,')'].	classParametrics with: aType classParametrics do: [:(Type)each :(Type)another| each generateDictionaryWith: another andDictionary: dict].	^self! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/6/2011 23:08'!(Integer) hash	^self subclassResponsibility! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/6/2011 23:08'!(Type) instanceType	^self subclassResponsibility! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/20/2012 13:36'!(Boolean) isCasteableTo: (Type) aType	^Type is: self casteableTo: aType! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/6/2011 23:08'!(Boolean) isConsistentSubtypeOf: (Type) aType	^Type is: self consistentSubtypeOf: aType! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/6/2011 23:08'!(Boolean) isSubtypeOf: (Type) aType	^Type is: self subtypeOf: aType! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/6/2011 23:08'!(Boolean) isType	^true! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/22/2011 12:06'!(Boolean) isValid	^self validate size = 0! !!Type methodsFor: 'as yet unclassified'!(Type) lowestCommonAncestorBetween: (Type) another	^self subclassResponsibility.! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/6/2011 23:08'!(Type) pureType	^self	! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/6/2011 23:08'!(Type) replaceSelfWith: (Type) aType	^self subclassResponsibility.! !!Type methodsFor: 'as yet unclassified'!(OrderedCollection) resolveParametricInGenericsWithReceiver: (Type)receiver andDictionary: (Dictionary) dict	^classParametrics ifNotNil: [		classParametrics collect: [:(Type)each| each resolveParametricWithReceiver: receiver andDictionary: dict].	] ifNil: [nil].! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/26/2012 16:30'!(Type) resolveParametricWith: (Type)aType andReceiver: (Type) receiver	|(Dictionary) dict|	dict := Dictionary new.	self generateDictionaryWith: aType andDictionary: dict.	^self resolveParametricWithReceiver: receiver andDictionary: dict.	! !!Type methodsFor: 'as yet unclassified'!(Type) resolveParametricWithReceiver: (Type)receiver andDictionary: (Dictionary) dict	^self subclassResponsibility.! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/21/2012 11:24'!(Type) resolveWith: (TypeEnvironment) env	classParametrics ifNotNil: [		classParametrics := classParametrics collect: [:each| each resolveWith: env].	].	^self.	! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/6/2011 23:08'!(Type) simplify	^self! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/13/2011 18:47'!(Boolean) typeEquality: (Self) another	<access: #protected>	^self subclassResponsibility.! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:49'!(Type) typeOfSelector: (Symbol)selector fromClass: (ClassDescription) requestor	^self subclassResponsibility.! !!Type methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/22/2011 12:14'!(OrderedCollection) validate	^#() asOrderedCollection! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Type class	uses: TTyped classTrait	instanceVariableNames: ''!!Type class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 02:12'!compilerContext	^OTCSupport defaultCompilerContext! !!Type class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 1/30/2012 13:52'!(Type) defaultType	^TypeConfiguration uniqueInstance defaultType! !!Type class methodsFor: 'as yet unclassified'!(Boolean) is: (Type) type1 casteableTo: (Type) type2	^TypeConfiguration uniqueInstance castingRules is: type1 relatedWith: type2.! !!Type class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 1/30/2012 14:00'!(Boolean) is: (Type) type1 consistentSubtypeOf: (Type) type2	^TypeConfiguration uniqueInstance consistentSubtypeRules is: type1 relatedWith: type2.! !!Type class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 1/30/2012 14:00'!(Boolean) is: (Type) type1 subtypeOf: (Type) type2	^TypeConfiguration uniqueInstance subtypeRules is: type1 relatedWith: type2.! !Object subclass: #TypeConfiguration	uses: TTyped	instanceVariableNames: '(Type)defaultType (RelationRules)subtypeRules (RelationRules)consistentSubtypeRules (RelationRules)castingRules (Boolean)typeTypesystem'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!TypeConfiguration methodsFor: 'accessing'!castingRules	^ castingRules! !!TypeConfiguration methodsFor: 'accessing'!castingRules: anObject	castingRules := anObject! !!TypeConfiguration methodsFor: 'accessing' stamp: 'EstebanAllende 1/30/2012 13:58'!consistentSubtypeRules	^ consistentSubtypeRules! !!TypeConfiguration methodsFor: 'accessing' stamp: 'EstebanAllende 1/30/2012 13:58'!consistentSubtypeRules: anObject	consistentSubtypeRules := anObject! !!TypeConfiguration methodsFor: 'accessing' stamp: 'EstebanAllende 1/30/2012 13:50'!(Type)defaultType	^defaultType! !!TypeConfiguration methodsFor: 'accessing' stamp: 'EstebanAllende 1/30/2012 13:53'!(Self)defaultType: (Type)aType	defaultType := aType.	PPTypedSmalltalkParser dynType: aType.! !!TypeConfiguration methodsFor: 'accessing' stamp: 'EstebanAllende 1/30/2012 13:58'!subtypeRules	^ subtypeRules! !!TypeConfiguration methodsFor: 'accessing' stamp: 'EstebanAllende 1/30/2012 13:58'!subtypeRules: anObject	subtypeRules := anObject! !!TypeConfiguration methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 02:17'!(Boolean)typeTypesystem	^ typeTypesystem! !!TypeConfiguration methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 02:17'!(Self) typeTypesystem: (Boolean)anObject	typeTypesystem := anObject! !!TypeConfiguration methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 02:17'!(Boolean) bootstrap	^OTCSupport bootstrapping.! !!TypeConfiguration methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 02:17'!(Self) bootstrap: (Boolean)aBoolean	OTCSupport bootstrapping: aBoolean.	"Must reinitialize everything after changing bootstrap variable"	PPTypedSmalltalkGrammar initialize.	PPTypedSmalltalkParser initialize.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TypeConfiguration class	uses: TTyped classTrait	instanceVariableNames: '(TypeConfiguration)uniqueInstance'!!TypeConfiguration class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/12/2011 17:50'!(Self) initialize	OTCSupport bootstrapping ifFalse: [^self].	uniqueInstance := self new.! !!TypeConfiguration class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 02:18'!(TypeConfiguration) uniqueInstance	^uniqueInstance! !TypeDictionary initialize!TypeEnvironment initialize!TypeConfiguration initialize!