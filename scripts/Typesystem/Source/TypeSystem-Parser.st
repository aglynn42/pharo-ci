Object subclass: #VariablesParser	instanceVariableNames: 'ivar cvar pvar parser class typeEnvironment parametricList'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Parser'!!VariablesParser methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 7/13/2012 13:35'!annotateVars	|dict classRef dynType|	OTCSupport bootstrapping ifTrue: [^self].	class isSymbol ifTrue: [class := Smalltalk at: class].	dict := (Smalltalk at: #TypeDictionary) uniqueInstance. 	dynType := (Smalltalk at: #Type) defaultType.	dict resetTypedClassDescription: class.	ivar do: [:var| dict class: class atInstVar: var second name putType: (var first ifNil: [dynType])].	cvar do: [:var| dict class: class atClassVar: var second name putType: (var first ifNil: [dynType])].	parametricList doWithIndex: [:pType :index| dict class: class defineParamVar: pType name withUpperBound: pType upperBound andPosition: index].! !!VariablesParser methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/2/2012 17:40'!class: aSymbol	class := aSymbol.! !!VariablesParser methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/20/2012 18:08'!cvar: aString	cvar := parser parse: aString.	(Smalltalk at: #OTCSupport) bootstrapping ifFalse:[		cvar := cvar collect: [:each| {each first ifNil: [DynType implicitInstance] ifNotNil: [each first resolveWith: typeEnvironment]. each second}].		cvar do: [:var|			var first ifNotNil: [var first isValid ifFalse: [Error signal: var first validate first messageText]].		]	].! !!VariablesParser methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/4/2012 16:16'!initialize	parser := PPTypedSmalltalkParser new classVariableParser.	cvar := #().	ivar := #().	OTCSupport bootstrapping ifFalse:[		typeEnvironment := TypeEnvironment globalEnvironment.		parametricList := #().	].		! !!VariablesParser methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/20/2012 18:08'!ivar: aString	ivar := parser parse: aString.	(Smalltalk at: #OTCSupport) bootstrapping ifFalse:[		ivar := ivar collect: [:each| {each first ifNil: [DynType implicitInstance] ifNotNil: [each first resolveWith: typeEnvironment]. each second}].		ivar do: [:var|			var first ifNotNil: [var first isValid ifFalse: [Error signal: var first validate first messageText] ].		]	].! !!VariablesParser methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 11/28/2011 01:47'!oldCvar	^' ' join: (cvar collect: [:each| each second name])! !!VariablesParser methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 11/28/2011 01:47'!oldIvar	^' ' join: (ivar collect: [:each| each second name])! !!VariablesParser methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 7/13/2012 12:38'!pvar: aString	pvar := parser parse: aString.	OTCSupport bootstrapping ifFalse:[		|oldpvar|		oldpvar := pvar.		pvar := pvar collect: [:each| {each first ifNil: [Object asType] ifNotNil: [TypeEnvironment globalEnvironment lookupType: each first name]. each second}].		pvar with: oldpvar do: [:var :ovar|			var first ifNil: [Error signal: 'Unknown class: ', ovar first name].			var first ifNotNil: [var first isValid ifFalse: [Error signal: var first validate first messageText]].		].			typeEnvironment := TypeEnvironment new.		typeEnvironment parent: TypeEnvironment globalEnvironment.		parametricList :=OrderedCollection new.		pvar do: [:var|			|pType|			pType := ParametricType new.			pType kind: #class.			pType name: var second name asSymbol.			pType upperBound: var first.			typeEnvironment define: var second name as: pType.			parametricList add: pType.		].	].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!VariablesParser class	instanceVariableNames: ''!!VariablesParser class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/28/2012 00:36'!defineOldParametric: aString inClass: aClass	|parser items typedClass localEnv classEnv|	parser := PPTypedSmalltalkParser new oldClassVariableParser.	items := parser parse: aString.	typedClass := TypeDictionary uniqueInstance getTypedClass: aClass.	typedClass oldpvar: aString.	localEnv := TypeDictionary uniqueInstance getLocalTypeEnvironmentFor: aClass.	classEnv := TypeDictionary uniqueInstance getClassTypeEnvironmentFor: aClass.	items do: [:each |		|localType classType|		localType := each second deepCopy resolveWith: localEnv.		classType := each second resolveWith: classEnv.		typedClass defineOldParamVar: each first withLocalType: localType andClassType: classType.	].! !!VariablesParser class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/27/2012 16:05'!parseOldParametric: aString inSuperclass: aClass	|parser items env|	parser := PPTypedSmalltalkParser new oldClassVariableParser.	items := parser parse: aString.	env := TypeDictionary uniqueInstance getClassTypeEnvironmentFor: aClass.	items do: [:each |		(env lookupType: each first) ifNil: [Error signal: 'Unknown old parametric variable'] .	].! !!VariablesParser class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/28/2012 13:10'!parsePragma: aString inClass: aClass	|parser tlist ntlist ctenv ltenv|	parser := PPTypedSmalltalkParser new classVariableParser.	tlist := parser parse: aString.	ltenv := TypeDictionary uniqueInstance getLocalTypeEnvironmentFor: aClass.	ctenv := TypeDictionary uniqueInstance getClassTypeEnvironmentFor: aClass.	ntlist:= tlist collect: [:each| 		{			each first ifNil: [Object asType] ifNotNil: [each first deepCopy resolveWith: ltenv].			each first ifNil: [Object asType] ifNotNil: [each first resolveWith: ctenv] . 			each second name asSymbol		}	].	ntlist with: tlist do: [:var :ovar|		var first ifNil: [Error signal: 'Unknown class: ', ovar first name].		var first ifNotNil: [var first isValid ifFalse: [Error signal: var first validate first messageText]].	].	^ntlist! !PPCompositeParser subclass: #PPBaseSmalltalkGrammar	instanceVariableNames: 'array arrayItem arrayLiteral arrayLiteralArray assignment assignmentToken binary binaryExpression binaryMessage binaryMethod binaryPragma binaryToken block blockArgument blockArguments blockArgumentsWith blockArgumentsWithout blockBody byteLiteral byteLiteralArray cascadeExpression cascadeMessage char charLiteral charToken expression falseLiteral falseToken identifier identifierToken keyword keywordExpression keywordMessage keywordMethod keywordPragma keywordToken literal message method methodDeclaration methodSequence multiword nilLiteral nilToken number numberLiteral numberToken parens period periodToken pragma pragmaMessage pragmas primary return sequence startExpression startMethod statements string stringLiteral stringToken symbol symbolLiteral symbolLiteralArray temporaries trueLiteral trueToken unary unaryExpression unaryMessage unaryMethod unaryPragma unaryToken variable'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Parser'!!PPBaseSmalltalkGrammar methodsFor: 'accessing' stamp: 'EstebanAllende 11/27/2011 18:59'!start	"Default start production."	^ startMethod! !!PPBaseSmalltalkGrammar methodsFor: 'accessing' stamp: 'EstebanAllende 11/27/2011 18:59'!startExpression	"Start production for the expression."	^ sequence end! !!PPBaseSmalltalkGrammar methodsFor: 'accessing' stamp: 'EstebanAllende 11/27/2011 18:59'!startMethod	"Start production for the method."	^ method end! !!PPBaseSmalltalkGrammar methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!array	^ ${ asParser smalltalkToken , (expression delimitedBy: periodToken) optional , $} asParser smalltalkToken! !!PPBaseSmalltalkGrammar methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!assignment	^ variable , assignmentToken! !!PPBaseSmalltalkGrammar methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!expression	^ assignment star , cascadeExpression! !!PPBaseSmalltalkGrammar methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!literal	^ numberLiteral / stringLiteral / charLiteral / arrayLiteral / byteLiteral / symbolLiteral / nilLiteral / trueLiteral / falseLiteral! !!PPBaseSmalltalkGrammar methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!message	^ keywordMessage / binaryMessage / unaryMessage! !!PPBaseSmalltalkGrammar methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!method	^ methodDeclaration , methodSequence! !!PPBaseSmalltalkGrammar methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!methodDeclaration	^ keywordMethod / unaryMethod / binaryMethod! !!PPBaseSmalltalkGrammar methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!methodSequence	^ periodToken star , pragmas , periodToken star , temporaries , periodToken star , pragmas , periodToken star , statements! !!PPBaseSmalltalkGrammar methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!parens	^ $( asParser smalltalkToken , expression , $) asParser smalltalkToken! !!PPBaseSmalltalkGrammar methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!pragma	^ $< asParser smalltalkToken , pragmaMessage , $> asParser smalltalkToken! !!PPBaseSmalltalkGrammar methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!pragmas	^ pragma star! !!PPBaseSmalltalkGrammar methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!primary	^ literal / variable / block / parens / array! !!PPBaseSmalltalkGrammar methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!return	^ $^ asParser smalltalkToken , expression! !!PPBaseSmalltalkGrammar methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!sequence	^ temporaries , periodToken star , statements! !!PPBaseSmalltalkGrammar methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!statements	^ 	(expression wrapped , (($. asParser smalltalkToken plus , statements ==> [ :nodes | nodes first , nodes last ])								/ $. asParser smalltalkToken star)			==> [ :nodes | (Array with: nodes first) , (nodes last) ])	/	(return , $. asParser smalltalkToken star			==> [ :nodes | (Array with: nodes first) , (nodes last) ])	/	($. asParser smalltalkToken star)! !!PPBaseSmalltalkGrammar methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!temporaries	^ ($| asParser smalltalkToken , variable star , $| asParser smalltalkToken) optional ==> [ :nodes | nodes ifNil: [ #() ] ]! !!PPBaseSmalltalkGrammar methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!variable	^ identifierToken! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-blocks' stamp: 'EstebanAllende 11/27/2011 18:59'!block	^ $[ asParser smalltalkToken , blockBody , $] asParser smalltalkToken! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-blocks' stamp: 'EstebanAllende 11/27/2011 18:59'!blockArgument	^ $: asParser smalltalkToken , variable! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-blocks' stamp: 'EstebanAllende 11/27/2011 18:59'!blockArguments	^ blockArgumentsWith / blockArgumentsWithout! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-blocks' stamp: 'EstebanAllende 11/27/2011 18:59'!blockArgumentsWith	^ blockArgument plus , ($| asParser smalltalkToken / ($] asParser smalltalkToken and ==> [ :node | nil ]))! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-blocks' stamp: 'EstebanAllende 11/27/2011 18:59'!blockArgumentsWithout	^ nil asParser ==> [ :nodes | Array with: #() with: nil ]! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-blocks' stamp: 'EstebanAllende 11/27/2011 18:59'!blockBody	^ blockArguments , sequence! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!arrayItem	^ literal / symbolLiteralArray / arrayLiteralArray / byteLiteralArray! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!arrayLiteral	^ '#(' asParser smalltalkToken , arrayItem star , $) asParser smalltalkToken! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!arrayLiteralArray	^ $( asParser smalltalkToken , arrayItem star , $) asParser smalltalkToken! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!byteLiteral	^ '#[' asParser smalltalkToken , numberLiteral star , $] asParser smalltalkToken! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!byteLiteralArray	^ $[ asParser smalltalkToken , numberLiteral star , $] asParser smalltalkToken! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!charLiteral	^ charToken! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!falseLiteral	^ falseToken! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!nilLiteral	^ nilToken! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!numberLiteral	^ numberToken! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!stringLiteral	^ stringToken! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!symbolLiteral	"This is totally fucked up: The Pharo compiler allows multiple #, arbitrary spaces between the # and the symbol, as well as comments inbetween. And yes, it is used."	^ $# asParser smalltalkToken plus , symbol smalltalkToken ==> [ :tokens | tokens first copyWith: tokens last ]! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!symbolLiteralArray	^ symbol smalltalkToken! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!trueLiteral	^ trueToken! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-messages' stamp: 'EstebanAllende 11/27/2011 18:59'!binaryExpression	^ unaryExpression , binaryMessage star! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-messages' stamp: 'EstebanAllende 11/27/2011 18:59'!binaryMessage	^ (binaryToken , unaryExpression) ==> [ :nodes | 		Array 			with: (Array with: nodes first)			with: (Array with: nodes second) ]! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-messages' stamp: 'EstebanAllende 11/27/2011 18:59'!cascadeExpression	^ keywordExpression , cascadeMessage star! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-messages' stamp: 'EstebanAllende 11/27/2011 18:59'!cascadeMessage	^ $; asParser smalltalkToken , message! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-messages' stamp: 'EstebanAllende 11/27/2011 18:59'!keywordExpression	^ binaryExpression , keywordMessage optional! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-messages' stamp: 'EstebanAllende 11/27/2011 18:59'!keywordMessage	^ (keywordToken , binaryExpression) plus ==> [ :nodes | 		Array 			with: (nodes collect: [ :each | each first ])			with: (nodes collect: [ :each | each second ]) ]! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-messages' stamp: 'EstebanAllende 11/27/2011 18:59'!unaryExpression	^ primary , unaryMessage star! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-messages' stamp: 'EstebanAllende 11/27/2011 18:59'!unaryMessage	^ unaryToken ==> [ :node | 		Array 			with: (Array with: node)			with: Array new ]! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-methods' stamp: 'EstebanAllende 11/27/2011 18:59'!binaryMethod	^ (binaryToken , variable) ==> [ :nodes | 		Array 			with: (Array with: nodes first)			with: (Array with: nodes second) ]! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-methods' stamp: 'EstebanAllende 11/27/2011 18:59'!keywordMethod	^ (keywordToken , variable) plus ==> [ :nodes | 		Array 			with: (nodes collect: [ :each | each first ])			with: (nodes collect: [ :each | each second ]) ]! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-methods' stamp: 'EstebanAllende 11/27/2011 18:59'!unaryMethod	^ identifierToken ==> [ :node | 		Array 			with: (Array with: node)			with: Array new ]! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-pragmas' stamp: 'EstebanAllende 11/27/2011 18:59'!binaryPragma	^ (binaryToken , arrayItem) ==> [ :nodes | 		Array 			with: (Array with: nodes first)			with: (Array with: nodes second) ]! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-pragmas' stamp: 'EstebanAllende 11/27/2011 18:59'!keywordPragma	^ (keywordToken , arrayItem) plus ==> [ :nodes | 		Array 			with: (nodes collect: [ :each | each first ])			with: (nodes collect: [ :each | each second ]) ]! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-pragmas' stamp: 'EstebanAllende 11/27/2011 18:59'!pragmaMessage	^ keywordPragma / unaryPragma / binaryPragma! !!PPBaseSmalltalkGrammar methodsFor: 'grammar-pragmas' stamp: 'EstebanAllende 11/27/2011 18:59'!unaryPragma	^ identifierToken ==> [ :node | 		Array 			with: (Array with: node)			with: (Array new) ]! !!PPBaseSmalltalkGrammar methodsFor: 'parsing' stamp: 'EstebanAllende 11/27/2011 18:59'!parseExpression: aString 	^ self parseExpression: aString onError: [ :msg :pos | self error: msg ]! !!PPBaseSmalltalkGrammar methodsFor: 'parsing' stamp: 'EstebanAllende 11/27/2011 18:59'!parseExpression: aString onError: aBlock	^ startExpression parse: aString onError: aBlock! !!PPBaseSmalltalkGrammar methodsFor: 'parsing' stamp: 'EstebanAllende 11/27/2011 18:59'!parseMethod: aString 	^ self parseMethod: aString onError: [ :msg :pos | self error: msg ]! !!PPBaseSmalltalkGrammar methodsFor: 'parsing' stamp: 'EstebanAllende 11/27/2011 18:59'!parseMethod: aString onError: aBlock	^ startMethod parse: aString onError: aBlock! !!PPBaseSmalltalkGrammar methodsFor: 'primitives' stamp: 'EstebanAllende 11/27/2011 18:59'!binary	^ (PPPredicateObjectParser anyOf: '!!%&*+,-/<=>?@\|~') plus! !!PPBaseSmalltalkGrammar methodsFor: 'primitives' stamp: 'EstebanAllende 11/27/2011 18:59'!char	^ $$ asParser , #any asParser! !!PPBaseSmalltalkGrammar methodsFor: 'primitives' stamp: 'EstebanAllende 11/27/2011 18:59'!identifier	^ self class allowUnderscoreAssignment		ifTrue: [ #letter asParser , #word asParser star ]		ifFalse: [			(PPPredicateObjectParser				on: [ :each | each isLetter or: [ each = $_ ] ]				message: 'letter expected') ,			(PPPredicateObjectParser				on: [ :each | each isAlphaNumeric or: [ each = $_ ] ]				message: 'letter or digit expected') star ]! !!PPBaseSmalltalkGrammar methodsFor: 'primitives' stamp: 'EstebanAllende 11/27/2011 18:59'!keyword	^ identifier , $: asParser! !!PPBaseSmalltalkGrammar methodsFor: 'primitives' stamp: 'EstebanAllende 11/27/2011 18:59'!multiword	^ keyword plus! !!PPBaseSmalltalkGrammar methodsFor: 'primitives' stamp: 'EstebanAllende 11/27/2011 18:59'!number	^ ($- asParser optional , #digit asParser) and , [ :stream | 		[ Number readFrom: stream ] 			on: Error			do: [ :err | PPFailure message: err messageText at: stream position ] ] 				asParser! !!PPBaseSmalltalkGrammar methodsFor: 'primitives' stamp: 'EstebanAllende 11/27/2011 18:59'!period	^ $. asParser! !!PPBaseSmalltalkGrammar methodsFor: 'primitives' stamp: 'EstebanAllende 11/27/2011 18:59'!string	^ $' asParser , ('''''' asParser / $' asParser negate) star , $' asParser! !!PPBaseSmalltalkGrammar methodsFor: 'primitives' stamp: 'EstebanAllende 11/27/2011 18:59'!symbol	^ unary / binary / multiword / string! !!PPBaseSmalltalkGrammar methodsFor: 'primitives' stamp: 'EstebanAllende 11/27/2011 18:59'!unary	^ identifier , $: asParser not! !!PPBaseSmalltalkGrammar methodsFor: 'token' stamp: 'EstebanAllende 11/27/2011 18:59'!assignmentToken	^ self class allowUnderscoreAssignment		ifTrue: [ (':=' asParser / '_' asParser) smalltalkToken ]		ifFalse: [ ':=' asParser smalltalkToken ]! !!PPBaseSmalltalkGrammar methodsFor: 'token' stamp: 'EstebanAllende 11/27/2011 18:59'!binaryToken	^ binary smalltalkToken! !!PPBaseSmalltalkGrammar methodsFor: 'token' stamp: 'EstebanAllende 11/27/2011 18:59'!charToken	^ char smalltalkToken! !!PPBaseSmalltalkGrammar methodsFor: 'token' stamp: 'EstebanAllende 11/27/2011 18:59'!falseToken	^ ('false' asParser , #word asParser not) smalltalkToken! !!PPBaseSmalltalkGrammar methodsFor: 'token' stamp: 'EstebanAllende 11/27/2011 18:59'!identifierToken	^ identifier smalltalkToken! !!PPBaseSmalltalkGrammar methodsFor: 'token' stamp: 'EstebanAllende 11/27/2011 18:59'!keywordToken	^ keyword smalltalkToken! !!PPBaseSmalltalkGrammar methodsFor: 'token' stamp: 'EstebanAllende 11/27/2011 18:59'!nilToken	^ ('nil' asParser , #word asParser not) smalltalkToken! !!PPBaseSmalltalkGrammar methodsFor: 'token' stamp: 'EstebanAllende 11/27/2011 18:59'!numberToken	^ number smalltalkToken! !!PPBaseSmalltalkGrammar methodsFor: 'token' stamp: 'EstebanAllende 11/27/2011 18:59'!periodToken	^ period smalltalkToken! !!PPBaseSmalltalkGrammar methodsFor: 'token' stamp: 'EstebanAllende 11/27/2011 18:59'!stringToken	^ string smalltalkToken! !!PPBaseSmalltalkGrammar methodsFor: 'token' stamp: 'EstebanAllende 11/27/2011 18:59'!trueToken	^ ('true' asParser , #word asParser not) smalltalkToken! !!PPBaseSmalltalkGrammar methodsFor: 'token' stamp: 'EstebanAllende 11/27/2011 18:59'!unaryToken	^ unary smalltalkToken! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPBaseSmalltalkGrammar class	instanceVariableNames: ''!!PPBaseSmalltalkGrammar class methodsFor: 'accessing' stamp: 'EstebanAllende 11/27/2011 18:59'!parseExpression: aString	^ self new parseExpression: aString! !!PPBaseSmalltalkGrammar class methodsFor: 'accessing' stamp: 'EstebanAllende 11/27/2011 18:59'!parseExpression: aString onError: aBlock	^ self new parseExpression: aString onError: aBlock! !!PPBaseSmalltalkGrammar class methodsFor: 'accessing' stamp: 'EstebanAllende 11/27/2011 18:59'!parseMethod: aString	^ self new parseMethod: aString! !!PPBaseSmalltalkGrammar class methodsFor: 'accessing' stamp: 'EstebanAllende 11/27/2011 18:59'!parseMethod: aString onError: aBlock	^ self new parseMethod: aString onError: aBlock! !!PPBaseSmalltalkGrammar class methodsFor: 'testing' stamp: 'EstebanAllende 11/27/2011 18:59'!allowUnderscoreAssignment	^ Scanner allowUnderscoreAsAssignment! !PPBaseSmalltalkGrammar subclass: #PPTypedSmalltalkGrammar	instanceVariableNames: 'type parenType cast'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Parser'!!PPTypedSmalltalkGrammar methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 11/27/2011 19:30'!parenType	^ self class parenType.! !!PPTypedSmalltalkGrammar methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 11/27/2011 19:30'!type	^ self class type.! !!PPTypedSmalltalkGrammar methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 19:59'!classVariableGrammar	^  (parenType optional , variable) star ! !!PPTypedSmalltalkGrammar methodsFor: 'grammar' stamp: 'EstebanAllende 6/27/2012 15:48'!oldClassVariableGrammar	^  (variable, ':=' asParser smalltalkToken , type) star ! !!PPTypedSmalltalkGrammar methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 19:59'!parens	^ $( asParser smalltalkToken , cast optional, expression , $) asParser smalltalkToken! !!PPTypedSmalltalkGrammar methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 20:00'!temporaries	^ ($| asParser smalltalkToken , (parenType optional, variable) star , $| asParser smalltalkToken) optional		==> [:nodes | nodes				ifNil: [#()]]! !!PPTypedSmalltalkGrammar methodsFor: 'grammar-methods' stamp: 'EstebanAllende 11/27/2011 19:58'!binaryMethod	^ parenType optional , binaryToken , parenType optional , variable		==> [:nodes | Array				with: (Array with: nodes second)				with: (Array with: nodes fourth)				with: {nodes third}				with: (nodes first)]! !!PPTypedSmalltalkGrammar methodsFor: 'grammar-methods' stamp: 'EstebanAllende 11/27/2011 19:57'!keywordMethod	^ parenType optional , (keywordToken , parenType optional , variable) plus		==> [:nodes | Array				with: (nodes second						collect: [:each | each first])				with: (nodes second						collect: [:each | each third])				with: (nodes second						collect: [:each | each second])				with: (nodes first)]! !!PPTypedSmalltalkGrammar methodsFor: 'grammar-methods' stamp: 'EstebanAllende 11/27/2011 19:56'!unaryMethod	^ parenType optional, identifierToken		==> [:nodes | Array				with: (Array with: nodes second)				with: Array new				with: Array new				with: (nodes first)]! !!PPTypedSmalltalkGrammar methodsFor: 'grammar-types' stamp: 'EstebanAllende 11/27/2011 19:48'!blockArgument	^ $: asParser smalltalkToken , parenType optional, variable! !!PPTypedSmalltalkGrammar methodsFor: 'grammar-types' stamp: 'EstebanAllende 11/27/2011 19:47'!cast	^$< asParser smalltalkToken, type, $> asParser smalltalkToken! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPTypedSmalltalkGrammar class	instanceVariableNames: 'typeGrammar parenToken parenType castBracketType bootstrapType'!!PPTypedSmalltalkGrammar class methodsFor: 'accessing' stamp: 'EstebanAllende 11/27/2011 19:15'!typeGrammar	^ typeGrammar! !!PPTypedSmalltalkGrammar class methodsFor: 'accessing' stamp: 'EstebanAllende 11/27/2011 20:58'!typeGrammar: anObject	typeGrammar := anObject.	self initialize.! !!PPTypedSmalltalkGrammar class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 11/28/2011 15:14'!bootstrapType	^((parenToken negate star), (parenType / castBracketType / '->' asParser)) star, (parenToken negate star)	! !!PPTypedSmalltalkGrammar class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 11/27/2011 20:47'!castBracketType	^$< asParser, self type, $> asParser! !!PPTypedSmalltalkGrammar class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 11/28/2011 12:06'!initialize	bootstrapType := PPUnresolvedParser new.	parenToken := PPUnresolvedParser new.	castBracketType := PPUnresolvedParser new.	parenType := PPUnresolvedParser new.	bootstrapType def: self bootstrapType.	parenToken def: self parenToken.	castBracketType def: self castBracketType.	parenType def: self parenType.	! !!PPTypedSmalltalkGrammar class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 11/28/2011 15:05'!parenToken	^($( asParser / $) asParser / $< asParser / $> asParser)	! !!PPTypedSmalltalkGrammar class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 11/27/2011 19:29'!parenType	^$( asParser, self type, $) asParser! !!PPTypedSmalltalkGrammar class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/28/2012 12:21'!type	^OTCSupport bootstrapping 		ifFalse: [typeGrammar]		ifTrue: [ |tConf|			tConf := Smalltalk at: #TypeConfiguration.			tConf 				ifNil:[bootstrapType]				ifNotNil: [tConf uniqueInstance disable ifTrue: [typeGrammar] ifFalse: [bootstrapType]]		].! !PPTypedSmalltalkGrammar subclass: #PPBaseSmalltalkParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Parser'!!PPBaseSmalltalkParser methodsFor: 'accessing' stamp: 'EstebanAllende 11/27/2011 18:59'!startExpression	"Make the sequence node has a method node as its parent and that the source is set."	^ ([ :stream | stream collection ] asParser and , super startExpression) map: [ :source :node | 		(RBMethodNode selector: #doIt body: node)			source: source.		(node statements size = 1 and: [ node temporaries isEmpty ])			ifTrue: [ node statements first ]			ifFalse: [ node ] ]! !!PPBaseSmalltalkParser methodsFor: 'accessing' stamp: 'EstebanAllende 11/27/2011 18:59'!startMethod	"Make sure the method node has the source code properly set."		^ ([ :stream | stream collection ] asParser and , super startMethod)		map: [ :source :node | node source: source ]! !!PPBaseSmalltalkParser methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!array	^ super array map: [ :openNode :statementNodes :closeNode |		(self buildArray: statementNodes)			left: openNode start;			right: closeNode start;			yourself ]! !!PPBaseSmalltalkParser methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!expression	^ super expression map: [ :variableNodes :expressionNodes | self build: expressionNodes assignment: variableNodes ]! !!PPBaseSmalltalkParser methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!method	^ super method map: [ :methodNode :bodyNode | 		methodNode pragmas: bodyNode first.		methodNode body: bodyNode second.		self buildMethod: methodNode ]! !!PPBaseSmalltalkParser methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!methodSequence	^ super methodSequence map: [ :periodNodes1 :pragmaNodes1 :periodNodes2 :tempNodes :periodNodes3 :pragmaNodes2 :periodNodes4 :statementNodes |		Array			with: pragmaNodes1 , pragmaNodes2			with: (self build: tempNodes sequence: periodNodes1 , periodNodes2 , periodNodes3 , periodNodes4 , statementNodes) ]! !!PPBaseSmalltalkParser methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!pragma	^ super pragma ==> [ :nodes | 		(RBPragmaNode selectorParts: nodes second first arguments: nodes second second)			addComments: nodes first comments;			addComments: nodes last comments;			left: nodes first start;			right: nodes last start;			yourself ]! !!PPBaseSmalltalkParser methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!return	^ super return map: [ :token :expressionNode | RBReturnNode return: token start value: expressionNode ]! !!PPBaseSmalltalkParser methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!sequence	^ super sequence map: [ :tempNodes :periodNodes :statementNodes | self build: tempNodes sequence: periodNodes , statementNodes ]! !!PPBaseSmalltalkParser methodsFor: 'grammar' stamp: 'EstebanAllende 11/27/2011 18:59'!variable	^ super variable ==> [ :token | RBVariableNode identifierToken: token ]! !!PPBaseSmalltalkParser methodsFor: 'grammar-blocks' stamp: 'EstebanAllende 11/27/2011 18:59'!block	^ super block map: [ :leftToken :blockNode :rightToken | blockNode left: leftToken start; right: rightToken start ]! !!PPBaseSmalltalkParser methodsFor: 'grammar-blocks' stamp: 'EstebanAllende 11/27/2011 18:59'!blockBody	^ super blockBody ==> [ :nodes | 		| result |		result := RBBlockNode arguments: nodes first first body: nodes last.		nodes first last isNil			ifFalse: [ result bar: nodes first last start ].		result ]! !!PPBaseSmalltalkParser methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!arrayLiteral	^ super arrayLiteral ==> [ :nodes | RBLiteralArrayNode startPosition: nodes first start contents: nodes second stopPosition: nodes last start isByteArray: false ]! !!PPBaseSmalltalkParser methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!arrayLiteralArray	^ super arrayLiteralArray ==> [ :nodes | RBLiteralArrayNode startPosition: nodes first start contents: nodes second stopPosition: nodes last start isByteArray: false ]! !!PPBaseSmalltalkParser methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!byteLiteral	^ super byteLiteral ==> [ :nodes | RBLiteralArrayNode startPosition: nodes first start contents: nodes second stopPosition: nodes last start isByteArray: true ]! !!PPBaseSmalltalkParser methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!byteLiteralArray	^ super byteLiteralArray ==> [ :nodes | RBLiteralArrayNode startPosition: nodes first start contents: nodes second stopPosition: nodes last start isByteArray: true ]! !!PPBaseSmalltalkParser methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!charLiteral	^ super charLiteral ==> [ :token | RBLiteralValueNode literalToken: (RBLiteralToken value: token value second start: token start stop: token stop) ]! !!PPBaseSmalltalkParser methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!falseLiteral	^ super falseLiteral ==> [ :token | RBLiteralValueNode literalToken: (RBLiteralToken value: false start: token start stop: token stop) ]! !!PPBaseSmalltalkParser methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!nilLiteral	^ super nilLiteral ==> [ :token | RBLiteralValueNode literalToken: (RBLiteralToken value: nil start: token start stop: token stop) ]! !!PPBaseSmalltalkParser methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!numberLiteral	^ super numberLiteral ==> [ :token | RBLiteralValueNode literalToken: (RBNumberLiteralToken value: (Number readFrom: token value) start: token start stop: token stop source: token value) ]! !!PPBaseSmalltalkParser methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!stringLiteral	^ super stringLiteral ==> [ :token | RBLiteralValueNode literalToken: (RBLiteralToken value: (self buildString: token value) start: token start stop: token stop) ]! !!PPBaseSmalltalkParser methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!symbolLiteral	^ super symbolLiteral ==> [ :tokens | RBLiteralValueNode literalToken: (RBLiteralToken value: (self buildString: tokens last value) asSymbol start: tokens first start stop: tokens last stop) ]! !!PPBaseSmalltalkParser methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!symbolLiteralArray	^ super symbolLiteralArray ==> [ :token | RBLiteralValueNode literalToken: (RBLiteralToken value: (self buildString: token value) asSymbol start: token start stop: token stop) ]! !!PPBaseSmalltalkParser methodsFor: 'grammar-literals' stamp: 'EstebanAllende 11/27/2011 18:59'!trueLiteral	^ super trueLiteral ==> [ :token | RBLiteralValueNode literalToken: (RBLiteralToken value: true start: token start stop: token stop) ]! !!PPBaseSmalltalkParser methodsFor: 'grammar-messages' stamp: 'EstebanAllende 11/27/2011 18:59'!binaryExpression	^ super binaryExpression map: [ :receiverNode :messageNodes | self build: receiverNode messages: messageNodes ]! !!PPBaseSmalltalkParser methodsFor: 'grammar-messages' stamp: 'EstebanAllende 11/27/2011 18:59'!cascadeExpression	^ super cascadeExpression map: [ :receiverNode :messageNodes | self build: receiverNode cascade: messageNodes ]! !!PPBaseSmalltalkParser methodsFor: 'grammar-messages' stamp: 'EstebanAllende 11/27/2011 18:59'!keywordExpression	^ super keywordExpression map: [ :receiveNode :messageNode | self build: receiveNode messages: (Array with: messageNode) ]! !!PPBaseSmalltalkParser methodsFor: 'grammar-messages' stamp: 'EstebanAllende 11/27/2011 18:59'!unaryExpression	^ super unaryExpression map: [ :receiverNode :messageNodes | self build: receiverNode messages: messageNodes ]! !!PPBaseSmalltalkParser methodsFor: 'private' stamp: 'EstebanAllende 11/27/2011 18:59'!addStatements: aCollection into: aNode	aCollection isNil 		ifTrue: [ ^ aNode ].	aCollection do: [ :each |		each class == PPSmalltalkToken			ifFalse: [ aNode addNode:  each ]			ifTrue: [				aNode statements isEmpty					ifTrue: [ aNode addComments: each comments ]					ifFalse: [ aNode statements last addComments: each comments ].				aNode periods: (aNode periods asOrderedCollection					addLast: each start;					yourself) ] ].	^ aNode! !!PPBaseSmalltalkParser methodsFor: 'private' stamp: 'EstebanAllende 11/27/2011 18:59'!build: aNode assignment: anArray	^ anArray isEmpty		ifTrue: [ aNode ]		ifFalse: [			anArray reverse 				inject: aNode				into: [ :result :each |					RBAssignmentNode 						variable: each first						value: result						position: each second start ] ]! !!PPBaseSmalltalkParser methodsFor: 'private' stamp: 'EstebanAllende 11/27/2011 18:59'!build: aNode cascade: anArray 	| messages semicolons |	^ (anArray isNil or: [ anArray isEmpty ]) 		ifTrue: [ aNode ]		ifFalse: [			messages := OrderedCollection new: anArray size + 1.			messages addLast: aNode.			semicolons := OrderedCollection new.			anArray do: [ :each | 				messages addLast: (self 					build: aNode receiver					messages: (Array with: each second)).				semicolons addLast: each first start ].			RBCascadeNode messages: messages semicolons: semicolons ]! !!PPBaseSmalltalkParser methodsFor: 'private' stamp: 'EstebanAllende 11/27/2011 18:59'!build: aNode messages: anArray 	^ (anArray isNil or: [ anArray isEmpty ]) 		ifTrue: [ aNode ]		ifFalse: [			anArray 				inject: aNode				into: [ :rec :msg | 					msg isNil 						ifTrue: [ rec ]						ifFalse: [							RBMessageNode 								receiver: rec								selectorParts: msg first								arguments: msg second ] ] ]! !!PPBaseSmalltalkParser methodsFor: 'private' stamp: 'EstebanAllende 11/27/2011 18:59'!build: aTempCollection sequence: aStatementCollection	| result |	result := self		addStatements: aStatementCollection		into: RBSequenceNode new.	aTempCollection isEmpty ifFalse: [		result			leftBar: aTempCollection first start			temporaries: aTempCollection second			rightBar: aTempCollection last start ].	^ result! !!PPBaseSmalltalkParser methodsFor: 'private' stamp: 'EstebanAllende 11/27/2011 18:59'!buildArray: aStatementCollection	^ self addStatements: aStatementCollection into: RBArrayNode new! !!PPBaseSmalltalkParser methodsFor: 'private' stamp: 'EstebanAllende 11/27/2011 18:59'!buildMethod: aMethodNode	aMethodNode selectorParts 		do: [ :each | aMethodNode addComments: each comments ].	aMethodNode arguments		do: [ :each | aMethodNode addComments: each token comments ].	aMethodNode pragmas do: [ :pragma |		aMethodNode addComments: pragma comments.		pragma selectorParts 			do: [ :each | aMethodNode addComments: each comments ].		pragma arguments do: [ :each | 			each isLiteralArray				ifFalse: [ aMethodNode addComments: each token comments ] ].		pragma comments: nil ].	^ aMethodNode! !!PPBaseSmalltalkParser methodsFor: 'private' stamp: 'EstebanAllende 11/27/2011 18:59'!buildString: aString 	(aString isEmpty or: [ aString first ~= $' or: [ aString last ~= $' ] ])		ifTrue: [ ^ aString ].	^ (aString 		copyFrom: 2		to: aString size - 1) 		copyReplaceAll: ''''''		with: ''''! !PPBaseSmalltalkParser subclass: #PPTypedSmalltalkParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Parser'!!PPTypedSmalltalkParser methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/6/2011 22:12'!blockArgument	^ super blockArgument		==> [:nodes | nodes third propertyAt: #type put: (nodes second ifNil: [PPTypedSmalltalkParser dynType]) ; yourself]! !!PPTypedSmalltalkParser methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/6/2011 16:46'!build: aTempCollection sequence: aStatementCollection	| result |	result := self		addStatements: aStatementCollection		into: RBSequenceNode new.	aTempCollection isEmpty ifFalse: [		result			leftBar: aTempCollection first start			temporaries: (aTempCollection second collect: [:nodes | nodes second propertyAt:#type put: (nodes first ifNil:[PPTypedSmalltalkParser dynType]); yourself]) 			rightBar: aTempCollection last start ].	^ result! !!PPTypedSmalltalkParser methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 11/27/2011 20:10'!cast	^ super cast ==> [:nodes| {nodes second. nodes first start. nodes last stop}]! !!PPTypedSmalltalkParser methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 11/27/2011 20:23'!classVariableParser	^ super classVariableGrammar! !!PPTypedSmalltalkParser methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 11/27/2011 20:13'!methodDeclaration	^ super methodDeclaration		==> [:nodes | RBMethodNode selectorParts: nodes first arguments: nodes second paramTypes: nodes third returnType:  nodes fourth]! !!PPTypedSmalltalkParser methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/27/2012 15:49'!oldClassVariableParser	^ super oldClassVariableGrammar ==> [:nodes| nodes collect: [:each| {each first name asSymbol. each third}]].! !!PPTypedSmalltalkParser methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 11/27/2011 20:15'!parenType	^ super parenType ==> [:nodes |		"|parenList|		parenList := nodes second parens.		parenList addFirst: nodes first.		parenList addLast: nodes last."		nodes second 		]! !!PPTypedSmalltalkParser methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 16:59'!parens	^ super parens		map: [:openToken :castExpr :expressionNode :closeToken | 			expressionNode				addParenthesis: (openToken start to: closeToken start).			castExpr ifNotNil: [				 CastExpr addCast: (CastExpr explicitToType: castExpr first) to: expressionNode].			expressionNode]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPTypedSmalltalkParser class	instanceVariableNames: 'typeParser dynType'!!PPTypedSmalltalkParser class methodsFor: 'accessing' stamp: 'EstebanAllende 11/27/2011 19:17'!dynType	^ dynType! !!PPTypedSmalltalkParser class methodsFor: 'accessing' stamp: 'EstebanAllende 11/27/2011 19:17'!dynType: anObject	dynType := anObject! !!PPTypedSmalltalkParser class methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 00:44'!initialize	super initialize.	dynType ifNil: [dynType := Object].! !!PPTypedSmalltalkParser class methodsFor: 'accessing' stamp: 'EstebanAllende 6/28/2012 11:58'!type	^OTCSupport bootstrapping 		ifFalse: [typeParser]		ifTrue: [ |tConf|			tConf := Smalltalk at: #TypeConfiguration.			tConf 				ifNil:[bootstrapType]				ifNotNil: [tConf uniqueInstance disable ifTrue: [typeParser] ifFalse: [bootstrapType]]		].! !!PPTypedSmalltalkParser class methodsFor: 'accessing' stamp: 'EstebanAllende 11/27/2011 19:15'!typeParser	^ typeParser! !!PPTypedSmalltalkParser class methodsFor: 'accessing' stamp: 'EstebanAllende 11/27/2011 19:15'!typeParser: anObject	typeParser := anObject! !PPSmalltalkToken subclass: #PPSpecialSmalltalkToken	instanceVariableNames: 'tokens'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Parser'!!PPSpecialSmalltalkToken methodsFor: 'accessing' stamp: 'EstebanAllende 11/27/2011 19:53'!tokens	^ tokens! !!PPSpecialSmalltalkToken methodsFor: 'accessing' stamp: 'EstebanAllende 11/27/2011 19:53'!tokens: anObject	tokens := anObject! !!PPSpecialSmalltalkToken methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 11/27/2011 19:51'!collection	"Answer the underlying collection of this token."	^ tokens! !!PPSpecialSmalltalkToken methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 11/27/2011 19:51'!column	"Answer the column number of this token in the underlying collection."		| position |	position := 0.	(NewLineParser , [ :stream |		self start  <= stream position			ifTrue: [ ^ self start - position ].		position := stream position ] asParser		/ #any asParser) star			parse: tokens first collection.	 ^ self start - position! !!PPSpecialSmalltalkToken methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 11/27/2011 19:52'!length	^ tokens inject: 0 into: [:acc :each| acc + each size].! !!PPSpecialSmalltalkToken methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 11/27/2011 19:52'!line	"Answer the line number of this token in the underlying collection."		| line |	line := 1.	(NewLineParser , [ :stream |		self start <= stream position			ifTrue: [ ^ line ].		line := line + 1 ] asParser		/ #any asParser) star			parse: tokens first collection.	^ line! !!PPSpecialSmalltalkToken methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 11/27/2011 19:52'!size	"Answer the size of this token."	^ self stop - self start + 1! !!PPSpecialSmalltalkToken methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 11/27/2011 19:52'!start	"Answer the start position of this token in the underlying collection."	^ tokens first start! !!PPSpecialSmalltalkToken methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 11/27/2011 19:52'!stop	"Answer the stop position of this token in the underlying collection."		^ tokens last stop! !!PPSpecialSmalltalkToken methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 11/27/2011 19:53'!value	"Answer the contents of this token."	^ String streamContents: [ :stream |			tokens do: [:each| each collection from: each start to: each stop do: [:l| stream nextPut: l]]	 ] ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PPSpecialSmalltalkToken class	instanceVariableNames: ''!!PPSpecialSmalltalkToken class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 11/27/2011 19:54'!on: aTokens	^self basicNew tokens: aTokens! !PPTypedSmalltalkGrammar initialize!PPTypedSmalltalkParser initialize!