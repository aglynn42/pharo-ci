Trait named: #TTyped	uses: {}	category: 'TypeSystem-Compiler'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TTyped classTrait	uses: {}!!TTyped classTrait methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 11/27/2011 21:17'!compilerContext	^OTCSupport defaultCompilerContext! !Object subclass: #CastExpr	instanceVariableNames: 'castType implicit'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Compiler'!!CastExpr methodsFor: 'accessing' stamp: 'EstebanAllende 12/5/2011 16:57'!castType	^ castType! !!CastExpr methodsFor: 'accessing' stamp: 'EstebanAllende 12/5/2011 16:57'!castType: anObject	castType := anObject! !!CastExpr methodsFor: 'accessing' stamp: 'EstebanAllende 12/5/2011 16:57'!implicit	^ implicit! !!CastExpr methodsFor: 'accessing' stamp: 'EstebanAllende 12/5/2011 16:57'!implicit: anObject	implicit := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CastExpr class	instanceVariableNames: ''!!CastExpr class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 16:58'!addCast: aCast to: aNode	|castCollection|	castCollection := aNode propertyAt: #cast ifAbsentPut: [OrderedCollection new].	aCast implicit 		ifTrue: [	castCollection addFirst: aCast.] 		ifFalse: [castCollection addLast: aCast.].! !!CastExpr class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 16:58'!explicitToType: aType	^self new castType: aType; implicit: false; yourself.! !!CastExpr class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 16:59'!toType: aType	^self new castType: aType; implicit: true; yourself.! !Object subclass: #OTCSupport	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Compiler'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OTCSupport class	instanceVariableNames: 'bootstrapping'!!OTCSupport class methodsFor: 'accessing' stamp: 'EstebanAllende 11/27/2011 20:27'!bootstrapping	^ bootstrapping ifNil: [bootstrapping := true]! !!OTCSupport class methodsFor: 'accessing' stamp: 'EstebanAllende 11/27/2011 20:26'!bootstrapping: anObject	bootstrapping := anObject! !!OTCSupport class methodsFor: 'accessing' stamp: 'EstebanAllende 12/5/2011 12:10'!defaultCompilerContext	|bool|	bool := self bootstrapping ifNil:[true].	bool ifTrue: [	^(OCCompilerContext new		parserBlock: self defaultParser;		astAnalyzerBlock: OCCompilerContext defaultASTAnalyzer;		irBuilderBlock: OCCompilerContext defaultIRBuilder;		bytecodeGeneratorBlock: OCCompilerContext defaultBytecodeGenerator;		mapperBlock: OCCompilerContext defaultMapper;		yourself).	] ifFalse: [^self defaultCompilerContextForClass: thisContext sender methodClass.]! !!OTCSupport class methodsFor: 'accessing' stamp: 'EstebanAllende 12/6/2011 23:05'!defaultCompilerContextForClass: aClass	^(OCCompilerContext new		parserBlock: self defaultParser;		astAnalyzerBlock: self defaultASTAnalyzer;		irBuilderBlock: self defaultIRBuilder;		bytecodeGeneratorBlock: OCCompilerContext defaultBytecodeGenerator;		mapperBlock: OCCompilerContext defaultMapper;		yourself).! !!OTCSupport class methodsFor: 'accessing' stamp: 'EstebanAllende 12/21/2011 17:22'!defaultIRBuilder	^[:request :methodNode | 		|ir md conf|		conf := methodNode propertyAt: #conf. 		ir := (OCASTTranslator new			visitNode: methodNode)			ir.		conf typecheck ifTrue: [			md := MethodDeclaration new.			md access: (conf access).			md type: (methodNode propertyAt: #methodType).			TypeDictionary uniqueInstance class: request target atSelector: methodNode selector putMethodDeclaration: md.			].		ir]! !!OTCSupport class methodsFor: 'accessing' stamp: 'EstebanAllende 11/27/2011 20:37'!defaultParser	^[:request | (PPTypedSmalltalkParser new) 							parse: request sourceStream contents	 						onError: [ :msg :pos | self error: msg ]].! !!OTCSupport class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/21/2012 14:29'!defaultASTAnalyzer	^[:request :methodNode | 		|conf target|		conf := ASTConfigurationAnalyzer for: methodNode.		conf typecheck ifTrue: [			ASTLinkerVisitor new setParentEnvironment: (TypeDictionary uniqueInstance getTypeEnvironmentFor: request target);visitNode: methodNode.			ASTPreprocessingVisitor new visitNode: methodNode		].		[			OCASTSemanticAnalyzer new				scope: request target parseScope;				visitNode: methodNode.		] on: OCSemanticWarning do: [:ex | ex correctIn: OCClosureCompiler new].		methodNode methodClass: request target.		conf typecheck ifTrue: [ |typechecker|			"The next lines allows us to compile correctly a recompiling class"			target := request target.			(target isKindOf: Class) ifTrue: [target := Smalltalk at: (target name asSymbol) ifAbsent:[target]].			(target isKindOf: Metaclass) ifTrue: [ |targetNonMeta| 				targetNonMeta := Smalltalk at: (target theNonMetaClass name asSymbol) ifAbsent: [nil].				target := targetNonMeta ifNil: [target] ifNotNil: [targetNonMeta class].			].			typechecker := ASTTypecheckVisitor new.			typechecker ownerClass: target; visitNode: methodNode.			typechecker informErrors.		].		OCASTClosureAnalyzer new visitNode: methodNode.		"ASTCastInsertionVisitor new ownerClass: request methodClass name; visitNode: methodNode.		OTCSupport blameLevel = #heavy ifTrue: [ASTBlameVisitor new methodClass: request methodClass; visitNode: methodNode; processQueues.].		ASTCheckVisitor new visitNode: methodNode; processQueue.""self halt."	].! !!OTCSupport class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/12/2011 17:51'!initialize	"MCVariableDefinition addInstVarNamed: #type."! !OTCSupport initialize!