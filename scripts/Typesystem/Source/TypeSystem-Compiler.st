Trait named: #TTyped	uses: {}	category: 'TypeSystem-Compiler'!!TTyped commentStamp: 'EstebanAllende 9/30/2012 23:55' prior: 0!TTyped is the trait required by all classes that use type annotations and want to be typechecked.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TTyped classTrait	uses: {}!!TTyped classTrait methodsFor: '*compiler-frontend' stamp: 'EstebanAllende 11/27/2011 21:17'!compilerContext	^OTCSupport defaultCompilerContext! !Trait named: #TUntyped	uses: {}	category: 'TypeSystem-Compiler'!!TUntyped commentStamp: 'EstebanAllende 9/30/2012 23:55' prior: 0!TUntyped is the trait that disables types and typechecking on classes. !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TUntyped classTrait	uses: {}!!TUntyped classTrait methodsFor: '*compiler-frontend' stamp: 'EstebanAllende 7/17/2012 15:18'!compilerContext	^ACCompilerContext uniqueInstance! !Object subclass: #OTCSupport	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Compiler'!!OTCSupport commentStamp: 'EstebanAllende 9/30/2012 23:53' prior: 0!OTCSupport provides the compiler context required to use the typesystem with Opal compiler.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OTCSupport class	instanceVariableNames: 'bootstrapping'!!OTCSupport class methodsFor: 'accessing' stamp: 'EstebanAllende 11/27/2011 20:27'!bootstrapping	^ bootstrapping ifNil: [bootstrapping := true]! !!OTCSupport class methodsFor: 'accessing' stamp: 'EstebanAllende 11/27/2011 20:26'!bootstrapping: anObject	bootstrapping := anObject! !!OTCSupport class methodsFor: 'compiler context' stamp: 'EstebanAllende 9/21/2012 12:46'!defaultASTAnalyzer	^[:request :methodNode | 		|conf target analisisDict classSet|		analisisDict := nil.		classSet := nil.		conf := ASTConfigurationAnalyzer for: methodNode.		conf typecheck ifTrue: [			|classDepTracker|			ASTLinkerVisitor new setParentsEnvironmentUsingClassDescription: request target;visitNode: methodNode.			classDepTracker := ASTClassDependencyVisitor new.			classDepTracker visitNode: methodNode.			classSet := classDepTracker classSet.						TypeConfiguration uniqueInstance enableAnalisis ifTrue:[ |visitor|				visitor := ASTTypeCounterVisitor new.				visitor  visitNode: methodNode.				analisisDict := visitor dictionary.			].			ASTPreprocessingVisitor new visitNode: methodNode.		].		methodNode propertyAt: #analisisDict put: analisisDict.		methodNode propertyAt: #classDep put: classSet.		[			OCASTSemanticAnalyzer new				scope: request target parseScope;				visitNode: methodNode.		] on: OCSemanticWarning do: [:ex | ex correctIn: OCClosureCompiler new].		methodNode methodClass: request target.		conf typecheck ifTrue: [ |typechecker dependencyTracker|			"The next lines allows us to compile correctly a recompiling class"			target := request target.			(target isKindOf: Class) ifTrue: [target := Smalltalk at: (target name asSymbol) ifAbsent:[target]].			(target isKindOf: Metaclass) ifTrue: [ |targetNonMeta| 				targetNonMeta := Smalltalk at: (target theNonMetaClass name asSymbol) ifAbsent: [nil].				target := targetNonMeta ifNil: [target] ifNotNil: [targetNonMeta class].			].			typechecker := ASTTypecheckVisitor new.			typechecker ignoreParent: conf ignoreParent.			typechecker ownerClass: target; visitNode: methodNode.			typechecker informErrorsNotifying: request requestor.						dependencyTracker := ASTDependencyVisitor new.			dependencyTracker ownerClass: target; visitNode: methodNode.			methodNode propertyAt: #dependencySet put: dependencyTracker dependencySet.		].		OCASTClosureAnalyzer new visitNode: methodNode.		conf typecheck ifTrue: [		ASTCastInsertionVisitor new ownerClass: request target; visitNode: methodNode."		OTCSupport blameLevel = #heavy ifTrue: [ASTBlameVisitor new methodClass: request methodClass; visitNode: methodNode; processQueues.]."		TypeConfiguration uniqueInstance enableInstrumentation ifTrue: [ ASTCheckVisitor new visitNode: methodNode; processQueue].		]."self halt."	].! !!OTCSupport class methodsFor: 'compiler context' stamp: 'EstebanAllende 12/5/2011 12:10'!defaultCompilerContext	|bool|	bool := self bootstrapping ifNil:[true].	bool ifTrue: [	^(OCCompilerContext new		parserBlock: self defaultParser;		astAnalyzerBlock: OCCompilerContext defaultASTAnalyzer;		irBuilderBlock: OCCompilerContext defaultIRBuilder;		bytecodeGeneratorBlock: OCCompilerContext defaultBytecodeGenerator;		mapperBlock: OCCompilerContext defaultMapper;		yourself).	] ifFalse: [^self defaultCompilerContextForClass: thisContext sender methodClass.]! !!OTCSupport class methodsFor: 'compiler context' stamp: 'EstebanAllende 12/6/2011 23:05'!defaultCompilerContextForClass: aClass	^(OCCompilerContext new		parserBlock: self defaultParser;		astAnalyzerBlock: self defaultASTAnalyzer;		irBuilderBlock: self defaultIRBuilder;		bytecodeGeneratorBlock: OCCompilerContext defaultBytecodeGenerator;		mapperBlock: OCCompilerContext defaultMapper;		yourself).! !!OTCSupport class methodsFor: 'compiler context' stamp: 'EstebanAllende 9/21/2012 12:49'!defaultIRBuilder	^[:request :methodNode | 		|ir md conf|		conf := methodNode propertyAt: #conf. 		ir := (OCASTTranslator new			visitNode: methodNode)			ir.		conf typecheck ifTrue: [			md := MethodDeclaration new.			md name: methodNode selector asSymbol.			md access: (conf access).			md dependencies: (methodNode propertyAt: #dependencySet).			md type: (methodNode propertyAt: #methodType).			md analisisDict: (methodNode propertyAt: #analisisDict).			md classDependencies: (methodNode propertyAt: #classDep).			TypeDictionary uniqueInstance class: request target atSelector: methodNode selector putMethodDeclaration: md.			].		ir]! !!OTCSupport class methodsFor: 'compiler context' stamp: 'EstebanAllende 11/27/2011 20:37'!defaultParser	^[:request | (PPTypedSmalltalkParser new) 							parse: request sourceStream contents	 						onError: [ :msg :pos | self error: msg ]].! !Object subclass: #CastExpr	instanceVariableNames: 'castType implicit'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Compiler'!!CastExpr commentStamp: 'EstebanAllende 9/30/2012 23:50' prior: 0!CastExpr is a structure used in the cast chain at AST nodes where it stores the type to cast and if the cast is implicit.!!CastExpr methodsFor: 'accessing' stamp: 'EstebanAllende 12/5/2011 16:57'!castType	^ castType! !!CastExpr methodsFor: 'accessing' stamp: 'EstebanAllende 12/5/2011 16:57'!castType: anObject	castType := anObject! !!CastExpr methodsFor: 'accessing' stamp: 'EstebanAllende 12/5/2011 16:57'!implicit	^ implicit! !!CastExpr methodsFor: 'accessing' stamp: 'EstebanAllende 12/5/2011 16:57'!implicit: anObject	implicit := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CastExpr class	instanceVariableNames: ''!!CastExpr class methodsFor: 'instance creation' stamp: 'EstebanAllende 12/5/2011 16:58'!explicitToType: aType	^self new castType: aType; implicit: false; yourself.! !!CastExpr class methodsFor: 'instance creation' stamp: 'EstebanAllende 12/5/2011 16:59'!toType: aType	^self new castType: aType; implicit: true; yourself.! !!CastExpr class methodsFor: 'utilities' stamp: 'EstebanAllende 12/5/2011 16:58'!addCast: aCast to: aNode	|castCollection|	castCollection := aNode propertyAt: #cast ifAbsentPut: [OrderedCollection new].	aCast implicit 		ifTrue: [	castCollection addFirst: aCast.] 		ifFalse: [castCollection addLast: aCast.].! !