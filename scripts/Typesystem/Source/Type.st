'From Pharo1.4 of 18 April 2012 [Latest update: #14438] on 1 October 2012 at 12:41:09 am'!Object subclass: #Type	uses: TTyped	instanceVariableNames: '(Collection<Type>)classParametrics (Symbol)usedAlias'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Core'!!Type commentStamp: 'EstebanAllende 9/30/2012 23:29' prior: 0!Type is the abstract root class of all types in Gradualtalk. All subclasses understand all of its messages (except UnlinkedType).!!Type methodsFor: '*typesystem-core' stamp: 'EstebanAllende 7/13/2012 14:23'!(Boolean) isType	^true! !!Type methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/7/2011 11:19'!(Boolean) isDyn	^false! !!Type methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/7/2011 11:19'!(Boolean) isLambda	^false! !!Type methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/7/2011 11:19'!(Boolean) isNominal	^false! !!Type methodsFor: '*typesystem-types'!(Boolean) isParametric	^false! !!Type methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/7/2011 11:20'!(Boolean) isSelf	^false! !!Type methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/7/2011 11:20'!(Boolean) isStructural	^false! !!Type methodsFor: '*typesystem-types' stamp: 'EstebanAllende 9/21/2012 11:52'!(Boolean) isSuper	^false! !!Type methodsFor: '*typesystem-types'!(Boolean) isUnion	^false! !!Type methodsFor: 'accessing' stamp: 'EstebanAllende 7/13/2012 14:49'!(OrderedCollection<Type>) classParametrics	^ classParametrics! !!Type methodsFor: 'accessing' stamp: 'EstebanAllende 7/13/2012 14:49'!(Self) classParametrics: (OrderedCollection<Type>)anObject		classParametrics := anObject! !!Type methodsFor: 'accessing' stamp: 'EstebanAllende 7/13/2012 14:49'!(Symbol) usedAlias	^ usedAlias! !!Type methodsFor: 'accessing' stamp: 'EstebanAllende 7/13/2012 14:49'!(Self) usedAlias: (Symbol)anObject	usedAlias := anObject! !!Type methodsFor: 'aliasing' stamp: 'EstebanAllende 9/16/2012 13:20'!(Self) addAlias: (Symbol) alias	TypeDictionary uniqueInstance name: alias aliasTo: self.! !!Type methodsFor: 'analisis' stamp: 'EstebanAllende 7/13/2012 14:20'!(Self) addCountIn: (Dictionary<Symbol, Integer>)aDictionary	|(Integer)implicitDyn (ClassDescription)classRef|	aDictionary at: #Total modify: [:(Integer)act| act +1].	classRef := self asNominalType classRef.	classRef isMeta ifTrue: [classRef := Class].	self classParametrics ifNotNil: [ 		(self classParametrics size > 0)			ifTrue: [aDictionary at: #GenericUsage modify: [:(Integer)act| act + 1]].		self classParametrics do: [:(Type)each| each addCountIn: aDictionary].		implicitDyn := ((TypeDictionary uniqueInstance getLocalParametricList: (<Class>classRef)) size) -  (self classParametrics size).		(implicitDyn > 0) ifTrue: [			aDictionary at: #ImplicitDyn modify: [:(Integer)act| act+ implicitDyn].			aDictionary at: #DynType modify: [:(Integer)act| act+ implicitDyn].			aDictionary at: #Total modify: [:(Integer)act| act + implicitDyn].		]	] ifNil: [		implicitDyn := (TypeDictionary uniqueInstance getLocalParametricList: (<Class>classRef)) size.		(implicitDyn > 0) ifTrue: [			aDictionary at: #ImplicitDyn modify: [:(Integer)act| act+ implicitDyn].			aDictionary at: #DynType modify: [:(Integer)act| act+ implicitDyn].			aDictionary at: #Total modify: [:(Integer)act| act + implicitDyn].		]	].! !!Type methodsFor: 'comparing' stamp: 'EstebanAllende 9/16/2012 19:08'!(Boolean) = (Object)another"   This method declaration is useful when cast are inserted into code. Until then, it useless.       |(Type)a (Type)b ({simplify (→Type)})c|       another ifNil: [^false].       a:= self simplify.       [c := another] on: CastError do: [:ex | ^ false].       b:= c simplify.       ^[a typeEquality: b] on: CastError do: [:ex | false]"|(Type)a (Type)b|another ifNil: [^false].another isType ifFalse: [^false].a:= self simplify.b:= (<Type>another) simplify.(a class = b class) ifFalse: [^false].^a typeEquality: b! !!Type methodsFor: 'comparing' stamp: 'EstebanAllende 7/13/2012 14:23'!(Integer) hash	^self subclassResponsibility! !!Type methodsFor: 'comparing' stamp: 'EstebanAllende 7/13/2012 14:25'!(Boolean) typeEquality: (Self) another	<access: #protected>	^self subclassResponsibility.! !!Type methodsFor: 'converting' stamp: 'EstebanAllende 7/13/2012 14:21'!(NominalType) asNominalType	^nil! !!Type methodsFor: 'converting' stamp: 'EstebanAllende 7/13/2012 14:21'!(String) asString	usedAlias notNil ifTrue: [^usedAlias asString].	(classParametrics isNil or: [classParametrics size = 0])		ifTrue: [^self baseString]		ifFalse: [^self baseString,'<',(', ' join: classParametrics),'>']! !!Type methodsFor: 'converting' stamp: 'EstebanAllende 7/13/2012 14:21'!(StructuralType) asStructuralType	^nil! !!Type methodsFor: 'converting' stamp: 'EstebanAllende 7/13/2012 14:21'!(Self) asType	^self! !!Type methodsFor: 'parallel hierarchies' stamp: 'EstebanAllende 7/13/2012 14:21'!(Type) classType	^self subclassResponsibility! !!Type methodsFor: 'parallel hierarchies' stamp: 'EstebanAllende 7/13/2012 14:23'!(Type) instanceType	^self subclassResponsibility! !!Type methodsFor: 'queries' stamp: 'EstebanAllende 7/13/2012 14:23'!(Type) lowestCommonAncestorBetween: (Type) another	^self subclassResponsibility.! !!Type methodsFor: 'queries' stamp: 'EstebanAllende 7/13/2012 14:25'!(Type) typeOfSelector: (Symbol)selector fromClass: (ClassDescription) requestor	^self subclassResponsibility.! !!Type methodsFor: 'relationships' stamp: 'EstebanAllende 7/13/2012 14:23'!(Boolean) isCasteableTo: (Type) aType	^Type is: self casteableTo: aType! !!Type methodsFor: 'relationships' stamp: 'EstebanAllende 7/13/2012 14:23'!(Boolean) isConsistentSubtypeOf: (Type) aType	^Type is: self consistentSubtypeOf: aType! !!Type methodsFor: 'relationships' stamp: 'EstebanAllende 9/13/2012 14:51'!(Boolean) isRuntimeCasteableTo: (Type) aType	^Type is: self runtimeCasteableTo: aType! !!Type methodsFor: 'relationships' stamp: 'EstebanAllende 7/13/2012 14:23'!(Boolean) isSubtypeOf: (Type) aType	^Type is: self subtypeOf: aType! !!Type methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 14:21'!(Type) annotateSelfWith: (ClassDescription)aClass inMethod: (MethodSignature) aMethodSignature withKind: (Symbol) aSymbol	^self subclassResponsibility! !!Type methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 14:22'!(Self) generateDictionaryWith: (Type) aType andDictionary: (Dictionary<Symbol, Type>) dict	"aType isSubtype."	|(Collection<Type>)aTypeClassParametrics (Integer)min|	aType isUnion ifTrue: [		(<UnionType>aType) union do: [:(Type)each|self generateDictionaryWith: each andDictionary: dict].		^self.	].	classParametrics ifNil:[^self].	aTypeClassParametrics := aType classParametrics ifNil: [#()].	min := classParametrics size min: aTypeClassParametrics size.	1 to: classParametrics size do: [ :(Integer)i| |(Type)each|		each := classParametrics at: i.		(i <= min) 			ifTrue: [ each generateDictionaryWith: (aTypeClassParametrics at: i) andDictionary: dict]			ifFalse: [each generateDictionaryWith: DynType implicitInstance andDictionary: dict].	].	"(classParametrics size = aType classParametrics size) ifFalse: [ResolveError signal: 'Incorrect numbers of generics between (', self asString,') and (',aType asString,')'].	classParametrics with: aType classParametrics do: [:(Type)each :(Type)another| each generateDictionaryWith: another andDictionary: dict]."	^self! !!Type methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 14:23'!(Type) replaceSelfWith: (Type) aType	^self subclassResponsibility.! !!Type methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 14:23'!(Type) resolveLocalWith: (TypeEnvironment) env	^self resolveWith: env ifNotFoundStore: [:(Symbol)name| 		|(ParametricType) pRes|		pRes := ParametricType new.		pRes kind: #local.		pRes name: name.		pRes	].	! !!Type methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 14:24'!(OrderedCollection<Type>) resolveParametricInGenericsWithReceiver: (Type)receiver andDictionary: (Dictionary<Symbol, Type>) dict	^classParametrics ifNotNil: [		classParametrics collect: [:(Type)each| each resolveParametricWithReceiver: receiver andDictionary: dict].	] ifNil: [nil].! !!Type methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 14:25'!(Type) resolveParametricWith: (Type)aType andReceiver: (Type) receiver	|(Dictionary<Symbol, Integer>) dict|	dict := Dictionary new.	dict at: #rcv put: receiver.	self generateDictionaryWith: aType andDictionary: dict.	^self resolveParametricWithReceiver: receiver andDictionary: dict.	! !!Type methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 14:25'!(Type) resolveParametricWithReceiver: (Type)receiver andDictionary: (Dictionary<Symbol, Type>) dict	^self subclassResponsibility.! !!Type methodsFor: 'type resolution' stamp: 'EstebanAllende 6/19/2012 18:04'!(Type) resolveWith: (TypeEnvironment) env	^self resolveWith: env ifNotFoundStore: [:(Symbol)name| 		|(ParametricType) pRes|		pRes := ParametricType new.		env local ifTrue: [pRes kind: #local] ifFalse: [pRes kind: #method].		pRes name: name.		pRes	].! !!Type methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 14:25'!(Type) resolveWith: (TypeEnvironment) env ifNotFoundStore: (Symbol → Type) aBlock	classParametrics ifNotNil: [		classParametrics := classParametrics collect: [:(Type)each| each resolveWith: env ifNotFoundStore: aBlock].	].	^self.	! !!Type methodsFor: 'validation' stamp: 'EstebanAllende 7/13/2012 14:23'!(Boolean) isValid	^self validate size = 0! !!Type methodsFor: 'validation' stamp: 'EstebanAllende 7/13/2012 14:26'!(OrderedCollection<Error>) validate	^#() asOrderedCollection! !!Type methodsFor: 'private' stamp: 'EstebanAllende 7/13/2012 14:21'!(String) baseString		^self subclassResponsibility! !!Type methodsFor: 'private' stamp: 'EstebanAllende 7/13/2012 14:23'!(Type) pureType	^self	! !!Type methodsFor: 'private' stamp: 'EstebanAllende 7/13/2012 14:25'!(Type) simplify	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Type class	uses: TTyped classTrait	instanceVariableNames: ''!!Type class methodsFor: '*compiler-frontend' stamp: 'EstebanAllende 12/7/2011 02:12'!compilerContext	^OTCSupport defaultCompilerContext! !!Type class methodsFor: 'accessing' stamp: 'EstebanAllende 7/3/2012 18:03'!(Type) defaultType	^TypeConfiguration uniqueInstance defaultType! !!Type class methodsFor: 'relationships'!(Boolean) is: (Type) type1 casteableTo: (Type) type2	^TypeConfiguration uniqueInstance castingRules is: type1 relatedWith: type2.! !!Type class methodsFor: 'relationships' stamp: 'EstebanAllende 1/30/2012 14:00'!(Boolean) is: (Type) type1 consistentSubtypeOf: (Type) type2	^TypeConfiguration uniqueInstance consistentSubtypeRules is: type1 relatedWith: type2.! !!Type class methodsFor: 'relationships' stamp: 'EstebanAllende 9/13/2012 11:33'!(Boolean) is: (Type) type1 runtimeCasteableTo: (Type) type2	^TypeConfiguration uniqueInstance runtimeCastingRules is: type1 relatedWith: type2.! !!Type class methodsFor: 'relationships' stamp: 'EstebanAllende 1/30/2012 14:00'!(Boolean) is: (Type) type1 subtypeOf: (Type) type2	^TypeConfiguration uniqueInstance subtypeRules is: type1 relatedWith: type2.! !