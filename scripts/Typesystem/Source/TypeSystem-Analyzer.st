RBProgramNodeVisitor subclass: #ASTPreprocessingVisitor	instanceVariableNames: 'body'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Analyzer'!!ASTPreprocessingVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 15:17'!acceptBlockNode: aBlockNode 	self visitArguments: aBlockNode arguments onBody: aBlockNode body.	self visitNode: aBlockNode body! !!ASTPreprocessingVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/6/2011 17:05'!acceptMethodNode: aMethodNode 	self visitArguments: aMethodNode arguments onBody: aMethodNode body.	aMethodNode pragmas		do: [ :each | self visitNode: each ].	self visitNode: aMethodNode body	! !!ASTPreprocessingVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 13:36'!visitArgument: each onBody: aNode	"Here to allow subclasses to detect arguments or temporaries."	|newVarNode newValueNode newAssignNode|	newValueNode := (RBVariableNode named: each name) "shadowNodeOf: each".	newVarNode := (RBVariableNode named: each name) "shadowNodeOf: each".	CastExpr addCast: (CastExpr explicitToType: (each propertyAt: #localType)) to: newValueNode.	newAssignNode := (RBAssignmentNode variable: newVarNode value: newValueNode) "shadowNodeOf: each".	newAssignNode propertyAt: #argCheck put: true.	newAssignNode value propertyAt: #argCheck put: true.	aNode addNodeFirst: newAssignNode.! !!ASTPreprocessingVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 17:01'!visitArguments: aNodeCollection onBody: aNode	^aNodeCollection do: [:each | self visitArgument: each onBody: aNode]! !RBProgramNodeVisitor subclass: #ASTLinkerVisitor	instanceVariableNames: 'classTypeEnvironment localTypeEnvironment ownerClass'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Analyzer'!!ASTLinkerVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/22/2012 13:40'!acceptMethodNode: aMethodNode 	aMethodNode pragmas		do: [:each | self visitNode: each].	self visitArguments: aMethodNode arguments.	aMethodNode propertyAt: #localReturnType put: ((aMethodNode propertyAt: #returnType) deepCopy resolveWith: localTypeEnvironment).	aMethodNode propertyAt: #returnType put: ((aMethodNode propertyAt: #returnType) resolveWith: classTypeEnvironment).	self visitNode: aMethodNode body.		! !!ASTLinkerVisitor methodsFor: 'as yet unclassified'!acceptPatternBlockNode: aRBPatternBlockNode 	self halt.! !!ASTLinkerVisitor methodsFor: 'as yet unclassified'!acceptPatternWrapperBlockNode: aRBPatternWrapperBlockNode 	self halt.! !!ASTLinkerVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/22/2012 13:49'!acceptPragmaNode: aPragmaNode	|sel tlist |	sel := aPragmaNode selector.	(sel = #whereType:) 		ifTrue:[			tlist := VariablesParser parsePragma: aPragmaNode arguments first value inClass: ownerClass.			tlist do: [ :each | |localType type|				type := classTypeEnvironment lookupType: each second.				type ifNotNil: [Error signal: 'whereType: ',each second,' is not a parametric defined in a method'].				type := ParametricType new.				type kind: #method; name: each second; upperBound: each first.				classTypeEnvironment define: each second as: type.								localType := ParametricType new.				localType kind: #local; name: each second; upperBound: each first.				localTypeEnvironment define: each second as: localType.			].					]	"aPragmaNode arguments do: [ :each | self visitNode: each ]"! !!ASTLinkerVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 10:46'!initialize	classTypeEnvironment := TypeEnvironment new.	classTypeEnvironment parent: TypeEnvironment globalEnvironment.	localTypeEnvironment := TypeEnvironment new.	localTypeEnvironment parent: TypeEnvironment globalEnvironment.! !!ASTLinkerVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 10:46'!setClassParentEnvironment: aTypeEnvironment	classTypeEnvironment parent: aTypeEnvironment.! !!ASTLinkerVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 10:46'!setLocalParentEnvironment: aTypeEnvironment	localTypeEnvironment parent: aTypeEnvironment.! !!ASTLinkerVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/22/2012 13:31'!setParentsEnvironmentUsingClassDescription: aClassDescription	|aClassTypeEnvironment aLocalTypeEnvironment|	aClassTypeEnvironment := TypeDictionary uniqueInstance getClassTypeEnvironmentFor: aClassDescription.	aLocalTypeEnvironment := TypeDictionary uniqueInstance getLocalTypeEnvironmentFor: aClassDescription.	classTypeEnvironment parent: aClassTypeEnvironment.	localTypeEnvironment parent: aLocalTypeEnvironment.	localTypeEnvironment local: true.	classTypeEnvironment local: false.	ownerClass := aClassDescription! !!ASTLinkerVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/19/2012 18:04'!visitArgument: each 	"Here to allow subclasses to detect arguments or temporaries."		each propertyAt: #localType put: ((each propertyAt: #type) deepCopy resolveWith: localTypeEnvironment).	each propertyAt: #type put: ((each propertyAt: #type) resolveWith: classTypeEnvironment).! !!ASTLinkerVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 13:27'!visitNode: aNode 	|casts|	aNode acceptVisitor: self.	casts := aNode propertyAt: #cast ifAbsent: [^self].	casts := casts collect: [:each|each castType: (each castType resolveLocalWith: localTypeEnvironment)].	aNode propertyAt: #cast put: casts.	! !Object subclass: #ASTConfigurationAnalyzer	uses: TTyped	instanceVariableNames: 'node access typecheck'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Analyzer'!!ASTConfigurationAnalyzer methodsFor: 'accessing' stamp: 'EstebanAllende 12/15/2011 12:11'!(Symbol) access	^ access! !!ASTConfigurationAnalyzer methodsFor: 'accessing' stamp: 'EstebanAllende 12/15/2011 12:12'!(Self) access: (Symbol)anObject	access := anObject! !!ASTConfigurationAnalyzer methodsFor: 'accessing' stamp: 'EstebanAllende 12/15/2011 12:12'!(Self) initialize	typecheck := true.	access := #public.! !!ASTConfigurationAnalyzer methodsFor: 'accessing' stamp: 'EstebanAllende 12/15/2011 12:15'!(RBMethodNode) node	^ node! !!ASTConfigurationAnalyzer methodsFor: 'accessing' stamp: 'EstebanAllende 12/15/2011 12:15'!(Self) node: (RBMethodNode) anObject	node := anObject! !!ASTConfigurationAnalyzer methodsFor: 'accessing' stamp: 'EstebanAllende 2/20/2012 21:42'!(Boolean) typecheck	^ (TypeConfiguration uniqueInstance bootstrap not) & typecheck! !!ASTConfigurationAnalyzer methodsFor: 'accessing' stamp: 'EstebanAllende 12/15/2011 12:16'!(Self) typecheck: (Boolean)anObject	typecheck := anObject! !!ASTConfigurationAnalyzer methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/15/2011 12:17'!(Self) process	node pragmas do: [:(RBPragmaNode)each| self visitPragma: each].	^self! !!ASTConfigurationAnalyzer methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/15/2011 12:18'!(Self)visitPragma: (RBPragmaNode)pragma	|(Symbol)selector (CompiledMethod)method|	selector := pragma selector.	method := self class lookupSelector: selector.	method ifNotNil: [method valueWithReceiver: self arguments: (pragma arguments collect: [:(RBLiteralNode)each| each value])]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ASTConfigurationAnalyzer class	uses: TTyped classTrait	instanceVariableNames: ''!!ASTConfigurationAnalyzer class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/13/2011 18:49'!for: aMethodNode	|res|	res :=(self new node: aMethodNode) process.	aMethodNode propertyAt: #conf put: res.	^res! !RBProgramNodeVisitor subclass: #ASTTypecheckVisitor	instanceVariableNames: 'declaredMethodType ownerClass declaredMethodSelector typecheckErrors'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Analyzer'!!ASTTypecheckVisitor methodsFor: 'accessing' stamp: 'EstebanAllende 12/5/2011 17:20'!declaredMethodSelector	^ declaredMethodSelector! !!ASTTypecheckVisitor methodsFor: 'accessing' stamp: 'EstebanAllende 12/5/2011 17:20'!declaredMethodSelector: anObject	declaredMethodSelector := anObject! !!ASTTypecheckVisitor methodsFor: 'accessing' stamp: 'EstebanAllende 12/5/2011 17:20'!declaredMethodType	^ declaredMethodType! !!ASTTypecheckVisitor methodsFor: 'accessing' stamp: 'EstebanAllende 12/5/2011 17:20'!declaredMethodType: anObject	declaredMethodType := anObject! !!ASTTypecheckVisitor methodsFor: 'accessing' stamp: 'EstebanAllende 12/5/2011 17:20'!ownerClass	^ ownerClass! !!ASTTypecheckVisitor methodsFor: 'accessing' stamp: 'EstebanAllende 12/5/2011 17:20'!ownerClass: anObject	ownerClass := anObject! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 17:02'!acceptArrayNode: anArrayNode 	super acceptArrayNode: anArrayNode.	^ NominalType named: Array name! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 17:03'!acceptAssignmentNode: anAssignmentNode	|leftSide rightSide|	leftSide := self visitNode: anAssignmentNode variable.	rightSide := self visitNode: anAssignmentNode value.	"Checking rules"	(rightSide isConsistentSubtypeOf: leftSide) ifFalse: [self typeError: (' ' join: anAssignmentNode value formattedCode lines)  ,' is not assignable to variable ', anAssignmentNode variable name ,', because its type (',(rightSide asString) ,') is not a consistent subtype of ', (leftSide asString)].	^rightSide! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 17:09'!acceptBlockNode: aBlockNode 	| type |	type := LambdaType new.	type params: (self visitArguments: aBlockNode arguments).	type return: (self visitNode: aBlockNode body).	^type.! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 17:10'!acceptCascadeNode: aCascadeNode 	|result|		aCascadeNode messages		do: [:each | result := self visitNode: each].	^result! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 17:10'!acceptLiteralArrayNode: aRBLiteralArrayNode 	super acceptLiteralArrayNode: aRBLiteralArrayNode .	^Array asType! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 17:11'!acceptLiteralNode: aLiteralNode 	^aLiteralNode value class asType! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/2/2012 16:00'!acceptMessageNode: aMessageNode 	| argTypes msgType rcvType|	(aMessageNode isCascaded not			or: [aMessageNode isFirstCascaded])		ifTrue: [aMessageNode				propertyAt: #receiverType				put: (self visitNode: aMessageNode receiver)]		ifFalse: [aMessageNode				propertyAt: #receiverType				put: (aMessageNode receiver propertyAt: #typeOfNode)].	argTypes := aMessageNode arguments				collect: [:each | self visitNode: each].	"Check"	rcvType := aMessageNode propertyAt: #receiverType.	"Hack1"	msgType := ((rcvType isSubtypeOf: ownerClass asType) and: [aMessageNode selector = declaredMethodSelector ]) 						ifTrue: [declaredMethodType] 						ifFalse: [rcvType typeOfSelector: aMessageNode selector fromClass: ownerClass].	msgType ifNil: [					self typeError: 'Method ''',aMessageNode selector,''' is not understandable by ', rcvType asString.					^DynType implicitInstance.					].	msgType isDyn ifTrue: [^DynType implicitInstance].	msgType isLambda ifFalse: [self typeError: 'Declared type of method ''',aMessageNode selector,''' is not a lambda'].	msgType := msgType resolveParametricWith: (LambdaType new params: argTypes; return: msgType return; yourself) andReceiver: rcvType.	(argTypes size = msgType params size) ifFalse: [self typeError: 'Number of arguments provided to invoke method ''',aMessageNode selector,''' is inconsistent with its declared type ',msgType asString].	1 to: argTypes size do: [:i| |aType pType|		aType := argTypes at: i .		pType := msgType params at: i.		(aType isConsistentSubtypeOf: pType) ifFalse: [self typeError: i asString,'° argument ''',(aMessageNode arguments at: i) formattedCode withoutCRs,''' has not valid type when invoking method ''',aMessageNode selector,''' (argument type: ',aType asString,', parameter type: ',pType asString,')'].	]. 	^msgType return.! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/28/2012 01:25'!acceptMethodNode: aMethodNode 	"Modificar"	|localArgTypes classArgTypes argTypes returnType methodType|	typecheckErrors := OrderedCollection new.	argTypes := self visitMethodArguments: aMethodNode arguments.	localArgTypes := argTypes collect: [:each| each first].	classArgTypes := argTypes collect: [:each| each second].	returnType := aMethodNode propertyAt: #localReturnType.	methodType := LambdaType new.	methodType params: localArgTypes.	methodType return: returnType.	methodType := methodType annotateSelfWith: self ownerClass inMethod: (MethodSignature new selector: declaredMethodSelector; signature: declaredMethodType) withKind: #normal.	typecheckErrors addAll: methodType validate.	ownerClass superclass ifNotNil: [		|superclassMethodType|		superclassMethodType := TypeDictionary uniqueInstance class: ownerClass superclass atSelector: aMethodNode selector asSymbol fromClass: ownerClass.		superclassMethodType ifNotNil: [			superclassMethodType := superclassMethodType resolveParametricWith: superclassMethodType  andReceiver: self createSelfType.			(methodType isConsistentSubtypeOf: superclassMethodType) ifFalse: [self typeError: 'Method declaration is inconsistent with declared in an ancestor of this class.'].		].	].	declaredMethodSelector := aMethodNode selector.	declaredMethodType := methodType.	aMethodNode pragmas		do: [:each | self visitNode: each].	self visitNode: aMethodNode body.	aMethodNode propertyAt: #localMethodType put: declaredMethodType.	aMethodNode propertyAt: #methodType put: (LambdaType new params: classArgTypes; return: (aMethodNode propertyAt: #returnType); yourself).	(aMethodNode lastIsReturn) ifFalse: [((self createSelfType) isConsistentSubtypeOf: returnType) ifFalse: [self typeError: 'Declared return type is inconsistent with returned value of type Self']].		^declaredMethodType	! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 17:17'!acceptPatternBlockNode: aRBPatternBlockNode 	self halt.! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 17:17'!acceptPatternWrapperBlockNode: aRBPatternWrapperBlockNode 	self halt.! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/2/2012 16:01'!acceptReturnNode: aReturnNode	|result| 	result := self visitNode: aReturnNode value.	(result isConsistentSubtypeOf: declaredMethodType return) ifFalse: [self typeError: 'Declared return type is inconsistent with returned value of type ',result asString].	^UndefinedObject asType! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 17:18'!acceptSequenceNode: aSequenceNode 	|result|	self visitArguments: aSequenceNode temporaries.	result := nil class asType.	aSequenceNode statements		do: [:each | result := self visitNode: each].	^result! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/19/2012 17:53'!acceptVariableNode: aVariableNode 	|result binding errBlk name|	name:= aVariableNode name.		"Check if variable is special"	(name = 'self') ifTrue: [^self createSelfType].	(name = 'super') ifTrue: [^self ownerClass asType superType ].	(name = 'thisContext') ifTrue: [^ContextPart asType].	"Check if its binding"	errBlk:= [self typeError: 'Free variable: ',  name. DynType implicitInstance].	binding := aVariableNode binding.	result := binding propertyAt: #localType ifAbsent: [nil].		result ifNil: [		(binding isTemp and: [binding isCopying]) ifTrue:[			"(name = 'type2') ifTrue: [self halt]."			^ (binding scope lookupNonCopyVar: name) propertyAt: #localType		].		binding isInstance ifTrue:[						^ (TypeDictionary uniqueInstance class: ownerClass atInstVar: name) ifNil: errBlk.		].				^(TypeDictionary uniqueInstance class: ownerClass theNonMetaClass atClassVar: name) ifNil: [			[(Smalltalk at: name asSymbol) class asType] ifError: errBlk.		].	].	result := result annotateSelfWith: self ownerClass inMethod: (MethodSignature new selector: declaredMethodSelector; signature: declaredMethodType) withKind: #normal.	typecheckErrors addAll: result validate.	^result! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 10:24'!createSelfType	|parametricList|	parametricList := TypeDictionary uniqueInstance getLocalParametricList: ownerClass.	^ (SelfType new annotateSelfWith: self ownerClass inMethod: (MethodSignature new selector: declaredMethodSelector; signature: declaredMethodType) withKind: #normal) classParametrics: parametricList	! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified'!informErrors	typecheckErrors ifNotEmpty: [		typecheckErrors first signal.	]! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 2/21/2012 19:21'!typeError: aString	self halt.	typecheckErrors add: (TypeValidationError kind: #generic msg: aString)! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 2/24/2012 00:32'!visitArgument: each 	"Here to allow subclasses to detect arguments or temporaries."	each binding		propertyAt: #type		put: ((each propertyAt: #type) annotateSelfWith: self ownerClass inMethod: (MethodSignature new selector: declaredMethodSelector; signature: declaredMethodType) withKind: #normal).	^ each binding propertyAt: #type.! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 17:20'!visitArguments: aNodeCollection 	^aNodeCollection collect: [:each | self visitArgument: each]! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 11:59'!visitMethodArgument: each 	"Here to allow subclasses to detect arguments or temporaries."	each binding		propertyAt: #localType		put: ((each propertyAt: #localType) annotateSelfWith: self ownerClass inMethod: (MethodSignature new selector: declaredMethodSelector; signature: declaredMethodType) withKind: #normal).	each binding		propertyAt: #type		put: (each propertyAt: #type).	^ {each binding propertyAt:#localType. each binding propertyAt: #type}.! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 11:59'!visitMethodArguments: aNodeCollection 	^aNodeCollection collect: [:each | self visitMethodArgument: each]! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 13:27'!visitNode: aNode 	|res casts|	res := aNode acceptVisitor: self.	casts := aNode propertyAt: #cast ifAbsent: [OrderedCollection new].	aNode propertyAt: #typeOfNodeWithoutCast put: res.	res:= casts inject: res into: [:before :actual|		 |castType|		castType := actual castType annotateSelfWith: self ownerClass inMethod: (MethodSignature new selector: declaredMethodSelector; signature: declaredMethodType) withKind: #normal.		typecheckErrors addAll: castType validate.		(before isCasteableTo: castType) ifFalse: [self typeError: 'Inconsistent cast: from ',before asString,' to ',castType asString].		castType	].	aNode propertyAt: #typeOfNode put: res.	^res! !