RBProgramNodeVisitor subclass: #ASTPreprocessingVisitor	instanceVariableNames: 'body'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Analyzer'!!ASTPreprocessingVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 15:17'!acceptBlockNode: aBlockNode 	self visitArguments: aBlockNode arguments onBody: aBlockNode body.	self visitNode: aBlockNode body! !!ASTPreprocessingVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/6/2011 17:05'!acceptMethodNode: aMethodNode 	self visitArguments: aMethodNode arguments onBody: aMethodNode body.	aMethodNode pragmas		do: [ :each | self visitNode: each ].	self visitNode: aMethodNode body	! !!ASTPreprocessingVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 13:36'!visitArgument: each onBody: aNode	"Here to allow subclasses to detect arguments or temporaries."	|newVarNode newValueNode newAssignNode|	newValueNode := (RBVariableNode named: each name) "shadowNodeOf: each".	newVarNode := (RBVariableNode named: each name) "shadowNodeOf: each".	CastExpr addCast: (CastExpr explicitToType: (each propertyAt: #localType)) to: newValueNode.	newAssignNode := (RBAssignmentNode variable: newVarNode value: newValueNode) "shadowNodeOf: each".	newAssignNode propertyAt: #argCheck put: true.	newAssignNode value propertyAt: #argCheck put: true.	aNode addNodeFirst: newAssignNode.! !!ASTPreprocessingVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 17:01'!visitArguments: aNodeCollection onBody: aNode	^aNodeCollection do: [:each | self visitArgument: each onBody: aNode]! !RBProgramNodeVisitor subclass: #ASTLinkerVisitor	instanceVariableNames: 'classTypeEnvironment localTypeEnvironment ownerClass'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Analyzer'!!ASTLinkerVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/22/2012 13:40'!acceptMethodNode: aMethodNode 	aMethodNode pragmas		do: [:each | self visitNode: each].	self visitArguments: aMethodNode arguments.	aMethodNode propertyAt: #localReturnType put: ((aMethodNode propertyAt: #returnType) deepCopy resolveWith: localTypeEnvironment).	aMethodNode propertyAt: #returnType put: ((aMethodNode propertyAt: #returnType) resolveWith: classTypeEnvironment).	self visitNode: aMethodNode body.		! !!ASTLinkerVisitor methodsFor: 'as yet unclassified'!acceptPatternBlockNode: aRBPatternBlockNode 	self halt.! !!ASTLinkerVisitor methodsFor: 'as yet unclassified'!acceptPatternWrapperBlockNode: aRBPatternWrapperBlockNode 	self halt.! !!ASTLinkerVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/28/2012 13:17'!acceptPragmaNode: aPragmaNode	|sel tlist |	sel := aPragmaNode selector.	(sel = #whereType:) 		ifTrue:[			tlist := VariablesParser parsePragma: aPragmaNode arguments first value inClass: ownerClass.			tlist do: [ :each | |localType type|				type := classTypeEnvironment lookupType: each third.				type ifNotNil: [Error signal: 'whereType: ',each third,' is not a parametric defined in a method'].				type := ParametricType new.				type kind: #method; name: each third; upperBound: each second.				classTypeEnvironment define: each third as: type.								localType := ParametricType new.				localType kind: #local; name: each third; upperBound: each first.				localTypeEnvironment define: each third as: localType.			].					]	"aPragmaNode arguments do: [ :each | self visitNode: each ]"! !!ASTLinkerVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 10:46'!initialize	classTypeEnvironment := TypeEnvironment new.	classTypeEnvironment parent: TypeEnvironment globalEnvironment.	localTypeEnvironment := TypeEnvironment new.	localTypeEnvironment parent: TypeEnvironment globalEnvironment.! !!ASTLinkerVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 10:46'!setClassParentEnvironment: aTypeEnvironment	classTypeEnvironment parent: aTypeEnvironment.! !!ASTLinkerVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 10:46'!setLocalParentEnvironment: aTypeEnvironment	localTypeEnvironment parent: aTypeEnvironment.! !!ASTLinkerVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 7/2/2012 12:57'!setParentsEnvironmentUsingClassDescription: aClassDescription	|aClassTypeEnvironment aLocalTypeEnvironment|	aClassDescription isMeta		ifTrue: [			aClassTypeEnvironment := TypeDictionary uniqueInstance getClassTypeEnvironmentFor: Class.			aLocalTypeEnvironment := TypeDictionary uniqueInstance getLocalTypeEnvironmentFor: Class.				] ifFalse: [			aClassTypeEnvironment := TypeDictionary uniqueInstance getClassTypeEnvironmentFor: aClassDescription.			aLocalTypeEnvironment := TypeDictionary uniqueInstance getLocalTypeEnvironmentFor: aClassDescription.		].	classTypeEnvironment parent: aClassTypeEnvironment.	localTypeEnvironment parent: aLocalTypeEnvironment.	localTypeEnvironment local: true.	classTypeEnvironment local: false.	ownerClass := aClassDescription! !!ASTLinkerVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/19/2012 18:04'!visitArgument: each 	"Here to allow subclasses to detect arguments or temporaries."		each propertyAt: #localType put: ((each propertyAt: #type) deepCopy resolveWith: localTypeEnvironment).	each propertyAt: #type put: ((each propertyAt: #type) resolveWith: classTypeEnvironment).! !!ASTLinkerVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 13:27'!visitNode: aNode 	|casts|	aNode acceptVisitor: self.	casts := aNode propertyAt: #cast ifAbsent: [^self].	casts := casts collect: [:each|each castType: (each castType resolveLocalWith: localTypeEnvironment)].	aNode propertyAt: #cast put: casts.	! !Object subclass: #ASTConfigurationAnalyzer	uses: TTyped	instanceVariableNames: '(RBMethodNode)node (Symbol)access (Boolean)typecheck (Boolean)ignoreParent'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Analyzer'!!ASTConfigurationAnalyzer methodsFor: 'accessing' stamp: 'EstebanAllende 12/15/2011 12:11'!(Symbol) access	^ access! !!ASTConfigurationAnalyzer methodsFor: 'accessing' stamp: 'EstebanAllende 12/15/2011 12:12'!(Self) access: (Symbol)anObject	access := anObject! !!ASTConfigurationAnalyzer methodsFor: 'accessing' stamp: 'EstebanAllende 7/19/2012 01:35'!(Boolean) ignoreParent	^ ignoreParent! !!ASTConfigurationAnalyzer methodsFor: 'accessing' stamp: 'EstebanAllende 7/19/2012 01:35'!(Self) ignoreParent: (Boolean)anObject	ignoreParent := anObject! !!ASTConfigurationAnalyzer methodsFor: 'accessing' stamp: 'EstebanAllende 7/19/2012 01:36'!(Self) initialize	typecheck := true.	ignoreParent := false.	access := #public.! !!ASTConfigurationAnalyzer methodsFor: 'accessing' stamp: 'EstebanAllende 12/15/2011 12:15'!(RBMethodNode) node	^ node! !!ASTConfigurationAnalyzer methodsFor: 'accessing' stamp: 'EstebanAllende 12/15/2011 12:15'!(Self) node: (RBMethodNode) anObject	node := anObject! !!ASTConfigurationAnalyzer methodsFor: 'accessing' stamp: 'EstebanAllende 2/20/2012 21:42'!(Boolean) typecheck	^ (TypeConfiguration uniqueInstance bootstrap not) & typecheck! !!ASTConfigurationAnalyzer methodsFor: 'accessing' stamp: 'EstebanAllende 12/15/2011 12:16'!(Self) typecheck: (Boolean)anObject	typecheck := anObject! !!ASTConfigurationAnalyzer methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/15/2011 12:17'!(Self) process	node pragmas do: [:(RBPragmaNode)each| self visitPragma: each].	^self! !!ASTConfigurationAnalyzer methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/15/2011 12:18'!(Self)visitPragma: (RBPragmaNode)pragma	|(Symbol)selector (CompiledMethod)method|	selector := pragma selector.	method := self class lookupSelector: selector.	method ifNotNil: [method valueWithReceiver: self arguments: (pragma arguments collect: [:(RBLiteralNode)each| each value])]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ASTConfigurationAnalyzer class	uses: TTyped classTrait	instanceVariableNames: ''!!ASTConfigurationAnalyzer class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 7/13/2012 16:09'!(Self instance) for: (RBMethodNode)aMethodNode	|(Self instance)res|	res :=(self new node: aMethodNode) process.	aMethodNode propertyAt: #conf put: res.	^res! !RBProgramNodeVisitor subclass: #ASTTypecheckVisitor	instanceVariableNames: 'declaredMethodType ownerClass declaredMethodSelector typecheckErrors ignoreParent'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Analyzer'!!ASTTypecheckVisitor methodsFor: 'accessing' stamp: 'EstebanAllende 12/5/2011 17:20'!declaredMethodSelector	^ declaredMethodSelector! !!ASTTypecheckVisitor methodsFor: 'accessing' stamp: 'EstebanAllende 12/5/2011 17:20'!declaredMethodSelector: anObject	declaredMethodSelector := anObject! !!ASTTypecheckVisitor methodsFor: 'accessing' stamp: 'EstebanAllende 12/5/2011 17:20'!declaredMethodType	^ declaredMethodType! !!ASTTypecheckVisitor methodsFor: 'accessing' stamp: 'EstebanAllende 12/5/2011 17:20'!declaredMethodType: anObject	declaredMethodType := anObject! !!ASTTypecheckVisitor methodsFor: 'accessing' stamp: 'EstebanAllende 7/19/2012 01:37'!ignoreParent 	^ignoreParent! !!ASTTypecheckVisitor methodsFor: 'accessing' stamp: 'EstebanAllende 7/19/2012 01:38'!ignoreParent: anObject	ignoreParent := anObject! !!ASTTypecheckVisitor methodsFor: 'accessing' stamp: 'EstebanAllende 12/5/2011 17:20'!ownerClass	^ ownerClass! !!ASTTypecheckVisitor methodsFor: 'accessing' stamp: 'EstebanAllende 12/5/2011 17:20'!ownerClass: anObject	ownerClass := anObject! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 17:02'!acceptArrayNode: anArrayNode 	super acceptArrayNode: anArrayNode.	^ NominalType named: Array name! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'OzC 9/13/2012 16:26'!acceptAssignmentNode: anAssignmentNode	|leftSide rightSide|	leftSide := self visitNode: anAssignmentNode variable.	rightSide := self visitNode: anAssignmentNode value.	"Checking rules"	(rightSide isConsistentSubtypeOf: leftSide) ifFalse: [			self typeError: (' ' join: anAssignmentNode value formattedCode lines)  ,' is not assignable to variable ', anAssignmentNode variable name ,', because its type (',(rightSide asString) ,') is not a consistent subtype of ', (leftSide asString) 				 in: (TSSourceRef from: anAssignmentNode start to: anAssignmentNode stop)].	^rightSide! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 17:09'!acceptBlockNode: aBlockNode 	| type |	type := LambdaType new.	type params: (self visitArguments: aBlockNode arguments).	type return: (self visitNode: aBlockNode body).	^type.! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 17:10'!acceptCascadeNode: aCascadeNode 	|result|		aCascadeNode messages		do: [:each | result := self visitNode: each].	^result! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 17:10'!acceptLiteralArrayNode: aRBLiteralArrayNode 	super acceptLiteralArrayNode: aRBLiteralArrayNode .	^Array asType! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 17:11'!acceptLiteralNode: aLiteralNode 	^aLiteralNode value class asType! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'OzC 9/13/2012 16:39'!acceptMessageNode: aMessageNode 	| argTypes msgType rcvType|	(aMessageNode isCascaded not			or: [aMessageNode isFirstCascaded])		ifTrue: [aMessageNode				propertyAt: #receiverType				put: (self visitNode: aMessageNode receiver)]		ifFalse: [aMessageNode				propertyAt: #receiverType				put: (aMessageNode receiver propertyAt: #typeOfNode)].	argTypes := aMessageNode arguments				collect: [:each | self visitNode: each].	"Check"	rcvType := aMessageNode propertyAt: #receiverType.	"Hack1"	msgType := ((rcvType isSubtypeOf: ownerClass asType) and: [aMessageNode selector = declaredMethodSelector ]) 						ifTrue: [declaredMethodType] 						ifFalse: [rcvType typeOfSelector: aMessageNode selector fromClass: ownerClass].	msgType ifNil: [					self typeError: 'Method ''',aMessageNode selector,''' is not understandable by ', rcvType asString						 in: (TSSourceRef from: aMessageNode start to: aMessageNode stop).					^DynType implicitInstance.					].	msgType isDyn ifTrue: [^DynType implicitInstance].	msgType isLambda ifFalse: [		self typeError: 'Declared type of method ''',aMessageNode selector,''' is not a lambda'			 in: (TSSourceRef from: aMessageNode start to: aMessageNode stop).].	msgType := msgType resolveParametricWith: (LambdaType new params: argTypes; return: nil; yourself) andReceiver: rcvType.	(argTypes size = msgType params size) ifFalse: [		self typeError: 'Number of arguments provided to invoke method ''',aMessageNode selector,''' is inconsistent with its declared type ',msgType asString			in: (TSSourceRef from: aMessageNode start to: aMessageNode stop).].	1 to: argTypes size do: [:i| |aType pType|		aType := argTypes at: i .		pType := msgType params at: i.		(aType isConsistentSubtypeOf: pType) ifFalse: [			self typeError: i asString,'° argument ''',(aMessageNode arguments at: i) formattedCode withoutCRs,''' has not valid type when invoking method ''',aMessageNode selector,''' (argument type: ',aType asString,', parameter type: ',pType asString,')'				 in: (TSSourceRef from: (aMessageNode arguments at: i) start to: (aMessageNode arguments at: i) stop).].	]. 	^msgType return.! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'OzC 9/13/2012 16:51'!acceptMethodNode: aMethodNode 	"Modificar"	|localArgTypes classArgTypes argTypes returnType methodType|	typecheckErrors := OrderedCollection new.	argTypes := self visitMethodArguments: aMethodNode arguments.	localArgTypes := argTypes collect: [:each| each first].	classArgTypes := argTypes collect: [:each| each second].	returnType := aMethodNode propertyAt: #localReturnType.	methodType := LambdaType new.	methodType params: localArgTypes.	methodType return: returnType.	methodType := methodType annotateSelfWith: self ownerClass inMethod: (MethodSignature new selector: declaredMethodSelector; signature: declaredMethodType) withKind: #normal.	typecheckErrors addAll: methodType validate.	ownerClass superclass ifNotNil: [		|superclassMethodType|		superclassMethodType := TypeDictionary uniqueInstance class: ownerClass superclass atSelector: aMethodNode selector asSymbol fromClass: ownerClass.		(superclassMethodType notNil & ignoreParent not) ifTrue: [ |tmpType|			tmpType :=LambdaType new.			tmpType params: methodType params.			tmpType return: nil.			superclassMethodType := superclassMethodType resolveParametricWith: tmpType  andReceiver: self createSelfType.			(methodType isConsistentSubtypeOf: superclassMethodType) ifFalse: [				self typeError: 'Method declaration is inconsistent with declared in an ancestor of this class.'					 in: (TSSourceRef from: aMethodNode start to: aMethodNode body start)].		].	].	declaredMethodSelector := aMethodNode selector.	declaredMethodType := methodType.	aMethodNode pragmas		do: [:each | self visitNode: each].	self visitNode: aMethodNode body.	aMethodNode propertyAt: #localMethodType put: declaredMethodType.	aMethodNode propertyAt: #methodType put: (LambdaType new params: classArgTypes; return: (aMethodNode propertyAt: #returnType); yourself).	(aMethodNode lastIsReturn) ifFalse: [((self createSelfType) isConsistentSubtypeOf: returnType) ifFalse: [			self typeError: 'Declared return type is inconsistent with returned value of type Self'				 in: (TSSourceRef from: aMethodNode start to: (aMethodNode selectorParts first start) -1)]].	^declaredMethodType	! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 17:17'!acceptPatternBlockNode: aRBPatternBlockNode 	self halt.! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 17:17'!acceptPatternWrapperBlockNode: aRBPatternWrapperBlockNode 	self halt.! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'OzC 9/13/2012 16:29'!acceptReturnNode: aReturnNode	|result| 	result := self visitNode: aReturnNode value.	(result isConsistentSubtypeOf: declaredMethodType return) ifFalse: [		self typeError: 'Declared return type is inconsistent with returned value of type ',result asString			 in: (TSSourceRef from: aReturnNode  start to: aReturnNode stop)].	^UndefinedObject asType! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 17:18'!acceptSequenceNode: aSequenceNode 	|result|	self visitArguments: aSequenceNode temporaries.	result := nil class asType.	aSequenceNode statements		do: [:each | result := self visitNode: each].	^result! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'OzC 9/13/2012 17:06'!acceptVariableNode: aVariableNode 	|result binding errBlk name|	name:= aVariableNode name.		"Check if variable is special"	(name = 'self') ifTrue: [^self createSelfType].	(name = 'super') ifTrue: [^self ownerClass asType superType ].	(name = 'thisContext') ifTrue: [^ContextPart asType].	"Check if its binding"	errBlk:= [self typeError: 'Free variable: ',  name				   in: (TSSourceRef from: aVariableNode start to: aVariableNode stop). 			  DynType implicitInstance ].	binding := aVariableNode binding.	result := binding propertyAt: #localType ifAbsent: [nil].		result ifNil: [		(binding isTemp and: [binding isCopying]) ifTrue:[			"(name = 'type2') ifTrue: [self halt]."			^ (binding scope lookupNonCopyVar: name) propertyAt: #localType		].		binding isInstance ifTrue:[			^ ((TypeDictionary uniqueInstance class: ownerClass atInstVar: name asSymbol) ifNil: errBlk) resolveParametricWith: DynType implicitInstance andReceiver: self createSelfType.		].				^(TypeDictionary uniqueInstance class: ownerClass theNonMetaClass atClassVar: name asSymbol) ifNil: [			[(Smalltalk at: name asSymbol) class asType] ifError: errBlk.		].	].	result := result annotateSelfWith: self ownerClass inMethod: (MethodSignature new selector: declaredMethodSelector; signature: declaredMethodType) withKind: #normal.	 result validate do: [:typeError|		typecheckErrors add: (typeError sourceRef: (TSSourceRef from: aVariableNode start to: aVariableNode stop))		].	^result ! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 7/7/2012 16:32'!createSelfType	|parametricList|	ownerClass isMeta ifTrue: [		parametricList := TypeDictionary uniqueInstance getLocalParametricList: Class.	] ifFalse: [		parametricList := TypeDictionary uniqueInstance getLocalParametricList: ownerClass.	].	^ (SelfType new annotateSelfWith: self ownerClass inMethod: (MethodSignature new selector: declaredMethodSelector; signature: declaredMethodType) withKind: #normal) classParametrics: parametricList	! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/28/2012 23:52'!visitArgument: each 	"Here to allow subclasses to detect arguments or temporaries."	each binding		propertyAt: #localType		put: ((each propertyAt: #localType) annotateSelfWith: self ownerClass inMethod: (MethodSignature new selector: declaredMethodSelector; signature: declaredMethodType) withKind: #normal).	^ each binding propertyAt: #localType.! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 17:20'!visitArguments: aNodeCollection 	^aNodeCollection collect: [:each | self visitArgument: each]! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 11:59'!visitMethodArgument: each 	"Here to allow subclasses to detect arguments or temporaries."	each binding		propertyAt: #localType		put: ((each propertyAt: #localType) annotateSelfWith: self ownerClass inMethod: (MethodSignature new selector: declaredMethodSelector; signature: declaredMethodType) withKind: #normal).	each binding		propertyAt: #type		put: (each propertyAt: #type).	^ {each binding propertyAt:#localType. each binding propertyAt: #type}.! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 11:59'!visitMethodArguments: aNodeCollection 	^aNodeCollection collect: [:each | self visitMethodArgument: each]! !!ASTTypecheckVisitor methodsFor: 'as yet unclassified' stamp: 'OzC 9/13/2012 17:05'!visitNode: aNode 	|res casts|	res := aNode acceptVisitor: self.	casts := aNode propertyAt: #cast ifAbsent: [OrderedCollection new].	aNode propertyAt: #typeOfNodeWithoutCast put: res.	res:= casts inject: res into: [:before :actual|		 |castType|		castType := actual castType annotateSelfWith: self ownerClass inMethod: (MethodSignature new selector: declaredMethodSelector; signature: declaredMethodType) withKind: #normal.		typecheckErrors addAll: castType validate.		(before isCasteableTo: castType) ifFalse: [			self typeError: 'Inconsistent cast: from ',before asString,' to ',castType asString				 in: (TSSourceRef from: aNode start to: aNode stop)].		castType	].	aNode propertyAt: #typeOfNode put: res.	^res! !!ASTTypecheckVisitor methodsFor: 'notifying-errors' stamp: 'OzC 9/13/2012 16:29'!informErrors	typecheckErrors ifNotEmpty: [		typecheckErrors do: #signal.	]! !!ASTTypecheckVisitor methodsFor: 'notifying-errors' stamp: 'OzC 9/13/2012 17:13'!informErrorsNotifying: pluggableText	"puggabletext must understand #selectFrom:to:"		typecheckErrors ifNotEmpty: [|error ref|		error:= typecheckErrors first.		ref:= error sourceRef .		((pluggableText respondsTo: #selectFrom:to:) and: ref notNil)ifTrue: [ "whatch out with noMetaClass"			pluggableText selectFrom: error sourceRef startPosition to: error sourceRef endPosition.			].		error signal.	]! !!ASTTypecheckVisitor methodsFor: 'notifying-errors' stamp: 'OzC 9/13/2012 15:51'!typeError: aString	typecheckErrors add: (TypeValidationError kind: #generic msg: aString)! !!ASTTypecheckVisitor methodsFor: 'notifying-errors' stamp: 'OzC 9/13/2012 16:27'!typeError: aString in: sourceRef	typecheckErrors add: ((TypeValidationError kind: #generic msg: aString) sourceRef: sourceRef)! !RBProgramNodeVisitor subclass: #ASTCastInsertionVisitor	instanceVariableNames: 'declaredMethodType ownerClass'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Analyzer'!!ASTCastInsertionVisitor methodsFor: 'accessing' stamp: 'EstebanAllende 10/21/2011 12:17'!ownerClass	^ ownerClass! !!ASTCastInsertionVisitor methodsFor: 'accessing' stamp: 'EstebanAllende 10/21/2011 12:17'!ownerClass: anObject	ownerClass := anObject! !!ASTCastInsertionVisitor methodsFor: 'visiting' stamp: 'EstebanAllende 10/21/2011 12:18'!visitNode: aNode 	^aNode acceptVisitor: self.! !!ASTCastInsertionVisitor methodsFor: 'visitor-double dispatching' stamp: 'EstebanAllende 10/21/2011 12:19'!acceptArrayNode: anArrayNode 	super acceptArrayNode: anArrayNode.	! !!ASTCastInsertionVisitor methodsFor: 'visitor-double dispatching' stamp: 'EstebanAllende 10/21/2011 17:01'!acceptAssignmentNode: anAssignmentNode	|leftSide rightSide|	self visitNode: anAssignmentNode variable.	self visitNode: anAssignmentNode value.	leftSide := anAssignmentNode variable propertyAt: #typeOfNode.	rightSide := anAssignmentNode value propertyAt: #typeOfNode.	"Checking rules"	(rightSide isSubtypeOf: leftSide) ifFalse: [		CastExpr addCast: (CastExpr toType: leftSide) to: anAssignmentNode value.	].! !!ASTCastInsertionVisitor methodsFor: 'visitor-double dispatching' stamp: 'EstebanAllende 10/21/2011 13:28'!acceptBlockNode: aBlockNode 		super acceptBlockNode: aBlockNode! !!ASTCastInsertionVisitor methodsFor: 'visitor-double dispatching' stamp: 'EstebanAllende 10/21/2011 13:28'!acceptCascadeNode: aCascadeNode 		super acceptCascadeNode: aCascadeNode! !!ASTCastInsertionVisitor methodsFor: 'visitor-double dispatching' stamp: 'EstebanAllende 10/21/2011 13:28'!acceptLiteralArrayNode: aRBLiteralArrayNode 	super acceptLiteralArrayNode: aRBLiteralArrayNode .! !!ASTCastInsertionVisitor methodsFor: 'visitor-double dispatching' stamp: 'EstebanAllende 10/21/2011 13:28'!acceptLiteralNode: aLiteralNode 	! !!ASTCastInsertionVisitor methodsFor: 'visitor-double dispatching' stamp: 'EstebanAllende 7/14/2012 18:45'!acceptMessageNode: aMessageNode "	| argTypes rcvType|"	super acceptMessageNode: aMessageNode."				argTypes := aMessageNode arguments				collect: [:each | each propertyAt: #typeOfNode].	''Check''	rcvType := aMessageNode receiver propertyAt: #typeOfNode. ''propertyAt: #receiverType''.		rcvType isDyn 		ifTrue:  	[ |cast nodeToAdd|			cast:= CastExpr toType: (StructuralType new methods: 					{MethodSignature new selector: aMessageNode selector ; 							signature: (LambdaType new paramTypes: argTypes											; returnType: DynType new)}).			nodeToAdd := aMessageNode isCascaded ifTrue: [aMessageNode] ifFalse:[aMessageNode receiver].			CastExpr addCast: cast to: nodeToAdd.			]		ifFalse:	[ |msgType|			msgType := rcvType methodTypeOfSelector: aMessageNode selector.			1 to: argTypes size do:  [:i | |arg param|				arg:= argTypes at: i.				param := msgType paramTypes at: i.				(arg isSubtypeOf: param) ifFalse:[					CastExpr addCast: (CastExpr toType: param) to: (aMessageNode arguments at: i) ]]].	"! !!ASTCastInsertionVisitor methodsFor: 'visitor-double dispatching' stamp: 'EstebanAllende 10/21/2011 16:28'!acceptMethodNode: aMethodNode 	"Modificar"	declaredMethodType := aMethodNode propertyAt: #methodType.	super acceptMethodNode: aMethodNode	! !!ASTCastInsertionVisitor methodsFor: 'visitor-double dispatching' stamp: 'EstebanAllende 10/21/2011 12:17'!acceptPatternBlockNode: aRBPatternBlockNode 	self halt.! !!ASTCastInsertionVisitor methodsFor: 'visitor-double dispatching' stamp: 'EstebanAllende 10/21/2011 12:17'!acceptPatternWrapperBlockNode: aRBPatternWrapperBlockNode 	self halt.! !!ASTCastInsertionVisitor methodsFor: 'visitor-double dispatching' stamp: 'EstebanAllende 7/14/2012 18:53'!acceptReturnNode: aReturnNode	|returnType decType| 	self visitNode: aReturnNode value.	returnType := aReturnNode value propertyAt: #typeOfNode.	decType := declaredMethodType return.	(returnType isSubtypeOf: decType) ifFalse: [CastExpr addCast: (CastExpr explicitToType: decType) to: aReturnNode value]! !!ASTCastInsertionVisitor methodsFor: 'visitor-double dispatching' stamp: 'EstebanAllende 10/21/2011 16:35'!acceptSequenceNode: aSequenceNode 	super acceptSequenceNode: aSequenceNode! !!ASTCastInsertionVisitor methodsFor: 'visitor-double dispatching' stamp: 'EstebanAllende 10/21/2011 16:45'!acceptVariableNode: aVariableNode 	! !RBProgramNodeVisitor subclass: #ASTCheckVisitor	instanceVariableNames: 'queue'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Analyzer'!!ASTCheckVisitor methodsFor: 'visiting' stamp: 'EstebanAllende 10/27/2011 12:28'!initialize	queue := OrderedCollection new.! !!ASTCheckVisitor methodsFor: 'visiting' stamp: 'EstebanAllende 7/16/2012 02:23'!processQueue	queue do: [:aNode|		|casts stringCast node ghostNode classNode selfClassNode selfNode selector|		casts := aNode propertyAt: #cast.		selector := #obj:type:class:.		(aNode propertyAt: #argCheck ifAbsent: [false]) ifTrue:[selector := #argObj:type:class: ].		ghostNode := RBLiteralNode value: 42.		selfNode := (RBVariableNode named: 'self') shadowNodeOf: aNode.		selfNode propertyAt: #binding put: (CastCheckAtRuntime bindingSelf: Object).		selfClassNode := (RBMessageNode receiver: selfNode  selector: #class arguments: {}) shadowNodeOf: aNode.		classNode := (RBVariableNode named: 'CastCheckAtRuntime') shadowNodeOf: aNode.		classNode propertyAt: #binding put: CastCheckAtRuntime binding.		stringCast:= (casts collect: [:each| each castType]) asArray."(casts collect: [:each| each castType asString]) asArray".				node := (RBMessageNode receiver: classNode selector: (selector) arguments: {ghostNode. (RBLiteralArrayNode value: stringCast) shadowNodeOf: aNode. selfClassNode}) shadowNodeOf: aNode.		aNode replaceWith: node.		aNode parent: nil.		ghostNode replaceWith: aNode.		"aNode parent replaceNode: aNode withNode: node."		"self halt"	].	! !!ASTCheckVisitor methodsFor: 'visiting' stamp: 'EstebanAllende 7/14/2012 23:35'!visitNode: aNode 	|casts stringCast|	aNode acceptVisitor: self.	casts := aNode propertyAt: #cast ifAbsent: [nil].	casts isEmptyOrNil ifFalse: [		queue addLast: aNode.	].	! !RBProgramNodeVisitor subclass: #ASTTypeCounterVisitor	instanceVariableNames: 'dictionary'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Analyzer'!!ASTTypeCounterVisitor methodsFor: 'accessing' stamp: 'EstebanAllende 7/3/2012 15:46'!dictionary	^ dictionary! !!ASTTypeCounterVisitor methodsFor: 'accessing' stamp: 'EstebanAllende 7/3/2012 15:46'!dictionary: anObject	dictionary := anObject! !!ASTTypeCounterVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 7/7/2012 12:15'!generateDictionary	|res|	res := Dictionary new.	res at: #ImplicitDyn put: 0.	res at: #ExplicitDyn put: 0.	res at: #DynType put: 0.	res at: #LambdaType put: 0.	res at: #NominalType put: 0.	res at: #ParametricType put: 0.	res at: #GenericUsage put: 0.	res at: #SelfType put: 0.	res at: #SelfInstance put: 0.	res at: #SelfClass put: 0.	res at: #Self put: 0.	res at: #StructuralType put: 0.	res at: #OnlyStructural put: 0.	res at: #MixedStructural put: 0.	res at: #UnionType put: 0.		res at: #ExplicitCasts put: 0.	res at: #Total put: 0.	^res.! !!ASTTypeCounterVisitor methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 7/3/2012 15:30'!initialize	dictionary := self generateDictionary.! !!ASTTypeCounterVisitor methodsFor: 'visiting' stamp: 'EstebanAllende 7/3/2012 15:37'!visitArgument: each 	"Here to allow subclasses to detect arguments or temporaries."		(each propertyAt: #localType) addCountIn: dictionary.	^super visitArgument: each.! !!ASTTypeCounterVisitor methodsFor: 'visiting' stamp: 'EstebanAllende 7/3/2012 15:39'!visitNode: aNode 	|casts|	aNode acceptVisitor: self.	casts := aNode propertyAt: #cast ifAbsent: [^self].	casts do: [:each|each castType addCountIn: dictionary. dictionary at: #ExplicitCasts modify: [:act| act +1]].! !!ASTTypeCounterVisitor methodsFor: 'visitor-double dispatching' stamp: 'EstebanAllende 7/3/2012 15:57'!acceptMethodNode: aMethodNode 	super acceptMethodNode: aMethodNode.	(aMethodNode propertyAt: #returnType) addCountIn: dictionary.! !