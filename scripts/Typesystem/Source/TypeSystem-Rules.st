Object subclass: #RelationRules	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Rules'!!RelationRules commentStamp: 'EstebanAllende 10/1/2012 14:08' prior: 0!A RelationRules is the abstract superclass of all rules concerning relationship between types.!!RelationRules methodsFor: 'type relationships' stamp: 'EstebanAllende 12/21/2011 17:36'!is: aType1 relatedWith: aType2	^self subclassResponsibility.! !RelationRules subclass: #SubtypingRules	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Rules'!!SubtypingRules commentStamp: 'EstebanAllende 10/1/2012 14:11' prior: 0!A SubtypingRules contains the rules governing subtyping relationship between types.!!SubtypingRules methodsFor: 'type relationships' stamp: 'EstebanAllende 6/29/2012 18:03'!is: aType1 relatedWith: aType2	((self isButtom: aType1) or: [self isTop: aType2]) ifTrue: [^true].	aType1 isParametric ifTrue: [		aType2 isParametric ifTrue: [			aType1 = aType2 ifTrue: [^true].		].		aType2 isUnion ifFalse: [	^self is: aType1 upperBound relatedWith: aType2].	].	aType1 isUnion ifTrue: [^aType1 union allSatisfy: [:each| self is: each relatedWith: aType2]].	aType2 class caseOf: {		[DynType]->[^aType1 isDyn].		[StructuralType]->[			|t1|			t1 := aType1 asStructuralType ifNil: [^false].			^self isStructural: t1 relatedWith: aType2.		].		[NominalType]->[			|t1 c1 c2|			t1 := aType1 asNominalType ifNil:[^false].			^self isNominal: t1 relatedWith: aType2.		].		[SelfType]->[^aType1 isSelf].		[LambdaType]->[^aType1 isLambda and: [self isLambda: aType1 relatedWith: aType2]].		[ParametricType]->[^aType1 = aType2].		[UnionType]->[^aType2 union anySatisfy: [:each| self is: aType1 relatedWith: each]].	} otherwise: [self error: 'Unknown kind of Type'].! !!SubtypingRules methodsFor: 'type relationships' stamp: 'EstebanAllende 1/26/2012 15:08'!isButtom: aType	aType isNominal ifTrue: [^ nil class asType = aType].	^false! !!SubtypingRules methodsFor: 'type relationships' stamp: 'EstebanAllende 1/26/2012 15:26'!isLambda: aType1 relatedWith: aType2	(self is: aType1 return relatedWith: aType2 return) ifFalse: [^false].	(aType1 params size = aType2 params size) ifFalse: [^false].	1 to: aType1 params size do: [:i|		|t1Param t2Param|		t1Param := aType1 params at: i.		t2Param := aType2 params at: i.		(self is: t2Param relatedWith: t1Param) ifFalse: [^false]	].	^true! !!SubtypingRules methodsFor: 'type relationships' stamp: 'EstebanAllende 1/26/2012 15:22'!isNominal: aType1 relatedWith: aType2	|c1 c2|	c1 := aType1 classRef ifNil: [^true].	c2 := aType2 classRef ifNil: [^true].	^((c1 = c2) or: [c1 inheritsFrom: c2]).! !!SubtypingRules methodsFor: 'type relationships' stamp: 'EstebanAllende 1/26/2012 17:43'!isStructural: aType1 relatedWith: aType2	(self is: aType1 base relatedWith: aType2 base)		ifFalse: [^ false].	aType2 methods do: [:method| |type|		type:= aType1 base typeOfSelector: method selector fromClass: Object.		type ifNil: [ |flag| 					flag:=false. 					aType1 methods do: [:each| 						(each selector == method selector) ifTrue: [							flag := self is: each signature relatedWith: method signature] ].					flag ifFalse: [^false]]			ifNotNil: [					(self is: type relatedWith: method signature) ifFalse: [^false]				]		].			^ true! !!SubtypingRules methodsFor: 'type relationships' stamp: 'EstebanAllende 1/26/2012 15:06'!isTop: aType	^false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SubtypingRules class	instanceVariableNames: ''!!SubtypingRules class methodsFor: 'class initialization' stamp: 'EstebanAllende 1/30/2012 14:04'!initialize	TypeConfiguration uniqueInstance subtypeRules: SubtypingRules new.! !SubtypingRules subclass: #ConsistentSubtypingRules	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Rules'!!ConsistentSubtypingRules commentStamp: 'EstebanAllende 10/1/2012 14:13' prior: 0!A ConsistentSubtypingRules contains the rules governing consistent subtyping relationship between types.!!ConsistentSubtypingRules methodsFor: 'type relationships' stamp: 'EstebanAllende 1/30/2012 13:43'!isButtom: aType	^aType isDyn or: [super isButtom: aType].! !!ConsistentSubtypingRules methodsFor: 'type relationships' stamp: 'EstebanAllende 1/30/2012 13:42'!isTop: aType	^aType isDyn.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ConsistentSubtypingRules class	instanceVariableNames: ''!!ConsistentSubtypingRules class methodsFor: 'class initialization' stamp: 'EstebanAllende 1/30/2012 14:07'!initialize	TypeConfiguration uniqueInstance consistentSubtypeRules: ConsistentSubtypingRules new.! !ConsistentSubtypingRules subclass: #CastingRules	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Rules'!!CastingRules commentStamp: 'EstebanAllende 10/1/2012 14:12' prior: 0!A CastingRules contains the rules governing casting relationship, i.e if a type is casteable to another, between two types.!!CastingRules methodsFor: 'type relationships' stamp: 'EstebanAllende 9/13/2012 14:22'!is: aType1 relatedWith: aType2	aType1 isDyn ifTrue: [^true].	aType1 isUnion ifTrue: [^aType1 union anySatisfy: [:each|self is: each relatedWith: aType2]].	aType2 class caseOf: {		[DynType]->[^true].		[StructuralType]->[^self is: aType1 relatedWith: aType2 base].		[ParametricType]->[^aType1 = aType2].		[SelfType]->[^(super is: aType1 relatedWith: aType2) or: [super is: aType2 asNominalType relatedWith: aType1] ].		[LambdaType]->[			aType1 isLambda ifTrue: [^(super is: aType1 relatedWith:  aType2) or: [super is: aType2 relatedWith: aType1]].			^self is: aType1 relatedWith: aType2 asNominalType.		].		[NominalType]->[ |nType1|			nType1 := aType1 asNominalType.			^(super is: nType1 relatedWith: aType2) or: [super is: aType2 relatedWith: nType1]		].		[UnionType]->[^aType2 union anySatisfy: [:each| self is: aType1 relatedWith: each]].	} otherwise: [^(super is: aType1 relatedWith: aType2) or: [super is: aType2 relatedWith: aType1]]. ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CastingRules class	instanceVariableNames: ''!!CastingRules class methodsFor: 'class initialization'!initialize	TypeConfiguration uniqueInstance castingRules: CastingRules new.! !CastingRules subclass: #RuntimeCastingRules	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Rules'!!RuntimeCastingRules commentStamp: 'EstebanAllende 10/1/2012 14:14' prior: 0!A RuntimeCastingRules contains the rules governing runtime casting between two types.!!RuntimeCastingRules methodsFor: 'type relationships' stamp: 'EstebanAllende 9/13/2012 11:31'!is: aType1 relatedWith: aType2	aType1 isParametric ifTrue: [^self is: aType1 upperBound relatedWith: aType2].	aType2 isParametric ifTrue: [^self is: aType1 relatedWith: aType2 upperBound].	^super is: aType1 relatedWith: aType2! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RuntimeCastingRules class	instanceVariableNames: ''!!RuntimeCastingRules class methodsFor: 'class initialization' stamp: 'EstebanAllende 9/13/2012 11:32'!initialize	TypeConfiguration uniqueInstance runtimeCastingRules: RuntimeCastingRules new.! !SubtypingRules initialize!ConsistentSubtypingRules initialize!CastingRules initialize!RuntimeCastingRules initialize!