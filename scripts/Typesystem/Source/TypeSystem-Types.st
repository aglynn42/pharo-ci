Type subclass: #UnlinkedType	uses: TTyped	instanceVariableNames: '(Symbol)name'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Types'!!UnlinkedType commentStamp: 'EstebanAllende 10/1/2012 14:03' prior: 0!An UnlinkedType is a type that has not been resolved. This type is incomplete and must not be used except for type resolution.!!UnlinkedType methodsFor: 'accessing' stamp: 'EstebanAllende 7/13/2012 16:01'!(Symbol) name	^name! !!UnlinkedType methodsFor: 'accessing' stamp: 'EstebanAllende 7/13/2012 16:01'!(Self) name: (Symbol)anObject	name := anObject asSymbol! !!UnlinkedType methodsFor: 'comparing'!(Integer) hash	^name hash! !!UnlinkedType methodsFor: 'converting'!(NominalType) asNominalType	^self shouldNotImplement.! !!UnlinkedType methodsFor: 'converting'!(StructuralType) asStructuralType	^self shouldNotImplement.! !!UnlinkedType methodsFor: 'parallel hierarchies'!(Type) classType	^self shouldNotImplement.! !!UnlinkedType methodsFor: 'parallel hierarchies'!(Type) instanceType	^self shouldNotImplement.! !!UnlinkedType methodsFor: 'relationships'!(Boolean) isCasteableTo: (Type) aType	^self shouldNotImplement.! !!UnlinkedType methodsFor: 'type resolution'!(Type) annotateSelfWith: (ClassDescription)aClass inMethod: (MethodSignature) aMethodSignature withKind: (Symbol) aSymbol	^self shouldNotImplement.! !!UnlinkedType methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 16:01'!(Type) resolveWith: (TypeEnvironment) env ifNotFoundStore: (Symbol → Type) aBlock	|(Type) res|	super resolveWith: env ifNotFoundStore: aBlock.	(name = #Self) ifTrue: [		res := SelfType new.		res classParametrics: self classParametrics.		^res	].	res := (env lookupType: name) copy.	res ifNil: [ 		res := aBlock value: name.		env define: name as: res.	].	res classParametrics: self classParametrics.	^res! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnlinkedType class	uses: TTyped classTrait	instanceVariableNames: '(Dictionary)subtypeRelations (Dictionary)consistentSubtypeRelations'!Type subclass: #LambdaType	uses: TTyped	instanceVariableNames: '(SequenceableCollection<Type>)params (Type)return'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Types'!!LambdaType commentStamp: 'EstebanAllende 10/1/2012 13:49' prior: 0!A LambdaType represent the type of a block.!!LambdaType methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/7/2011 11:35'!(Boolean)isLambda	^true! !!LambdaType methodsFor: 'accessing' stamp: 'EstebanAllende 7/13/2012 15:38'!(SequenceableCollection<Type>) params	^ params! !!LambdaType methodsFor: 'accessing' stamp: 'EstebanAllende 7/13/2012 15:38'!(Self) params: (SequenceableCollection<Type>)anObject	params := anObject! !!LambdaType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:34'!(Type) return	^ return! !!LambdaType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:34'!(Self) return: (Type)anObject	return := anObject! !!LambdaType methodsFor: 'analisis' stamp: 'EstebanAllende 7/13/2012 15:21'!(Self) addCountIn: (Dictionary<Symbol,Integer>)aDictionary	aDictionary at: #LambdaType modify: [:(Integer)act| act + 1].	self params do: [:(Type)each| each addCountIn: aDictionary].	self return addCountIn: aDictionary.	aDictionary at: #Total modify: [:(Integer)act| act +1].! !!LambdaType methodsFor: 'comparing' stamp: 'EstebanAllende 12/7/2011 11:35'!(Integer) hash	|(Integer) res|	res := self return hash.	1 to: self params size do: [:(Integer)i|		res:= res + (self params at: i) hash	].	^res! !!LambdaType methodsFor: 'comparing' stamp: 'EstebanAllende 12/7/2011 11:47'!(Boolean) typeEquality: (Self) another	<access: protected>	((self return) = (another return)) ifFalse: [^false].	(self params size = another params size) ifFalse: [^false].	1 to: self params size do: [:(Integer)i|		((self params at: i) = (another params at: i)) ifFalse: [^false].	].	^true! !!LambdaType methodsFor: 'converting' stamp: 'EstebanAllende 3/20/2012 17:52'!(NominalType) asNominalType	^ LambdaType lambdaNominalType.! !!LambdaType methodsFor: 'converting' stamp: 'EstebanAllende 1/26/2012 14:43'!(StructuralType) asStructuralType	^ LambdaType lambdaNominalType asStructuralType.! !!LambdaType methodsFor: 'parallel hierarchies' stamp: 'EstebanAllende 3/13/2012 14:46'!(Type) classType	^self class lambdaNominalType classType! !!LambdaType methodsFor: 'parallel hierarchies' stamp: 'EstebanAllende 12/7/2011 11:35'!(Type) instanceType	^nil! !!LambdaType methodsFor: 'queries'!(Type) lowestCommonAncestorBetween: (Type) another	self flag: #TODO.	^self asNominalType lowestCommonAncestorBetween: another.! !!LambdaType methodsFor: 'queries' stamp: 'EstebanAllende 1/30/2012 14:09'!(Type) typeOfSelector: (Symbol)selector fromClass: (ClassDescription) requestor	(#(value value: value:value: value:value:value: value:value:value:value: valueNoContextSwitch: valueNoContextSwitch valueWithArguments: ) includes: selector) ifTrue: [^self].	^ LambdaType lambdaNominalType typeOfSelector: selector fromClass: requestor.! !!LambdaType methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 15:21'!(Type) annotateSelfWith: (ClassDescription)aClass inMethod: (MethodSignature) aMethodSignature withKind: (Symbol) aSymbol	|(SequenceableCollection<Type>)pType (Type)rType|	pType := self params collect: [:(Type)each| each annotateSelfWith: aClass inMethod: aMethodSignature withKind: aSymbol].	rType := self return annotateSelfWith: aClass inMethod: aMethodSignature withKind: aSymbol.	^LambdaType new params: pType; return: rType.! !!LambdaType methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 15:22'!(Self) generateDictionaryWith: (Type) aType andDictionary: (Dictionary<Symbol, Type>) dict	(aType isDyn | aType isNominal) ifTrue: [		self params do: [:(Type)each| each generateDictionaryWith: DynType implicitInstance andDictionary: dict].		self return generateDictionaryWith: DynType implicitInstance andDictionary: dict.	].	(aType isLambda) ifTrue: [		|(LambdaType)lType|		lType := (<LambdaType> aType).		(self params size = lType params size) ifTrue: [			self params with: lType params do: [:(Type)each :(Type)another| each generateDictionaryWith: another andDictionary: dict].		].		lType return ifNotNil: [ self return generateDictionaryWith: lType return andDictionary: dict.].	].	super generateDictionaryWith: aType andDictionary: dict.! !!LambdaType methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 15:23'!(Type) replaceSelfWith: (Type) aType	|(SequenceableCollection<Type>)pType (Type)rType|	pType := self params collect: [:(Type)each| each replaceSelfWith: aType].	rType := self return replaceSelfWith: aType.	^LambdaType new params: pType; return: rType.! !!LambdaType methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 15:24'!(Type) resolveParametricWithReceiver: (Type)receiver andDictionary: (Dictionary<Symbol, Type>) dict	|(SequenceableCollection<Type>)pType (Type)rType|	pType := self params collect: [:(Type)each| each resolveParametricWithReceiver: receiver andDictionary: dict].	rType := self return resolveParametricWithReceiver: receiver andDictionary: dict.	^LambdaType new params: pType; return: rType.! !!LambdaType methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 15:24'!(Type) resolveWith: (TypeEnvironment) env ifNotFoundStore: (Symbol → Type) aBlock	params := params collect: [:(Type)each| each resolveWith: env ifNotFoundStore: aBlock].	return := return resolveWith: env ifNotFoundStore: aBlock.	^self.! !!LambdaType methodsFor: 'validation' stamp: 'EstebanAllende 7/13/2012 15:27'!(OrderedCollection<Error>) validate	|(OrderedCollection<Error>)res|	res := OrderedCollection new.	self params do: [:(Type)each| res addAll: each validate].	res addAll: self return validate.	^res.! !!LambdaType methodsFor: 'private'!(String) baseString	^ (' ' join: (params collect: [:(Type)each | each asString])),' -> ',(return asString)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!LambdaType class	uses: TTyped classTrait	instanceVariableNames: ''!!LambdaType class methodsFor: 'converting' stamp: 'EstebanAllende 7/13/2012 15:28'!(NominalType) lambdaNominalType	^[:(Object)x|x] class asType! !Type subclass: #ParametricType	uses: TTyped	instanceVariableNames: '(Symbol)name (Symbol)kind (Integer)pos (Type)upperBound'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Types'!!ParametricType commentStamp: 'EstebanAllende 10/1/2012 13:56' prior: 0!A ParametricType represent a type variable.!!ParametricType methodsFor: '*typesystem-types'!(Boolean) isParametric	^true! !!ParametricType methodsFor: 'accessing' stamp: 'EstebanAllende 3/20/2012 15:37'!(Symbol) kind	^ kind! !!ParametricType methodsFor: 'accessing' stamp: 'EstebanAllende 3/20/2012 15:38'!(Self) kind: (Symbol)anObject	kind := anObject! !!ParametricType methodsFor: 'accessing'!(Symbol) name	^name! !!ParametricType methodsFor: 'accessing' stamp: 'EstebanAllende 4/9/2012 13:40'!(Self) name: (Symbol)anObject	anObject isSymbol ifFalse: [self halt].	name := anObject! !!ParametricType methodsFor: 'accessing' stamp: 'EstebanAllende 3/20/2012 15:38'!(Integer) pos	^ pos! !!ParametricType methodsFor: 'accessing' stamp: 'EstebanAllende 3/20/2012 15:39'!(Self) pos: (Integer)anObject	pos := anObject! !!ParametricType methodsFor: 'accessing' stamp: 'EstebanAllende 3/20/2012 15:39'!(Type) upperBound	^ upperBound! !!ParametricType methodsFor: 'accessing' stamp: 'EstebanAllende 3/20/2012 15:40'!(Self) upperBound: (Type)anObject	upperBound := anObject! !!ParametricType methodsFor: 'analisis' stamp: 'EstebanAllende 7/13/2012 15:19'!(Self) addCountIn: (Dictionary<Symbol,Integer>)aDictionary	aDictionary at: #ParametricType modify: [:(Integer)act| act + 1].	upperBound addCountIn: aDictionary.	super addCountIn: aDictionary! !!ParametricType methodsFor: 'comparing'!(Integer) hash	^self identityHash! !!ParametricType methodsFor: 'comparing' stamp: 'EstebanAllende 4/9/2012 12:08'!(Boolean) typeEquality: (Self) x	self kind = x kind ifFalse: [^false].	^self name = x name! !!ParametricType methodsFor: 'converting'!(NominalType) asNominalType	^upperBound asNominalType! !!ParametricType methodsFor: 'converting'!(StructuralType) asStructuralType	^upperBound asStructuralType! !!ParametricType methodsFor: 'copying' stamp: 'EstebanAllende 7/13/2012 15:34'!(Self) deepCopy	^self! !!ParametricType methodsFor: 'initialize-release' stamp: 'EstebanAllende 3/29/2012 14:39'!(Self) initialize	upperBound := ProtoObject asType! !!ParametricType methodsFor: 'parallel hierarchies'!(Type) classType	^upperBound classType! !!ParametricType methodsFor: 'queries'!(Type) lowestCommonAncestorBetween: (Type) another	(another = self) ifTrue: [^self].	^self upperBound lowestCommonAncestorBetween: another.! !!ParametricType methodsFor: 'queries'!(Type) typeOfSelector: (Symbol)selector fromClass: (ClassDescription) requestor	^upperBound typeOfSelector: selector fromClass: requestor.! !!ParametricType methodsFor: 'type resolution'!(Type) annotateSelfWith: (ClassDescription)aClass inMethod: (MethodSignature) aMethodSignature withKind: (Symbol) aSymbol	^self! !!ParametricType methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 15:34'!(Self) generateDictionaryWith: (Type) aType andDictionary: (Dictionary<Symbol, Type>) dict	"(self == aType) ifTrue: [^self]."	|(Type)resolvedUpperbound|	(kind = #class) ifTrue: [super generateDictionaryWith: aType andDictionary: dict. ^self].	resolvedUpperbound := upperBound resolveParametricWithReceiver: (dict at: #rcv) andDictionary: nil.	(aType isConsistentSubtypeOf: resolvedUpperbound)		ifTrue: [dict at: name put: aType]		ifFalse: [dict at: name put: resolvedUpperbound].	super generateDictionaryWith: aType andDictionary: dict.! !!ParametricType methodsFor: 'type resolution'!(Type) replaceSelfWith: (Type) aType	^self.! !!ParametricType methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 15:37'!(Type) resolveParametricWithReceiver: (Type)receiver andDictionary: (Dictionary<Symbol, Type>) dict	(kind = #local) ifTrue: [^self].	(kind = #class)		ifTrue: [ |(Type)lookedType (ClassDescription)classRef|			classRef := receiver asNominalType classRef.			classRef isMeta ifTrue: [classRef := Class].			lookedType := (TypeDictionary uniqueInstance getClassTypeEnvironmentFor: (<Class>classRef)) lookupType: name.			lookedType isParametric ifTrue: [				(receiver classParametrics isNil or: [receiver classParametrics size < (<ParametricType>lookedType) pos]) ifTrue: [^DynType implicitInstance].				^receiver classParametrics at: (<ParametricType>lookedType) pos.			].			^lookedType resolveParametricWithReceiver: receiver andDictionary: dict.		] ifFalse: [^dict at: name ifAbsent: [Error signal: 'Internal error: Unknown parametric'] ].! !!ParametricType methodsFor: 'type resolution' stamp: 'EstebanAllende 10/17/2012 22:15'!(Type) resolveWith: (TypeEnvironment) env ifNotFoundStore: (Symbol → Type) aBlock	super resolveWith: env ifNotFoundStore: aBlock.	"upperBound := upperBound resolveWith: env ifNotFoundStore: aBlock."	(kind = #unknown) 		ifTrue: [			|res ub|			ub := upperBound resolveWith: env ifNotFoundStore: aBlock.			res := (env lookupType: name) copy.			res ifNil: [ 				res := aBlock value: name.				env define: name as: res.				res upperBound: ub.			].			res classParametrics: classParametrics.			(upperBound isNominal and: [(<NominalType>ub) classRef = ProtoObject]) ifFalse:[				res upperBound: ub.			].			^res		].	^self.! !!ParametricType methodsFor: 'private'!(String) baseString	^name asString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ParametricType class	uses: TTyped classTrait	instanceVariableNames: ''!Type subclass: #StructuralType	uses: TTyped	instanceVariableNames: '(Type)base (Collection<MethodSignature>)methods'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Types'!!StructuralType commentStamp: 'EstebanAllende 10/1/2012 13:59' prior: 0!A StructuralType represent a type that conform a certain structure, i.e. contain at least a number of methods.!!StructuralType methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/7/2011 13:52'!(Boolean) isStructural	^true! !!StructuralType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 13:48'!(Type) base	^ base! !!StructuralType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 13:49'!(Self) base: (Type) anObject	base := anObject! !!StructuralType methodsFor: 'accessing' stamp: 'EstebanAllende 7/13/2012 15:48'!(Collection<MethodSignature>) methods	^ methods! !!StructuralType methodsFor: 'accessing' stamp: 'EstebanAllende 7/13/2012 15:48'!(Self) methods: (Collection<MethodSignature>)anObject	methods := anObject! !!StructuralType methodsFor: 'analisis' stamp: 'EstebanAllende 7/13/2012 15:43'!(Self) addCountIn: (Dictionary<Symbol,Integer>)aDictionary	aDictionary at: #StructuralType modify: [:(Integer)act| act + 1].	((Object asType = base) and: [base classParametrics isEmptyOrNil])		ifTrue: [aDictionary at: #OnlyStructural modify: [:(Integer)act| act +1]]		ifFalse: [			aDictionary at: #MixedStructural modify: [:(Integer)act| act + 1].			base addCountIn: aDictionary.		].	self methods do: [:(MethodSignature)each| each addCountIn: aDictionary].	super addCountIn: aDictionary! !!StructuralType methodsFor: 'comparing' stamp: 'EstebanAllende 12/7/2011 13:50'!(Integer) hash		^ methods inject: (self base hash) into: [:(Integer)acc :(MethodSignature)mth | acc hash + mth hash] ! !!StructuralType methodsFor: 'comparing' stamp: 'EstebanAllende 12/5/2011 14:05'!(Boolean) typeEquality: (Self) another	<access: protected>	(self base = another base) ifFalse: [^false].	^ self methods = another methods.! !!StructuralType methodsFor: 'converting' stamp: 'EstebanAllende 2/28/2012 20:38'!(NominalType) asNominalType	^ base asNominalType.! !!StructuralType methodsFor: 'converting' stamp: 'EstebanAllende 1/26/2012 14:46'!(StructuralType) asStructuralType	^self! !!StructuralType methodsFor: 'initialize-release' stamp: 'EstebanAllende 12/16/2011 18:24'!(Self) initialize	methods := #()! !!StructuralType methodsFor: 'parallel hierarchies' stamp: 'EstebanAllende 12/5/2011 12:38'!(Type) classType	^base classType! !!StructuralType methodsFor: 'parallel hierarchies' stamp: 'EstebanAllende 12/5/2011 12:47'!(Type) instanceType	^base instanceType! !!StructuralType methodsFor: 'queries' stamp: 'EstebanAllende 3/27/2012 18:00'!(Type) lowestCommonAncestorBetween: (Type) another	self flag: #TODO.	^self base lowestCommonAncestorBetween: another.! !!StructuralType methodsFor: 'queries' stamp: 'EstebanAllende 7/13/2012 15:49'!(Type) typeOfSelector: (Symbol)selector fromClass: (ClassDescription) requestor	|(Type)methodType|	methodType := self base typeOfSelector: selector fromClass: requestor.	methodType ifNil:[ |(Collection<MethodSignature>)temp|		temp := methods select: [:(MethodSignature)method| method selector = selector].		(temp size = 1) ifTrue: [methodType := temp anyOne signature]	].	methodType ifNil: [^nil].	^ methodType replaceSelfWith: self! !!StructuralType methodsFor: 'type resolution' stamp: 'EstebanAllende 3/28/2012 17:08'!(Type) annotateSelfWith: (ClassDescription)aClass inMethod: (MethodSignature) aMethodSignature withKind: (Symbol) aSymbol 	^self class new base: (self base annotateSelfWith: aClass inMethod: aMethodSignature withKind: aSymbol); 					 methods: (self methods collect: [:(MethodSignature)each| each annotateSelfWith: aClass inMethod: aMethodSignature withKind: aSymbol]).! !!StructuralType methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 15:43'!(Self) generateDictionaryWith: (Type) aType andDictionary: (Dictionary<Symbol, Type>) dict	self base generateDictionaryWith: aType andDictionary: dict.	self methods do: [:(MethodSignature)each| each generateDictionaryWith: aType andDictionary: dict].		super generateDictionaryWith: aType andDictionary: dict.	^self! !!StructuralType methodsFor: 'type resolution' stamp: 'EstebanAllende 3/28/2012 17:09'!(Type) replaceSelfWith: (Type) aType	^self class new base: (self base replaceSelfWith: aType); 					 methods: (self methods collect: [:(MethodSignature)each| each replaceSelfWith: aType]).! !!StructuralType methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 15:48'!(Type) resolveParametricWithReceiver: (Type)receiver andDictionary: (Dictionary<Symbol, Type>) dict	^self class new base: (self base resolveParametricWithReceiver: receiver andDictionary: dict); 					 methods: (self methods collect: [:(MethodSignature)each| each resolveParametricWithReceiver: receiver andDictionary: dict]).! !!StructuralType methodsFor: 'type resolution' stamp: 'EstebanAllende 4/9/2012 11:48'!(Type) resolveWith: (TypeEnvironment) env ifNotFoundStore: (Symbol → Type) aBlock	base := base resolveWith: env ifNotFoundStore: aBlock.	methods do: [:(MethodSignature)each| each resolveWith: env ifNotFoundStore: aBlock].	^self.! !!StructuralType methodsFor: 'validation' stamp: 'EstebanAllende 7/13/2012 15:49'!(OrderedCollection<Error>) validate	|(OrderedCollection<Error>)res (Set<Symbol>)set|	self flag: #TODO.	res := base validate.	set := Set new.	methods do: [:(MethodSignature)method|		(set includes: method selector) 			ifTrue: [res addLast: (TypeValidationError kind: #duplicatedMethodSelector msg:'Selector #',method selector,' is duplicated.'). res addAll: method signature validate]			ifFalse: [				|(Type) bmt|				set add: method selector.				res addAll: method signature validate.				bmt := base typeOfSelector: method selector fromClass: Object.				bmt ifNotNil: [(method signature isConsistentSubtypeOf: bmt) ifFalse: [res addLast: (TypeValidationError kind: #inconsistentSignature msg:'Inconsistent signature')]]			].						].	^res.! !!StructuralType methodsFor: 'private'!(String) baseString	|(String) structure|	structure := ((methods size) > 0) ifTrue:[					'{',('. ' join: (methods collect: [:(MethodSignature)method| (method selector asString), ' (' ,(method signature asString),')'])),'}'				] ifFalse: [''].	^base 		ifNil: [structure]		ifNotNil: [base asString , structure].! !!StructuralType methodsFor: 'private' stamp: 'EstebanAllende 12/7/2011 13:54'!(Type) simplify	(methods size = 0) ifTrue:[^base].	^self.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StructuralType class	uses: TTyped classTrait	instanceVariableNames: ''!Type subclass: #UnionType	uses: TTyped	instanceVariableNames: '(OrderedCollection<Type>)union'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Types'!!UnionType commentStamp: 'EstebanAllende 10/1/2012 14:02' prior: 0!An UnionType represent the type of an object that can be of any of the composing types.!!UnionType methodsFor: '*typesystem-types' stamp: 'EstebanAllende 3/29/2012 14:41'!(Boolean) isUnion	^true! !!UnionType methodsFor: 'accessing' stamp: 'EstebanAllende 7/13/2012 15:58'!(OrderedCollection<Type>) union	^ union! !!UnionType methodsFor: 'accessing' stamp: 'EstebanAllende 7/13/2012 15:58'!(Self) union: (OrderedCollection<Type>)anObject	union := anObject! !!UnionType methodsFor: 'analisis' stamp: 'EstebanAllende 7/13/2012 15:50'!(Self) addCountIn: (Dictionary<Symbol,Integer>)aDictionary	aDictionary at: #UnionType modify: [:(Integer)act| act + 1].	self union do: [:(Type)each| each addCountIn: aDictionary].	aDictionary at: #Total modify: [:(Integer)act| act +1].! !!UnionType methodsFor: 'comparing'!(Integer) hash	^self union inject: 0 into: [:(Integer)sum :(Type)each| sum + each hash].! !!UnionType methodsFor: 'comparing' stamp: 'EstebanAllende 3/27/2012 18:30'!(Boolean) typeEquality: (Self) another	<access: #protected>	self flag: #TODO. "This is wrong"	^self hash = another hash.! !!UnionType methodsFor: 'converting' stamp: 'EstebanAllende 3/27/2012 18:20'!(NominalType) asNominalType	^self commonAncestor asNominalType! !!UnionType methodsFor: 'converting' stamp: 'EstebanAllende 3/27/2012 18:21'!(StructuralType) asStructuralType	^self commonAncestor asStructuralType! !!UnionType methodsFor: 'parallel hierarchies' stamp: 'EstebanAllende 3/27/2012 18:25'!(Type) classType	^UnionType new union: (self union collect: [:(Type)each| each classType]).! !!UnionType methodsFor: 'parallel hierarchies'!(Type) instanceType	^UnionType new union: (self union collect: [:(Type)each| each instanceType]).! !!UnionType methodsFor: 'queries' stamp: 'EstebanAllende 7/13/2012 15:51'!(Type) commonAncestor	^self union inject: UndefinedObject asType 			     into: [:(Type)before :(Type)each| before lowestCommonAncestorBetween: each]! !!UnionType methodsFor: 'queries'!(Type) lowestCommonAncestorBetween: (Type) another	^self commonAncestor lowestCommonAncestorBetween: another.! !!UnionType methodsFor: 'queries'!(Type) typeOfSelector: (Symbol)selector fromClass: (ClassDescription) requestor	^self commonAncestor typeOfSelector: selector fromClass: requestor.! !!UnionType methodsFor: 'type resolution' stamp: 'EstebanAllende 3/27/2012 18:15'!(Type) annotateSelfWith: (ClassDescription)aClass inMethod: (MethodSignature) aMethodSignature withKind: (Symbol) aSymbol	^UnionType new union: (self union collect: [:(Type)each| each annotateSelfWith: aClass inMethod: aMethodSignature withKind: aSymbol]).! !!UnionType methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 15:51'!(Self) generateDictionaryWith: (Type) aType andDictionary: (Dictionary<Symbol, Type>) dict	"(self == aType) ifTrue: [^self]".	self union do: [:(Type)each| each generateDictionaryWith: aType andDictionary: dict].	! !!UnionType methodsFor: 'type resolution'!(Type) replaceSelfWith: (Type) aType	^UnionType new union: (self union collect: [:(Type)each| each replaceSelfWith: aType]).! !!UnionType methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 15:52'!(Type) resolveParametricWithReceiver: (Type)receiver andDictionary: (Dictionary<Symbol, Type>) dict	^UnionType new union: (self union collect: [:(Type)each| each resolveParametricWithReceiver: receiver andDictionary: dict]).! !!UnionType methodsFor: 'type resolution' stamp: 'EstebanAllende 4/9/2012 11:45'!(Type) resolveWith: (TypeEnvironment) env ifNotFoundStore: (Symbol → Type) aBlock	self union: (self union collect: [:(Type)each| each resolveWith: env ifNotFoundStore: aBlock]).	^self! !!UnionType methodsFor: 'validation' stamp: 'EstebanAllende 7/13/2012 16:00'!(OrderedCollection<Error>) validate	^self union inject: OrderedCollection new into: [:(OrderedCollection<Error>)col :(Type)each| col addAll: each validate].! !!UnionType methodsFor: 'private'!(String) baseString	^' | ' join: union.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnionType class	uses: TTyped classTrait	instanceVariableNames: ''!Type subclass: #SelfType	uses: TTyped	instanceVariableNames: '(ClassDescription)ownerClass (Symbol)kind (MethodSignature)definingMethod (Boolean)isSuper'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Types'!!SelfType commentStamp: 'EstebanAllende 10/1/2012 13:58' prior: 0!A SelfType represent the type of the receiver, self.!!SelfType methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/14/2011 11:58'!(Boolean)isSelf	^true! !!SelfType methodsFor: '*typesystem-types' stamp: 'EstebanAllende 9/21/2012 11:52'!(Boolean)isSuper	^isSuper! !!SelfType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 12:57'!(MethodSignature) definingMethod	^ definingMethod! !!SelfType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 12:58'!(Self) definingMethod: (MethodSignature) anObject	definingMethod := anObject! !!SelfType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 12:59'!(Symbol) kind	^ kind! !!SelfType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 13:00'!(Self) kind: (Symbol) anObject	kind := anObject! !!SelfType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 13:01'!(ClassDescription) ownerClass	^ ownerClass! !!SelfType methodsFor: 'accessing' stamp: 'EstebanAllende 3/29/2012 17:56'!(Self) ownerClass: (ClassDescription)anObject	anObject ifNotNil: [		(anObject name = #TUndefinedObject) ifTrue: [ownerClass := UndefinedObject. ^self]	].	ownerClass := anObject! !!SelfType methodsFor: 'analisis' stamp: 'EstebanAllende 7/13/2012 15:39'!(Self) addCountIn: (Dictionary<Symbol,Integer>)aDictionary	(kind = #class) ifTrue: [aDictionary at: #SelfClass modify: [:(Integer)act| act + 1].].	(kind = #instance) ifTrue: [aDictionary at: #SelfInstance modify: [:(Integer)act| act + 1].].	(kind = #normal) ifTrue: [aDictionary at: #Self modify: [:(Integer)act| act + 1].].	aDictionary at: #SelfType modify: [:(Integer)act| act + 1].	self classParametrics isEmptyOrNil 		ifFalse: [			aDictionary at: #GenericUsage modify: [:(Integer)act| act + 1].			self classParametrics do: [:(Type)each| each addCountIn: aDictionary].		].	aDictionary at: #Total modify: [:(Integer)act| act +1].! !!SelfType methodsFor: 'comparing' stamp: 'EstebanAllende 12/14/2011 11:58'!(Integer) hash	^ ownerClass hash + kind hash + 42.! !!SelfType methodsFor: 'comparing' stamp: 'EstebanAllende 12/14/2011 11:57'!(Boolean) typeEquality: (Self) another	<access: protected>	^(self ownerClass = another ownerClass) and: [self kind = another kind]! !!SelfType methodsFor: 'converting' stamp: 'EstebanAllende 2/21/2012 01:32'!(NominalType) asNominalType	^ self classRef asType! !!SelfType methodsFor: 'converting' stamp: 'EstebanAllende 2/21/2012 01:33'!(StructuralType) asStructuralType	^ self asNominalType asStructuralType! !!SelfType methodsFor: 'initialize-release' stamp: 'EstebanAllende 9/20/2012 17:00'!(Self) initialize	kind := #normal.	ownerClass := nil.	definingMethod := nil.	isSuper := false.! !!SelfType methodsFor: 'initialize-release' stamp: 'EstebanAllende 9/20/2012 17:00'!(Self) makeSuper	isSuper := true.! !!SelfType methodsFor: 'parallel hierarchies' stamp: 'EstebanAllende 12/14/2011 11:58'!(Type) classType	(kind = #normal) ifTrue: [^self shallowCopy kind: #class].	(kind = #instance) ifTrue: [^self shallowCopy kind: #normal].	ownerClass ifNil: [^Behavior asType].	^ownerClass asType classType classType! !!SelfType methodsFor: 'parallel hierarchies' stamp: 'EstebanAllende 12/14/2011 11:58'!(Type) instanceType	(kind = #normal) ifTrue: [^self shallowCopy kind: #instance].	(kind = #class) ifTrue: [^self shallowCopy kind: #normal].	ownerClass ifNil: [^nil].	^ownerClass asType instanceType instanceType! !!SelfType methodsFor: 'queries' stamp: 'EstebanAllende 2/21/2012 01:31'!(ClassDescription) classRef	ownerClass ifNil: [^nil].	^ kind caseOf: {		[#normal]->[ownerClass].		[#class]->[ownerClass asType classType classRef].		[#instance]->[ownerClass asType instanceType classRef]		}		! !!SelfType methodsFor: 'queries'!(Type) lowestCommonAncestorBetween: (Type) another		(another isSelf and: [(<SelfType>another) kind = self kind ]) ifTrue: [^self].	^self asNominalType lowestCommonAncestorBetween: another! !!SelfType methodsFor: 'queries' stamp: 'EstebanAllende 9/20/2012 19:24'!(Type) typeOfSelector: (Symbol)selector fromClass: (ClassDescription) requestor	|(Type)res|	self ownerClass ifNil: [^self error: 'Internal error. Owner class must never be nil when calling typeOfSelector'].	isSuper ifTrue: [		res := TypeDictionary uniqueInstance class: (<ClassDescription>self classRef superclass) atSelector: selector fromClass: requestor.		isSuper := false.	] ifFalse:[		((selector = definingMethod selector) & (kind = #normal) ) ifTrue: [ 			^definingMethod signature deepCopy annotateSelfWith: ownerClass inMethod: definingMethod withKind: kind		].		res := TypeDictionary uniqueInstance class: self classRef atSelector: selector fromClass: requestor.	].	res ifNil: [^nil].	^ res annotateSelfWith: ownerClass inMethod: definingMethod withKind: self kind! !!SelfType methodsFor: 'type resolution' stamp: 'EstebanAllende 6/29/2012 00:27'!(Type) annotateSelfWith: (ClassDescription)aClass inMethod: (MethodSignature) aMethodSignature withKind: (Symbol) aSymbol	kind caseOf: {		[#normal]->[^self class new ownerClass: aClass;definingMethod: aMethodSignature; kind: aSymbol; classParametrics: classParametrics].		[#class]->[			aSymbol caseOf: {				[#normal]->[^self class new ownerClass: aClass;definingMethod: aMethodSignature; kind: #class; classParametrics: classParametrics].				[#class]->[^aClass class class asType].				[#instance]->[^self class new ownerClass: aClass;definingMethod: aMethodSignature; kind: #normal]			}		].		[#instance]->[			aSymbol caseOf: {				[#normal]->[^self class new ownerClass: aClass;definingMethod: aMethodSignature; kind: #instance; classParametrics: classParametrics].				[#class]->[^self class new ownerClass: aClass;definingMethod: aMethodSignature; kind: #normal].				[#instance]->[^aClass asType instanceType instanceType]			}		]	}.	^nil! !!SelfType methodsFor: 'type resolution' stamp: 'EstebanAllende 7/7/2012 18:33'!(Type) replaceSelfWith: (Type) aType	^kind caseOf: {		[#normal]->[classParametrics ifNil: [aType] ifNotNil: [aType deepCopy classParametrics: classParametrics]].		[#class]->[classParametrics ifNil: [aType classType] ifNotNil: [aType classType deepCopy classParametrics: classParametrics]].		[#instance]->[classParametrics ifNil: [aType instanceType] ifNotNil: [aType instanceType deepCopy classParametrics: classParametrics]]	}.! !!SelfType methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 15:41'!(Type) resolveParametricWithReceiver: (Type)receiver andDictionary: (Dictionary<Symbol,Type>) dict	^self copy classParametrics: (self resolveParametricInGenericsWithReceiver: receiver andDictionary: dict).! !!SelfType methodsFor: 'validation' stamp: 'EstebanAllende 7/13/2012 15:42'!(OrderedCollection<Error>) validate	|(OrderedCollection<Error>)res|	res := OrderedCollection new.	(self kind = #instance and: [ownerClass asType instanceType isNil]) 		ifTrue:[ res addLast: (TypeValidationError kind: #noMetaClass msg: 'Class ''',self ownerClass name,''' is not a metaclass to have instances')].	^res! !!SelfType methodsFor: 'private'!(String) baseString	kind = #normal ifTrue: [^'Self'].	^'Self ',kind.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SelfType class	uses: TTyped classTrait	instanceVariableNames: ''!Type subclass: #DynType	uses: TTyped	instanceVariableNames: '(Boolean)implicit'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Types'!!DynType commentStamp: 'EstebanAllende 10/1/2012 13:50' prior: 0!A DynType represent the type of a dynamically typed objects.!!DynType methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/7/2011 11:23'!(Boolean) isDyn	^true! !!DynType methodsFor: 'accessing' stamp: 'EstebanAllende 7/13/2012 15:17'!(Self) classParametrics: (OrderedCollection<Type>)anObject	"Dyn cannot have class parametrics"! !!DynType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:18'!(Boolean) implicit	^implicit! !!DynType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:18'!(Self) implicit: (Boolean) i	<access: private>	implicit := i.! !!DynType methodsFor: 'analisis' stamp: 'EstebanAllende 7/13/2012 15:15'!(Self) addCountIn: (Dictionary<Symbol,Integer>)aDictionary	self implicit 		ifTrue: [aDictionary at: #ImplicitDyn modify: [:(Integer)act| act + 1]]		ifFalse: [aDictionary at: #ExplicitDyn modify: [:(Integer)act| act + 1]].	aDictionary at: #DynType modify: [:(Integer)act| act + 1].	aDictionary at: #Total modify: [:(Integer)act| act +1].	! !!DynType methodsFor: 'comparing' stamp: 'EstebanAllende 12/7/2011 11:18'!(Integer) hash	^self class explicitInstance identityHash! !!DynType methodsFor: 'comparing' stamp: 'EstebanAllende 12/7/2011 11:22'!(Boolean) typeEquality: (Self) another	<access: protected>	^true! !!DynType methodsFor: 'copying' stamp: 'EstebanAllende 4/9/2012 11:32'!(Self) copy	"Dyn is not cloneable"	^self! !!DynType methodsFor: 'copying' stamp: 'EstebanAllende 4/9/2012 11:32'!(Self) deepCopy	"Dyn is not cloneable"	^self! !!DynType methodsFor: 'parallel hierarchies' stamp: 'EstebanAllende 12/7/2011 11:18'!(Type) classType	^DynType implicitInstance! !!DynType methodsFor: 'parallel hierarchies' stamp: 'EstebanAllende 12/7/2011 11:23'!(Type) instanceType	^DynType implicitInstance! !!DynType methodsFor: 'queries'!(Type) lowestCommonAncestorBetween: (Type) another	^self! !!DynType methodsFor: 'queries' stamp: 'EstebanAllende 12/7/2011 11:53'!(Type) typeOfSelector: (Symbol)selector fromClass: (ClassDescription) requestor	^DynType implicitInstance! !!DynType methodsFor: 'type resolution' stamp: 'EstebanAllende 12/16/2011 18:02'!(Type) annotateSelfWith: (ClassDescription)aClass inMethod: (MethodSignature) aMethodSignature withKind: (Symbol) aSymbol	^self! !!DynType methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 15:17'!(Self) generateDictionaryWith: (Type) aType andDictionary: (Dictionary<Symbol,Type>) dict	^self! !!DynType methodsFor: 'type resolution' stamp: 'EstebanAllende 12/7/2011 11:22'!(Type) replaceSelfWith: (Type) aType	^self! !!DynType methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 15:18'!(Type) resolveParametricWithReceiver: (Type)receiver andDictionary: (Dictionary<Symbol, Type>) dict	^self.! !!DynType methodsFor: 'private'!(String) baseString	^'?'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DynType class	uses: TTyped classTrait	instanceVariableNames: '(DynType)explicitInstance (DynType)implicitInstance'!!DynType class methodsFor: 'class initialization' stamp: 'EstebanAllende 12/12/2011 17:53'!(Self) initialize	TypeConfiguration uniqueInstance bootstrap ifFalse: [^self].	explicitInstance := DynType new implicit: false.	implicitInstance := DynType new implicit: true.	TypeConfiguration uniqueInstance defaultType: implicitInstance! !!DynType class methodsFor: 'instance access' stamp: 'EstebanAllende 12/7/2011 11:17'!(DynType) explicitInstance	^explicitInstance! !!DynType class methodsFor: 'instance access' stamp: 'EstebanAllende 12/7/2011 11:17'!(DynType) implicitInstance	^implicitInstance! !Type subclass: #NominalType	uses: TTyped	instanceVariableNames: '(Symbol)name (Boolean)isMeta'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Types'!!NominalType commentStamp: 'EstebanAllende 10/1/2012 13:55' prior: 0!A NominalType represent the type of an object that is instance of a class or their subclasses.!!NominalType methodsFor: '*typesystem-types' stamp: 'EstebanAllende 12/7/2011 11:55'!(Boolean) isNominal	^true! !!NominalType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:56'!(Boolean) isMeta	^ isMeta! !!NominalType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:57'!(Self) isMeta: (Boolean)anObject	isMeta := anObject! !!NominalType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:57'!(Symbol) name	^name! !!NominalType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:57'!(Self) name: (Symbol)anObject	name := anObject! !!NominalType methodsFor: 'analisis' stamp: 'EstebanAllende 7/13/2012 15:19'!(Self) addCountIn: (Dictionary<Symbol,Integer>)aDictionary	aDictionary at: #NominalType modify: [:(Integer)act| act + 1].	super addCountIn: aDictionary! !!NominalType methodsFor: 'comparing' stamp: 'EstebanAllende 12/7/2011 11:55'!(Integer) hash	^self classRef hash! !!NominalType methodsFor: 'comparing' stamp: 'EstebanAllende 12/7/2011 11:56'!(Boolean) typeEquality: (Self) another	<access: protected>	(self name = another name) ifFalse: [^false].	(self isMeta = another isMeta) ifFalse: [^false].	^true! !!NominalType methodsFor: 'converting' stamp: 'EstebanAllende 12/22/2011 11:39'!(NominalType) asNominalType	^ self! !!NominalType methodsFor: 'converting' stamp: 'EstebanAllende 1/26/2012 14:46'!(StructuralType) asStructuralType	^StructuralType new base: self.! !!NominalType methodsFor: 'parallel hierarchies' stamp: 'EstebanAllende 12/7/2011 13:35'!(NominalType) classType	|(ClassDescription)class|	class := self classRef.	class ifNil: [^nil].	((class== Object) or: [Object inheritsFrom: class])		ifTrue: [^Behavior asType].			((class== ClassDescription) or: [ClassDescription inheritsFrom: class])		ifTrue: [^ClassDescription asType].			(class== Class) ifTrue: [^Metaclass asType].	"(class== Metaclass) ifTrue: [^Metaclass class asType]."	^class class asType! !!NominalType methodsFor: 'parallel hierarchies' stamp: 'EstebanAllende 12/7/2011 13:36'!(NominalType) instanceType	|(ClassDescription) class|	class := self classRef.	((class== Object) or: [Object inheritsFrom: class])		ifTrue: [^nil].		((class== ClassDescription) or: [ClassDescription inheritsFrom: class])		ifTrue: [^Behavior asType].			(class== Class) ifTrue: [^ProtoObject asType].	(class== Metaclass) ifTrue: [^Class asType].	class isMeta ifTrue: [^class theNonMetaClass asType].	^nil! !!NominalType methodsFor: 'queries' stamp: 'EstebanAllende 12/7/2011 13:31'!(ClassDescription) classRef	|(Class)ref|	ref:= [Smalltalk at: name asSymbol] on: Error do: [^nil].	self isMeta ifTrue:[^ ref class].	 ^ ref! !!NominalType methodsFor: 'queries' stamp: 'EstebanAllende 3/29/2012 14:58'!(Type) lowestCommonAncestorBetween: (Type) another	(self classRef = UndefinedObject) ifTrue: [^another].		another ifNil: [^nil].	another class caseOf: {		[DynType]->[^another].		[NominalType]->[^self nominalLCABetween: (<NominalType>another)].	} otherwise:  [self lowestCommonAncestorBetween: another asNominalType]! !!NominalType methodsFor: 'queries' stamp: 'EstebanAllende 7/7/2012 18:21'!(Type) typeOfSelector: (Symbol)selector fromClass: (ClassDescription) requestor	|(Type)type (ClassDescription)klass|	klass := self classRef.	klass ifNil: [^nil].	type:= TypeDictionary uniqueInstance class: klass atSelector: selector fromClass: requestor.	type ifNil: [^ nil].	^ type replaceSelfWith: self! !!NominalType methodsFor: 'relationships' stamp: 'EstebanAllende 7/13/2012 15:30'!(Boolean) isConsistentSubtypeOf: (Type) aType	|(ClassDescription)cr|	cr := self classRef.	(cr notNil and: [cr = UndefinedObject]) ifTrue: [^true].	^Type is: self consistentSubtypeOf: aType! !!NominalType methodsFor: 'relationships' stamp: 'EstebanAllende 12/7/2011 11:55'!(Boolean) isSubtypeOf: (Type) aType	|(ClassDescription) cr|	cr := self classRef.	(cr notNil and: [cr = UndefinedObject]) ifTrue: [^true].	^Type is: self subtypeOf: aType! !!NominalType methodsFor: 'type resolution' stamp: 'EstebanAllende 12/16/2011 18:02'!(Type) annotateSelfWith: (ClassDescription)aClass inMethod: (MethodSignature) aMethodSignature withKind: (Symbol) aSymbol	^self! !!NominalType methodsFor: 'type resolution' stamp: 'EstebanAllende 12/7/2011 11:56'!(Type) replaceSelfWith: (Type) aType	^self! !!NominalType methodsFor: 'type resolution' stamp: 'EstebanAllende 7/13/2012 15:32'!(Type) resolveParametricWithReceiver: (Type)receiver andDictionary: (Dictionary<Symbol, Type>) dict	^self copy classParametrics: (self resolveParametricInGenericsWithReceiver: receiver andDictionary: dict).! !!NominalType methodsFor: 'validation' stamp: 'EstebanAllende 7/13/2012 15:32'!(OrderedCollection<Error>) validate	|(OrderedCollection<Error>)res|	res := OrderedCollection new.	self classRef ifNil: [		res addLast: (TypeValidationError kind: #unknownClass msg: 'Class ''',self name,''' is not known in the system').	].	^res! !!NominalType methodsFor: 'private'!(String) baseString	^isMeta 		ifTrue:[name asString,' class']		ifFalse:[name asString].! !!NominalType methodsFor: 'private' stamp: 'EstebanAllende 3/29/2012 14:58'!(Type) nominalLCABetween: (NominalType) another	|(Behavior)class1 (Behavior)class2 |	(another classRef = UndefinedObject) ifTrue: [^self].	class1 := self classRef.	class2 := another classRef.		(class1 inheritsFrom: class2) ifTrue: [^another].	[(class1 = class2) or: [class2 inheritsFrom: class1]] 		whileFalse: [class1 := class1 superclass].	^ (<ClassDescription>class1) asType.		! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NominalType class	uses: TTyped classTrait	instanceVariableNames: ''!!NominalType class methodsFor: 'instance creation' stamp: 'EstebanAllende 12/7/2011 11:57'!(Self instance) for: (ClassDescription) class	|(Self instance) res|	res := self new.	res name: class theNonMetaClass name.	res isMeta: class isMeta.	^res! !!NominalType class methodsFor: 'instance creation' stamp: 'EstebanAllende 7/13/2012 16:04'!(Self instance) named: (String) aName	|(Collection<String>)ids|	ids:= aName subStrings: ' '.	^ self new name: (ids at: 1) asSymbol ; isMeta: (ids size > 1)! !DynType initialize!