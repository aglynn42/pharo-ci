Type subclass: #ParametricType	uses: TTyped	instanceVariableNames: '(Symbol)name (Symbol)kind (Integer)pos (Type)upperBound'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Types'!!ParametricType methodsFor: 'accessing' stamp: 'EstebanAllende 7/3/2012 13:58'!(Self) addCountIn: (Dictionary)aDictionary	aDictionary at: #ParametricType modify: [:act| act + 1].	upperBound addCountIn: aDictionary.	super addCountIn: aDictionary! !!ParametricType methodsFor: 'accessing'!(Type) annotateSelfWith: (ClassDescription)aClass inMethod: (MethodSignature) aMethodSignature withKind: (Symbol) aSymbol	^self! !!ParametricType methodsFor: 'accessing'!(NominalType) asNominalType	^upperBound asNominalType! !!ParametricType methodsFor: 'accessing'!(StructuralType) asStructuralType	^upperBound asStructuralType! !!ParametricType methodsFor: 'accessing'!(String) baseString	^name asString! !!ParametricType methodsFor: 'accessing'!(Type) classType	^upperBound classType! !!ParametricType methodsFor: 'accessing' stamp: 'EstebanAllende 6/28/2012 13:05'!deepCopy	^self! !!ParametricType methodsFor: 'accessing' stamp: 'EstebanAllende 7/3/2012 02:13'!(Self) generateDictionaryWith: (Type) aType andDictionary: (Dictionary) dict	"(self == aType) ifTrue: [^self]."	|(Type)resolvedUpperbound|	(kind = #class) ifTrue: [super generateDictionaryWith: aType andDictionary: dict. ^self].	resolvedUpperbound := upperBound resolveParametricWithReceiver: (dict at: #rcv) andDictionary: nil.	(aType isConsistentSubtypeOf: resolvedUpperbound)		ifTrue: [dict at: name put: aType]		ifFalse: [dict at: name put: resolvedUpperbound].	super generateDictionaryWith: aType andDictionary: dict.! !!ParametricType methodsFor: 'accessing'!(Integer) hash	^self identityHash! !!ParametricType methodsFor: 'accessing' stamp: 'EstebanAllende 3/29/2012 14:39'!(Self) initialize	upperBound := ProtoObject asType! !!ParametricType methodsFor: 'accessing'!(Boolean) isParametric	^true! !!ParametricType methodsFor: 'accessing' stamp: 'EstebanAllende 3/20/2012 15:37'!(Symbol) kind	^ kind! !!ParametricType methodsFor: 'accessing' stamp: 'EstebanAllende 3/20/2012 15:38'!(Self) kind: (Symbol)anObject	kind := anObject! !!ParametricType methodsFor: 'accessing'!(Type) lowestCommonAncestorBetween: (Type) another	(another = self) ifTrue: [^self].	^self upperBound lowestCommonAncestorBetween: another.! !!ParametricType methodsFor: 'accessing'!(Symbol) name	^name! !!ParametricType methodsFor: 'accessing' stamp: 'EstebanAllende 4/9/2012 13:40'!(Self) name: (Symbol)anObject	anObject isSymbol ifFalse: [self halt].	name := anObject! !!ParametricType methodsFor: 'accessing' stamp: 'EstebanAllende 3/20/2012 15:38'!(Integer) pos	^ pos! !!ParametricType methodsFor: 'accessing' stamp: 'EstebanAllende 3/20/2012 15:39'!(Self) pos: (Integer)anObject	pos := anObject! !!ParametricType methodsFor: 'accessing'!(Type) replaceSelfWith: (Type) aType	^self.! !!ParametricType methodsFor: 'accessing' stamp: 'EstebanAllende 7/3/2012 03:17'!(Type) resolveParametricWithReceiver: (Type)receiver andDictionary: (Dictionary) dict	(kind = #local) ifTrue: [^self].	(kind = #class)		ifTrue: [ |lookedType|			lookedType := (TypeDictionary uniqueInstance getClassTypeEnvironmentFor: (receiver asNominalType classRef)) lookupType: name.			lookedType isParametric ifTrue: [				(receiver classParametrics isNil or: [receiver classParametrics size < pos]) ifTrue: [^DynType implicitInstance].				^receiver classParametrics at: lookedType pos.			].			^lookedType resolveParametricWithReceiver: receiver andDictionary: dict.		] ifFalse: [^dict at: name ifAbsent: [Error signal: 'Internal error: Unknown parametric'] ].! !!ParametricType methodsFor: 'accessing' stamp: 'EstebanAllende 4/9/2012 12:06'!(Type) resolveWith: (TypeEnvironment) env ifNotFoundStore: (Symbol → Type) aBlock	super resolveWith: env ifNotFoundStore: aBlock.	upperBound := upperBound resolveWith: env ifNotFoundStore: aBlock.	^self.! !!ParametricType methodsFor: 'accessing' stamp: 'EstebanAllende 4/9/2012 12:08'!(Boolean) typeEquality: (Self) x	self kind = x kind ifFalse: [^false].	^self name = x name! !!ParametricType methodsFor: 'accessing'!(Type) typeOfSelector: (Symbol)selector fromClass: (ClassDescription) requestor	^upperBound typeOfSelector: selector fromClass: requestor.! !!ParametricType methodsFor: 'accessing' stamp: 'EstebanAllende 3/20/2012 15:39'!(Type) upperBound	^ upperBound! !!ParametricType methodsFor: 'accessing' stamp: 'EstebanAllende 3/20/2012 15:40'!(Self) upperBound: (Type)anObject	upperBound := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ParametricType class	uses: TTyped classTrait	instanceVariableNames: ''!Type subclass: #UnlinkedType	uses: TTyped	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Types'!!UnlinkedType methodsFor: 'accessing'!(Type) annotateSelfWith: (ClassDescription)aClass inMethod: (MethodSignature) aMethodSignature withKind: (Symbol) aSymbol	^self shouldNotImplement.! !!UnlinkedType methodsFor: 'accessing'!(NominalType) asNominalType	^self shouldNotImplement.! !!UnlinkedType methodsFor: 'accessing'!(StructuralType) asStructuralType	^self shouldNotImplement.! !!UnlinkedType methodsFor: 'accessing'!(Type) classType	^self shouldNotImplement.! !!UnlinkedType methodsFor: 'accessing'!(Type) instanceType	^self shouldNotImplement.! !!UnlinkedType methodsFor: 'accessing'!(Boolean) isCasteableTo: (Type) aType	^self shouldNotImplement.! !!UnlinkedType methodsFor: 'accessing' stamp: 'EstebanAllende 4/9/2012 11:11'!name	^name! !!UnlinkedType methodsFor: 'accessing' stamp: 'EstebanAllende 3/20/2012 17:07'!name: anObject	name := anObject asSymbol! !!UnlinkedType methodsFor: 'accessing' stamp: 'EstebanAllende 4/9/2012 15:06'!(Type) resolveWith: (TypeEnvironment) env ifNotFoundStore: (Symbol → Type) aBlock	|(Type) res|	super resolveWith: env ifNotFoundStore: aBlock.	(name = #Self) ifTrue: [		res := SelfType new.		res classParametrics: self classParametrics.		^res	].	res := (env lookupType: name) copy.	res ifNil: [ |pRes|		res := aBlock value: name.		env define: name as: res.	].	res classParametrics: self classParametrics.	^res! !!UnlinkedType methodsFor: 'as yet unclassified'!(Integer) hash	^name hash! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnlinkedType class	uses: TTyped classTrait	instanceVariableNames: '(Dictionary)subtypeRelations (Dictionary)consistentSubtypeRelations'!Type subclass: #DynType	uses: TTyped	instanceVariableNames: '(Boolean)implicit'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Types'!!DynType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 7/3/2012 17:36'!(Self) addCountIn: (Dictionary)aDictionary	self implicit 		ifTrue: [aDictionary at: #ImplicitDyn modify: [:act| act + 1]]		ifFalse: [aDictionary at: #ExplicitDyn modify: [:act| act + 1]].	aDictionary at: #DynType modify: [:act| act + 1].	aDictionary at: #Total modify: [:act| act +1].	! !!DynType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/16/2011 18:02'!(Type) annotateSelfWith: (ClassDescription)aClass inMethod: (MethodSignature) aMethodSignature withKind: (Symbol) aSymbol	^self! !!DynType methodsFor: 'as yet unclassified'!(String) baseString	^'?'! !!DynType methodsFor: 'as yet unclassified'!(Self) classParametrics: (OrderedCollection)anObject	"Dyn cannot have class parametrics"! !!DynType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:18'!(Type) classType	^DynType implicitInstance! !!DynType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 11:32'!(Self) copy	"Dyn is not cloneable"	^self! !!DynType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 11:32'!(Self) deepCopy	"Dyn is not cloneable"	^self! !!DynType methodsFor: 'as yet unclassified'!(Self) generateDictionaryWith: (Type) aType andDictionary: (Dictionary) dict	^self! !!DynType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:18'!(Integer) hash	^self class explicitInstance identityHash! !!DynType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:18'!(Boolean) implicit	^implicit! !!DynType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:18'!(Self) implicit: (Boolean) i	<access: private>	implicit := i.! !!DynType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:23'!(Type) instanceType	^DynType implicitInstance! !!DynType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:23'!(Boolean) isDyn	^true! !!DynType methodsFor: 'as yet unclassified'!(Type) lowestCommonAncestorBetween: (Type) another	^self! !!DynType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:22'!(Type) replaceSelfWith: (Type) aType	^self! !!DynType methodsFor: 'as yet unclassified'!(Type) resolveParametricWithReceiver: (Type)receiver andDictionary: (Dictionary) dict	^self.! !!DynType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:22'!(Boolean) typeEquality: (Self) another	<access: protected>	^true! !!DynType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:53'!(Type) typeOfSelector: (Symbol)selector fromClass: (ClassDescription) requestor	^DynType implicitInstance! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DynType class	uses: TTyped classTrait	instanceVariableNames: '(DynType)explicitInstance (DynType)implicitInstance'!!DynType class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:17'!(DynType) explicitInstance	^explicitInstance! !!DynType class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:17'!(DynType) implicitInstance	^implicitInstance! !!DynType class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/12/2011 17:53'!(Self) initialize	TypeConfiguration uniqueInstance bootstrap ifFalse: [^self].	explicitInstance := DynType new implicit: false.	implicitInstance := DynType new implicit: true.	TypeConfiguration uniqueInstance defaultType: implicitInstance! !Type subclass: #SelfType	uses: TTyped	instanceVariableNames: '(ClassDescription)ownerClass (Symbol)kind (MethodSignature)definingMethod'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Types'!!SelfType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 12:57'!(MethodSignature) definingMethod	^ definingMethod! !!SelfType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 12:58'!(Self) definingMethod: (MethodSignature) anObject	definingMethod := anObject! !!SelfType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 12:59'!(Symbol) kind	^ kind! !!SelfType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 13:00'!(Self) kind: (Symbol) anObject	kind := anObject! !!SelfType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 13:01'!(ClassDescription) ownerClass	^ ownerClass! !!SelfType methodsFor: 'accessing' stamp: 'EstebanAllende 3/29/2012 17:56'!(Self) ownerClass: (ClassDescription)anObject	anObject ifNotNil: [		(anObject name = #TUndefinedObject) ifTrue: [ownerClass := UndefinedObject. ^self]	].	ownerClass := anObject! !!SelfType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 7/4/2012 12:12'!(Self) addCountIn: (Dictionary)aDictionary	(kind = #class) ifTrue: [aDictionary at: #SelfClass modify: [:act| act + 1].].	(kind = #instance) ifTrue: [aDictionary at: #SelfInstance modify: [:act| act + 1].].	(kind = #normal) ifTrue: [aDictionary at: #Self modify: [:act| act + 1].].	aDictionary at: #SelfType modify: [:act| act + 1].	self classParametrics isEmptyOrNil 		ifFalse: [			self classParametrics do: [:each| each addCountIn: aDictionary].		].	aDictionary at: #Total modify: [:act| act +1].! !!SelfType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/29/2012 00:27'!(Type) annotateSelfWith: (ClassDescription)aClass inMethod: (MethodSignature) aMethodSignature withKind: (Symbol) aSymbol	kind caseOf: {		[#normal]->[^self class new ownerClass: aClass;definingMethod: aMethodSignature; kind: aSymbol; classParametrics: classParametrics].		[#class]->[			aSymbol caseOf: {				[#normal]->[^self class new ownerClass: aClass;definingMethod: aMethodSignature; kind: #class; classParametrics: classParametrics].				[#class]->[^aClass class class asType].				[#instance]->[^self class new ownerClass: aClass;definingMethod: aMethodSignature; kind: #normal]			}		].		[#instance]->[			aSymbol caseOf: {				[#normal]->[^self class new ownerClass: aClass;definingMethod: aMethodSignature; kind: #instance; classParametrics: classParametrics].				[#class]->[^self class new ownerClass: aClass;definingMethod: aMethodSignature; kind: #normal].				[#instance]->[^aClass asType instanceType instanceType]			}		]	}.	^nil! !!SelfType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 2/21/2012 01:32'!(NominalType) asNominalType	^ self classRef asType! !!SelfType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 2/21/2012 01:33'!(StructuralType) asStructuralType	^ self asNominalType asStructuralType! !!SelfType methodsFor: 'as yet unclassified'!(String) baseString	kind = #normal ifTrue: [^'Self'].	^'Self ',kind.! !!SelfType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 2/21/2012 01:31'!(ClassDescription) classRef	ownerClass ifNil: [^nil].	^ kind caseOf: {		[#normal]->[ownerClass].		[#class]->[ownerClass asType classType classRef].		[#instance]->[ownerClass asType instanceType classRef]		}		! !!SelfType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/14/2011 11:58'!(Type) classType	(kind = #normal) ifTrue: [^self shallowCopy kind: #class].	(kind = #instance) ifTrue: [^self shallowCopy kind: #normal].	ownerClass ifNil: [^Behavior asType].	^ownerClass asType classType classType! !!SelfType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/14/2011 11:58'!(Integer) hash	^ ownerClass hash + kind hash + 42.! !!SelfType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/27/2012 17:27'!(Self) initialize	kind := #normal.	ownerClass := nil.	definingMethod := nil.! !!SelfType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/14/2011 11:58'!(Type) instanceType	(kind = #normal) ifTrue: [^self shallowCopy kind: #instance].	(kind = #class) ifTrue: [^self shallowCopy kind: #normal].	ownerClass ifNil: [^nil].	^ownerClass asType instanceType instanceType! !!SelfType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/14/2011 11:58'!(Boolean)isSelf	^true! !!SelfType methodsFor: 'as yet unclassified'!(Type) lowestCommonAncestorBetween: (Type) another		(another isSelf and: [(<SelfType>another) kind = self kind ]) ifTrue: [^self].	^self asNominalType lowestCommonAncestorBetween: another! !!SelfType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 6/29/2012 17:33'!(Type) replaceSelfWith: (Type) aType	^kind caseOf: {		[#normal]->[classParametrics ifNil: [aType] ifNotNil: [aType deepCopy classParametrics: classParametrics]].		[#class]->[aType classType].		[#instance]->[aType instanceType]	}.! !!SelfType methodsFor: 'as yet unclassified'!(Type) resolveParametricWithReceiver: (Type)receiver andDictionary: (Dictionary) dict	^self copy classParametrics: (self resolveParametricInGenericsWithReceiver: receiver andDictionary: dict).! !!SelfType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/14/2011 11:57'!(Boolean) typeEquality: (Self) another	<access: protected>	^(self ownerClass = another ownerClass) and: [self kind = another kind]! !!SelfType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/20/2012 18:21'!(Type) typeOfSelector: (Symbol)selector fromClass: (ClassDescription) requestor	|(Type)res|	self ownerClass ifNil: [^self error: 'Internal error. Owner class must never be nil when calling typeOfSelector'].	((selector = definingMethod selector) & (kind = #normal) ) ifTrue: [ ^definingMethod signature annotateSelfWith: ownerClass inMethod: definingMethod withKind: kind].	res := TypeDictionary uniqueInstance class: self classRef atSelector: selector fromClass: requestor.	res ifNil: [^nil].	^ res annotateSelfWith: ownerClass inMethod: definingMethod withKind: self kind! !!SelfType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/22/2011 13:17'!(OrderedCollection) validate	|res|	res := OrderedCollection new.	(self kind = #instance and: [ownerClass asType instanceType isNil]) 		ifTrue:[ res addLast: (TypeValidationError kind: #noMetaClass msg: 'Class ''',self ownerClass name,''' is not a metaclass to have instances')].	^res! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SelfType class	uses: TTyped classTrait	instanceVariableNames: ''!Type subclass: #NominalType	uses: TTyped	instanceVariableNames: '(Symbol)name (Boolean)isMeta'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Types'!!NominalType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:56'!(Boolean) isMeta	^ isMeta! !!NominalType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:57'!(Self) isMeta: (Boolean)anObject	isMeta := anObject! !!NominalType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:57'!(Symbol) name	^name! !!NominalType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:57'!(Self) name: (Symbol)anObject	name := anObject! !!NominalType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 7/3/2012 13:18'!(Self) addCountIn: (Dictionary)aDictionary	aDictionary at: #NominalType modify: [:act| act + 1].	super addCountIn: aDictionary! !!NominalType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/16/2011 18:02'!(Type) annotateSelfWith: (ClassDescription)aClass inMethod: (MethodSignature) aMethodSignature withKind: (Symbol) aSymbol	^self! !!NominalType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/22/2011 11:39'!(NominalType) asNominalType	^ self! !!NominalType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 1/26/2012 14:46'!(StructuralType) asStructuralType	^StructuralType new base: self.! !!NominalType methodsFor: 'as yet unclassified'!(String) baseString	^isMeta 		ifTrue:[name asString,' class']		ifFalse:[name asString].! !!NominalType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 13:31'!(ClassDescription) classRef	|(Class)ref|	ref:= [Smalltalk at: name asSymbol] on: Error do: [^nil].	self isMeta ifTrue:[^ ref class].	 ^ ref! !!NominalType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 13:35'!(NominalType) classType	|(ClassDescription)class|	class := self classRef.	class ifNil: [^nil].	((class== Object) or: [Object inheritsFrom: class])		ifTrue: [^Behavior asType].			((class== ClassDescription) or: [ClassDescription inheritsFrom: class])		ifTrue: [^ClassDescription asType].			(class== Class) ifTrue: [^Metaclass asType].	"(class== Metaclass) ifTrue: [^Metaclass class asType]."	^class class asType! !!NominalType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:55'!(Integer) hash	^self classRef hash! !!NominalType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 13:36'!(NominalType) instanceType	|(ClassDescription) class|	class := self classRef.	((class== Object) or: [Object inheritsFrom: class])		ifTrue: [^nil].		((class== ClassDescription) or: [ClassDescription inheritsFrom: class])		ifTrue: [^Behavior asType].			(class== Class) ifTrue: [^ProtoObject asType].	(class== Metaclass) ifTrue: [^Class asType].	class isMeta ifTrue: [^class theNonMetaClass asType].	^nil! !!NominalType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:55'!(Boolean) isConsistentSubtypeOf: (Type) aType	|cr|	cr := self classRef.	(cr notNil and: [cr = UndefinedObject]) ifTrue: [^true].	^Type is: self consistentSubtypeOf: aType! !!NominalType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:55'!(Boolean) isNominal	^true! !!NominalType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:55'!(Boolean) isSubtypeOf: (Type) aType	|(ClassDescription) cr|	cr := self classRef.	(cr notNil and: [cr = UndefinedObject]) ifTrue: [^true].	^Type is: self subtypeOf: aType! !!NominalType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/29/2012 14:58'!(Type) lowestCommonAncestorBetween: (Type) another	(self classRef = UndefinedObject) ifTrue: [^another].		another ifNil: [^nil].	another class caseOf: {		[DynType]->[^another].		[NominalType]->[^self nominalLCABetween: (<NominalType>another)].	} otherwise:  [self lowestCommonAncestorBetween: another asNominalType]! !!NominalType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/29/2012 14:58'!(Type) nominalLCABetween: (NominalType) another	|(Behavior)class1 (Behavior)class2 |	(another classRef = UndefinedObject) ifTrue: [^self].	class1 := self classRef.	class2 := another classRef.		(class1 inheritsFrom: class2) ifTrue: [^another].	[(class1 = class2) or: [class2 inheritsFrom: class1]] 		whileFalse: [class1 := class1 superclass].	^ (<ClassDescription>class1) asType.		! !!NominalType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:56'!(Type) replaceSelfWith: (Type) aType	^self! !!NominalType methodsFor: 'as yet unclassified'!(Type) resolveParametricWithReceiver: (Type)receiver andDictionary: (Dictionary) dict	^self copy classParametrics: (self resolveParametricInGenericsWithReceiver: receiver andDictionary: dict).! !!NominalType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/28/2012 18:19'!(Type) superType	^(<ClassDescription>self classRef superclass) asType! !!NominalType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:56'!(Boolean) typeEquality: (Self) another	<access: protected>	(self name = another name) ifFalse: [^false].	(self isMeta = another isMeta) ifFalse: [^false].	^true! !!NominalType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:56'!(Type) typeOfSelector: (Symbol)selector fromClass: (ClassDescription) requestor	|(Type)type (ClassDescription)klass|	klass := self classRef.	klass ifNil: [^nil].	type:= TypeDictionary uniqueInstance class: klass atSelector: selector fromClass: requestor.	type ifNil: [^ nil].	^ type replaceSelfWith: self! !!NominalType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/22/2011 13:00'!(OrderedCollection) validate	|res|	res := OrderedCollection new.	self classRef ifNil: [		res addLast: (TypeValidationError kind: #unknownClass msg: 'Class ''',self name,''' is not known in the system').	].	^res! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NominalType class	uses: TTyped classTrait	instanceVariableNames: ''!!NominalType class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:57'!(Self instance) for: (ClassDescription) class	|(Self instance) res|	res := self new.	res name: class theNonMetaClass name.	res isMeta: class isMeta.	^res! !!NominalType class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:58'!(Self instance) named: (String) aName	|(Collection)ids|	ids:= aName subStrings: ' '.	^ self new name: (ids at: 1) asSymbol ; isMeta: (ids size > 1)! !Type subclass: #UnionType	uses: TTyped	instanceVariableNames: '(OrderedCollection)union'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Types'!!UnionType methodsFor: 'accessing'!union	^ union! !!UnionType methodsFor: 'accessing'!union: anObject	union := anObject! !!UnionType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 7/3/2012 17:38'!(Self) addCountIn: (Dictionary)aDictionary	aDictionary at: #UnionType modify: [:act| act + 1].	self union do: [:each| each addCountIn: aDictionary].	aDictionary at: #Total modify: [:act| act +1].! !!UnionType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/27/2012 18:15'!(Type) annotateSelfWith: (ClassDescription)aClass inMethod: (MethodSignature) aMethodSignature withKind: (Symbol) aSymbol	^UnionType new union: (self union collect: [:(Type)each| each annotateSelfWith: aClass inMethod: aMethodSignature withKind: aSymbol]).! !!UnionType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/27/2012 18:20'!(NominalType) asNominalType	^self commonAncestor asNominalType! !!UnionType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/27/2012 18:21'!(StructuralType) asStructuralType	^self commonAncestor asStructuralType! !!UnionType methodsFor: 'as yet unclassified'!(String) baseString	^' | ' join: union.! !!UnionType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/27/2012 18:25'!(Type) classType	^UnionType new union: (self union collect: [:(Type)each| each classType]).! !!UnionType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/27/2012 18:20'!(Type) commonAncestor	^self union inject: UndefinedObject asType 			     into: [:(Type)before :(Type)each| before lowestCommonAncestorBetween: each]! !!UnionType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 7/3/2012 00:02'!(Self) generateDictionaryWith: (Type) aType andDictionary: (Dictionary) dict	"(self == aType) ifTrue: [^self]".	self union do: [:(Type)each| each generateDictionaryWith: aType andDictionary: dict].	! !!UnionType methodsFor: 'as yet unclassified'!(Integer) hash	^self union inject: 0 into: [:(Integer)sum :(Type)each| sum + each hash].! !!UnionType methodsFor: 'as yet unclassified'!(Type) instanceType	^UnionType new union: (self union collect: [:(Type)each| each instanceType]).! !!UnionType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/29/2012 14:41'!(Boolean) isUnion	^true! !!UnionType methodsFor: 'as yet unclassified'!(Type) lowestCommonAncestorBetween: (Type) another	^self commonAncestor lowestCommonAncestorBetween: another.! !!UnionType methodsFor: 'as yet unclassified'!(Type) replaceSelfWith: (Type) aType	^UnionType new union: (self union collect: [:(Type)each| each replaceSelfWith: aType]).! !!UnionType methodsFor: 'as yet unclassified'!(Type) resolveParametricWithReceiver: (Type)receiver andDictionary: (Dictionary) dict	^UnionType new union: (self union collect: [:(Type)each| each resolveParametricWithReceiver: receiver andDictionary: dict]).! !!UnionType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 11:45'!(Type) resolveWith: (TypeEnvironment) env ifNotFoundStore: (Symbol → Type) aBlock	self union: (self union collect: [:(Type)each| each resolveWith: env ifNotFoundStore: aBlock]).	^self! !!UnionType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/27/2012 18:30'!(Boolean) typeEquality: (Self) another	<access: #protected>	self flag: #TODO. "This is wrong"	^self hash = another hash.! !!UnionType methodsFor: 'as yet unclassified'!(Type) typeOfSelector: (Symbol)selector fromClass: (ClassDescription) requestor	^self commonAncestor typeOfSelector: selector fromClass: requestor.! !!UnionType methodsFor: 'as yet unclassified'!(OrderedCollection) validate	^self union inject: OrderedCollection new into: [:(OrderedCollection)col :(Type)each| col addAll: each validate].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnionType class	uses: TTyped classTrait	instanceVariableNames: ''!Type subclass: #LambdaType	uses: TTyped	instanceVariableNames: '(SequenceableCollection)params (Type)return'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Types'!!LambdaType methodsFor: 'accessing' stamp: 'EstebanAllende 3/27/2012 00:14'!(SequenceableCollection) params	^ params! !!LambdaType methodsFor: 'accessing' stamp: 'EstebanAllende 3/27/2012 00:14'!(Self) params: (SequenceableCollection)anObject	params := anObject! !!LambdaType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:34'!(Type) return	^ return! !!LambdaType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 11:34'!(Self) return: (Type)anObject	return := anObject! !!LambdaType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 7/3/2012 17:37'!(Self) addCountIn: (Dictionary)aDictionary	aDictionary at: #LambdaType modify: [:act| act + 1].	self params do: [:each| each addCountIn: aDictionary].	self return addCountIn: aDictionary.	aDictionary at: #Total modify: [:act| act +1].! !!LambdaType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/28/2012 17:05'!(Type) annotateSelfWith: (ClassDescription)aClass inMethod: (MethodSignature) aMethodSignature withKind: (Symbol) aSymbol	|(SequenceableCollection)pType (Type)rType|	pType := self params collect: [:(Type)each| each annotateSelfWith: aClass inMethod: aMethodSignature withKind: aSymbol].	rType := self return annotateSelfWith: aClass inMethod: aMethodSignature withKind: aSymbol.	^LambdaType new params: pType; return: rType.! !!LambdaType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/20/2012 17:52'!(NominalType) asNominalType	^ LambdaType lambdaNominalType.! !!LambdaType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 1/26/2012 14:43'!(StructuralType) asStructuralType	^ LambdaType lambdaNominalType asStructuralType.! !!LambdaType methodsFor: 'as yet unclassified'!(String) baseString	^ (' ' join: (params collect: [:(Type)each | each asString])),' -> ',(return asString)! !!LambdaType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/13/2012 14:46'!(Type) classType	^self class lambdaNominalType classType! !!LambdaType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 7/2/2012 23:59'!(Self) generateDictionaryWith: (Type) aType andDictionary: (Dictionary) dict	(aType isDyn | aType isNominal) ifTrue: [		self params do: [:(Type)each| each generateDictionaryWith: DynType implicitInstance andDictionary: dict].		self return generateDictionaryWith: DynType implicitInstance andDictionary: dict.	].	(aType isLambda) ifTrue: [		|(LambdaType)lType|		lType := (<LambdaType> aType).		(self params size = lType params size) ifTrue: [			self params with: lType params do: [:(Type)each :(Type)another| each generateDictionaryWith: another andDictionary: dict].		].		lType return ifNotNil: [ self return generateDictionaryWith: lType return andDictionary: dict.].	].	super generateDictionaryWith: aType andDictionary: dict.! !!LambdaType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:35'!(Integer) hash	|(Integer) res|	res := self return hash.	1 to: self params size do: [:(Integer)i|		res:= res + (self params at: i) hash	].	^res! !!LambdaType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:35'!(Type) instanceType	^nil! !!LambdaType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:35'!(Boolean)isLambda	^true! !!LambdaType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:36'!(Boolean) isLambdaConsistentSubtypeOf: (LambdaType)another		(self return isConsistentSubtypeOf: another return) ifFalse: [^false].	(self params size = another params size) ifFalse: [^false].	1 to: self params size do: [:(Integer)i|		|(Type)selfParam (Type)anotherParam|		selfParam := self params at: i.		anotherParam := another params at: i.		(anotherParam isConsistentSubtypeOf: selfParam) ifFalse: [^false]	].	^true	! !!LambdaType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:36'!(Boolean) isLambdaSubtypeOf: (LambdaType)another		(self return isSubtypeOf: another return) ifFalse: [^false].	(self params size = another params size) ifFalse: [^false].	1 to: self params size do: [:(Integer)i|		|(Type)selfParam (Type)anotherParam|		selfParam := self params at: i.		anotherParam := another params at: i.		(anotherParam isSubtypeOf: selfParam) ifFalse: [^false]	].	^true	! !!LambdaType methodsFor: 'as yet unclassified'!(Type) lowestCommonAncestorBetween: (Type) another	self flag: #TODO.	^self asNominalType lowestCommonAncestorBetween: another.! !!LambdaType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/28/2012 17:05'!(Type) replaceSelfWith: (Type) aType	|(SequenceableCollection)pType (Type)rType|	pType := self params collect: [:(Type)each| each replaceSelfWith: aType].	rType := self return replaceSelfWith: aType.	^LambdaType new params: pType; return: rType.! !!LambdaType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/28/2012 17:06'!(Type) resolveParametricWithReceiver: (Type)receiver andDictionary: (Dictionary) dict	|(SequenceableCollection)pType (Type)rType|	pType := self params collect: [:(Type)each| each resolveParametricWithReceiver: receiver andDictionary: dict].	rType := self return resolveParametricWithReceiver: receiver andDictionary: dict.	^LambdaType new params: pType; return: rType.! !!LambdaType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 11:45'!(Type) resolveWith: (TypeEnvironment) env ifNotFoundStore: (Symbol → Type) aBlock	params := params collect: [:each| each resolveWith: env ifNotFoundStore: aBlock].	return := return resolveWith: env ifNotFoundStore: aBlock.	^self.! !!LambdaType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 11:47'!(Boolean) typeEquality: (Self) another	<access: protected>	((self return) = (another return)) ifFalse: [^false].	(self params size = another params size) ifFalse: [^false].	1 to: self params size do: [:(Integer)i|		((self params at: i) = (another params at: i)) ifFalse: [^false].	].	^true! !!LambdaType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 1/30/2012 14:09'!(Type) typeOfSelector: (Symbol)selector fromClass: (ClassDescription) requestor	(#(value value: value:value: value:value:value: value:value:value:value: valueNoContextSwitch: valueNoContextSwitch valueWithArguments: ) includes: selector) ifTrue: [^self].	^ LambdaType lambdaNominalType typeOfSelector: selector fromClass: requestor.! !!LambdaType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/28/2012 17:06'!(OrderedCollection) validate	|res|	res := OrderedCollection new.	self params do: [:(Type)each| res addAll: each validate].	res addAll: self return validate.	^res.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!LambdaType class	uses: TTyped classTrait	instanceVariableNames: ''!!LambdaType class methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/20/2012 17:51'!(NominalType) lambdaNominalType	^[:x|x] class asType! !Type subclass: #StructuralType	uses: TTyped	instanceVariableNames: '(Type)base (Collection)methods'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Types'!!StructuralType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 13:48'!(Type) base	^ base! !!StructuralType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 13:49'!(Self) base: (Type) anObject	base := anObject! !!StructuralType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 13:49'!(Collection) methods	^ methods! !!StructuralType methodsFor: 'accessing' stamp: 'EstebanAllende 12/7/2011 13:49'!(Self) methods: (Collection)anObject	methods := anObject! !!StructuralType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 7/4/2012 12:09'!(Self) addCountIn: (Dictionary)aDictionary	aDictionary at: #StructuralType modify: [:act| act + 1].	((Object asType = base) and: [base classParametrics isEmptyOrNil])		ifTrue: [aDictionary at: #OnlyStructural modify: [:act| act +1]]		ifFalse: [			aDictionary at: #MixedStructural modify: [:act| act + 1].			base addCountIn: aDictionary.		].	self methods do: [:each| each addCountIn: aDictionary].	super addCountIn: aDictionary! !!StructuralType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/28/2012 17:08'!(Type) annotateSelfWith: (ClassDescription)aClass inMethod: (MethodSignature) aMethodSignature withKind: (Symbol) aSymbol 	^self class new base: (self base annotateSelfWith: aClass inMethod: aMethodSignature withKind: aSymbol); 					 methods: (self methods collect: [:(MethodSignature)each| each annotateSelfWith: aClass inMethod: aMethodSignature withKind: aSymbol]).! !!StructuralType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 2/28/2012 20:38'!(NominalType) asNominalType	^ base asNominalType.! !!StructuralType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 1/26/2012 14:46'!(StructuralType) asStructuralType	^self! !!StructuralType methodsFor: 'as yet unclassified'!(String) baseString	|(String) structure|	structure := ((methods size) > 0) ifTrue:[					'{',('. ' join: (methods collect: [:(MethodSignature)method| (method selector asString), ' (' ,(method signature asString),')'])),'}'				] ifFalse: [''].	^base 		ifNil: [structure]		ifNotNil: [base asString , structure].! !!StructuralType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 12:38'!(Type) classType	^base classType! !!StructuralType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/22/2012 15:51'!(Self) generateDictionaryWith: (Type) aType andDictionary: (Dictionary) dict	self base generateDictionaryWith: aType andDictionary: dict.	self methods do: [:(MethodSignature)each| each generateDictionaryWith: aType andDictionary: dict].		super generateDictionaryWith: aType andDictionary: dict.	^self! !!StructuralType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 13:50'!(Integer) hash		^ methods inject: (self base hash) into: [:(Integer)acc :(MethodSignature)mth | acc hash + mth hash] ! !!StructuralType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/16/2011 18:24'!(Self) initialize	methods := #()! !!StructuralType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 12:47'!(Type) instanceType	^base instanceType! !!StructuralType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 13:52'!(Boolean) isConsistentStructuralSubtype: (StructuralType) aStructuralType 	(self base isConsistentSubtypeOf: aStructuralType base)		ifFalse: [^ false].	aStructuralType methods do: [:(MethodSignature)method| |(Type)type|		type:= base typeOfSelector: method selector fromClass: Object.		type ifNil: [ |(Boolean)flag| 					flag:=false. 					self methods do: [:(MethodSignature)each| 						(each selector == method selector) ifTrue: [							flag:= each signature isConsistentSubtypeOf: method signature] ].				    flag ifFalse: [^false]]			ifNotNil: [|(Boolean)flag|					flag:= type isConsistentSubtypeOf: method signature.					flag ifFalse: [^false]				]		].			^ true! !!StructuralType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 13:52'!(Boolean) isStructural	^true! !!StructuralType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 13:54'!(Boolean) isStructuralSubtype: (StructuralType) aStructuralType 	(self base isSubtypeOf: aStructuralType base)		ifFalse: [^ false].	aStructuralType methods do: [:(MethodSignature)method| |type|		type:= base typeOfSelector: method selector fromClass: Object.		type ifNil: [ |(Boolean)flag| 					flag:=false. 					self methods do: [:(MethodSignature)each| 						(each selector == method selector) ifTrue: [							flag:= each signature isSubtypeOf: method signature] ].				    flag ifFalse: [^false]]			ifNotNil: [|(Boolean)flag|					flag:= type isSubtypeOf: method signature.					flag ifFalse: [^false]				]		].			^ true! !!StructuralType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/22/2011 11:51'!(Boolean) isStructuralSubtypeOf: (StructuralType) aStructuralType 	(self base isSubtypeOf: aStructuralType base)		ifFalse: [^ false].	aStructuralType methods do: [:(MethodSignature)method| |type|		type:= base typeOfSelector: method selector fromClass: Object.		type ifNil: [ |(Boolean)flag| 					flag:=false. 					self methods do: [:(MethodSignature)each| 						(each selector == method selector) ifTrue: [							flag:= each signature isSubtypeOf: method signature] ].				    flag ifFalse: [^false]]			ifNotNil: [|(Boolean)flag|					flag:= type isSubtypeOf: method signature.					flag ifFalse: [^false]				]		].			^ true! !!StructuralType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/27/2012 18:00'!(Type) lowestCommonAncestorBetween: (Type) another	self flag: #TODO.	^self base lowestCommonAncestorBetween: another.! !!StructuralType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/28/2012 17:09'!(Type) replaceSelfWith: (Type) aType	^self class new base: (self base replaceSelfWith: aType); 					 methods: (self methods collect: [:(MethodSignature)each| each replaceSelfWith: aType]).! !!StructuralType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/26/2012 19:08'!(Type) resolveParametricWithReceiver: (Type)receiver andDictionary: (Dictionary) dict	^self class new base: (self base resolveParametricWithReceiver: receiver andDictionary: dict); 					 methods: (self methods collect: [:(MethodSignature)each| each resolveParametricWithReceiver: receiver andDictionary: dict]).! !!StructuralType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 4/9/2012 11:48'!(Type) resolveWith: (TypeEnvironment) env ifNotFoundStore: (Symbol → Type) aBlock	base := base resolveWith: env ifNotFoundStore: aBlock.	methods do: [:(MethodSignature)each| each resolveWith: env ifNotFoundStore: aBlock].	^self.! !!StructuralType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/7/2011 13:54'!(Type) simplify	(methods size = 0) ifTrue:[^base].	^self.! !!StructuralType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/5/2011 14:05'!(Boolean) typeEquality: (Self) another	<access: protected>	(self base = another base) ifFalse: [^false].	^ self methods = another methods.! !!StructuralType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 3/28/2012 17:10'!(Type) typeOfSelector: (Symbol)selector fromClass: (ClassDescription) requestor	|(Type)methodType|	methodType := self base typeOfSelector: selector fromClass: requestor.	methodType ifNil:[ |(Collection)temp|		temp := methods select: [:(MethodSignature)method| method selector = selector].		(temp size = 1) ifTrue: [methodType := temp anyOne signature]	].	methodType ifNil: [^nil].	^ methodType replaceSelfWith: self! !!StructuralType methodsFor: 'as yet unclassified' stamp: 'EstebanAllende 12/22/2011 13:42'!(OrderedCollection) validate	|(OrderedCollection)res (Set)set|	self flag: #TODO.	res := base validate.	set := Set new.	methods do: [:(MethodSignature)method|		(set includes: method selector) 			ifTrue: [res addLast: (TypeValidationError kind: #duplicatedMethodSelector msg:'Selector #',method selector,' is duplicated.'). res addAll: method signature validate]			ifFalse: [				|(Type) bmt|				set add: method selector.				res addAll: method signature validate.				bmt := base typeOfSelector: method selector fromClass: Object.				bmt ifNotNil: [(method signature isConsistentSubtypeOf: bmt) ifFalse: [res addLast: (TypeValidationError kind: #inconsistentSignature msg:'Inconsistent signature')]]			].						].	^res.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StructuralType class	uses: TTyped classTrait	instanceVariableNames: ''!DynType initialize!