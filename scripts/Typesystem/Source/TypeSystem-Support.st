BlockClosure variableSubclass: #WrappedBlockClosure	uses: TUntyped	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Support'!!WrappedBlockClosure commentStamp: 'EstebanAllende 10/1/2012 15:07' prior: 0!A WrappedBlockClosure is a null wrapper for block closure. Used by subclasses to reuse basic wrapping code.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WrappedBlockClosure class	uses: TUntyped classTrait	instanceVariableNames: ''!!WrappedBlockClosure class methodsFor: 'instance creation' stamp: 'EstebanAllende 7/17/2012 15:20'!fromBlockClosure: aBlockClosure	^self outerContext: aBlockClosure outerContext startpc: aBlockClosure startpc numArgs: aBlockClosure numArgs copiedValues: aBlockClosure.! !Object subclass: #CastCheckAtRuntime	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Support'!!CastCheckAtRuntime commentStamp: 'EstebanAllende 10/1/2012 14:59' prior: 0!CastCheckAtRuntime is the class containing all casting methods and utilities for runtime.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CastCheckAtRuntime class	instanceVariableNames: 'astBinding'!!CastCheckAtRuntime class methodsFor: 'casting' stamp: 'EstebanAllende 8/14/2012 17:50'!argObj: anObject type: aLiteralArray class: aClass	|parser res ctx activeProcess env klass|	res := anObject.	activeProcess := Processor activeProcess.	(TSLinkedSet includes: activeProcess) ifTrue: [^anObject].	TSLinkedSet add: activeProcess.	TypeConfiguration uniqueInstance enableCasts ifFalse:[TSLinkedSet remove: activeProcess.^anObject].	ctx := thisContext sender sender.		[ ctx methodClass = WrappedLambda] whileTrue: [	ctx := ctx sender.	] .	ctx := MementoContext for: ctx.	["		env := TypeEnvironment new.		env local: false.		klass := aClass theNonMetaClass.		aClass isMeta ifTrue: [klass := Class].		env parent: (TypeDictionary uniqueInstance getClassTypeEnvironmentFor: klass)."		res := anObject.		aLiteralArray do: [ :sType|"			|type|			type := parser parse: sType.			type := type resolveWith: env."			res := self cast: res to: sType inClass: aClass blameContext: ctx.		].	] ensure: [TSLinkedSet remove: activeProcess].	^res! !!CastCheckAtRuntime class methodsFor: 'casting' stamp: 'EstebanAllende 7/16/2012 01:47'!cast: res to: aType inClass: aClass blameContext: ctx	res ifNil: [^res].	aType isNominal ifTrue: [^self castNominal: res to: aType inClass: aClass blameContext: ctx].	aType isSelf ifTrue: [^self castSelf: res to: aType inClass: aClass blameContext: ctx].	aType isLambda ifTrue: [^self castLambda: res to: aType inClass: aClass blameContext: ctx].	aType isSelf ifTrue: [^self castSelf: res to: aType inClass: aClass blameContext: ctx].	aType isStructural ifTrue: [^self castStructural: res to: aType inClass: aClass blameContext: ctx].	aType isUnion ifTrue: [^self castUnion: res to: aType inClass: aClass blameContext: ctx].	(aType class == UnlinkedType) ifTrue: [^self error: 'Internal error: Unlinked type in cast'].	^res.! !!CastCheckAtRuntime class methodsFor: 'casting' stamp: 'EstebanAllende 9/13/2012 11:34'!castLambda: res to: aType inClass: aClass blameContext: ctx	|block|	res isBlock ifFalse: [self castError: '''', res asString,''' is not a block' blaming: ctx].	res numArgs = aType params size ifFalse: [self castError: 'Incompatible parameters size for block. Expected #params: ',aType params size asString,', actual #params: ', res numArgs asString ].	aType return isDyn ifTrue: [( aType params allSatisfy: [:each | each isDyn]) ifTrue: [^ res] ].	block := res.	[block isKindOf: WrappedLambda]		whileTrue: [			1 to: block paramCasts size do: [:i|				((aType params at: i) isRuntimeCasteableTo: (block paramCasts at: i))					ifFalse: [self castError: 'Incompatible casts between lambdas. Intended: ', aType asString,'. Conflict:  ',(LambdaType new params: block paramCasts; return: block returnCast) asString, ' in ', block ctx method methodClass name,'<<',block ctx method selector blaming: ctx]			].			(aType return  isRuntimeCasteableTo: block returnCast)					ifFalse: [self castError: 'Incompatible casts between lambdas. Intended: ', aType asString,'. Conflict:  ',(LambdaType new params: block paramCasts; return: block returnCast) asString, ' in ', block ctx method methodClass name,'<<',block ctx method selector  blaming: ctx].			block := block obc.		].	^WrappedLambda fromBlockClosure: res  withParamCasts: aType params  withReturnCast: aType return inClass: aClass withContext: (MementoContext for: ctx). ! !!CastCheckAtRuntime class methodsFor: 'casting' stamp: 'EstebanAllende 7/19/2012 03:31'!castNominal: res to: aType inClass: aClass blameContext: ctx	(res isTKindOf: aType classRef) ifFalse: [self castError: ('''',res asString,''' is not casteable to type ',aType classRef asString) blaming: ctx].	^res	! !!CastCheckAtRuntime class methodsFor: 'casting' stamp: 'EstebanAllende 7/19/2012 03:32'!castSelf: res to: aType inClass: aClass blameContext: ctx	aType kind = #normal ifTrue: [(res isTKindOf: aClass) ifFalse: [self castError: '''',res asString,''' is not casteable to type Self (',aClass asString,')' blaming: ctx]].	aType kind = #class ifTrue: [(res isTKindOf: aClass class) ifFalse: [self castError: '''',res asString,''' is not casteable to type Self class (',aClass class asString,')' blaming: ctx]].	aType kind = #instance ifTrue: [(res class isTKindOf: aClass) ifFalse: [self castError: '''',res asString,''' is not casteable to type Self instance(',aClass asNominalType instanceType classRef asString,')' blaming: ctx]].	^res! !!CastCheckAtRuntime class methodsFor: 'casting' stamp: 'EstebanAllende 7/15/2012 22:17'!castStructural: res to: aType inClass: aClass blameContext: ctx	self cast: res to: aType base inClass: aClass blameContext: ctx.	aType methods do: [:method|		|objectMethod|		objectMethod := TypeDictionary uniqueInstance class:  res class atSelector: method selector fromClass: aClass.		objectMethod ifNil: [self castError: '''',res asString,''' is not casteable to type ',aType asString, ' (Does not have method ''',method selector,''')' blaming: ctx].		(objectMethod isConsistentSubtypeOf: method signature) ifFalse: [self castError: '''',res asString,''' is not casteable to type ',aType asString, ' (Inconsistent type of selector ''',method selector,'''. Declared type: ',objectMethod asString,', encountered type: ',method signature asString,')' blaming: ctx].		].	^res! !!CastCheckAtRuntime class methodsFor: 'casting' stamp: 'EstebanAllende 7/15/2012 22:17'!castUnion: res to: aType inClass: aClass blameContext: ctx	aType union do: [:each| |casteable newRes|		casteable := true.		[newRes := self cast: res to: each inClass: aClass blameContext: ctx.] on: Exception do: [casteable := false].		casteable ifTrue: [^newRes].	].	^self castError: '''',res asString,''' is not casteable to type ',aType asString, '''' blaming: ctx.! !!CastCheckAtRuntime class methodsFor: 'casting' stamp: 'EstebanAllende 8/14/2012 17:53'!obj: anObject type: aLiteralArray class: aClass	|parser res ctx activeProcess env klass|	res := anObject.	activeProcess := Processor activeProcess.	(TSLinkedSet includes: activeProcess) ifTrue: [^anObject].	TSLinkedSet add: activeProcess.	TypeConfiguration uniqueInstance enableCasts ifFalse:[TSLinkedSet remove: activeProcess.^anObject].	ctx := thisContext sender.	ctx := MementoContext for: ctx.	["		env := TypeEnvironment new.		env local: false.		klass := aClass theNonMetaClass.		aClass isMeta ifTrue: [klass := Class].		env parent: (TypeDictionary uniqueInstance getClassTypeEnvironmentFor: klass)."		res := anObject.		aLiteralArray do: [ :sType|"			|type|			type := parser parse: sType.			type := type resolveWith: env."			res := self cast: res to: sType inClass: aClass blameContext: ctx.		].	] ensure: [TSLinkedSet remove: activeProcess].	^res! !!CastCheckAtRuntime class methodsFor: 'compiling' stamp: 'EstebanAllende 11/16/2011 13:01'!binding	^astBinding ifNil: [		|node|		node := RBVariableNode named: 'CastCheckAtRuntime'.		OCASTSemanticAnalyzer new				scope: self parseScope;				visitNode: node.		astBinding := node propertyAt: #binding.	].! !!CastCheckAtRuntime class methodsFor: 'compiling' stamp: 'EstebanAllende 10/27/2011 15:41'!bindingSelf: aClass		|node|		node := RBVariableNode named: 'self'.		OCASTSemanticAnalyzer new				scope: aClass parseScope newMethodScope;				visitNode: node.		^node propertyAt: #binding.	! !!CastCheckAtRuntime class methodsFor: 'error handling' stamp: 'EstebanAllende 7/16/2012 01:26'!castError: aString blaming: blame	^CastError signal: aString blaming: blame.! !WrappedBlockClosure variableSubclass: #WrappedLambda	instanceVariableNames: 'paramCasts returnCast casterClass obc ctx'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Support'!!WrappedLambda commentStamp: 'EstebanAllende 10/1/2012 15:09' prior: 0!A WrappedLambda is wrapper for blocks that casts their arguments and return values to specified types.!!WrappedLambda methodsFor: 'accessing' stamp: 'EstebanAllende 7/17/2012 15:19'!casterClass	^ casterClass! !!WrappedLambda methodsFor: 'accessing' stamp: 'EstebanAllende 7/17/2012 15:19'!casterClass: anObject	casterClass := anObject! !!WrappedLambda methodsFor: 'accessing' stamp: 'EstebanAllende 7/17/2012 15:19'!ctx	^ ctx! !!WrappedLambda methodsFor: 'accessing' stamp: 'EstebanAllende 7/17/2012 15:19'!ctx: anObject	ctx := anObject! !!WrappedLambda methodsFor: 'accessing' stamp: 'EstebanAllende 7/17/2012 15:19'!obc	^ obc! !!WrappedLambda methodsFor: 'accessing' stamp: 'EstebanAllende 7/17/2012 15:19'!obc: anObject	obc := anObject! !!WrappedLambda methodsFor: 'accessing' stamp: 'EstebanAllende 7/17/2012 15:19'!paramCasts	^ paramCasts! !!WrappedLambda methodsFor: 'accessing' stamp: 'EstebanAllende 9/13/2012 11:16'!paramCasts: anObject	paramCasts := anObject collect: [:each| each deepCopy annotateSelfWith: ctx methodClass inMethod: nil withKind: #normal]! !!WrappedLambda methodsFor: 'accessing' stamp: 'EstebanAllende 7/17/2012 15:19'!returnCast	^ returnCast! !!WrappedLambda methodsFor: 'accessing' stamp: 'EstebanAllende 9/13/2012 11:16'!returnCast: anObject	returnCast := anObject deepCopy annotateSelfWith: ctx methodClass inMethod: nil withKind: #normal! !!WrappedLambda methodsFor: 'control flow' stamp: 'EstebanAllende 7/17/2012 23:53'!ifCasting: aBlock1 ifNotCastingCast: aBlock2	|activeProcess|	activeProcess := Processor activeProcess.	(TSLinkedSet includes: activeProcess) ifTrue: [aBlock1 value. ^self].	TSLinkedSet add: activeProcess.	TypeConfiguration uniqueInstance enableCasts ifFalse: [		TSLinkedSet remove: activeProcess.		aBlock1 value.		^self	].	aBlock2 ensure: [TSLinkedSet remove: activeProcess].	! !!WrappedLambda methodsFor: 'evaluating' stamp: 'EstebanAllende 7/17/2012 22:05'!value	|res|	res:= obc value.	self 		ifCasting: [^res]		ifNotCastingCast:[ 			res := CastCheckAtRuntime cast: res to: returnCast inClass: casterClass blameContext: (MementoContext for: obc asContext).		].	^res! !!WrappedLambda methodsFor: 'evaluating' stamp: 'EstebanAllende 7/17/2012 22:12'!value: anObject	| first res|	self 		ifCasting: [^obc value: anObject]		ifNotCastingCast: [			first := CastCheckAtRuntime cast: anObject to: paramCasts first inClass: casterClass blameContext: ctx.		].		"paramCasts first blame: ctx.	paramCasts first castCheck: anObject inClass: casterClass.	"	res:= obc value: first.	self 		ifCasting: [^res]		ifNotCastingCast:[ 			res := CastCheckAtRuntime cast: res to: returnCast inClass: casterClass blameContext: (MementoContext for: obc asContext).		].	"	res:= obc value: anObject.	returnCast blame: (MementoContext for: obc asContext).	returnCast castCheck: res inClass: casterClass."	^res! !!WrappedLambda methodsFor: 'evaluating' stamp: 'EstebanAllende 7/17/2012 22:12'!value: anObject1 value: anObject2	|first second res|	self 		ifCasting: [^obc value: anObject1 value: anObject2]		ifNotCastingCast: [			first := CastCheckAtRuntime cast: anObject1 to: paramCasts first inClass: casterClass blameContext: ctx.			second := CastCheckAtRuntime cast: anObject2 to: paramCasts second inClass: casterClass blameContext: ctx.		].			res:= obc value: first value: second.	self 		ifCasting: [^res]		ifNotCastingCast:[ 			res := CastCheckAtRuntime cast: res to: returnCast inClass: casterClass blameContext: (MementoContext for: obc asContext).		].	"	paramCasts first blame: ctx.	paramCasts second blame: ctx.	paramCasts first castCheck: anObject1 inClass: casterClass.	paramCasts second castCheck: anObject2 inClass: casterClass.	res:= obc value: anObject1 value: anObject2.	returnCast blame: (MementoContext for: obc asContext).	returnCast castCheck: res inClass: casterClass."	^res! !!WrappedLambda methodsFor: 'evaluating' stamp: 'EstebanAllende 7/17/2012 22:13'!value: anObject1 value: anObject2 value: anObject3	|first second third res|	self 		ifCasting: [^obc value: anObject1 value: anObject2 value: anObject3]		ifNotCastingCast: [			first := CastCheckAtRuntime cast: anObject1 to: paramCasts first inClass: casterClass blameContext: ctx.			second := CastCheckAtRuntime cast: anObject2 to: paramCasts second inClass: casterClass blameContext: ctx.			third := CastCheckAtRuntime cast: anObject3 to: paramCasts third inClass: casterClass blameContext: ctx.		].		res:= obc value: first value: second value: third.	self 		ifCasting: [^res]		ifNotCastingCast:[ 			res := CastCheckAtRuntime cast: res to: returnCast inClass: casterClass blameContext: (MementoContext for: obc asContext).		]."	paramCasts first blame: ctx.	paramCasts second blame: ctx.	paramCasts third blame: ctx.	paramCasts first castCheck: anObject1 inClass: casterClass.	paramCasts second castCheck: anObject2 inClass: casterClass.	paramCasts third castCheck: anObject3 inClass: casterClass.	res:= obc value: anObject1 value: anObject2 value: anObject3.	returnCast blame: (MementoContext for: obc asContext).	returnCast castCheck: res inClass: casterClass."	^res! !!WrappedLambda methodsFor: 'evaluating' stamp: 'EstebanAllende 7/17/2012 23:47'!value: anObject1 value: anObject2 value: anObject3 value: anObject4	|first second third fourth res|	self 		ifCasting: [^obc value: anObject1 value: anObject2 value: anObject3 value: anObject4]		ifNotCastingCast: [			first := CastCheckAtRuntime cast: anObject1 to: paramCasts first inClass: casterClass blameContext: ctx.			second := CastCheckAtRuntime cast: anObject2 to: paramCasts second inClass: casterClass blameContext: ctx.			third := CastCheckAtRuntime cast: anObject3 to: paramCasts third inClass: casterClass blameContext: ctx.			fourth := CastCheckAtRuntime cast: anObject4 to: paramCasts fourth inClass: casterClass blameContext: ctx.		].	res := obc value: first value: second value: third value: fourth.	self 		ifCasting: [^res]		ifNotCastingCast:[ 			res := CastCheckAtRuntime cast: res to: returnCast inClass: casterClass blameContext: (MementoContext for: obc asContext).		]."	paramCasts first blame: ctx.	paramCasts second blame: ctx.	paramCasts third blame: ctx.	paramCasts fourth blame: ctx.	paramCasts first castCheck: anObject1 inClass: casterClass.	paramCasts second castCheck: anObject2 inClass: casterClass.	paramCasts third castCheck: anObject3 inClass: casterClass.	paramCasts fourth castCheck: anObject4 inClass: casterClass.	res:= obc value: anObject1 value: anObject2 value: anObject3 value: anObject4.	returnCast blame: (MementoContext for: obc asContext).	returnCast castCheck: res inClass: casterClass."	^res! !!WrappedLambda methodsFor: 'evaluating' stamp: 'EstebanAllende 7/17/2012 22:08'!valueNoContextSwitch	|res|		res:= obc valueNoContextSwitch.	self 		ifCasting: [^res]		ifNotCastingCast:[ 			res := CastCheckAtRuntime cast: res to: returnCast inClass: casterClass blameContext: (MementoContext for: obc asContext).		]."	returnCast blame: (MementoContext for: obc asContext).	returnCast castCheck: res inClass: casterClass."	^res! !!WrappedLambda methodsFor: 'evaluating' stamp: 'EstebanAllende 7/17/2012 23:48'!valueNoContextSwitch: anArg	|res first|	self 		ifCasting: [^obc value: anArg]		ifNotCastingCast: [			first := CastCheckAtRuntime cast: anArg to: paramCasts first inClass: casterClass blameContext: ctx.		].		res:= obc valueNoContextSwitch: first.	self 		ifCasting: [^res]		ifNotCastingCast:[ 			res := CastCheckAtRuntime cast: res to: returnCast inClass: casterClass blameContext: (MementoContext for: obc asContext).		].	"res:= obc valueNoContextSwitch: anArg.	returnCast blame: (MementoContext for: obc asContext).	returnCast castCheck: res inClass: casterClass."	^res! !!WrappedLambda methodsFor: 'evaluating' stamp: 'EstebanAllende 7/17/2012 23:50'!valueWithArguments: anArray	|args res|	self 		ifCasting: [^obc valueWithArguments: anArray]		ifNotCastingCast: [			args := Array new: anArray size.				1 to: anArray size do: [:i| 				|pCast arg|		 		pCast := paramCasts at: i.				arg := CastCheckAtRuntime cast: (anArray at: i) to: pCast inClass: casterClass blameContext: ctx.				args at: i put: arg.			].		].	res:= obc valueWithArguments: args.	self 		ifCasting: [^res]		ifNotCastingCast:[ 			res := CastCheckAtRuntime cast: res to: returnCast inClass: casterClass blameContext: (MementoContext for: obc asContext).		].	"	first := CastCheckAtRuntime cast: anObject1 to: paramCasts first inClass: casterClass blameContext: ctx.	second := CastCheckAtRuntime cast: anObject2 to: paramCasts second inClass: casterClass blameContext: ctx.		res:= obc value: first value: second.	res := CastCheckAtRuntime cast: res to: returnCast inClass: casterClass blameContext: (MementoContext for: obc asContext)."	"	1 to: anArray size do: [:i| |pCast|		 pCast := paramCasts at: i.		pCast blame: ctx. 		pCast castCheck: (anArray at: i) inClass: casterClass ].	res:= obc valueWithArguments: anArray.	returnCast blame: (MementoContext for: obc asContext).	returnCast castCheck: res inClass: casterClass."	^res! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!WrappedLambda class	instanceVariableNames: ''!!WrappedLambda class methodsFor: 'instance creation' stamp: 'EstebanAllende 9/13/2012 11:15'!fromBlockClosure: aBlockClosure withParamCasts: anArray withReturnCast: aType inClass: aClass withContext: aContext	^(self outerContext: aBlockClosure outerContext startpc: aBlockClosure startpc numArgs: aBlockClosure numArgs copiedValues: aBlockClosure) ctx: aContext; paramCasts: anArray; returnCast: aType; casterClass: aClass; obc: aBlockClosure. ! !Object subclass: #MementoContext	instanceVariableNames: 'pc method ctxStack'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Support'!!MementoContext commentStamp: 'EstebanAllende 10/1/2012 15:00' prior: 0!A MementoContext is a copy of a context for being used in blame tracking.!!MementoContext methodsFor: 'accessing' stamp: 'EstebanAllende 7/15/2012 23:12'!ctxStack	^ ctxStack! !!MementoContext methodsFor: 'accessing' stamp: 'EstebanAllende 7/15/2012 23:12'!ctxStack: anObject	ctxStack := anObject! !!MementoContext methodsFor: 'accessing' stamp: 'EstebanAllende 11/16/2011 19:34'!method	^ method! !!MementoContext methodsFor: 'accessing' stamp: 'EstebanAllende 11/16/2011 19:34'!method: anObject	method := anObject! !!MementoContext methodsFor: 'accessing' stamp: 'EstebanAllende 11/18/2011 11:58'!methodClass	^ method methodClass! !!MementoContext methodsFor: 'accessing' stamp: 'EstebanAllende 11/16/2011 19:34'!pc	^ pc! !!MementoContext methodsFor: 'accessing' stamp: 'EstebanAllende 11/16/2011 19:34'!pc: anObject	pc := anObject! !!MementoContext methodsFor: 'accessing' stamp: 'EstebanAllende 7/15/2012 23:15'!stackOfSize: x	^ ctxStack! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MementoContext class	instanceVariableNames: ''!!MementoContext class methodsFor: 'instance creation' stamp: 'EstebanAllende 7/15/2012 23:14'!for: aContext	|ctx res|	ctx := aContext.	res := self basicNew.	res pc: ctx pc.	res method: ctx method.	res ctxStack: (ctx stackOfSize: 1).	^res	! !!MementoContext class methodsFor: 'instance creation' stamp: 'EstebanAllende 7/15/2012 23:13'!new	|ctx|	ctx := thisContext sender.	^self for: ctx.	! !Object subclass: #TSLogger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Support'!!TSLogger commentStamp: 'EstebanAllende 10/2/2012 12:27' prior: 0!TSLogger is the class using for logging information by the typesystem!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TSLogger class	instanceVariableNames: ''!!TSLogger class methodsFor: 'class initialization' stamp: 'EstebanAllende 10/2/2012 12:26'!initialize	^OTCSupport bootstrapping ifTrue: [self installLoggers].! !!TSLogger class methodsFor: 'class initialization' stamp: 'EstebanAllende 10/2/2012 11:04'!installLoggers	|logger|	logger := TranscriptLogger new.	logger format: SimpleLoggingFormatter defaultFormat.	logger policy: (LoggingPolicy category: #typesystem level: #all).		(LoggingMultiplexer current)		addLogger: logger;		startAllLoggers! !!TSLogger class methodsFor: 'instance creation' stamp: 'EstebanAllende 10/2/2012 10:59'!new	^self error: 'This class is uninstantiable'.! !!TSLogger class methodsFor: 'logging' stamp: 'EstebanAllende 10/2/2012 12:02'!info: aString	self level: #info message: aString context: thisContext sender.! !!TSLogger class methodsFor: 'logging' stamp: 'EstebanAllende 10/2/2012 12:08'!level: aLevel message: aString context: ctx	self level: aLevel message: aString context: ctx exception: nil! !!TSLogger class methodsFor: 'logging' stamp: 'EstebanAllende 10/2/2012 12:07'!level: aLevel message: aString context: ctx exception: ex	|ctxString|	((ctx methodClass = UndefinedObject) and: [ctx method selector = #DoIt])		ifTrue: [ctxString := 'Workspace']		ifFalse: [ctxString := ctx methodClass name asString, ' >> ',ctx method selector].	LoggingEvent 		category: #typesystem		timeStamp: LoggingEvent timestampClass now		level: aLevel		message: aString		context: ctxString		exception: ex.! !ProtoObject subclass: #ShadowNode	instanceVariableNames: 'object start stop'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Support'!!ShadowNode commentStamp: 'EstebanAllende 10/1/2012 15:03' prior: 0!A ShadowNode is a node wrapper where the start and stop values are setteable.!!ShadowNode methodsFor: 'accessing' stamp: 'EstebanAllende 7/14/2012 23:22'!class	^object class! !!ShadowNode methodsFor: 'accessing' stamp: 'EstebanAllende 7/14/2012 23:24'!debugHighlightStart	^start! !!ShadowNode methodsFor: 'accessing' stamp: 'EstebanAllende 7/14/2012 23:24'!debugHighlightStop	^stop! !!ShadowNode methodsFor: 'accessing' stamp: 'EstebanAllende 7/14/2012 23:24'!start	^ start! !!ShadowNode methodsFor: 'accessing' stamp: 'EstebanAllende 7/14/2012 23:24'!start: anObject	start := anObject! !!ShadowNode methodsFor: 'accessing' stamp: 'EstebanAllende 7/14/2012 23:24'!stop	^ stop! !!ShadowNode methodsFor: 'accessing' stamp: 'EstebanAllende 7/14/2012 23:24'!stop: anObject	stop := anObject! !!ShadowNode methodsFor: 'system primitives' stamp: 'EstebanAllende 7/14/2012 23:22'!doesNotUnderstand: aMessage	^aMessage sendTo: object! !!ShadowNode methodsFor: 'system primitives' stamp: 'EstebanAllende 7/14/2012 23:20'!tryNamedPrimitive: arg1 with: arg2	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	(arg1 = #'blame shadow:') ifTrue: [^object := arg2].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ShadowNode class	instanceVariableNames: ''!!ShadowNode class methodsFor: 'instance creation' stamp: 'EstebanAllende 7/14/2012 23:21'!shadow: anObject	|res|	res := self basicNew.	res tryNamedPrimitive: #'blame shadow:' with: anObject.	^res! !Object subclass: #TSLinkedSet	instanceVariableNames: 'value next'	classVariableNames: ''	poolDictionaries: ''	category: 'TypeSystem-Support'!!TSLinkedSet commentStamp: 'EstebanAllende 7/15/2012 20:52' prior: 0!A TSLinkedSet is a singleton Set implemented as a linked list. Its main function is to be a set that never requires a cast to function normally.!!TSLinkedSet methodsFor: 'accessing' stamp: 'EstebanAllende 7/15/2012 20:31'!next	^ next! !!TSLinkedSet methodsFor: 'accessing' stamp: 'EstebanAllende 7/15/2012 20:31'!next: anObject	next := anObject! !!TSLinkedSet methodsFor: 'accessing' stamp: 'EstebanAllende 7/15/2012 20:32'!value	^value! !!TSLinkedSet methodsFor: 'accessing' stamp: 'EstebanAllende 7/15/2012 20:31'!value: anObject	value := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TSLinkedSet class	instanceVariableNames: 'first last'!!TSLinkedSet class methodsFor: 'class initialization' stamp: 'EstebanAllende 7/15/2012 20:33'!initialize	first := nil.	last := nil.! !!TSLinkedSet class methodsFor: 'instance creation' stamp: 'EstebanAllende 7/15/2012 20:36'!basicNew	"We redefine basicNew so we use directly the primitive without any chance of casts"	<primitive: 70>! !!TSLinkedSet class methodsFor: 'linked set methods' stamp: 'EstebanAllende 7/15/2012 20:40'!add: x	|node|	node := self basicNew.	node next: nil.	node value: x.	first isNil 		ifTrue: [first := node. last := node]		ifFalse: [last next: node. last := node]! !!TSLinkedSet class methodsFor: 'linked set methods' stamp: 'EstebanAllende 7/15/2012 20:50'!includes: x	|node|	node := first.	[node isNil]		whileFalse: [node value == x ifTrue: [^true]. node := node next].	^false! !!TSLinkedSet class methodsFor: 'linked set methods' stamp: 'EstebanAllende 7/15/2012 22:59'!remove: x	|node|	(first value == x) ifTrue: [		(first == last) 			ifTrue: [first := nil. last := nil]			ifFalse: [first := first next].		^self.	].	node := first.	[node next notNil and: [node next value ~= x]]			whileTrue: [node := node next].	(node next == last)		ifTrue: [last := node. node next: nil]		ifFalse: [node next: (node next next)].! !TSLogger initialize!TSLinkedSet initialize!